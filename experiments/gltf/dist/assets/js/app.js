/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "8aed7ad8fa191b4630e7"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve().then(function() {
/******/ 				return hotApply(hotApplyOnUpdate);
/******/ 			}).then(
/******/ 				function(result) {
/******/ 					deferred.resolve(result);
/******/ 				},
/******/ 				function(err) {
/******/ 					deferred.reject(err);
/******/ 				}
/******/ 			);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if(cb) {
/******/ 							if(callbacks.indexOf(cb) >= 0) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for(i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch(err) {
/******/ 							if(options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if(!options.ignoreErrored) {
/******/ 								if(!error)
/******/ 									error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err, // TODO remove in webpack 4
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(111)(__webpack_require__.s = 111);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTool.js

var _glMatrix = __webpack_require__(2);

var _getAndApplyExtension = __webpack_require__(54);

var _getAndApplyExtension2 = _interopRequireDefault(_getAndApplyExtension);

var _exposeAttributes = __webpack_require__(55);

var _exposeAttributes2 = _interopRequireDefault(_exposeAttributes);

var _getFloat = __webpack_require__(56);

var _getFloat2 = _interopRequireDefault(_getFloat);

var _getHalfFloat = __webpack_require__(57);

var _getHalfFloat2 = _interopRequireDefault(_getHalfFloat);

var _getAttribLoc = __webpack_require__(33);

var _getAttribLoc2 = _interopRequireDefault(_getAttribLoc);

var _ExtensionsList = __webpack_require__(58);

var _ExtensionsList2 = _interopRequireDefault(_ExtensionsList);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _Mesh = __webpack_require__(13);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _Object3D = __webpack_require__(8);

var _Object3D2 = _interopRequireDefault(_Object3D);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var GLTool = function () {
	function GLTool() {
		_classCallCheck(this, GLTool);

		this.canvas;
		this._viewport = [0, 0, 0, 0];
		this._enabledVertexAttribute = [];
		this.identityMatrix = _glMatrix.mat4.create();
		this._normalMatrix = _glMatrix.mat3.create();
		this._inverseModelViewMatrix = _glMatrix.mat3.create();
		this._modelMatrix = _glMatrix.mat4.create();
		this._matrix = _glMatrix.mat4.create();
		this._matrixStacks = [];
		this._lastMesh = null;
		this._useWebGL2 = false;
		this._hasArrayInstance;
		this._extArrayInstance;
		this._hasCheckedExt = false;
		_glMatrix.mat4.identity(this.identityMatrix, this.identityMatrix);

		this.isMobile = false;
		if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			this.isMobile = true;
		}
	}

	//	INITIALIZE

	_createClass(GLTool, [{
		key: 'init',
		value: function init(mCanvas) {
			var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


			if (mCanvas === null || mCanvas === undefined) {
				console.error('Canvas not exist');
				return;
			}

			if (this.canvas !== undefined && this.canvas !== null) {
				this.destroy();
			}

			this.canvas = mCanvas;
			this.setSize(window.innerWidth, window.innerHeight);

			mParameters.useWebgl2 = mParameters.useWebgl2 || false;

			var ctx = void 0;
			if (mParameters.useWebgl2) {
				ctx = this.canvas.getContext('experimental-webgl2', mParameters) || this.canvas.getContext('webgl2', mParameters);

				if (!ctx) {
					ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
					this._useWebGL2 = false;
				} else {
					this._useWebGL2 = true;
				}
			} else {
				// ctx = this.canvas.getContext('experimental-webgl2', mParameters) || this.canvas.getContext('webgl2', mParameters);
				// if(ctx) {
				// 	this._useWebGL2 = true;
				// } else {
				// 	ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
				// }

				ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
				this._useWebGL2 = false;
			}

			console.log('Using WebGL 2 ?', this.webgl2);

			//	extensions
			this.initWithGL(ctx);
		}
	}, {
		key: 'initWithGL',
		value: function initWithGL(ctx) {
			if (!this.canvas) {
				this.canvas = ctx.canvas;
			}
			gl = this.gl = ctx;

			this.extensions = {};
			for (var i = 0; i < _ExtensionsList2.default.length; i++) {
				this.extensions[_ExtensionsList2.default[i]] = gl.getExtension(_ExtensionsList2.default[i]);
			}

			//	Copy gl Attributes
			(0, _exposeAttributes2.default)();
			(0, _getAndApplyExtension2.default)(gl, 'OES_vertex_array_object');
			(0, _getAndApplyExtension2.default)(gl, 'ANGLE_instanced_arrays');
			(0, _getAndApplyExtension2.default)(gl, 'WEBGL_draw_buffers');

			this.enable(this.DEPTH_TEST);
			this.enable(this.CULL_FACE);
			this.enable(this.BLEND);
			this.enableAlphaBlending();
		}

		//	PUBLIC METHODS

	}, {
		key: 'setViewport',
		value: function setViewport(x, y, w, h) {
			var hasChanged = false;
			if (x !== this._viewport[0]) {
				hasChanged = true;
			}
			if (y !== this._viewport[1]) {
				hasChanged = true;
			}
			if (w !== this._viewport[2]) {
				hasChanged = true;
			}
			if (h !== this._viewport[3]) {
				hasChanged = true;
			}

			if (hasChanged) {
				gl.viewport(x, y, w, h);
				this._viewport = [x, y, w, h];
			}
		}
	}, {
		key: 'scissor',
		value: function scissor(x, y, w, h) {
			gl.scissor(x, y, w, h);
		}
	}, {
		key: 'clear',
		value: function clear(r, g, b, a) {
			gl.clearColor(r, g, b, a);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		}
	}, {
		key: 'cullFace',
		value: function cullFace(mValue) {
			gl.cullFace(mValue);
		}
	}, {
		key: 'setMatrices',
		value: function setMatrices(mCamera) {
			this.camera = mCamera;
			this.rotate(this.identityMatrix);
		}
	}, {
		key: 'useShader',
		value: function useShader(mShader) {
			this.shader = mShader;
			this.shaderProgram = this.shader.shaderProgram;
		}
	}, {
		key: 'rotate',
		value: function rotate(mRotation) {
			_glMatrix.mat4.copy(this._modelMatrix, mRotation);
			_glMatrix.mat4.multiply(this._matrix, this.camera.matrix, this._modelMatrix);
			_glMatrix.mat3.fromMat4(this._normalMatrix, this._matrix);
			_glMatrix.mat3.invert(this._normalMatrix, this._normalMatrix);
			_glMatrix.mat3.transpose(this._normalMatrix, this._normalMatrix);

			_glMatrix.mat3.fromMat4(this._inverseModelViewMatrix, this._matrix);
			_glMatrix.mat3.invert(this._inverseModelViewMatrix, this._inverseModelViewMatrix);
		}
	}, {
		key: 'drawGeometry',
		value: function drawGeometry(mGeometry, modelMatrix) {
			if (mGeometry.length) {
				for (var i = 0; i < mGeometry.length; i++) {
					this.draw(mGeometry[i]);
				}
				return;
			}

			mGeometry.bind(this.shaderProgram);

			//	DEFAULT UNIFORMS
			if (this.camera !== undefined) {
				this.shader.uniform('uProjectionMatrix', 'mat4', this.camera.projection);
				this.shader.uniform('uViewMatrix', 'mat4', this.camera.matrix);
			}

			this.shader.uniform('uCameraPos', 'vec3', this.camera.position);
			this.shader.uniform('uModelMatrix', 'mat4', modelMatrix || this._modelMatrix);
			this.shader.uniform('uNormalMatrix', 'mat3', this._normalMatrix);
			this.shader.uniform('uModelViewMatrixInverse', 'mat3', this._inverseModelViewMatrix);

			var drawType = mGeometry.drawType;

			if (mGeometry.isInstanced) {
				gl.drawElementsInstanced(mGeometry.drawType, mGeometry.iBuffer.numItems, gl.UNSIGNED_SHORT, 0, mGeometry.numInstance);
			} else {
				if (drawType === gl.POINTS) {
					gl.drawArrays(drawType, 0, mGeometry.vertexSize);
				} else {
					gl.drawElements(drawType, mGeometry.iBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				}
			}

			mGeometry.unbind();
		}
	}, {
		key: 'drawMesh',
		value: function drawMesh(mMesh) {
			var material = mMesh.material,
			    geometry = mMesh.geometry;


			if (material.doubleSided) {
				this.disable(GL.CULL_FACE);
			} else {
				this.enable(GL.CULL_FACE);
			}

			material.update();
			this.drawGeometry(geometry, mMesh.matrix);
		}
	}, {
		key: 'draw',
		value: function draw(mObj) {
			var _this = this;

			if (mObj instanceof _Geometry2.default) {
				this.drawGeometry(mObj);
			} else if (mObj instanceof _Mesh2.default) {
				this.drawMesh(mObj);
			} else if (mObj instanceof _Object3D2.default) {
				// console.log('here');
				mObj.updateMatrix();
				mObj.children.forEach(function (child) {
					_this.draw(child);
				});
			}
		}
	}, {
		key: 'drawTransformFeedback',
		value: function drawTransformFeedback(mTransformObject) {
			var meshSource = mTransformObject.meshSource,
			    meshDestination = mTransformObject.meshDestination,
			    numPoints = mTransformObject.numPoints,
			    transformFeedback = mTransformObject.transformFeedback;

			//	BIND SOURCE BUFFERS -> setupVertexAttr(sourceVAO)

			meshSource.bind(this.shaderProgram);
			meshDestination.generateBuffers(this.shaderProgram);

			//	BIND DESTINATION BUFFERS
			gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);

			meshDestination.attributes.forEach(function (attr, i) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attr.buffer);
			});

			gl.enable(gl.RASTERIZER_DISCARD);

			gl.beginTransformFeedback(gl.POINTS);
			gl.drawArrays(gl.POINTS, 0, numPoints);
			gl.endTransformFeedback();

			//	reset state
			gl.disable(gl.RASTERIZER_DISCARD);
			gl.useProgram(null);
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			meshDestination.attributes.forEach(function (attr, i) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, null);
			});
			gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

			meshSource.unbind();
		}
	}, {
		key: 'setSize',
		value: function setSize(mWidth, mHeight) {
			this._width = mWidth;
			this._height = mHeight;
			this.canvas.width = this._width;
			this.canvas.height = this._height;
			this._aspectRatio = this._width / this._height;

			if (gl) {
				this.viewport(0, 0, this._width, this._height);
			}
		}
	}, {
		key: 'showExtensions',
		value: function showExtensions() {
			console.log('Extensions : ', this.extensions);
			for (var ext in this.extensions) {
				if (this.extensions[ext]) {
					console.log(ext, ':', this.extensions[ext]);
				}
			}
		}
	}, {
		key: 'checkExtension',
		value: function checkExtension(mExtension) {
			return !!this.extensions[mExtension];
		}
	}, {
		key: 'getExtension',
		value: function getExtension(mExtension) {
			return this.extensions[mExtension];
		}

		//	BLEND MODES

	}, {
		key: 'enableAlphaBlending',
		value: function enableAlphaBlending() {
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		}
	}, {
		key: 'enableAdditiveBlending',
		value: function enableAdditiveBlending() {
			gl.blendFunc(gl.ONE, gl.ONE);
		}

		//	matrices

	}, {
		key: 'pushMatrix',
		value: function pushMatrix() {
			var mtx = _glMatrix.mat4.clone(this._modelMatrix);
			this._matrixStacks.push(mtx);
		}
	}, {
		key: 'popMatrix',
		value: function popMatrix() {
			if (this._matrixStacks.length == 0) {
				return null;
			}
			var mtx = this._matrixStacks.pop();
			this.rotate(mtx);
		}

		//	GL NATIVE FUNCTIONS

	}, {
		key: 'enable',
		value: function enable(mParameter) {
			gl.enable(mParameter);
		}
	}, {
		key: 'disable',
		value: function disable(mParameter) {
			gl.disable(mParameter);
		}
	}, {
		key: 'viewport',
		value: function viewport(x, y, w, h) {
			this.setViewport(x, y, w, h);
		}

		//	GETTER AND SETTERS

	}, {
		key: 'destroy',


		//	DESTROY

		value: function destroy() {

			if (this.canvas.parentNode) {
				try {
					this.canvas.parentNode.removeChild(this.canvas);
				} catch (e) {
					console.log('Error : ', e);
				}
			}

			this.canvas = null;
		}
	}, {
		key: 'FLOAT',
		get: function get() {
			return (0, _getFloat2.default)();
		}
	}, {
		key: 'HALF_FLOAT',
		get: function get() {
			return (0, _getHalfFloat2.default)();
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'aspectRatio',
		get: function get() {
			return this._aspectRatio;
		}
	}, {
		key: 'webgl2',
		get: function get() {
			return this._useWebGL2;
		}
	}]);

	return GLTool;
}();

var GL = new GLTool();

exports.default = GL;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GLShader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _GLCubeTexture = __webpack_require__(14);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var glslify = __webpack_require__(61);
var isSame = function isSame(array1, array2) {
	if (array1.length !== array2.length) {
		return false;
	}

	for (var i = 0; i < array1.length; i++) {
		if (array1[i] !== array2[i]) {
			return false;
		}
	}

	return true;
};

var addLineNumbers = function addLineNumbers(string) {
	var lines = string.split('\n');
	for (var i = 0; i < lines.length; i++) {
		lines[i] = i + 1 + ': ' + lines[i];
	}
	return lines.join('\n');
};

var cloneArray = function cloneArray(mArray) {
	if (mArray.slice) {
		return mArray.slice(0);
	} else {
		return new Float32Array(mArray);
	}
};

var gl = void 0;
var defaultVertexShader = __webpack_require__(15);
var defaultFragmentShader = __webpack_require__(62);

var uniformMapping = {
	float: 'uniform1f',
	vec2: 'uniform2fv',
	vec3: 'uniform3fv',
	vec4: 'uniform4fv',
	int: 'uniform1i',
	mat3: 'uniformMatrix3fv',
	mat4: 'uniformMatrix4fv'
};

var GLShader = function () {
	function GLShader() {
		var strVertexShader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultVertexShader;
		var strFragmentShader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFragmentShader;
		var mVaryings = arguments[2];

		_classCallCheck(this, GLShader);

		gl = _GLTool2.default.gl;
		this.parameters = [];
		this._uniformTextures = [];
		this._varyings = mVaryings;

		if (!strVertexShader) {
			strVertexShader = defaultVertexShader;
		}
		if (!strFragmentShader) {
			strFragmentShader = defaultVertexShader;
		}

		var vsShader = this._createShaderProgram(strVertexShader, true);
		var fsShader = this._createShaderProgram(strFragmentShader, false);
		this._attachShaderProgram(vsShader, fsShader);
	}

	_createClass(GLShader, [{
		key: 'bind',
		value: function bind() {

			if (_GLTool2.default.shader === this) {
				return;
			}
			gl.useProgram(this.shaderProgram);
			_GLTool2.default.useShader(this);
			// this.uniformTextures = [];
		}
	}, {
		key: 'uniform',
		value: function uniform(mName, mType, mValue) {
			if ((typeof mName === 'undefined' ? 'undefined' : _typeof(mName)) === 'object') {
				this.uniformObject(mName);
				return;
			}
			/*
   if(!!mValue === undefined || mValue === null) {
   	console.warn('mValue Error:', mName);
   	return;
   }
   */
			var uniformType = uniformMapping[mType] || mType;

			var hasUniform = false;
			var oUniform = void 0;
			var parameterIndex = -1;

			for (var i = 0; i < this.parameters.length; i++) {
				oUniform = this.parameters[i];
				if (oUniform.name === mName) {
					hasUniform = true;
					parameterIndex = i;
					break;
				}
			}

			var isNumber = false;

			if (!hasUniform) {
				isNumber = uniformType === 'uniform1i' || uniformType === 'uniform1f';
				this.shaderProgram[mName] = gl.getUniformLocation(this.shaderProgram, mName);
				if (isNumber) {
					this.parameters.push({ name: mName, type: uniformType, value: mValue, uniformLoc: this.shaderProgram[mName], isNumber: isNumber });
				} else {
					this.parameters.push({ name: mName, type: uniformType, value: cloneArray(mValue), uniformLoc: this.shaderProgram[mName], isNumber: isNumber });
				}

				parameterIndex = this.parameters.length - 1;
			} else {
				this.shaderProgram[mName] = oUniform.uniformLoc;
				isNumber = oUniform.isNumber;
			}

			if (!this.parameters[parameterIndex].uniformLoc) {
				return;
			}

			if (uniformType.indexOf('Matrix') === -1) {
				if (!isNumber) {
					if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
						gl[uniformType](this.shaderProgram[mName], mValue);
						this.parameters[parameterIndex].value = cloneArray(mValue);
					}
				} else {
					var needUpdate = this.parameters[parameterIndex].value !== mValue || !hasUniform;
					if (needUpdate) {
						gl[uniformType](this.shaderProgram[mName], mValue);
						this.parameters[parameterIndex].value = mValue;
					}
				}
			} else {
				if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
					gl[uniformType](this.shaderProgram[mName], false, mValue);
					this.parameters[parameterIndex].value = cloneArray(mValue);
				}
			}
		}
	}, {
		key: 'uniformObject',
		value: function uniformObject(mUniformObj) {
			var _this = this;

			var _loop = function _loop(uniformName) {

				if (mUniformObj[uniformName] instanceof _GLTexture2.default || mUniformObj[uniformName] instanceof _GLCubeTexture2.default) {
					var texture = mUniformObj[uniformName];

					var textureIndex = -1;;
					_this._uniformTextures.forEach(function (ut, i) {
						if (ut.name === uniformName) {
							textureIndex = i;
							ut.texture = texture;
						}
					});

					if (textureIndex === -1) {
						textureIndex = _this._uniformTextures.length;
						_this._uniformTextures.push({
							name: uniformName,
							texture: texture
						});
					}

					_this.uniform(uniformName, 'uniform1i', textureIndex);
					texture.bind(textureIndex);
				} else {
					var uniformValue = mUniformObj[uniformName];
					var uniformType = GLShader.getUniformType(uniformValue);

					if (uniformValue.concat && uniformValue[0].concat) {
						var tmp = [];
						for (var i = 0; i < uniformValue.length; i++) {
							tmp = tmp.concat(uniformValue[i]);
						}
						uniformValue = tmp;
					}

					_this.uniform(uniformName, uniformType, uniformValue);
				}
			};

			for (var uniformName in mUniformObj) {
				_loop(uniformName);
			}
		}
	}, {
		key: '_createShaderProgram',
		value: function _createShaderProgram(mShaderStr, isVertexShader) {

			var shaderType = isVertexShader ? _GLTool2.default.VERTEX_SHADER : _GLTool2.default.FRAGMENT_SHADER;
			var shader = gl.createShader(shaderType);

			gl.shaderSource(shader, mShaderStr);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				console.warn('Error in Shader : ', gl.getShaderInfoLog(shader));
				console.log(addLineNumbers(mShaderStr));
				return null;
			}

			return shader;
		}
	}, {
		key: '_attachShaderProgram',
		value: function _attachShaderProgram(mVertexShader, mFragmentShader) {

			this.shaderProgram = gl.createProgram();
			gl.attachShader(this.shaderProgram, mVertexShader);
			gl.attachShader(this.shaderProgram, mFragmentShader);

			gl.deleteShader(mVertexShader);
			gl.deleteShader(mFragmentShader);

			if (this._varyings) {
				console.log('Transform feedback setup : ', this._varyings);
				gl.transformFeedbackVaryings(this.shaderProgram, this._varyings, gl.SEPARATE_ATTRIBS);
			}

			gl.linkProgram(this.shaderProgram);
		}
	}]);

	return GLShader;
}();

GLShader.getUniformType = function (mValue) {
	var isArray = !!mValue.concat;

	var getArrayUniformType = function getArrayUniformType(mValue) {
		if (mValue.length === 9) {
			return 'uniformMatrix3fv';
		} else if (mValue.length === 16) {
			return 'uniformMatrix4fv';
		} else {
			return 'vec' + mValue.length;
		}
	};

	if (!isArray) {
		return 'float';
	} else {
		if (!mValue[0].concat) {
			return getArrayUniformType(mValue);
		} else {
			return getArrayUniformType(mValue[0]);
		}
	}
};

exports.default = GLShader;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__ = __webpack_require__(31);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__; });
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.4.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER













/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _glMatrix = __webpack_require__(2);

var _getAttribLoc = __webpack_require__(33);

var _getAttribLoc2 = _interopRequireDefault(_getAttribLoc);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var STATIC_DRAW = 35044;

var getBuffer = function getBuffer(attr) {
	var buffer = void 0;

	if (attr.buffer !== undefined) {
		buffer = attr.buffer;
	} else {
		buffer = gl.createBuffer();
		attr.buffer = buffer;
	}

	return buffer;
};

var formBuffer = function formBuffer(mData, mNum) {
	var ary = [];

	for (var i = 0; i < mData.length; i += mNum) {
		var o = [];
		for (var j = 0; j < mNum; j++) {
			o.push(mData[i + j]);
		}

		ary.push(o);
	}

	return ary;
};

var Geometry = function () {
	function Geometry() {
		var mDrawingType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
		var mUseVao = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

		_classCallCheck(this, Geometry);

		gl = _GLTool2.default.gl;
		this.drawType = mDrawingType;
		this._attributes = [];
		this._numInstance = -1;
		this._enabledVertexAttribute = [];

		this._indices = [];
		this._faces = [];
		this._bufferChanged = [];
		this._hasIndexBufferChanged = false;
		this._hasVAO = false;
		this._isInstanced = false;

		this._extVAO = !!_GLTool2.default.gl.createVertexArray;
		this._useVAO = !!this._extVAO && mUseVao;
		// this._useVAO = false;
	}

	_createClass(Geometry, [{
		key: 'bufferVertex',
		value: function bufferVertex(mArrayVertices) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mArrayVertices, 'aVertexPosition', 3, mDrawType);

			if (this.normals.length < this.vertices.length) {
				this.bufferNormal(mArrayVertices, mDrawType);
			}

			return this;
		}
	}, {
		key: 'bufferTexCoord',
		value: function bufferTexCoord(mArrayTexCoords) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mArrayTexCoords, 'aTextureCoord', 2, mDrawType);
			return this;
		}
	}, {
		key: 'bufferNormal',
		value: function bufferNormal(mNormals) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mNormals, 'aNormal', 3, mDrawType);
			return this;
		}
	}, {
		key: 'bufferIndex',
		value: function bufferIndex(mArrayIndices) {
			var isDynamic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

			this._drawType = isDynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
			if (mArrayIndices instanceof Array) {
				this._indices = new Uint16Array(mArrayIndices);
			} else {
				this._indices = mArrayIndices;
			}

			this._numItems = this._indices.length;
			return this;
		}
	}, {
		key: 'bufferFlattenData',
		value: function bufferFlattenData(mData, mName, mItemSize) {
			var mDrawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STATIC_DRAW;
			var isInstanced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;


			var data = formBuffer(mData, mItemSize);
			this.bufferData(data, mName, mItemSize, mDrawType = STATIC_DRAW, isInstanced = false);
			return this;
		}
	}, {
		key: 'bufferData',
		value: function bufferData(mData, mName, mItemSize) {
			var mDrawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STATIC_DRAW;
			var isInstanced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

			var i = 0;
			var drawType = mDrawType;
			if (!drawType) debugger;

			var bufferData = [];
			if (!mItemSize) {
				mItemSize = mData[0].length;
			}
			this._isInstanced = isInstanced || this._isInstanced;

			//	flatten buffer data		
			for (i = 0; i < mData.length; i++) {
				for (var j = 0; j < mData[i].length; j++) {
					bufferData.push(mData[i][j]);
				}
			}
			var dataArray = new Float32Array(bufferData);
			var attribute = this.getAttribute(mName);

			if (attribute) {
				//	attribute existed, replace with new data
				attribute.itemSize = mItemSize;
				attribute.dataArray = dataArray;
				attribute.source = mData;
			} else {
				//	attribute not exist yet, create new attribute object
				this._attributes.push({ name: mName, source: mData, itemSize: mItemSize, drawType: drawType, dataArray: dataArray, isInstanced: isInstanced });
			}

			this._bufferChanged.push(mName);
			return this;
		}
	}, {
		key: 'bufferInstance',
		value: function bufferInstance(mData, mName) {
			if (!_GLTool2.default.gl.vertexAttribDivisor) {
				console.error('Extension : ANGLE_instanced_arrays is not supported with this device !');
				return;
			}

			var itemSize = mData[0].length;
			this._numInstance = mData.length;
			this.bufferData(mData, mName, itemSize, STATIC_DRAW, true);
		}
	}, {
		key: 'bind',
		value: function bind(mShaderProgram) {
			this.generateBuffers(mShaderProgram);

			if (this.hasVAO) {
				gl.bindVertexArray(this.vao);
			} else {
				this.attributes.forEach(function (attribute) {
					gl.bindBuffer(gl.ARRAY_BUFFER, attribute.buffer);
					var attrPosition = attribute.attrPosition;
					gl.vertexAttribPointer(attrPosition, attribute.itemSize, gl.FLOAT, false, 0, 0);

					if (attribute.isInstanced) {
						gl.vertexAttribDivisor(attrPosition, 1);
					}
				});

				//	BIND INDEX BUFFER
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
			}
		}
	}, {
		key: 'generateBuffers',
		value: function generateBuffers(mShaderProgram) {
			var _this = this;

			if (this._bufferChanged.length == 0) {
				return;
			}

			if (this._useVAO) {
				//	IF SUPPORTED, CREATE VAO

				//	CREATE & BIND VAO
				if (!this._vao) {
					this._vao = gl.createVertexArray();
				}

				gl.bindVertexArray(this._vao);

				//	UPDATE BUFFERS
				this._attributes.forEach(function (attrObj) {

					if (_this._bufferChanged.indexOf(attrObj.name) !== -1) {
						var buffer = getBuffer(attrObj);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);

						var attrPosition = (0, _getAttribLoc2.default)(gl, mShaderProgram, attrObj.name);
						gl.enableVertexAttribArray(attrPosition);
						gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
						attrObj.attrPosition = attrPosition;

						if (attrObj.isInstanced) {
							gl.vertexAttribDivisor(attrPosition, 1);
						}
					}
				});

				//	check index buffer
				this._updateIndexBuffer();

				//	UNBIND VAO
				gl.bindVertexArray(null);

				this._hasVAO = true;
			} else {
				//	ELSE, USE TRADITIONAL METHOD

				this._attributes.forEach(function (attrObj) {
					//	SKIP IF BUFFER HASN'T CHANGED
					if (_this._bufferChanged.indexOf(attrObj.name) !== -1) {
						var buffer = getBuffer(attrObj);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);

						var attrPosition = (0, _getAttribLoc2.default)(gl, mShaderProgram, attrObj.name);
						gl.enableVertexAttribArray(attrPosition);
						gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
						attrObj.attrPosition = attrPosition;

						if (attrObj.isInstanced) {
							gl.vertexAttribDivisor(attrPosition, 1);
						}
					}
				});

				this._updateIndexBuffer();
			}

			this._hasIndexBufferChanged = false;
			this._bufferChanged = [];
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			if (this._useVAO) {
				gl.bindVertexArray(null);
			}

			this._attributes.forEach(function (attribute) {
				if (attribute.isInstanced) {
					gl.vertexAttribDivisor(attribute.attrPosition, 0);
				}
			});
		}
	}, {
		key: '_updateIndexBuffer',
		value: function _updateIndexBuffer() {
			if (!this._hasIndexBufferChanged) {
				if (!this.iBuffer) {
					this.iBuffer = gl.createBuffer();
				}
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, this._drawType);
				this.iBuffer.itemSize = 1;
				this.iBuffer.numItems = this._numItems;
			}
		}
	}, {
		key: 'computeNormals',
		value: function computeNormals() {
			var usingFaceNormals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


			this.generateFaces();

			if (usingFaceNormals) {
				this._computeFaceNormals();
			} else {
				this._computeVertexNormals();
			}
		}

		//	PRIVATE METHODS

	}, {
		key: '_computeFaceNormals',
		value: function _computeFaceNormals() {

			var faceIndex = void 0;
			var face = void 0;
			var normals = [];

			for (var i = 0; i < this._indices.length; i += 3) {
				faceIndex = i / 3;
				face = this._faces[faceIndex];
				var N = face.normal;

				normals[face.indices[0]] = N;
				normals[face.indices[1]] = N;
				normals[face.indices[2]] = N;
			}

			this.bufferNormal(normals);
		}
	}, {
		key: '_computeVertexNormals',
		value: function _computeVertexNormals() {
			//	loop through all vertices
			var face = void 0;
			var sumNormal = _glMatrix.vec3.create();
			var normals = [];
			var vertices = this.vertices;


			for (var i = 0; i < vertices.length; i++) {

				_glMatrix.vec3.set(sumNormal, 0, 0, 0);

				for (var j = 0; j < this._faces.length; j++) {
					face = this._faces[j];

					//	if vertex exist in the face, add the normal to sum normal
					if (face.indices.indexOf(i) >= 0) {

						sumNormal[0] += face.normal[0];
						sumNormal[1] += face.normal[1];
						sumNormal[2] += face.normal[2];
					}
				}

				_glMatrix.vec3.normalize(sumNormal, sumNormal);
				normals.push([sumNormal[0], sumNormal[1], sumNormal[2]]);
			}

			this.bufferNormal(normals);
		}
	}, {
		key: 'generateFaces',
		value: function generateFaces() {
			var ia = void 0,
			    ib = void 0,
			    ic = void 0;
			var a = void 0,
			    b = void 0,
			    c = void 0;
			var vba = _glMatrix.vec3.create(),
			    vca = _glMatrix.vec3.create(),
			    vNormal = _glMatrix.vec3.create();
			var vertices = this.vertices;


			for (var i = 0; i < this._indices.length; i += 3) {

				ia = this._indices[i];
				ib = this._indices[i + 1];
				ic = this._indices[i + 2];

				a = vertices[ia];
				b = vertices[ib];
				c = vertices[ic];

				var face = {
					indices: [ia, ib, ic],
					vertices: [a, b, c]
				};

				this._faces.push(face);
			}
		}
	}, {
		key: 'getAttribute',
		value: function getAttribute(mName) {
			return this._attributes.find(function (a) {
				return a.name === mName;
			});
		}
	}, {
		key: 'getSource',
		value: function getSource(mName) {
			var attr = this.getAttribute(mName);
			return attr ? attr.source : [];
		}

		//	GETTER AND SETTERS

	}, {
		key: 'vertices',
		get: function get() {
			return this.getSource('aVertexPosition');
		}
	}, {
		key: 'normals',
		get: function get() {
			return this.getSource('aNormal');
		}
	}, {
		key: 'coords',
		get: function get() {
			return this.getSource('aTextureCoord');
		}
	}, {
		key: 'indices',
		get: function get() {
			return this._indices;
		}
	}, {
		key: 'vertexSize',
		get: function get() {
			return this.vertices.length;
		}
	}, {
		key: 'faces',
		get: function get() {
			return this._faces;
		}
	}, {
		key: 'attributes',
		get: function get() {
			return this._attributes;
		}
	}, {
		key: 'hasVAO',
		get: function get() {
			return this._hasVAO;
		}
	}, {
		key: 'vao',
		get: function get() {
			return this._vao;
		}
	}, {
		key: 'numInstance',
		get: function get() {
			return this._numInstance;
		}
	}, {
		key: 'isInstanced',
		get: function get() {
			return this._isInstanced;
		}
	}]);

	return Geometry;
}();

exports.default = Geometry;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (immutable) */ __webpack_exports__["setMatrixArrayType"] = setMatrixArrayType;
/* harmony export (immutable) */ __webpack_exports__["toRadian"] = toRadian;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = 0.000001;
/* harmony export (immutable) */ __webpack_exports__["EPSILON"] = EPSILON;

let ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
const RANDOM = Math.random;
/* harmony export (immutable) */ __webpack_exports__["RANDOM"] = RANDOM;


/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

const degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Batch.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Batch = function () {
	function Batch(mGeometry, mShader) {
		_classCallCheck(this, Batch);

		this._geometry = mGeometry;
		this._shader = mShader;
	}

	//	PUBLIC METHODS

	_createClass(Batch, [{
		key: 'draw',
		value: function draw() {
			this._shader.bind();
			_GLTool2.default.draw(this._geometry);
		}

		//	GETTER AND SETTER

	}, {
		key: 'geometry',
		get: function get() {
			return this._geometry;
		}
	}, {
		key: 'shader',
		get: function get() {
			return this._shader;
		}
	}]);

	return Batch;
}();

exports.default = Batch;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
// Scheduler.js


class Scheduler {

	constructor() {
		this._delayTasks = [];
		this._nextTasks = [];
		this._deferTasks = [];
		this._highTasks = [];
		this._usurpTask = [];
		this._enterframeTasks = [];
		this._idTable = 0;
		this.frameRate = 60;
		this._startTime = new Date().getTime();

		this._deltaTime = 0;

		this._loop();
	}


	//  PUBLIC METHODS

	addEF(func, params) {
		params = params || [];
		const id = this._idTable;
		this._enterframeTasks[id] = { func, params };
		this._idTable ++;
		return id;
	}

	removeEF(id) {
		if (this._enterframeTasks[id] !== undefined) {
			this._enterframeTasks[id] = null;
		}
		return -1;
	}

	delay(func, params, delay) {
		const time = new Date().getTime();
		const t = { func, params, delay, time };
		this._delayTasks.push(t);
	}

	defer(func, params) {
		const t = { func, params };
		this._deferTasks.push(t);
	}

	next(func, params) {
		const t = { func, params };
		this._nextTasks.push(t);
	}

	usurp(func, params) {
		const t = { func, params };
		this._usurpTask.push(t);
	}


	//  PRIVATE METHODS

	_process() {
		let i = 0;
		let task;
		let interval;
		let current;
		for (i = 0; i < this._enterframeTasks.length; i++) {
			task = this._enterframeTasks[i];
			if (task !== null && task !== undefined) {
				task.func(task.params);
			}
		}

		while (this._highTasks.length > 0) {
			task = this._highTasks.pop();
			task.func(task.params);
		}


		let startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;

		for (i = 0; i < this._delayTasks.length; i++) {
			task = this._delayTasks[i];
			if (startTime - task.time > task.delay) {
				task.func(task.params);
				this._delayTasks.splice(i, 1);
			}
		}

		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / this.frameRate;
		while (this._deferTasks.length > 0) {
			task = this._deferTasks.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			} else {
				this._deferTasks.unshift(task);
				break;
			}
		}


		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / this.frameRate;
		while (this._usurpTask.length > 0) {
			task = this._usurpTask.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			}
		}

		this._highTasks = this._highTasks.concat(this._nextTasks);
		this._nextTasks = [];
		this._usurpTask = [];
	}


	_loop() {
		this._process();
		window.requestAnimationFrame(() => this._loop());
	}

	get deltaTime() {
		return this._deltaTime;
	}
}

const scheduler = new Scheduler();

/* harmony default export */ __webpack_exports__["default"] = (scheduler);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Geom.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Geom = {};
var meshTri = void 0;

Geom.plane = function plane(width, height, numSegments) {
	var axis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'xy';
	var drawType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];

	var gapX = width / numSegments;
	var gapY = height / numSegments;
	var gapUV = 1 / numSegments;
	var sx = -width * 0.5;
	var sy = -height * 0.5;
	var index = 0;

	for (var i = 0; i < numSegments; i++) {
		for (var j = 0; j < numSegments; j++) {
			var tx = gapX * i + sx;
			var ty = gapY * j + sy;

			var u = i / numSegments;
			var v = j / numSegments;

			if (axis === 'xz') {
				positions.push([tx, 0, ty + gapY]);
				positions.push([tx + gapX, 0, ty + gapY]);
				positions.push([tx + gapX, 0, ty]);
				positions.push([tx, 0, ty]);

				coords.push([u, 1.0 - (v + gapUV)]);
				coords.push([u + gapUV, 1.0 - (v + gapUV)]);
				coords.push([u + gapUV, 1.0 - v]);
				coords.push([u, 1.0 - v]);

				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
			} else if (axis === 'yz') {
				positions.push([0, ty, tx]);
				positions.push([0, ty, tx + gapX]);
				positions.push([0, ty + gapY, tx + gapX]);
				positions.push([0, ty + gapY, tx]);

				coords.push([u, v]);
				coords.push([u + gapUV, v]);
				coords.push([u + gapUV, v + gapUV]);
				coords.push([u, v + gapUV]);

				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
			} else {
				positions.push([tx, ty, 0]);
				positions.push([tx + gapX, ty, 0]);
				positions.push([tx + gapX, ty + gapY, 0]);
				positions.push([tx, ty + gapY, 0]);

				coords.push([u, v]);
				coords.push([u + gapUV, v]);
				coords.push([u + gapUV, v + gapUV]);
				coords.push([u, v + gapUV]);

				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
			}

			indices.push(index * 4 + 0);
			indices.push(index * 4 + 1);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 0);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 3);

			index++;
		}
	}

	var mesh = new _Geometry2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.sphere = function sphere(size, numSegments) {
	var isInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	var drawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var gapUV = 1 / numSegments;
	var index = 0;

	function getPosition(i, j) {
		var isNormal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		//	rx : -90 ~ 90 , ry : 0 ~ 360
		var rx = i / numSegments * Math.PI - Math.PI * 0.5;
		var ry = j / numSegments * Math.PI * 2;
		var r = isNormal ? 1 : size;
		var pos = [];
		pos[1] = Math.sin(rx) * r;
		var t = Math.cos(rx) * r;
		pos[0] = Math.cos(ry) * t;
		pos[2] = Math.sin(ry) * t;

		var precision = 10000;
		pos[0] = Math.floor(pos[0] * precision) / precision;
		pos[1] = Math.floor(pos[1] * precision) / precision;
		pos[2] = Math.floor(pos[2] * precision) / precision;

		return pos;
	};

	for (var i = 0; i < numSegments; i++) {
		for (var j = 0; j < numSegments; j++) {
			positions.push(getPosition(i, j));
			positions.push(getPosition(i + 1, j));
			positions.push(getPosition(i + 1, j + 1));
			positions.push(getPosition(i, j + 1));

			normals.push(getPosition(i, j, true));
			normals.push(getPosition(i + 1, j, true));
			normals.push(getPosition(i + 1, j + 1, true));
			normals.push(getPosition(i, j + 1, true));

			var u = j / numSegments;
			var v = i / numSegments;

			coords.push([1.0 - u, v]);
			coords.push([1.0 - u, v + gapUV]);
			coords.push([1.0 - u - gapUV, v + gapUV]);
			coords.push([1.0 - u - gapUV, v]);

			indices.push(index * 4 + 0);
			indices.push(index * 4 + 1);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 0);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 3);

			index++;
		}
	}

	if (isInvert) {
		indices.reverse();
	}

	var mesh = new _Geometry2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.cube = function cube(w, h, d) {
	var drawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;

	h = h || w;
	d = d || w;

	var x = w / 2;
	var y = h / 2;
	var z = d / 2;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var count = 0;

	// BACK
	positions.push([-x, y, -z]);
	positions.push([x, y, -z]);
	positions.push([x, -y, -z]);
	positions.push([-x, -y, -z]);

	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// RIGHT
	positions.push([x, y, -z]);
	positions.push([x, y, z]);
	positions.push([x, -y, z]);
	positions.push([x, -y, -z]);

	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// FRONT
	positions.push([x, y, z]);
	positions.push([-x, y, z]);
	positions.push([-x, -y, z]);
	positions.push([x, -y, z]);

	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// LEFT
	positions.push([-x, y, z]);
	positions.push([-x, y, -z]);
	positions.push([-x, -y, -z]);
	positions.push([-x, -y, z]);

	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// TOP
	positions.push([x, y, -z]);
	positions.push([-x, y, -z]);
	positions.push([-x, y, z]);
	positions.push([x, y, z]);

	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// BOTTOM
	positions.push([x, -y, z]);
	positions.push([-x, -y, z]);
	positions.push([-x, -y, -z]);
	positions.push([x, -y, -z]);

	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	var mesh = new _Geometry2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.skybox = function skybox(size) {
	var drawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var count = 0;

	// BACK
	positions.push([size, size, -size]);
	positions.push([-size, size, -size]);
	positions.push([-size, -size, -size]);
	positions.push([size, -size, -size]);

	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// RIGHT
	positions.push([size, -size, -size]);
	positions.push([size, -size, size]);
	positions.push([size, size, size]);
	positions.push([size, size, -size]);

	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// FRONT
	positions.push([-size, size, size]);
	positions.push([size, size, size]);
	positions.push([size, -size, size]);
	positions.push([-size, -size, size]);

	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// LEFT
	positions.push([-size, -size, size]);
	positions.push([-size, -size, -size]);
	positions.push([-size, size, -size]);
	positions.push([-size, size, size]);

	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// TOP
	positions.push([size, size, size]);
	positions.push([-size, size, size]);
	positions.push([-size, size, -size]);
	positions.push([size, size, -size]);

	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// BOTTOM
	positions.push([size, -size, -size]);
	positions.push([-size, -size, -size]);
	positions.push([-size, -size, size]);
	positions.push([size, -size, size]);

	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	var mesh = new _Geometry2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.bigTriangle = function bigTriangle() {

	if (!meshTri) {
		var indices = [2, 1, 0];
		var positions = [[-1, -1], [-1, 4], [4, -1]];

		meshTri = new _Geometry2.default();
		meshTri.bufferData(positions, 'aPosition', 2);
		meshTri.bufferIndex(indices);
	}

	return meshTri;
};

exports.default = Geom;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Object3D.js

var _glMatrix = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Object3D = function () {
	function Object3D() {
		_classCallCheck(this, Object3D);

		this._needUpdate = true;

		this._x = 0;
		this._y = 0;
		this._z = 0;

		this._sx = 1;
		this._sy = 1;
		this._sz = 1;

		this._rx = 0;
		this._ry = 0;
		this._rz = 0;

		this._position = _glMatrix.vec3.create();
		this._scale = _glMatrix.vec3.fromValues(1, 1, 1);
		this._rotation = _glMatrix.vec3.create();

		this._matrix = _glMatrix.mat4.create();
		this._matrixParent = _glMatrix.mat4.create();
		this._matrixRotation = _glMatrix.mat4.create();
		this._matrixScale = _glMatrix.mat4.create();
		this._matrixTranslation = _glMatrix.mat4.create();
		this._matrixQuaternion = _glMatrix.mat4.create();
		this._quat = _glMatrix.quat.create();

		this._children = [];
	}

	_createClass(Object3D, [{
		key: 'updateMatrix',
		value: function updateMatrix() {
			var _this = this;

			if (!this._needUpdate) {
				return;
			}

			_glMatrix.vec3.set(this._scale, this._sx, this._sy, this._sz);
			_glMatrix.vec3.set(this._rotation, this._rx, this._ry, this._rz);
			_glMatrix.vec3.set(this._position, this._x, this._y, this._z);

			_glMatrix.mat4.identity(this._matrixTranslation, this._matrixTranslation);
			_glMatrix.mat4.identity(this._matrixScale, this._matrixScale);
			_glMatrix.mat4.identity(this._matrixRotation, this._matrixRotation);

			_glMatrix.mat4.rotateX(this._matrixRotation, this._matrixRotation, this._rx);
			_glMatrix.mat4.rotateY(this._matrixRotation, this._matrixRotation, this._ry);
			_glMatrix.mat4.rotateZ(this._matrixRotation, this._matrixRotation, this._rz);

			_glMatrix.mat4.fromQuat(this._matrixQuaternion, this._quat);
			_glMatrix.mat4.mul(this._matrixRotation, this._matrixQuaternion, this._matrixRotation);

			_glMatrix.mat4.scale(this._matrixScale, this._matrixScale, this._scale);
			_glMatrix.mat4.translate(this._matrixTranslation, this._matrixTranslation, this._position);

			_glMatrix.mat4.mul(this._matrix, this._matrixTranslation, this._matrixRotation);
			_glMatrix.mat4.mul(this._matrix, this._matrix, this._matrixScale);
			_glMatrix.mat4.mul(this._matrix, this._matrixParent, this._matrix);

			this._children.forEach(function (child) {
				child.updateParentMatrix(_this._matrix);
			});

			this._needUpdate = false;
		}
	}, {
		key: 'updateParentMatrix',
		value: function updateParentMatrix(mParentMatrix) {
			mParentMatrix = mParentMatrix || _glMatrix.mat4.create();
			_glMatrix.mat4.copy(this._matrixParent, mParentMatrix);
			this._needUpdate = true;
		}
	}, {
		key: 'setRotationFromQuaternion',
		value: function setRotationFromQuaternion(mQuat) {
			_glMatrix.quat.copy(this._quat, mQuat);
			this._needUpdate = true;
		}
	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}
	}, {
		key: 'matrix',
		get: function get() {
			this.updateMatrix();
			return this._matrix;
		}
	}, {
		key: 'x',
		get: function get() {
			return this._x;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._x = mValue;
		}
	}, {
		key: 'y',
		get: function get() {
			return this._y;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._y = mValue;
		}
	}, {
		key: 'z',
		get: function get() {
			return this._z;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._z = mValue;
		}
	}, {
		key: 'scaleX',
		get: function get() {
			return this._sx;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sx = mValue;
		}
	}, {
		key: 'scaleY',
		get: function get() {
			return this._sy;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sy = mValue;
		}
	}, {
		key: 'scaleZ',
		get: function get() {
			return this._sz;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sz = mValue;
		}
	}, {
		key: 'rotationX',
		get: function get() {
			return this._rx;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._rx = mValue;
		}
	}, {
		key: 'rotationY',
		get: function get() {
			return this._ry;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._ry = mValue;
		}
	}, {
		key: 'rotationZ',
		get: function get() {
			return this._rz;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._rz = mValue;
		}
	}, {
		key: 'children',
		get: function get() {
			return this._children;
		}
	}]);

	return Object3D;
}();

exports.default = Object3D;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTexture.js

var _getTextureParameters = __webpack_require__(59);

var _getTextureParameters2 = _interopRequireDefault(_getTextureParameters);

var _WebglNumber = __webpack_require__(10);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var GLTexture = function () {
	function GLTexture(mSource) {
		var mParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var _this = this;

		var mWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
		var mHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

		_classCallCheck(this, GLTexture);

		gl = _GLTool2.default.gl;

		this._source = mSource;
		this._getDimension(mSource, mWidth, mHeight);
		this._sourceType = mParam.type || getSourceType(mSource);
		this._checkSource();
		this._texelType = this._getTexelType();
		this._isTextureReady = true;

		this._params = (0, _getTextureParameters2.default)(mParam, mSource, this._width, this._height);
		this._checkMipmap();
		this._checkWrapping();

		//	setup texture
		this._texture = gl.createTexture();

		if (this._sourceType === 'video') {
			this._isTextureReady = false;
			_scheduling2.default.addEF(function () {
				return _this._loop();
			});
		} else {
			this._uploadTexture();
		}
	}

	_createClass(GLTexture, [{
		key: '_loop',
		value: function _loop() {
			if (this._source.readyState == 4) {
				this._isTextureReady = true;
				this._uploadTexture();
			}
		}
	}, {
		key: '_uploadTexture',
		value: function _uploadTexture() {
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			if (this._isSourceHtmlElement()) {
				gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._params.format, this._texelType, this._source);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._width, this._height, 0, this._params.format, this._texelType, this._source);
			}

			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._params.premultiplyAlpha);

			if (this._params.anisotropy > 0) {
				var ext = _GLTool2.default.getExtension('EXT_texture_filter_anisotropic');
				if (ext) {
					var max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
					var level = Math.min(max, this._params.anisotropy);
					gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, level);
				}
			}

			if (this._generateMipmap) {
				gl.generateMipmap(gl.TEXTURE_2D);
			}

			//	unbind texture
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'bind',
		value: function bind(index) {
			if (index === undefined) {
				index = 0;
			}
			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			if (this._isTextureReady) {
				gl.bindTexture(gl.TEXTURE_2D, this._texture);
			} else {
				gl.bindTexture(gl.TEXTURE_2D, GLTexture.blackTexture().texture);
			}

			this._bindIndex = index;
		}
	}, {
		key: 'updateTexture',
		value: function updateTexture(mSource) {
			this._source = mSource;
			this._checkSource();
			this._uploadTexture();
		}
	}, {
		key: 'generateMipmap',
		value: function generateMipmap() {
			if (!this._generateMipmap) {
				return;
			}
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.generateMipmap(gl.TEXTURE_2D);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'showParameters',
		value: function showParameters() {
			console.log('Source type : ', _WebglNumber2.default[this._sourceType] || this._sourceType);
			console.log('Texel type:', _WebglNumber2.default[this.texelType]);
			console.log('Dimension :', this._width, this._height);
			for (var s in this._params) {
				console.log(s, _WebglNumber2.default[this._params[s]] || this._params[s]);
			}

			console.log('Mipmapping :', this._generateMipmap);
		}
	}, {
		key: '_getDimension',
		value: function _getDimension(mSource, mWidth, mHeight) {
			if (mSource) {
				//	for html image / video element
				this._width = mSource.width || mSource.videoWidth;
				this._height = mSource.height || mSource.videoWidth;

				//	for manual width / height settings
				this._width = this._width || mWidth;
				this._height = this._height || mHeight;

				//	auto detect ( data array) ? not sure is good idea ? 
				//	todo : check HDR 
				if (!this._width || !this._height) {
					this._width = this._height = Math.sqrt(mSource.length / 4);
					// console.log('Auto detect, data dimension : ', this._width, this._height);	
				}
			} else {
				this._width = mWidth;
				this._height = mHeight;
			}
		}
	}, {
		key: '_checkSource',
		value: function _checkSource() {
			if (!this._source) {
				return;
			}

			if (this._sourceType === _GLTool2.default.UNSIGNED_BYTE) {
				if (!(this._source instanceof Uint8Array)) {
					// console.log('Converting to Uint8Array');
					this._source = new Uint8Array(this._source);
				}
			} else if (this._sourceType === _GLTool2.default.FLOAT) {
				if (!(this._source instanceof Float32Array)) {
					// console.log('Converting to Float32Array');
					this._source = new Float32Array(this._source);
				}
			}
		}
	}, {
		key: '_getTexelType',
		value: function _getTexelType() {
			if (this._isSourceHtmlElement()) {
				return _GLTool2.default.UNSIGNED_BYTE;
			}

			//	bad code here, if the type is not on the webglNumber list, it doesn't work
			return _GLTool2.default[_WebglNumber2.default[this._sourceType]] || this._sourceType;
		}
	}, {
		key: '_checkMipmap',
		value: function _checkMipmap() {
			this._generateMipmap = this._params.mipmap;

			if (!(isPowerOfTwo(this._width) && isPowerOfTwo(this._height))) {
				this._generateMipmap = false;
			}

			var minFilter = _WebglNumber2.default[this._params.minFilter];
			if (minFilter.indexOf('MIPMAP') == -1) {
				this._generateMipmap = false;
			}
		}
	}, {
		key: '_checkWrapping',
		value: function _checkWrapping() {
			if (!this._generateMipmap) {
				this._params.wrapS = _GLTool2.default.CLAMP_TO_EDGE;
				this._params.wrapT = _GLTool2.default.CLAMP_TO_EDGE;
			}
		}
	}, {
		key: '_isSourceHtmlElement',
		value: function _isSourceHtmlElement() {
			return this._sourceType === 'image' || this._sourceType === 'video' || this._sourceType === 'canvas';
		}
	}, {
		key: 'minFilter',
		get: function get() {
			return this._params.minFilter;
		},
		set: function set(mValue) {
			this._params.minFilter = mValue;
			this._checkMipmap();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);

			this.generateMipmap();
		}
	}, {
		key: 'magFilter',
		get: function get() {
			return this._params.minFilter;
		},
		set: function set(mValue) {
			this._params.magFilter = mValue;

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'wrapS',
		get: function get() {
			return this._params.wrapS;
		},
		set: function set(mValue) {
			this._params.wrapS = mValue;
			this._checkWrapping();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'wrapT',
		get: function get() {
			return this._params.wrapT;
		},
		set: function set(mValue) {
			this._params.wrapT = mValue;
			this._checkWrapping();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'texelType',
		get: function get() {
			return this._texelType;
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'texture',
		get: function get() {
			return this._texture;
		}
	}, {
		key: 'isTextureReady',
		get: function get() {
			return this._isTextureReady;
		}
	}]);

	return GLTexture;
}();

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

function getSourceType(mSource) {
	//	possible source type : Image / Video / Unit8Array / Float32Array
	//	this list must be flexible

	var type = _GLTool2.default.UNSIGNED_BYTE;

	if (mSource instanceof Array) {
		type = _GLTool2.default.UNSIGNED_BYTE;
	} else if (mSource instanceof Uint8Array) {
		type = _GLTool2.default.UNSIGNED_BYTE;
	} else if (mSource instanceof Float32Array) {
		type = _GLTool2.default.FLOAT;
	} else if (mSource instanceof HTMLImageElement) {
		type = 'image';
	} else if (mSource instanceof HTMLCanvasElement) {
		type = 'canvas';
	} else if (mSource instanceof HTMLVideoElement) {
		type = 'video';
	}
	return type;
}

var _whiteTexture = void 0,
    _greyTexture = void 0,
    _blackTexture = void 0;

GLTexture.whiteTexture = function whiteTexture() {
	if (_whiteTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = '#fff';
		ctx.fillRect(0, 0, 2, 2);
		_whiteTexture = new GLTexture(canvas);
	}

	return _whiteTexture;
};

GLTexture.greyTexture = function greyTexture() {
	if (_greyTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(127, 127, 127)';
		ctx.fillRect(0, 0, 2, 2);
		_greyTexture = new GLTexture(canvas);
	}
	return _greyTexture;
};

GLTexture.blackTexture = function blackTexture() {
	if (_blackTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(0, 0, 0)';
		ctx.fillRect(0, 0, 2, 2);
		_blackTexture = new GLTexture(canvas);
	}
	return _blackTexture;
};

exports.default = GLTexture;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^
module.exports = {
	0: 'NONE',
	1: 'ONE',
	2: 'LINE_LOOP',
	3: 'LINE_STRIP',
	4: 'TRIANGLES',
	5: 'TRIANGLE_STRIP',
	6: 'TRIANGLE_FAN',
	256: 'DEPTH_BUFFER_BIT',
	512: 'NEVER',
	513: 'LESS',
	514: 'EQUAL',
	515: 'LEQUAL',
	516: 'GREATER',
	517: 'NOTEQUAL',
	518: 'GEQUAL',
	519: 'ALWAYS',
	768: 'SRC_COLOR',
	769: 'ONE_MINUS_SRC_COLOR',
	770: 'SRC_ALPHA',
	771: 'ONE_MINUS_SRC_ALPHA',
	772: 'DST_ALPHA',
	773: 'ONE_MINUS_DST_ALPHA',
	774: 'DST_COLOR',
	775: 'ONE_MINUS_DST_COLOR',
	776: 'SRC_ALPHA_SATURATE',
	1024: 'STENCIL_BUFFER_BIT',
	1028: 'FRONT',
	1029: 'BACK',
	1032: 'FRONT_AND_BACK',
	1280: 'INVALID_ENUM',
	1281: 'INVALID_VALUE',
	1282: 'INVALID_OPERATION',
	1285: 'OUT_OF_MEMORY',
	1286: 'INVALID_FRAMEBUFFER_OPERATION',
	2304: 'CW',
	2305: 'CCW',
	2849: 'LINE_WIDTH',
	2884: 'CULL_FACE',
	2885: 'CULL_FACE_MODE',
	2886: 'FRONT_FACE',
	2928: 'DEPTH_RANGE',
	2929: 'DEPTH_TEST',
	2930: 'DEPTH_WRITEMASK',
	2931: 'DEPTH_CLEAR_VALUE',
	2932: 'DEPTH_FUNC',
	2960: 'STENCIL_TEST',
	2961: 'STENCIL_CLEAR_VALUE',
	2962: 'STENCIL_FUNC',
	2963: 'STENCIL_VALUE_MASK',
	2964: 'STENCIL_FAIL',
	2965: 'STENCIL_PASS_DEPTH_FAIL',
	2966: 'STENCIL_PASS_DEPTH_PASS',
	2967: 'STENCIL_REF',
	2968: 'STENCIL_WRITEMASK',
	2978: 'VIEWPORT',
	3024: 'DITHER',
	3042: 'BLEND',
	3088: 'SCISSOR_BOX',
	3089: 'SCISSOR_TEST',
	3106: 'COLOR_CLEAR_VALUE',
	3107: 'COLOR_WRITEMASK',
	3317: 'UNPACK_ALIGNMENT',
	3333: 'PACK_ALIGNMENT',
	3379: 'MAX_TEXTURE_SIZE',
	3386: 'MAX_VIEWPORT_DIMS',
	3408: 'SUBPIXEL_BITS',
	3410: 'RED_BITS',
	3411: 'GREEN_BITS',
	3412: 'BLUE_BITS',
	3413: 'ALPHA_BITS',
	3414: 'DEPTH_BITS',
	3415: 'STENCIL_BITS',
	3553: 'TEXTURE_2D',
	4352: 'DONT_CARE',
	4353: 'FASTEST',
	4354: 'NICEST',
	5120: 'BYTE',
	5121: 'UNSIGNED_BYTE',
	5122: 'SHORT',
	5123: 'UNSIGNED_SHORT',
	5124: 'INT',
	5125: 'UNSIGNED_INT',
	5126: 'FLOAT',
	5386: 'INVERT',
	5890: 'TEXTURE',
	6401: 'STENCIL_INDEX',
	6402: 'DEPTH_COMPONENT',
	6403: 'RED',
	6406: 'ALPHA',
	6407: 'RGB',
	6408: 'RGBA',
	6409: 'LUMINANCE',
	6410: 'LUMINANCE_ALPHA',
	7680: 'KEEP',
	7681: 'REPLACE',
	7682: 'INCR',
	7683: 'DECR',
	7936: 'VENDOR',
	7937: 'RENDERER',
	7938: 'VERSION',
	9728: 'NEAREST',
	9729: 'LINEAR',
	9984: 'NEAREST_MIPMAP_NEAREST',
	9985: 'LINEAR_MIPMAP_NEAREST',
	9986: 'NEAREST_MIPMAP_LINEAR',
	9987: 'LINEAR_MIPMAP_LINEAR',
	10240: 'TEXTURE_MAG_FILTER',
	10241: 'TEXTURE_MIN_FILTER',
	10242: 'TEXTURE_WRAP_S',
	10243: 'TEXTURE_WRAP_T',
	10497: 'REPEAT',
	10752: 'POLYGON_OFFSET_UNITS',
	16384: 'COLOR_BUFFER_BIT',
	32769: 'CONSTANT_COLOR',
	32770: 'ONE_MINUS_CONSTANT_COLOR',
	32771: 'CONSTANT_ALPHA',
	32772: 'ONE_MINUS_CONSTANT_ALPHA',
	32773: 'BLEND_COLOR',
	32774: 'FUNC_ADD',
	32777: 'BLEND_EQUATION_RGB',
	32778: 'FUNC_SUBTRACT',
	32779: 'FUNC_REVERSE_SUBTRACT',
	32819: 'UNSIGNED_SHORT_4_4_4_4',
	32820: 'UNSIGNED_SHORT_5_5_5_1',
	32823: 'POLYGON_OFFSET_FILL',
	32824: 'POLYGON_OFFSET_FACTOR',
	32854: 'RGBA4',
	32855: 'RGB5_A1',
	32873: 'TEXTURE_BINDING_2D',
	32926: 'SAMPLE_ALPHA_TO_COVERAGE',
	32928: 'SAMPLE_COVERAGE',
	32936: 'SAMPLE_BUFFERS',
	32937: 'SAMPLES',
	32938: 'SAMPLE_COVERAGE_VALUE',
	32939: 'SAMPLE_COVERAGE_INVERT',
	32968: 'BLEND_DST_RGB',
	32969: 'BLEND_SRC_RGB',
	32970: 'BLEND_DST_ALPHA',
	32971: 'BLEND_SRC_ALPHA',
	33071: 'CLAMP_TO_EDGE',
	33170: 'GENERATE_MIPMAP_HINT',
	33189: 'DEPTH_COMPONENT16',
	33306: 'DEPTH_STENCIL_ATTACHMENT',
	33321: 'R8',
	33635: 'UNSIGNED_SHORT_5_6_5',
	33648: 'MIRRORED_REPEAT',
	33901: 'ALIASED_POINT_SIZE_RANGE',
	33902: 'ALIASED_LINE_WIDTH_RANGE',
	33984: 'TEXTURE0',
	33985: 'TEXTURE1',
	33986: 'TEXTURE2',
	33987: 'TEXTURE3',
	33988: 'TEXTURE4',
	33989: 'TEXTURE5',
	33990: 'TEXTURE6',
	33991: 'TEXTURE7',
	33992: 'TEXTURE8',
	33993: 'TEXTURE9',
	33994: 'TEXTURE10',
	33995: 'TEXTURE11',
	33996: 'TEXTURE12',
	33997: 'TEXTURE13',
	33998: 'TEXTURE14',
	33999: 'TEXTURE15',
	34000: 'TEXTURE16',
	34001: 'TEXTURE17',
	34002: 'TEXTURE18',
	34003: 'TEXTURE19',
	34004: 'TEXTURE20',
	34005: 'TEXTURE21',
	34006: 'TEXTURE22',
	34007: 'TEXTURE23',
	34008: 'TEXTURE24',
	34009: 'TEXTURE25',
	34010: 'TEXTURE26',
	34011: 'TEXTURE27',
	34012: 'TEXTURE28',
	34013: 'TEXTURE29',
	34014: 'TEXTURE30',
	34015: 'TEXTURE31',
	34016: 'ACTIVE_TEXTURE',
	34024: 'MAX_RENDERBUFFER_SIZE',
	34041: 'DEPTH_STENCIL',
	34055: 'INCR_WRAP',
	34056: 'DECR_WRAP',
	34067: 'TEXTURE_CUBE_MAP',
	34068: 'TEXTURE_BINDING_CUBE_MAP',
	34069: 'TEXTURE_CUBE_MAP_POSITIVE_X',
	34070: 'TEXTURE_CUBE_MAP_NEGATIVE_X',
	34071: 'TEXTURE_CUBE_MAP_POSITIVE_Y',
	34072: 'TEXTURE_CUBE_MAP_NEGATIVE_Y',
	34073: 'TEXTURE_CUBE_MAP_POSITIVE_Z',
	34074: 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
	34076: 'MAX_CUBE_MAP_TEXTURE_SIZE',
	34338: 'VERTEX_ATTRIB_ARRAY_ENABLED',
	34339: 'VERTEX_ATTRIB_ARRAY_SIZE',
	34340: 'VERTEX_ATTRIB_ARRAY_STRIDE',
	34341: 'VERTEX_ATTRIB_ARRAY_TYPE',
	34342: 'CURRENT_VERTEX_ATTRIB',
	34373: 'VERTEX_ATTRIB_ARRAY_POINTER',
	34466: 'NUM_COMPRESSED_TEXTURE_FORMATS',
	34467: 'COMPRESSED_TEXTURE_FORMATS',
	34660: 'BUFFER_SIZE',
	34661: 'BUFFER_USAGE',
	34816: 'STENCIL_BACK_FUNC',
	34817: 'STENCIL_BACK_FAIL',
	34818: 'STENCIL_BACK_PASS_DEPTH_FAIL',
	34819: 'STENCIL_BACK_PASS_DEPTH_PASS',
	34877: 'BLEND_EQUATION_ALPHA',
	34921: 'MAX_VERTEX_ATTRIBS',
	34922: 'VERTEX_ATTRIB_ARRAY_NORMALIZED',
	34930: 'MAX_TEXTURE_IMAGE_UNITS',
	34962: 'ARRAY_BUFFER',
	34963: 'ELEMENT_ARRAY_BUFFER',
	34964: 'ARRAY_BUFFER_BINDING',
	34965: 'ELEMENT_ARRAY_BUFFER_BINDING',
	34975: 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING',
	35040: 'STREAM_DRAW',
	35044: 'STATIC_DRAW',
	35048: 'DYNAMIC_DRAW',
	35632: 'FRAGMENT_SHADER',
	35633: 'VERTEX_SHADER',
	35660: 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
	35661: 'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
	35663: 'SHADER_TYPE',
	35664: 'FLOAT_VEC2',
	35665: 'FLOAT_VEC3',
	35666: 'FLOAT_VEC4',
	35667: 'INT_VEC2',
	35668: 'INT_VEC3',
	35669: 'INT_VEC4',
	35670: 'BOOL',
	35671: 'BOOL_VEC2',
	35672: 'BOOL_VEC3',
	35673: 'BOOL_VEC4',
	35674: 'FLOAT_MAT2',
	35675: 'FLOAT_MAT3',
	35676: 'FLOAT_MAT4',
	35678: 'SAMPLER_2D',
	35680: 'SAMPLER_CUBE',
	35712: 'DELETE_STATUS',
	35713: 'COMPILE_STATUS',
	35714: 'LINK_STATUS',
	35715: 'VALIDATE_STATUS',
	35716: 'INFO_LOG_LENGTH',
	35717: 'ATTACHED_SHADERS',
	35718: 'ACTIVE_UNIFORMS',
	35719: 'ACTIVE_UNIFORM_MAX_LENGTH',
	35720: 'SHADER_SOURCE_LENGTH',
	35721: 'ACTIVE_ATTRIBUTES',
	35722: 'ACTIVE_ATTRIBUTE_MAX_LENGTH',
	35724: 'SHADING_LANGUAGE_VERSION',
	35725: 'CURRENT_PROGRAM',
	36003: 'STENCIL_BACK_REF',
	36004: 'STENCIL_BACK_VALUE_MASK',
	36005: 'STENCIL_BACK_WRITEMASK',
	36006: 'FRAMEBUFFER_BINDING',
	36007: 'RENDERBUFFER_BINDING',
	36048: 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE',
	36049: 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME',
	36050: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL',
	36051: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE',
	36053: 'FRAMEBUFFER_COMPLETE',
	36054: 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',
	36055: 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',
	36057: 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',
	36061: 'FRAMEBUFFER_UNSUPPORTED',
	36064: 'COLOR_ATTACHMENT0',
	36096: 'DEPTH_ATTACHMENT',
	36128: 'STENCIL_ATTACHMENT',
	36160: 'FRAMEBUFFER',
	36161: 'RENDERBUFFER',
	36162: 'RENDERBUFFER_WIDTH',
	36163: 'RENDERBUFFER_HEIGHT',
	36164: 'RENDERBUFFER_INTERNAL_FORMAT',
	36168: 'STENCIL_INDEX8',
	36176: 'RENDERBUFFER_RED_SIZE',
	36177: 'RENDERBUFFER_GREEN_SIZE',
	36178: 'RENDERBUFFER_BLUE_SIZE',
	36179: 'RENDERBUFFER_ALPHA_SIZE',
	36180: 'RENDERBUFFER_DEPTH_SIZE',
	36181: 'RENDERBUFFER_STENCIL_SIZE',
	36194: 'RGB565',
	36336: 'LOW_FLOAT',
	36337: 'MEDIUM_FLOAT',
	36338: 'HIGH_FLOAT',
	36339: 'LOW_INT',
	36340: 'MEDIUM_INT',
	36341: 'HIGH_INT',
	36346: 'SHADER_COMPILER',
	36347: 'MAX_VERTEX_UNIFORM_VECTORS',
	36348: 'MAX_VARYING_VECTORS',
	36349: 'MAX_FRAGMENT_UNIFORM_VECTORS',
	37440: 'UNPACK_FLIP_Y_WEBGL',
	37441: 'UNPACK_PREMULTIPLY_ALPHA_WEBGL',
	37442: 'CONTEXT_LOST_WEBGL',
	37443: 'UNPACK_COLORSPACE_CONVERSION_WEBGL',
	37444: 'BROWSER_DEFAULT_WEBGL'
};

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = "// simpleColor.frag\n\n#define SHADER_NAME SIMPLE_COLOR\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec3 color;\nuniform float opacity;\n\nvoid main(void) {\n    gl_FragColor = vec4(color, opacity);\n}"

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Pass.js

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _FrameBuffer = __webpack_require__(18);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

var _ShaderLibs = __webpack_require__(21);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Pass = function () {
	function Pass(mSource) {
		var mWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var mHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
		var mParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

		_classCallCheck(this, Pass);

		this.shader = new _GLShader2.default(_ShaderLibs2.default.bigTriangleVert, mSource);

		this._width = mWidth;
		this._height = mHeight;
		this._uniforms = {};
		this._hasOwnFbo = this._width > 0 && this._width > 0;
		this._uniforms = {};

		if (this._hasOwnFbo) {
			this._fbo = new _FrameBuffer2.default(this._width, this.height, mParmas);
		}
	}

	_createClass(Pass, [{
		key: 'uniform',
		value: function uniform(mName, mValue) {
			this._uniforms[mName] = mValue;
		}
	}, {
		key: 'render',
		value: function render(texture) {
			this.shader.bind();
			this.shader.uniform('texture', 'uniform1i', 0);
			texture.bind(0);

			this.shader.uniform(this._uniforms);
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'fbo',
		get: function get() {
			return this._fbo;
		}
	}, {
		key: 'hasFbo',
		get: function get() {
			return this._hasOwnFbo;
		}
	}]);

	return Pass;
}();

exports.default = Pass;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Object3D2 = __webpack_require__(8);

var _Object3D3 = _interopRequireDefault(_Object3D2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Mesh = function (_Object3D) {
	_inherits(Mesh, _Object3D);

	function Mesh(geometry, material) {
		_classCallCheck(this, Mesh);

		var _this = _possibleConstructorReturn(this, (Mesh.__proto__ || Object.getPrototypeOf(Mesh)).call(this));

		_this.geometry = geometry;
		_this.material = material;
		return _this;
	}

	return Mesh;
}(_Object3D3.default);

exports.default = Mesh;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GLCubeTexture.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _parseDds = __webpack_require__(60);

var _parseDds2 = _interopRequireDefault(_parseDds);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var DDSD_MIPMAPCOUNT = 0x20000;
var OFF_MIPMAPCOUNT = 7;
var headerLengthInt = 31;

var GLCubeTexture = function () {
	function GLCubeTexture(mSource) {
		var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var isCubeTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

		_classCallCheck(this, GLCubeTexture);

		gl = _GLTool2.default.gl;

		if (isCubeTexture) {
			this.texture = mSource;
			return;
		}

		var hasMipmaps = mSource.length > 6;
		if (mSource[0].mipmapCount) {
			hasMipmaps = mSource[0].mipmapCount > 1;
		}

		this.texture = gl.createTexture();
		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR_MIPMAP_LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

		if (!hasMipmaps && this.minFilter == gl.LINEAR_MIPMAP_LINEAR) {
			this.minFilter = gl.LINEAR;
		}

		gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
		var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

		var numLevels = 1;
		var index = 0;
		numLevels = mSource.length / 6;
		this.numLevels = numLevels;

		if (hasMipmaps) {
			for (var j = 0; j < 6; j++) {
				for (var i = 0; i < numLevels; i++) {
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

					index = j * numLevels + i;
					if (mSource[index].shape) {
						gl.texImage2D(targets[j], i, gl.RGBA, mSource[index].shape[0], mSource[index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[index].data);
					} else {
						gl.texImage2D(targets[j], i, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[index]);
					}

					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
				}
			}
		} else {
			var _index = 0;
			for (var _j = 0; _j < 6; _j++) {
				_index = _j * numLevels;
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				if (mSource[_index].shape) {
					gl.texImage2D(targets[_j], 0, gl.RGBA, mSource[_index].shape[0], mSource[_index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[_index].data);
				} else {
					gl.texImage2D(targets[_j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[_index]);
				}
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
			}

			gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
		}

		gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	}

	//	PUBLIC METHOD

	_createClass(GLCubeTexture, [{
		key: 'bind',
		value: function bind() {
			var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
			// gl.uniform1i(GL.shader.uniformTextures[index], index);
			this._bindIndex = index;
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		}
	}]);

	return GLCubeTexture;
}();

GLCubeTexture.parseDDS = function parseDDS(mArrayBuffer) {

	function clamp(value, min, max) {
		if (min > max) {
			return clamp(value, max, min);
		}

		if (value < min) return min;else if (value > max) return max;else return value;
	}

	//	CHECKING MIP MAP LEVELS
	var ddsInfos = (0, _parseDds2.default)(mArrayBuffer);
	var flags = ddsInfos.flags;

	var header = new Int32Array(mArrayBuffer, 0, headerLengthInt);
	var mipmapCount = 1;
	if (flags & DDSD_MIPMAPCOUNT) {
		mipmapCount = Math.max(1, header[OFF_MIPMAPCOUNT]);
	}
	var sources = ddsInfos.images.map(function (img) {
		var faceData = new Float32Array(mArrayBuffer.slice(img.offset, img.offset + img.length));
		return {
			data: faceData,
			shape: img.shape,
			mipmapCount: mipmapCount
		};
	});

	return new GLCubeTexture(sources);
};

exports.default = GLCubeTexture;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shaderCache = []; // Shaders.js

var definesToString = function definesToString(defines) {
	var outStr = '';
	for (var def in defines) {
		if (defines[def]) {
			outStr += '#define ' + def + ' ' + defines[def] + '\n';
		}
	}
	return outStr;
};

var getUniformType = function getUniformType(mValue) {
	if (mValue.length) {
		return 'vec' + mValue.length;
	} else {
		return 'float';
	}
};

var addUniforms = function addUniforms(mShader, mObjUniforms) {

	var strUniforms = '';
	for (var uniformName in mObjUniforms) {
		var uniformValue = mObjUniforms[uniformName];
		var uniformType = getUniformType(uniformValue);

		strUniforms += 'uniform ' + uniformType + ' ' + uniformName + ';\n';
	}

	mShader = mShader.replace('{{UNIFORMS}}', strUniforms);

	return mShader;
};

var bindUniforms = function bindUniforms(mShader, mObjUniforms) {

	for (var uniformName in mObjUniforms) {
		var uniformValue = mObjUniforms[uniformName];
		var uniformType = getUniformType(uniformValue);
		mShader.uniform(uniformName, uniformType, uniformValue);
	}
};

var injectDefines = function injectDefines(mShader, mDefines) {

	return definesToString(mDefines) + '\n' + mShader;
};

var get = function get(vs, fs) {
	var defines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	var _shader = void 0;
	var _vs = injectDefines(vs, defines);
	var _fs = injectDefines(fs, defines);

	shaderCache.forEach(function (shader) {
		if (_vs === shader.vs && _fs === shader.fs) {
			_shader = shader.glShader;
		}
	});

	if (!_shader) {
		_shader = new _GLShader2.default(_vs, _fs);
		shaderCache.push({
			vs: _vs,
			fs: _fs,
			glShader: _shader
		});
	}

	return _shader;
};

exports.default = {
	get: get,
	addUniforms: addUniforms,
	bindUniforms: bindUniforms,
	injectDefines: injectDefines
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // FrameBuffer.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _WebglNumber = __webpack_require__(10);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _objectAssign = __webpack_require__(17);

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var webglDepthTexture = void 0;
var hasCheckedMultiRenderSupport = false;
var extDrawBuffer = void 0;

var checkMultiRender = function checkMultiRender() {
	if (_GLTool2.default.webgl2) {
		return true;
	} else {
		extDrawBuffer = _GLTool2.default.getExtension('WEBGL_draw_buffers');
		return !!extDrawBuffer;
	}

	hasCheckedMultiRenderSupport = true;
};

var FrameBuffer = function () {
	function FrameBuffer(mWidth, mHeight) {
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		var mNumTargets = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

		_classCallCheck(this, FrameBuffer);

		gl = _GLTool2.default.gl;
		webglDepthTexture = _GLTool2.default.checkExtension('WEBGL_depth_texture');

		this.width = mWidth;
		this.height = mHeight;
		this._numTargets = mNumTargets;
		this._multipleTargets = mNumTargets > 1;
		this._parameters = mParameters;

		if (!hasCheckedMultiRenderSupport) {
			checkMultiRender();
		}

		if (this._multipleTargets) {
			this._checkMaxNumRenderTarget();
		}

		this._init();
	}

	_createClass(FrameBuffer, [{
		key: '_init',
		value: function _init() {
			this._initTextures();

			this.frameBuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

			if (_GLTool2.default.webgl2) {
				// this.renderBufferDepth = gl.createRenderbuffer();
				// gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
				// gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
				// gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);

				var buffers = [];
				for (var i = 0; i < this._numTargets; i++) {
					gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, this._textures[i].texture, 0);
					buffers.push(gl['COLOR_ATTACHMENT' + i]);
				}

				gl.drawBuffers(buffers);

				gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			} else {
				for (var _i = 0; _i < this._numTargets; _i++) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i, gl.TEXTURE_2D, this._textures[_i].texture, 0);
				}

				if (this._multipleTargets) {
					var drawBuffers = [];
					for (var _i2 = 0; _i2 < this._numTargets; _i2++) {
						drawBuffers.push(extDrawBuffer['COLOR_ATTACHMENT' + _i2 + '_WEBGL']);
					}

					extDrawBuffer.drawBuffersWEBGL(drawBuffers);
				}

				if (webglDepthTexture) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
				}
			}

			//	CHECKING FBO
			var FBOstatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			if (FBOstatus != gl.FRAMEBUFFER_COMPLETE) {
				console.error('GL_FRAMEBUFFER_COMPLETE failed, CANNOT use Framebuffer', _WebglNumber2.default[FBOstatus]);
			}

			//	UNBIND

			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			//	CLEAR FRAMEBUFFER 

			this.clear();
		}
	}, {
		key: '_checkMaxNumRenderTarget',
		value: function _checkMaxNumRenderTarget() {
			var maxNumDrawBuffers = _GLTool2.default.gl.getParameter(extDrawBuffer.MAX_DRAW_BUFFERS_WEBGL);
			if (this._numTargets > maxNumDrawBuffers) {
				console.error('Over max number of draw buffers supported : ', maxNumDrawBuffers);
				this._numTargets = maxNumDrawBuffers;
			}
		}
	}, {
		key: '_initTextures',
		value: function _initTextures() {
			this._textures = [];
			for (var i = 0; i < this._numTargets; i++) {
				var glt = this._createTexture();
				this._textures.push(glt);
			}

			if (_GLTool2.default.webgl2) {
				this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);
			} else {
				this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, { minFilter: _GLTool2.default.LINEAR });
			}
		}
	}, {
		key: '_createTexture',
		value: function _createTexture(mInternalformat, mTexelType, mFormat) {
			var mParameters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

			var parameters = (0, _objectAssign2.default)({}, this._parameters);
			if (!mFormat) {
				mFormat = mInternalformat;
			}

			parameters.internalFormat = mInternalformat || gl.RGBA;
			parameters.format = mFormat;
			parameters.type = mTexelType || parameters.type || _GLTool2.default.UNSIGNED_BYTE;
			for (var s in mParameters) {
				parameters[s] = mParameters[s];
			}

			var texture = new _GLTexture2.default(null, parameters, this.width, this.height);
			return texture;
		}

		//	PUBLIC METHODS

	}, {
		key: 'bind',
		value: function bind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, this.width, this.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			this._textures.forEach(function (texture) {
				texture.generateMipmap();
			});
		}
	}, {
		key: 'clear',
		value: function clear() {
			var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
			var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
			var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

			this.bind();
			_GLTool2.default.clear(r, g, b, a);
			this.unbind();
		}

		//	TEXTURES

	}, {
		key: 'getTexture',
		value: function getTexture() {
			var mIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			return this._textures[mIndex];
		}
	}, {
		key: 'getDepthTexture',
		value: function getDepthTexture() {
			return this.glDepthTexture;
		}

		//	TOUGHTS : Should I remove these from frame buffer ? 
		//	Shouldn't these be set individually to each texture ? 
		//	e.g. fbo.getTexture(0).minFilter = GL.NEAREST;
		//		 fbo.getTexture(1).minFilter = GL.LINEAR; ... etc ? 

		//	MIPMAP FILTER

	}, {
		key: 'showParameters',


		//	UTILS

		value: function showParameters() {
			this._textures[0].showParameters();
		}
	}, {
		key: 'minFilter',
		get: function get() {
			return this._textures[0].minFilter;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.minFilter = mValue;
			});
		}
	}, {
		key: 'magFilter',
		get: function get() {
			return this._textures[0].magFilter;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.magFilter = mValue;
			});
		}

		//	WRAPPING

	}, {
		key: 'wrapS',
		get: function get() {
			return this._textures[0].wrapS;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.wrapS = mValue;
			});
		}
	}, {
		key: 'wrapT',
		get: function get() {
			return this._textures[0].wrapT;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.wrapT = mValue;
			});
		}
	}, {
		key: 'numTargets',
		get: function get() {
			return this._numTargets;
		}
	}]);

	return FrameBuffer;
}();

exports.default = FrameBuffer;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // EaseNumber.js

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EaseNumber = function () {
	function EaseNumber(mValue) {
		var _this = this;

		var mEasing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;

		_classCallCheck(this, EaseNumber);

		this.easing = mEasing;
		this._value = mValue;
		this._targetValue = mValue;
		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._update();
		});
	}

	_createClass(EaseNumber, [{
		key: '_update',
		value: function _update() {
			var MIN_DIFF = 0.0001;
			this._checkLimit();
			this._value += (this._targetValue - this._value) * this.easing;
			if (Math.abs(this._targetValue - this._value) < MIN_DIFF) {
				this._value = this._targetValue;
			}
		}
	}, {
		key: 'setTo',
		value: function setTo(mValue) {
			this._targetValue = this._value = mValue;
		}
	}, {
		key: 'add',
		value: function add(mAdd) {
			this._targetValue += mAdd;
		}
	}, {
		key: 'limit',
		value: function limit(mMin, mMax) {
			if (mMin > mMax) {
				this.limit(mMax, mMin);
				return;
			}

			this._min = mMin;
			this._max = mMax;

			this._checkLimit();
		}
	}, {
		key: '_checkLimit',
		value: function _checkLimit() {
			if (this._min !== undefined && this._targetValue < this._min) {
				this._targetValue = this._min;
			}

			if (this._max !== undefined && this._targetValue > this._max) {
				this._targetValue = this._max;
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			_scheduling2.default.removeEF(this._efIndex);
		}

		//	GETTERS / SETTERS

	}, {
		key: 'value',
		set: function set(mValue) {
			this._targetValue = mValue;
		},
		get: function get() {
			return this._value;
		}
	}, {
		key: 'targetValue',
		get: function get() {
			return this._targetValue;
		}
	}]);

	return EaseNumber;
}();

exports.default = EaseNumber;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Ray.js

var _glMatrix = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var a = _glMatrix.vec3.create();
var b = _glMatrix.vec3.create();
var c = _glMatrix.vec3.create();
var target = _glMatrix.vec3.create();
var edge1 = _glMatrix.vec3.create();
var edge2 = _glMatrix.vec3.create();
var normal = _glMatrix.vec3.create();
var diff = _glMatrix.vec3.create();

var Ray = function () {
	function Ray(mOrigin, mDirection) {
		_classCallCheck(this, Ray);

		this.origin = _glMatrix.vec3.clone(mOrigin);
		this.direction = _glMatrix.vec3.clone(mDirection);
	}

	_createClass(Ray, [{
		key: 'at',
		value: function at(t) {
			_glMatrix.vec3.copy(target, this.direction);
			_glMatrix.vec3.scale(target, target, t);
			_glMatrix.vec3.add(target, target, this.origin);

			return target;
		}
	}, {
		key: 'lookAt',
		value: function lookAt(mTarget) {
			_glMatrix.vec3.sub(this.direction, mTarget, this.origin);
			_glMatrix.vec3.normalize(this.origin, this.origin);
		}
	}, {
		key: 'closestPointToPoint',
		value: function closestPointToPoint(mPoint) {
			var result = _glMatrix.vec3.create();
			_glMatrix.vec3.sub(mPoint, this.origin);
			var directionDistance = _glMatrix.vec3.dot(result, this.direction);

			if (directionDistance < 0) {
				return _glMatrix.vec3.clone(this.origin);
			}

			_glMatrix.vec3.copy(result, this.direction);
			_glMatrix.vec3.scale(result, result, directionDistance);
			_glMatrix.vec3.add(result, result, this.origin);

			return result;
		}
	}, {
		key: 'distanceToPoint',
		value: function distanceToPoint(mPoint) {
			return Math.sqrt(this.distanceSqToPoint(mPoint));
		}
	}, {
		key: 'distanceSqToPoint',
		value: function distanceSqToPoint(mPoint) {
			var v1 = _glMatrix.vec3.create();

			_glMatrix.vec3.sub(v1, mPoint, this.origin);
			var directionDistance = _glMatrix.vec3.dot(v1, this.direction);

			if (directionDistance < 0) {
				return _glMatrix.vec3.squaredDistance(this.origin, mPoint);
			}

			_glMatrix.vec3.copy(v1, this.direction);
			_glMatrix.vec3.scale(v1, v1, directionDistance);
			_glMatrix.vec3.add(v1, v1, this.origin);
			return _glMatrix.vec3.squaredDistance(v1, mPoint);
		}
	}, {
		key: 'intersectsSphere',
		value: function intersectsSphere(mCenter, mRadius) {
			return this.distanceToPoint(mCenter) <= mRadius;
		}
	}, {
		key: 'intersectSphere',
		value: function intersectSphere(mCenter, mRadius) {
			var v1 = _glMatrix.vec3.create();
			_glMatrix.vec3.sub(v1, mCenter, this.origin);
			var tca = _glMatrix.vec3.dot(v1, this.direction);
			var d2 = _glMatrix.vec3.dot(v1, v1) - tca * tca;
			var radius2 = mRadius * mRadius;

			if (d2 > radius2) return null;

			var thc = Math.sqrt(radius2 - d2);

			var t0 = tca - thc;

			var t1 = tca + thc;

			if (t0 < 0 && t1 < 0) return null;

			if (t0 < 0) return this.at(t1);

			return this.at(t0);
		}
	}, {
		key: 'distanceToPlane',
		value: function distanceToPlane(mPlaneCenter, mNormal) {
			var denominator = _glMatrix.vec3.dot(mNormal, this.direction);

			if (denominator === 0) {}
		}
	}, {
		key: 'intersectTriangle',
		value: function intersectTriangle(mPA, mPB, mPC) {
			var backfaceCulling = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

			_glMatrix.vec3.copy(a, mPA);
			_glMatrix.vec3.copy(b, mPB);
			_glMatrix.vec3.copy(c, mPC);

			// const edge1 = vec3.create();
			// const edge2 = vec3.create();
			// const normal = vec3.create();
			// const diff = vec3.create();

			_glMatrix.vec3.sub(edge1, b, a);
			_glMatrix.vec3.sub(edge2, c, a);
			_glMatrix.vec3.cross(normal, edge1, edge2);

			var DdN = _glMatrix.vec3.dot(this.direction, normal);
			var sign = void 0;

			if (DdN > 0) {
				if (backfaceCulling) {
					return null;
				}
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_glMatrix.vec3.sub(diff, this.origin, a);

			_glMatrix.vec3.cross(edge2, diff, edge2);
			var DdQxE2 = sign * _glMatrix.vec3.dot(this.direction, edge2);
			if (DdQxE2 < 0) {
				return null;
			}

			_glMatrix.vec3.cross(edge1, edge1, diff);
			var DdE1xQ = sign * _glMatrix.vec3.dot(this.direction, edge1);
			if (DdE1xQ < 0) {
				return null;
			}

			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			}

			var Qdn = -sign * _glMatrix.vec3.dot(diff, normal);
			if (Qdn < 0) {
				return null;
			}

			return this.at(Qdn / DdN);
		}
	}]);

	return Ray;
}();

exports.default = Ray;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _simpleColor = __webpack_require__(11);

var _simpleColor2 = _interopRequireDefault(_simpleColor);

var _bigTriangle = __webpack_require__(22);

var _bigTriangle2 = _interopRequireDefault(_bigTriangle);

var _general = __webpack_require__(37);

var _general2 = _interopRequireDefault(_general);

var _copy = __webpack_require__(23);

var _copy2 = _interopRequireDefault(_copy);

var _basic = __webpack_require__(15);

var _basic2 = _interopRequireDefault(_basic);

var _skybox = __webpack_require__(38);

var _skybox2 = _interopRequireDefault(_skybox);

var _skybox3 = __webpack_require__(39);

var _skybox4 = _interopRequireDefault(_skybox3);

var _gltf = __webpack_require__(70);

var _gltf2 = _interopRequireDefault(_gltf);

var _gltf3 = __webpack_require__(71);

var _gltf4 = _interopRequireDefault(_gltf3);

var _debug = __webpack_require__(72);

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ShaderLbs.js

var ShaderLibs = {
	simpleColorFrag: _simpleColor2.default,
	bigTriangleVert: _bigTriangle2.default,
	generalVert: _general2.default,
	copyFrag: _copy2.default,
	basicVert: _basic2.default,
	skyboxVert: _skybox2.default,
	skyboxFrag: _skybox4.default,
	gltfVert: _gltf2.default,
	gltfFrag: _gltf4.default,
	debugFrag: _debug2.default
};

exports.default = ShaderLibs;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = "// bigTriangle.vert\n\n#define SHADER_NAME BIG_TRIANGLE_VERTEX\n\nprecision mediump float;\n#define GLSLIFY 1\nattribute vec2 aPosition;\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vTextureCoord = aPosition * .5 + .5;\n}"

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME COPY_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = texture2D(texture, vTextureCoord);\n}"

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Camera.js

var _glMatrix = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Camera = function () {
	function Camera() {
		_classCallCheck(this, Camera);

		//	VIEW MATRIX
		this._matrix = _glMatrix.mat4.create();

		//	FOR TRANSFORM FROM ORIENTATION
		this._quat = _glMatrix.quat.create();
		this._orientation = _glMatrix.mat4.create();

		//	PROJECTION MATRIX
		this._projection = _glMatrix.mat4.create();

		//	POSITION OF CAMERA
		this.position = vec3.create();
	}

	_createClass(Camera, [{
		key: 'lookAt',
		value: function lookAt(aEye, aCenter) {
			var aUp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1, 0];

			this._eye = vec3.clone(aEye);
			this._center = vec3.clone(aCenter);

			vec3.copy(this.position, aEye);
			_glMatrix.mat4.identity(this._matrix);
			_glMatrix.mat4.lookAt(this._matrix, aEye, aCenter, aUp);
		}
	}, {
		key: 'setFromOrientation',
		value: function setFromOrientation(x, y, z, w) {
			_glMatrix.quat.set(this._quat, x, y, z, w);
			_glMatrix.mat4.fromQuat(this._orientation, this._quat);
			_glMatrix.mat4.translate(this._matrix, this._orientation, this.positionOffset);
		}
	}, {
		key: 'setProjection',
		value: function setProjection(mProj) {
			this._projection = _glMatrix.mat4.clone(mProj);
		}
	}, {
		key: 'setView',
		value: function setView(mView) {
			this._matrix = _glMatrix.mat4.clone(mView);
		}
	}, {
		key: 'setFromViewProj',
		value: function setFromViewProj(mView, mProj) {
			this.setView(mView);
			this.setProjection(mProj);
		}

		//	GETTERS 

	}, {
		key: 'matrix',
		get: function get() {
			return this._matrix;
		}
	}, {
		key: 'viewMatrix',
		get: function get() {
			return this._matrix;
		}
	}, {
		key: 'projection',
		get: function get() {
			return this._projection;
		}
	}, {
		key: 'projectionMatrix',
		get: function get() {
			return this._projection;
		}
	}, {
		key: 'eye',
		get: function get() {
			return this._eye;
		}
	}, {
		key: 'center',
		get: function get() {
			return this._center;
		}
	}]);

	return Camera;
}();

exports.default = Camera;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Camera2 = __webpack_require__(24);

var _Camera3 = _interopRequireDefault(_Camera2);

var _Ray = __webpack_require__(20);

var _Ray2 = _interopRequireDefault(_Ray);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // CameraPerspective.js

var mInverseViewProj = _glMatrix.mat4.create();
var cameraDir = _glMatrix.vec3.create();

var CameraPerspective = function (_Camera) {
	_inherits(CameraPerspective, _Camera);

	function CameraPerspective() {
		_classCallCheck(this, CameraPerspective);

		return _possibleConstructorReturn(this, (CameraPerspective.__proto__ || Object.getPrototypeOf(CameraPerspective)).apply(this, arguments));
	}

	_createClass(CameraPerspective, [{
		key: 'setPerspective',
		value: function setPerspective(mFov, mAspectRatio, mNear, mFar) {

			this._fov = mFov;
			this._near = mNear;
			this._far = mFar;
			this._aspectRatio = mAspectRatio;
			_glMatrix.mat4.perspective(this._projection, mFov, mAspectRatio, mNear, mFar);

			// this._frustumTop = this._near * Math.tan(this._fov * 0.5);
			// this._frustumButtom = -this._frustumTop;
			// this._frustumRight = this._frustumTop * this._aspectRatio;
			// this._frustumLeft = -this._frustumRight;
		}
	}, {
		key: 'setAspectRatio',
		value: function setAspectRatio(mAspectRatio) {
			this._aspectRatio = mAspectRatio;
			_glMatrix.mat4.perspective(this.projection, this._fov, mAspectRatio, this._near, this._far);
		}
	}, {
		key: 'generateRay',
		value: function generateRay(mScreenPosition, mRay) {
			var proj = this.projectionMatrix;
			var view = this.viewMatrix;

			_glMatrix.mat4.multiply(mInverseViewProj, proj, view);
			_glMatrix.mat4.invert(mInverseViewProj, mInverseViewProj);

			_glMatrix.vec3.transformMat4(cameraDir, mScreenPosition, mInverseViewProj);
			_glMatrix.vec3.sub(cameraDir, cameraDir, this.position);
			_glMatrix.vec3.normalize(cameraDir, cameraDir);

			if (!mRay) {
				mRay = new _Ray2.default(this.position, cameraDir);
			} else {
				mRay.origin = this.position;
				mRay.direction = cameraDir;
			}

			return mRay;
		}
	}]);

	return CameraPerspective;
}(_Camera3.default);

exports.default = CameraPerspective;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// BinaryLoader.js

var BinaryLoader = function () {
	function BinaryLoader() {
		var _this = this;

		var isArrayBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		_classCallCheck(this, BinaryLoader);

		this._req = new XMLHttpRequest();
		this._req.addEventListener('load', function (e) {
			return _this._onLoaded(e);
		});
		this._req.addEventListener('progress', function (e) {
			return _this._onProgress(e);
		});
		if (isArrayBuffer) {
			this._req.responseType = 'arraybuffer';
		}
	}

	_createClass(BinaryLoader, [{
		key: 'load',
		value: function load(url, callback) {
			console.log('Loading : ', url);
			this._callback = callback;

			this._req.open('GET', url);
			this._req.send();
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			this._callback(this._req.response);
		}
	}, {
		key: '_onProgress',
		value: function _onProgress() /* e*/{
			// console.log('on Progress:', (e.loaded/e.total*100).toFixed(2));
		}
	}]);

	return BinaryLoader;
}();

exports.default = BinaryLoader;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ShaderLibs = exports.Shaders = exports.View3D = exports.View = exports.Scene = exports.BatchFXAA = exports.BatchSky = exports.BatchSkybox = exports.BatchLine = exports.BatchDotsPlane = exports.BatchBall = exports.BatchAxis = exports.BatchCopy = exports.PassFxaa = exports.PassHBlur = exports.PassVBlur = exports.PassBlur = exports.PassMacro = exports.Pass = exports.EffectComposer = exports.ColladaParser = exports.loadImages = exports.GLTFLoader = exports.HDRLoader = exports.ObjLoader = exports.BinaryLoader = exports.Object3D = exports.Ray = exports.CameraCube = exports.CameraPerspective = exports.CameraOrtho = exports.Camera = exports.TouchDetector = exports.QuatRotation = exports.WebglNumber = exports.OrbitalControl = exports.TweenNumber = exports.EaseNumber = exports.EventDispatcher = exports.Scheduler = exports.TransformFeedbackObject = exports.MultisampleFrameBuffer = exports.CubeFrameBuffer = exports.FrameBuffer = exports.Batch = exports.Geom = exports.Material = exports.Geometry = exports.Mesh = exports.GLCubeTexture = exports.GLTexture = exports.GLShader = exports.GL = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // alfrid.js

//	WEBGL 2


//	TOOLS


//	SHADERS


//	CAMERAS


//	MATH


//	OBJECT


//	LOADERS


//	POST EFFECT


//	HELPERS


var _glMatrix = __webpack_require__(2);

var GLM = _interopRequireWildcard(_glMatrix);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _GLCubeTexture = __webpack_require__(14);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

var _Mesh = __webpack_require__(13);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _Material = __webpack_require__(34);

var _Material2 = _interopRequireDefault(_Material);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _Batch = __webpack_require__(5);

var _Batch2 = _interopRequireDefault(_Batch);

var _FrameBuffer = __webpack_require__(18);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

var _CubeFrameBuffer = __webpack_require__(63);

var _CubeFrameBuffer2 = _interopRequireDefault(_CubeFrameBuffer);

var _MultisampleFrameBuffer = __webpack_require__(64);

var _MultisampleFrameBuffer2 = _interopRequireDefault(_MultisampleFrameBuffer);

var _TransformFeedbackObject = __webpack_require__(65);

var _TransformFeedbackObject2 = _interopRequireDefault(_TransformFeedbackObject);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _EventDispatcher = __webpack_require__(35);

var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

var _EaseNumber = __webpack_require__(19);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _TweenNumber = __webpack_require__(66);

var _TweenNumber2 = _interopRequireDefault(_TweenNumber);

var _OrbitalControl = __webpack_require__(36);

var _OrbitalControl2 = _interopRequireDefault(_OrbitalControl);

var _QuatRotation = __webpack_require__(67);

var _QuatRotation2 = _interopRequireDefault(_QuatRotation);

var _TouchDetector = __webpack_require__(68);

var _TouchDetector2 = _interopRequireDefault(_TouchDetector);

var _WebglNumber = __webpack_require__(10);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _WebglConst = __webpack_require__(32);

var _WebglConst2 = _interopRequireDefault(_WebglConst);

var _Shaders = __webpack_require__(16);

var _Shaders2 = _interopRequireDefault(_Shaders);

var _ShaderLibs = __webpack_require__(21);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

var _Camera = __webpack_require__(24);

var _Camera2 = _interopRequireDefault(_Camera);

var _CameraOrtho = __webpack_require__(40);

var _CameraOrtho2 = _interopRequireDefault(_CameraOrtho);

var _CameraPerspective = __webpack_require__(25);

var _CameraPerspective2 = _interopRequireDefault(_CameraPerspective);

var _CameraCube = __webpack_require__(73);

var _CameraCube2 = _interopRequireDefault(_CameraCube);

var _Ray = __webpack_require__(20);

var _Ray2 = _interopRequireDefault(_Ray);

var _Object3D = __webpack_require__(8);

var _Object3D2 = _interopRequireDefault(_Object3D);

var _BinaryLoader = __webpack_require__(26);

var _BinaryLoader2 = _interopRequireDefault(_BinaryLoader);

var _ObjLoader = __webpack_require__(74);

var _ObjLoader2 = _interopRequireDefault(_ObjLoader);

var _HDRLoader = __webpack_require__(75);

var _HDRLoader2 = _interopRequireDefault(_HDRLoader);

var _ColladaParser = __webpack_require__(77);

var _ColladaParser2 = _interopRequireDefault(_ColladaParser);

var _GltfLoader = __webpack_require__(80);

var _GltfLoader2 = _interopRequireDefault(_GltfLoader);

var _loadImages = __webpack_require__(41);

var _loadImages2 = _interopRequireDefault(_loadImages);

var _EffectComposer = __webpack_require__(85);

var _EffectComposer2 = _interopRequireDefault(_EffectComposer);

var _Pass = __webpack_require__(12);

var _Pass2 = _interopRequireDefault(_Pass);

var _PassMacro = __webpack_require__(43);

var _PassMacro2 = _interopRequireDefault(_PassMacro);

var _PassBlur = __webpack_require__(86);

var _PassBlur2 = _interopRequireDefault(_PassBlur);

var _PassVBlur = __webpack_require__(44);

var _PassVBlur2 = _interopRequireDefault(_PassVBlur);

var _PassHBlur = __webpack_require__(46);

var _PassHBlur2 = _interopRequireDefault(_PassHBlur);

var _PassFxaa = __webpack_require__(90);

var _PassFxaa2 = _interopRequireDefault(_PassFxaa);

var _BatchCopy = __webpack_require__(91);

var _BatchCopy2 = _interopRequireDefault(_BatchCopy);

var _BatchAxis = __webpack_require__(92);

var _BatchAxis2 = _interopRequireDefault(_BatchAxis);

var _BatchBall = __webpack_require__(95);

var _BatchBall2 = _interopRequireDefault(_BatchBall);

var _BatchDotsPlane = __webpack_require__(96);

var _BatchDotsPlane2 = _interopRequireDefault(_BatchDotsPlane);

var _BatchLine = __webpack_require__(98);

var _BatchLine2 = _interopRequireDefault(_BatchLine);

var _BatchSkybox = __webpack_require__(99);

var _BatchSkybox2 = _interopRequireDefault(_BatchSkybox);

var _BatchSky = __webpack_require__(100);

var _BatchSky2 = _interopRequireDefault(_BatchSky);

var _BatchFXAA = __webpack_require__(102);

var _BatchFXAA2 = _interopRequireDefault(_BatchFXAA);

var _Scene = __webpack_require__(103);

var _Scene2 = _interopRequireDefault(_Scene);

var _View = __webpack_require__(104);

var _View2 = _interopRequireDefault(_View);

var _View3D = __webpack_require__(105);

var _View3D2 = _interopRequireDefault(_View3D);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VERSION = '0.2.0';

var Alfrid = function () {
	function Alfrid() {
		_classCallCheck(this, Alfrid);

		this.glm = GLM;
		this.GL = _GLTool2.default;
		this.GLTool = _GLTool2.default;
		this.GLShader = _GLShader2.default;
		this.GLTexture = _GLTexture2.default;
		this.GLCubeTexture = _GLCubeTexture2.default;
		this.Mesh = _Mesh2.default;
		this.Geometry = _Geometry2.default;
		this.Material = _Material2.default;
		this.Geom = _Geom2.default;
		this.Batch = _Batch2.default;
		this.FrameBuffer = _FrameBuffer2.default;
		this.CubeFrameBuffer = _CubeFrameBuffer2.default;
		this.Scheduler = _scheduling2.default;
		this.EventDispatcher = _EventDispatcher2.default;
		this.EaseNumber = _EaseNumber2.default;
		this.TweenNumber = _TweenNumber2.default;
		this.Camera = _Camera2.default;
		this.CameraOrtho = _CameraOrtho2.default;
		this.CameraPerspective = _CameraPerspective2.default;
		this.Ray = _Ray2.default;
		this.CameraCube = _CameraCube2.default;
		this.OrbitalControl = _OrbitalControl2.default;
		this.QuatRotation = _QuatRotation2.default;
		this.TouchDetector = _TouchDetector2.default;
		this.BinaryLoader = _BinaryLoader2.default;
		this.ObjLoader = _ObjLoader2.default;
		this.ColladaParser = _ColladaParser2.default;
		this.HDRLoader = _HDRLoader2.default;
		this.GLTFLoader = _GltfLoader2.default;
		this.loadImages = _loadImages2.default;
		this.BatchCopy = _BatchCopy2.default;
		this.BatchAxis = _BatchAxis2.default;
		this.BatchBall = _BatchBall2.default;
		this.BatchBall = _BatchBall2.default;
		this.BatchLine = _BatchLine2.default;
		this.BatchSkybox = _BatchSkybox2.default;
		this.BatchSky = _BatchSky2.default;
		this.BatchFXAA = _BatchFXAA2.default;
		this.BatchDotsPlane = _BatchDotsPlane2.default;
		this.Scene = _Scene2.default;
		this.View = _View2.default;
		this.View3D = _View3D2.default;
		this.Object3D = _Object3D2.default;
		this.Shaders = _Shaders2.default;
		this.ShaderLibs = _ShaderLibs2.default;
		this.WebglNumber = _WebglNumber2.default;

		this.EffectComposer = _EffectComposer2.default;
		this.Pass = _Pass2.default;
		this.PassMacro = _PassMacro2.default;
		this.PassBlur = _PassBlur2.default;
		this.PassVBlur = _PassVBlur2.default;
		this.PassHBlur = _PassHBlur2.default;
		this.PassFxaa = _PassFxaa2.default;

		this.MultisampleFrameBuffer = _MultisampleFrameBuffer2.default;
		this.TransformFeedbackObject = _TransformFeedbackObject2.default;

		//	NOT SUPER SURE I'VE DONE THIS IS A GOOD WAY

		for (var s in GLM) {
			if (GLM[s]) {
				window[s] = GLM[s];
			}
		}
	}

	_createClass(Alfrid, [{
		key: 'log',
		value: function log() {
			if (navigator.userAgent.indexOf('Chrome') > -1) {
				console.log('%clib alfrid : VERSION ' + VERSION, 'background: #193441; color: #FCFFF5');
			} else {
				console.log('lib alfrid : VERSION ', VERSION);
			}
			console.log('%cClasses : ', 'color: #193441');

			for (var s in this) {
				if (this[s]) {
					console.log('%c - ' + s, 'color: #3E606F');
				}
			}
		}
	}]);

	return Alfrid;
}();

var al = new Alfrid();

exports.default = al;
exports.GL = _GLTool2.default;
exports.GLShader = _GLShader2.default;
exports.GLTexture = _GLTexture2.default;
exports.GLCubeTexture = _GLCubeTexture2.default;
exports.Mesh = _Mesh2.default;
exports.Geometry = _Geometry2.default;
exports.Material = _Material2.default;
exports.Geom = _Geom2.default;
exports.Batch = _Batch2.default;
exports.FrameBuffer = _FrameBuffer2.default;
exports.CubeFrameBuffer = _CubeFrameBuffer2.default;
exports.MultisampleFrameBuffer = _MultisampleFrameBuffer2.default;
exports.TransformFeedbackObject = _TransformFeedbackObject2.default;
exports.Scheduler = _scheduling2.default;
exports.EventDispatcher = _EventDispatcher2.default;
exports.EaseNumber = _EaseNumber2.default;
exports.TweenNumber = _TweenNumber2.default;
exports.OrbitalControl = _OrbitalControl2.default;
exports.WebglNumber = _WebglNumber2.default;
exports.QuatRotation = _QuatRotation2.default;
exports.TouchDetector = _TouchDetector2.default;
exports.Camera = _Camera2.default;
exports.CameraOrtho = _CameraOrtho2.default;
exports.CameraPerspective = _CameraPerspective2.default;
exports.CameraCube = _CameraCube2.default;
exports.Ray = _Ray2.default;
exports.Object3D = _Object3D2.default;
exports.BinaryLoader = _BinaryLoader2.default;
exports.ObjLoader = _ObjLoader2.default;
exports.HDRLoader = _HDRLoader2.default;
exports.GLTFLoader = _GltfLoader2.default;
exports.loadImages = _loadImages2.default;
exports.ColladaParser = _ColladaParser2.default;
exports.EffectComposer = _EffectComposer2.default;
exports.Pass = _Pass2.default;
exports.PassMacro = _PassMacro2.default;
exports.PassBlur = _PassBlur2.default;
exports.PassVBlur = _PassVBlur2.default;
exports.PassHBlur = _PassHBlur2.default;
exports.PassFxaa = _PassFxaa2.default;
exports.BatchCopy = _BatchCopy2.default;
exports.BatchAxis = _BatchAxis2.default;
exports.BatchBall = _BatchBall2.default;
exports.BatchDotsPlane = _BatchDotsPlane2.default;
exports.BatchLine = _BatchLine2.default;
exports.BatchSkybox = _BatchSkybox2.default;
exports.BatchSky = _BatchSky2.default;
exports.BatchFXAA = _BatchFXAA2.default;
exports.Scene = _Scene2.default;
exports.View = _View2.default;
exports.View3D = _View3D2.default;
exports.Shaders = _Shaders2.default;
exports.ShaderLibs = _ShaderLibs2.default;

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["fromMat4"] = fromMat4;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromMat2d"] = fromMat2d;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["normalFromMat4"] = normalFromMat4;
/* harmony export (immutable) */ __webpack_exports__["projection"] = projection;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b01 = a22 * a11 - a12 * a21;
  let b11 = -a22 * a10 + a12 * a20;
  let b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  let det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  out[0] = (a11 * a22 - a12 * a21);
  out[1] = (a02 * a21 - a01 * a22);
  out[2] = (a01 * a12 - a02 * a11);
  out[3] = (a12 * a20 - a10 * a22);
  out[4] = (a00 * a22 - a02 * a20);
  out[5] = (a02 * a10 - a00 * a12);
  out[6] = (a10 * a21 - a11 * a20);
  out[7] = (a01 * a20 - a00 * a21);
  out[8] = (a00 * a11 - a01 * a10);
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b00 = b[0], b01 = b[1], b02 = b[2];
  let b10 = b[3], b11 = b[4], b12 = b[5];
  let b20 = b[6], b21 = b[7], b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],
    x = v[0], y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],

    s = Math.sin(rad),
    c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
          a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}



/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["hermite"] = hermite;
/* harmony export (immutable) */ __webpack_exports__["bezier"] = bezier;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["angle"] = angle;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return x*x + y*y + z*z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return x*x + y*y + z*z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x*x + y*y + z*z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  let factorTimes2 = t * t;
  let factor1 = factorTimes2 * (2 * t - 3) + 1;
  let factor2 = factorTimes2 * (t - 2) + t;
  let factor3 = factorTimes2 * (t - 1);
  let factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  let inverseFactor = 1 - t;
  let inverseFactorTimesTwo = inverseFactor * inverseFactor;
  let factorTimes2 = t * t;
  let factor1 = inverseFactorTimesTwo * inverseFactor;
  let factor2 = 3 * t * inverseFactorTimesTwo;
  let factor3 = 3 * factorTimes2 * inverseFactor;
  let factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  let r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  let z = (__WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0) - 1.0;
  let zScale = Math.sqrt(1.0-z*z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  r[1] = p[1];
  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  let tempA = fromValues(a[0], a[1], a[2]);
  let tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  let cosine = dot(tempA, tempB);

  if(cosine > 1.0) {
    return 0;
  }
  else if(cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2];
  let b0 = b[0], b1 = b[1], b2 = b[2];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec3.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec3.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec3.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 3;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x*x + y*y + z*z + w*w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  let aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, vectorScale) {
  vectorScale = vectorScale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[1] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[2] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[3] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  normalize(out, out);
  scale(out, out, vectorScale);
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec4.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec4.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec4.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 4;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// WebglConst.js

// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^

module.exports = {
	ACTIVE_ATTRIBUTES: 35721,
	ACTIVE_ATTRIBUTE_MAX_LENGTH: 35722,
	ACTIVE_TEXTURE: 34016,
	ACTIVE_UNIFORMS: 35718,
	ACTIVE_UNIFORM_MAX_LENGTH: 35719,
	ALIASED_LINE_WIDTH_RANGE: 33902,
	ALIASED_POINT_SIZE_RANGE: 33901,
	ALPHA: 6406,
	ALPHA_BITS: 3413,
	ALWAYS: 519,
	ARRAY_BUFFER: 34962,
	ARRAY_BUFFER_BINDING: 34964,
	ATTACHED_SHADERS: 35717,
	BACK: 1029,
	BLEND: 3042,
	BLEND_COLOR: 32773,
	BLEND_DST_ALPHA: 32970,
	BLEND_DST_RGB: 32968,
	BLEND_EQUATION: 32777,
	BLEND_EQUATION_ALPHA: 34877,
	BLEND_EQUATION_RGB: 32777,
	BLEND_SRC_ALPHA: 32971,
	BLEND_SRC_RGB: 32969,
	BLUE_BITS: 3412,
	BOOL: 35670,
	BOOL_VEC2: 35671,
	BOOL_VEC3: 35672,
	BOOL_VEC4: 35673,
	BROWSER_DEFAULT_WEBGL: 37444,
	BUFFER_SIZE: 34660,
	BUFFER_USAGE: 34661,
	BYTE: 5120,
	CCW: 2305,
	CLAMP_TO_EDGE: 33071,
	COLOR_ATTACHMENT0: 36064,
	COLOR_BUFFER_BIT: 16384,
	COLOR_CLEAR_VALUE: 3106,
	COLOR_WRITEMASK: 3107,
	COMPILE_STATUS: 35713,
	COMPRESSED_TEXTURE_FORMATS: 34467,
	CONSTANT_ALPHA: 32771,
	CONSTANT_COLOR: 32769,
	CONTEXT_LOST_WEBGL: 37442,
	CULL_FACE: 2884,
	CULL_FACE_MODE: 2885,
	CURRENT_PROGRAM: 35725,
	CURRENT_VERTEX_ATTRIB: 34342,
	CW: 2304,
	DECR: 7683,
	DECR_WRAP: 34056,
	DELETE_STATUS: 35712,
	DEPTH_ATTACHMENT: 36096,
	DEPTH_BITS: 3414,
	DEPTH_BUFFER_BIT: 256,
	DEPTH_CLEAR_VALUE: 2931,
	DEPTH_COMPONENT: 6402,
	RED: 6403,
	DEPTH_COMPONENT16: 33189,
	DEPTH_FUNC: 2932,
	DEPTH_RANGE: 2928,
	DEPTH_STENCIL: 34041,
	DEPTH_STENCIL_ATTACHMENT: 33306,
	DEPTH_TEST: 2929,
	DEPTH_WRITEMASK: 2930,
	DITHER: 3024,
	DONT_CARE: 4352,
	DST_ALPHA: 772,
	DST_COLOR: 774,
	DYNAMIC_DRAW: 35048,
	ELEMENT_ARRAY_BUFFER: 34963,
	ELEMENT_ARRAY_BUFFER_BINDING: 34965,
	EQUAL: 514,
	FASTEST: 4353,
	FLOAT: 5126,
	FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	FRAGMENT_SHADER: 35632,
	FRAMEBUFFER: 36160,
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
	FRAMEBUFFER_BINDING: 36006,
	FRAMEBUFFER_COMPLETE: 36053,
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
	FRAMEBUFFER_UNSUPPORTED: 36061,
	FRONT: 1028,
	FRONT_AND_BACK: 1032,
	FRONT_FACE: 2886,
	FUNC_ADD: 32774,
	FUNC_REVERSE_SUBTRACT: 32779,
	FUNC_SUBTRACT: 32778,
	GENERATE_MIPMAP_HINT: 33170,
	GEQUAL: 518,
	GREATER: 516,
	GREEN_BITS: 3411,
	HIGH_FLOAT: 36338,
	HIGH_INT: 36341,
	INCR: 7682,
	INCR_WRAP: 34055,
	INFO_LOG_LENGTH: 35716,
	INT: 5124,
	INT_VEC2: 35667,
	INT_VEC3: 35668,
	INT_VEC4: 35669,
	INVALID_ENUM: 1280,
	INVALID_FRAMEBUFFER_OPERATION: 1286,
	INVALID_OPERATION: 1282,
	INVALID_VALUE: 1281,
	INVERT: 5386,
	KEEP: 7680,
	LEQUAL: 515,
	LESS: 513,
	LINEAR: 9729,
	LINEAR_MIPMAP_LINEAR: 9987,
	LINEAR_MIPMAP_NEAREST: 9985,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	LINE_WIDTH: 2849,
	LINK_STATUS: 35714,
	LOW_FLOAT: 36336,
	LOW_INT: 36339,
	LUMINANCE: 6409,
	LUMINANCE_ALPHA: 6410,
	MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
	MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
	MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
	MAX_RENDERBUFFER_SIZE: 34024,
	MAX_TEXTURE_IMAGE_UNITS: 34930,
	MAX_TEXTURE_SIZE: 3379,
	MAX_VARYING_VECTORS: 36348,
	MAX_VERTEX_ATTRIBS: 34921,
	MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
	MAX_VERTEX_UNIFORM_VECTORS: 36347,
	MAX_VIEWPORT_DIMS: 3386,
	MEDIUM_FLOAT: 36337,
	MEDIUM_INT: 36340,
	MIRRORED_REPEAT: 33648,
	NEAREST: 9728,
	NEAREST_MIPMAP_LINEAR: 9986,
	NEAREST_MIPMAP_NEAREST: 9984,
	NEVER: 512,
	NICEST: 4354,
	NONE: 0,
	NOTEQUAL: 517,
	NO_ERROR: 0,
	NUM_COMPRESSED_TEXTURE_FORMATS: 34466,
	ONE: 1,
	ONE_MINUS_CONSTANT_ALPHA: 32772,
	ONE_MINUS_CONSTANT_COLOR: 32770,
	ONE_MINUS_DST_ALPHA: 773,
	ONE_MINUS_DST_COLOR: 775,
	ONE_MINUS_SRC_ALPHA: 771,
	ONE_MINUS_SRC_COLOR: 769,
	OUT_OF_MEMORY: 1285,
	PACK_ALIGNMENT: 3333,
	POINTS: 0,
	POLYGON_OFFSET_FACTOR: 32824,
	POLYGON_OFFSET_FILL: 32823,
	POLYGON_OFFSET_UNITS: 10752,
	RED_BITS: 3410,
	RENDERBUFFER: 36161,
	RENDERBUFFER_ALPHA_SIZE: 36179,
	RENDERBUFFER_BINDING: 36007,
	RENDERBUFFER_BLUE_SIZE: 36178,
	RENDERBUFFER_DEPTH_SIZE: 36180,
	RENDERBUFFER_GREEN_SIZE: 36177,
	RENDERBUFFER_HEIGHT: 36163,
	RENDERBUFFER_INTERNAL_FORMAT: 36164,
	RENDERBUFFER_RED_SIZE: 36176,
	RENDERBUFFER_STENCIL_SIZE: 36181,
	RENDERBUFFER_WIDTH: 36162,
	RENDERER: 7937,
	REPEAT: 10497,
	REPLACE: 7681,
	RGB: 6407,
	RGB5_A1: 32855,
	RGB565: 36194,
	RGBA: 6408,
	RGBA4: 32854,
	SAMPLER_2D: 35678,
	SAMPLER_CUBE: 35680,
	SAMPLES: 32937,
	SAMPLE_ALPHA_TO_COVERAGE: 32926,
	SAMPLE_BUFFERS: 32936,
	SAMPLE_COVERAGE: 32928,
	SAMPLE_COVERAGE_INVERT: 32939,
	SAMPLE_COVERAGE_VALUE: 32938,
	SCISSOR_BOX: 3088,
	SCISSOR_TEST: 3089,
	SHADER_COMPILER: 36346,
	SHADER_SOURCE_LENGTH: 35720,
	SHADER_TYPE: 35663,
	SHADING_LANGUAGE_VERSION: 35724,
	SHORT: 5122,
	SRC_ALPHA: 770,
	SRC_ALPHA_SATURATE: 776,
	SRC_COLOR: 768,
	STATIC_DRAW: 35044,
	STENCIL_ATTACHMENT: 36128,
	STENCIL_BACK_FAIL: 34817,
	STENCIL_BACK_FUNC: 34816,
	STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
	STENCIL_BACK_PASS_DEPTH_PASS: 34819,
	STENCIL_BACK_REF: 36003,
	STENCIL_BACK_VALUE_MASK: 36004,
	STENCIL_BACK_WRITEMASK: 36005,
	STENCIL_BITS: 3415,
	STENCIL_BUFFER_BIT: 1024,
	STENCIL_CLEAR_VALUE: 2961,
	STENCIL_FAIL: 2964,
	STENCIL_FUNC: 2962,
	STENCIL_INDEX: 6401,
	STENCIL_INDEX8: 36168,
	STENCIL_PASS_DEPTH_FAIL: 2965,
	STENCIL_PASS_DEPTH_PASS: 2966,
	STENCIL_REF: 2967,
	STENCIL_TEST: 2960,
	STENCIL_VALUE_MASK: 2963,
	STENCIL_WRITEMASK: 2968,
	STREAM_DRAW: 35040,
	SUBPIXEL_BITS: 3408,
	TEXTURE: 5890,
	TEXTURE0: 33984,
	TEXTURE1: 33985,
	TEXTURE2: 33986,
	TEXTURE3: 33987,
	TEXTURE4: 33988,
	TEXTURE5: 33989,
	TEXTURE6: 33990,
	TEXTURE7: 33991,
	TEXTURE8: 33992,
	TEXTURE9: 33993,
	TEXTURE10: 33994,
	TEXTURE11: 33995,
	TEXTURE12: 33996,
	TEXTURE13: 33997,
	TEXTURE14: 33998,
	TEXTURE15: 33999,
	TEXTURE16: 34000,
	TEXTURE17: 34001,
	TEXTURE18: 34002,
	TEXTURE19: 34003,
	TEXTURE20: 34004,
	TEXTURE21: 34005,
	TEXTURE22: 34006,
	TEXTURE23: 34007,
	TEXTURE24: 34008,
	TEXTURE25: 34009,
	TEXTURE26: 34010,
	TEXTURE27: 34011,
	TEXTURE28: 34012,
	TEXTURE29: 34013,
	TEXTURE30: 34014,
	TEXTURE31: 34015,
	TEXTURE_2D: 3553,
	TEXTURE_BINDING_2D: 32873,
	TEXTURE_BINDING_CUBE_MAP: 34068,
	TEXTURE_CUBE_MAP: 34067,
	TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
	TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
	TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
	TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
	TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
	TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
	TEXTURE_MAG_FILTER: 10240,
	TEXTURE_MIN_FILTER: 10241,
	TEXTURE_WRAP_S: 10242,
	TEXTURE_WRAP_T: 10243,
	TRIANGLES: 4,
	TRIANGLE_FAN: 6,
	TRIANGLE_STRIP: 5,
	UNPACK_ALIGNMENT: 3317,
	UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
	UNPACK_FLIP_Y_WEBGL: 37440,
	UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_INT: 5125,
	UNSIGNED_SHORT: 5123,
	UNSIGNED_SHORT_4_4_4_4: 32819,
	UNSIGNED_SHORT_5_5_5_1: 32820,
	UNSIGNED_SHORT_5_6_5: 33635,
	VALIDATE_STATUS: 35715,
	VENDOR: 7936,
	VERSION: 7938,
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
	VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
	VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
	VERTEX_ATTRIB_ARRAY_POINTER: 34373,
	VERTEX_ATTRIB_ARRAY_SIZE: 34339,
	VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
	VERTEX_ATTRIB_ARRAY_TYPE: 34341,
	VERTEX_SHADER: 35633,
	VIEWPORT: 2978,
	ZERO: 0,
	R8: 33321
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (gl, shaderProgram, name) {
	if (shaderProgram.cacheAttribLoc === undefined) {
		shaderProgram.cacheAttribLoc = {};
	}
	if (shaderProgram.cacheAttribLoc[name] === undefined) {
		shaderProgram.cacheAttribLoc[name] = gl.getAttribLocation(shaderProgram, name);
	}

	return shaderProgram.cacheAttribLoc[name];
};

; // getAttribLoc.js

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Material.js

var _Shaders = __webpack_require__(16);

var _Shaders2 = _interopRequireDefault(_Shaders);

var _objectAssign = __webpack_require__(17);

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Material = function () {
	function Material(vs, fs) {
		var uniforms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		var defines = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

		_classCallCheck(this, Material);

		this._shader = _Shaders2.default.get(vs, fs, defines);
		this.uniforms = (0, _objectAssign2.default)({}, uniforms);
	}

	_createClass(Material, [{
		key: 'update',
		value: function update() {
			this._shader.bind();
			this._shader.uniform(this.uniforms);
		}
	}, {
		key: 'shader',
		get: function get() {
			return this._shader;
		}
	}]);

	return Material;
}();

exports.default = Material;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// EventDispatcher.js

var supportsCustomEvents = true;
try {
	var newTestCustomEvent = document.createEvent('CustomEvent');
	newTestCustomEvent = null;
} catch (e) {
	supportsCustomEvents = false;
}

var EventDispatcher = function () {
	function EventDispatcher() {
		_classCallCheck(this, EventDispatcher);

		this._eventListeners = {};
	}

	_createClass(EventDispatcher, [{
		key: 'addEventListener',
		value: function addEventListener(aEventType, aFunction) {

			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}

			if (!this._eventListeners[aEventType]) {
				this._eventListeners[aEventType] = [];
			}
			this._eventListeners[aEventType].push(aFunction);

			return this;
		}
	}, {
		key: 'on',
		value: function on(aEventType, aFunction) {
			return this.addEventListener(aEventType, aFunction);
		}
	}, {
		key: 'removeEventListener',
		value: function removeEventListener(aEventType, aFunction) {
			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}
			var currentArray = this._eventListeners[aEventType];

			if (typeof currentArray === 'undefined') {
				return this;
			}

			var currentArrayLength = currentArray.length;
			for (var i = 0; i < currentArrayLength; i++) {
				if (currentArray[i] === aFunction) {
					currentArray.splice(i, 1);
					i--;
					currentArrayLength--;
				}
			}
			return this;
		}
	}, {
		key: 'off',
		value: function off(aEventType, aFunction) {
			return this.removeEventListener(aEventType, aFunction);
		}
	}, {
		key: 'dispatchEvent',
		value: function dispatchEvent(aEvent) {
			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}
			var eventType = aEvent.type;

			try {
				if (aEvent.target === null) {
					aEvent.target = this;
				}
				aEvent.currentTarget = this;
			} catch (theError) {
				var newEvent = { type: eventType, detail: aEvent.detail, dispatcher: this };
				return this.dispatchEvent(newEvent);
			}

			var currentEventListeners = this._eventListeners[eventType];
			if (currentEventListeners !== null && currentEventListeners !== undefined) {
				var currentArray = this._copyArray(currentEventListeners);
				var currentArrayLength = currentArray.length;
				for (var i = 0; i < currentArrayLength; i++) {
					var currentFunction = currentArray[i];
					currentFunction.call(this, aEvent);
				}
			}
			return this;
		}
	}, {
		key: 'dispatchCustomEvent',
		value: function dispatchCustomEvent(aEventType, aDetail) {
			var newEvent = void 0;
			if (supportsCustomEvents) {
				newEvent = document.createEvent('CustomEvent');
				newEvent.dispatcher = this;
				newEvent.initCustomEvent(aEventType, false, false, aDetail);
			} else {
				newEvent = { type: aEventType, detail: aDetail, dispatcher: this };
			}
			return this.dispatchEvent(newEvent);
		}
	}, {
		key: 'trigger',
		value: function trigger(aEventType, aDetail) {
			return this.dispatchCustomEvent(aEventType, aDetail);
		}
	}, {
		key: '_destroy',
		value: function _destroy() {
			if (this._eventListeners !== null) {
				for (var objectName in this._eventListeners) {
					if (this._eventListeners.hasOwnProperty(objectName)) {
						var currentArray = this._eventListeners[objectName];
						var currentArrayLength = currentArray.length;
						for (var i = 0; i < currentArrayLength; i++) {
							currentArray[i] = null;
						}
						delete this._eventListeners[objectName];
					}
				}
				this._eventListeners = null;
			}
		}
	}, {
		key: '_copyArray',
		value: function _copyArray(aArray) {
			var currentArray = new Array(aArray.length);
			var currentArrayLength = currentArray.length;
			for (var i = 0; i < currentArrayLength; i++) {
				currentArray[i] = aArray[i];
			}
			return currentArray;
		}
	}]);

	return EventDispatcher;
}();

exports.default = EventDispatcher;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OrbitalControl.js


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EaseNumber = __webpack_require__(19);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getMouse = function getMouse(mEvent, mTarget) {

	var o = mTarget || {};
	if (mEvent.touches) {
		o.x = mEvent.touches[0].pageX;
		o.y = mEvent.touches[0].pageY;
	} else {
		o.x = mEvent.clientX;
		o.y = mEvent.clientY;
	}

	return o;
};

var OrbitalControl = function () {
	function OrbitalControl(mTarget) {
		var _this = this;

		var mListenerTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
		var mRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;

		_classCallCheck(this, OrbitalControl);

		this._target = mTarget;
		this._listenerTarget = mListenerTarget;
		this._mouse = {};
		this._preMouse = {};
		this.center = _glMatrix.vec3.create();
		this._up = _glMatrix.vec3.fromValues(0, 1, 0);
		this.radius = new _EaseNumber2.default(mRadius);
		this.position = _glMatrix.vec3.fromValues(0, 0, this.radius.value);
		this.positionOffset = _glMatrix.vec3.create();
		this._rx = new _EaseNumber2.default(0);
		this._rx.limit(-Math.PI / 2, Math.PI / 2);
		this._ry = new _EaseNumber2.default(0);
		this._preRX = 0;
		this._preRY = 0;

		this._isLockZoom = false;
		this._isLockRotation = false;
		this._isInvert = false;
		this.sensitivity = 1.0;

		this._wheelBind = function (e) {
			return _this._onWheel(e);
		};
		this._downBind = function (e) {
			return _this._onDown(e);
		};
		this._moveBind = function (e) {
			return _this._onMove(e);
		};
		this._upBind = function () {
			return _this._onUp();
		};

		this.connect();
		_scheduling2.default.addEF(function () {
			return _this._loop();
		});
	}

	_createClass(OrbitalControl, [{
		key: 'connect',
		value: function connect() {
			this.disconnect();

			this._listenerTarget.addEventListener('mousewheel', this._wheelBind);
			this._listenerTarget.addEventListener('DOMMouseScroll', this._wheelBind);

			this._listenerTarget.addEventListener('mousedown', this._downBind);
			this._listenerTarget.addEventListener('touchstart', this._downBind);
			this._listenerTarget.addEventListener('mousemove', this._moveBind);
			this._listenerTarget.addEventListener('touchmove', this._moveBind);
			window.addEventListener('touchend', this._upBind);
			window.addEventListener('mouseup', this._upBind);
		}
	}, {
		key: 'disconnect',
		value: function disconnect() {
			this._listenerTarget.removeEventListener('mousewheel', this._wheelBind);
			this._listenerTarget.removeEventListener('DOMMouseScroll', this._wheelBind);

			this._listenerTarget.removeEventListener('mousedown', this._downBind);
			this._listenerTarget.removeEventListener('touchstart', this._downBind);
			this._listenerTarget.removeEventListener('mousemove', this._moveBind);
			this._listenerTarget.removeEventListener('touchmove', this._moveBind);
			window.removeEventListener('touchend', this._upBind);
			window.removeEventListener('mouseup', this._upBind);
		}

		//	PUBLIC METHODS

	}, {
		key: 'lock',
		value: function lock() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockZoom = mValue;
			this._isLockRotation = mValue;
			this._isMouseDown = false;
		}
	}, {
		key: 'lockZoom',
		value: function lockZoom() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockZoom = mValue;
		}
	}, {
		key: 'lockRotation',
		value: function lockRotation() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockRotation = mValue;
		}
	}, {
		key: 'inverseControl',
		value: function inverseControl() {
			var isInvert = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isInvert = isInvert;
		}

		//	EVENT HANDLERES

	}, {
		key: '_onDown',
		value: function _onDown(mEvent) {
			if (this._isLockRotation) {
				return;
			}
			this._isMouseDown = true;
			getMouse(mEvent, this._mouse);
			getMouse(mEvent, this._preMouse);
			this._preRX = this._rx.targetValue;
			this._preRY = this._ry.targetValue;
		}
	}, {
		key: '_onMove',
		value: function _onMove(mEvent) {
			if (this._isLockRotation) {
				return;
			}
			getMouse(mEvent, this._mouse);
			if (mEvent.touches) {
				mEvent.preventDefault();
			}

			if (this._isMouseDown) {
				var diffX = -(this._mouse.x - this._preMouse.x);
				if (this._isInvert) {
					diffX *= -1;
				}
				this._ry.value = this._preRY - diffX * 0.01 * this.sensitivity;

				var diffY = -(this._mouse.y - this._preMouse.y);
				if (this._isInvert) {
					diffY *= -1;
				}
				this._rx.value = this._preRX - diffY * 0.01 * this.sensitivity;
			}
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			if (this._isLockRotation) {
				return;
			}
			this._isMouseDown = false;
		}
	}, {
		key: '_onWheel',
		value: function _onWheel(mEvent) {
			if (this._isLockZoom) {
				return;
			}
			var w = mEvent.wheelDelta;
			var d = mEvent.detail;
			var value = 0;
			if (d) {
				if (w) {
					value = w / d / 40 * d > 0 ? 1 : -1; // Opera
				} else {
					value = -d / 3; // Firefox;         TODO: do not /3 for OS X
				}
			} else {
				value = w / 120;
			}

			this.radius.add(-value * 2);
		}

		//	PRIVATE METHODS

	}, {
		key: '_loop',
		value: function _loop() {

			this._updatePosition();

			if (this._target) {
				this._updateCamera();
			}
		}
	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			this.position[1] = Math.sin(this._rx.value) * this.radius.value;
			var tr = Math.cos(this._rx.value) * this.radius.value;
			this.position[0] = Math.cos(this._ry.value + Math.PI * 0.5) * tr;
			this.position[2] = Math.sin(this._ry.value + Math.PI * 0.5) * tr;
			_glMatrix.vec3.add(this.position, this.position, this.positionOffset);
		}
	}, {
		key: '_updateCamera',
		value: function _updateCamera() {
			this._target.lookAt(this.position, this.center, this._up);
		}

		//	GETTER / SETTER


	}, {
		key: 'rx',
		get: function get() {
			return this._rx;
		}
	}, {
		key: 'ry',
		get: function get() {
			return this._ry;
		}
	}]);

	return OrbitalControl;
}();

exports.default = OrbitalControl;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = "// generalWithNormal.vert\n\n#define SHADER_NAME GENERAL_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform vec3 position;\nuniform vec3 scale;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tvec3 pos      = aVertexPosition * scale;\n\tpos           += position;\n\tgl_Position   = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\t\n\tvTextureCoord = aTextureCoord;\n\tvNormal       = normalize(uNormalMatrix * aNormal);\n}"

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME SKYBOX_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n\tgl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvTextureCoord = aTextureCoord;\n\t\n\tvVertex = aVertexPosition;\n\tvNormal = aNormal;\n}"

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = "// basic.frag\n\n#define SHADER_NAME SKYBOX_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\nuniform samplerCube texture;\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\n\nvoid main(void) {\n    gl_FragColor = textureCube(texture, vVertex);\n}"

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Camera2 = __webpack_require__(24);

var _Camera3 = _interopRequireDefault(_Camera2);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // CameraOrtho.js

var CameraOrtho = function (_Camera) {
	_inherits(CameraOrtho, _Camera);

	function CameraOrtho() {
		_classCallCheck(this, CameraOrtho);

		var _this = _possibleConstructorReturn(this, (CameraOrtho.__proto__ || Object.getPrototypeOf(CameraOrtho)).call(this));

		var eye = _glMatrix.vec3.clone([0, 0, 15]);
		var center = _glMatrix.vec3.create();
		var up = _glMatrix.vec3.clone([0, -1, 0]);
		_this.lookAt(eye, center, up);
		_this.ortho(1, -1, 1, -1);
		return _this;
	}

	_createClass(CameraOrtho, [{
		key: 'setBoundary',
		value: function setBoundary(left, right, top, bottom) {
			var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
			var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;

			this.ortho(left, right, top, bottom, near, far);
		}
	}, {
		key: 'ortho',
		value: function ortho(left, right, top, bottom) {
			var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
			var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			mat4.ortho(this._projection, left, right, top, bottom, near, far);
		}
	}]);

	return CameraOrtho;
}(_Camera3.default);

exports.default = CameraOrtho;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _promisePolyfill = __webpack_require__(42);

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var get = function get(url) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var img = new Image();
		img.onload = function onLoad() {
			resolve(this);
		};

		img.onerror = function onError() {
			reject('Image not found : ' + url);
		};

		img.src = url;
	});
}; // loadImages.js

var loadImages = function loadImages(paths) {
	return _promisePolyfill2.default.all(paths.map(get));
};

exports.default = loadImages;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  this._state = 0;
  this._handled = false;
  this._value = undefined;
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = function(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
};

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!arr || typeof arr.length === 'undefined')
      throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(values) {
  return new Promise(function(resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  (typeof setImmediate === 'function' &&
    function(fn) {
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

module.exports = Promise;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(82).setImmediate))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// PassMacro.js

var PassMacro = function () {
	function PassMacro() {
		_classCallCheck(this, PassMacro);

		this._passes = [];
	}

	_createClass(PassMacro, [{
		key: "addPass",
		value: function addPass(pass) {
			this._passes.push(pass);
		}
	}, {
		key: "passes",
		get: function get() {
			return this._passes;
		}
	}]);

	return PassMacro;
}();

exports.default = PassMacro;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassBlurBase2 = __webpack_require__(45);

var _PassBlurBase3 = _interopRequireDefault(_PassBlurBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassVBlur.js

var PassVBlur = function (_PassBlurBase) {
	_inherits(PassVBlur, _PassBlurBase);

	function PassVBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassVBlur);

		return _possibleConstructorReturn(this, (PassVBlur.__proto__ || Object.getPrototypeOf(PassVBlur)).call(this, mQuality, [0, 1], mWidth, mHeight, mParams));
	}

	return PassVBlur;
}(_PassBlurBase3.default);

exports.default = PassVBlur;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Pass2 = __webpack_require__(12);

var _Pass3 = _interopRequireDefault(_Pass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassBlurBase.js

var fsBlur5 = __webpack_require__(87);
var fsBlur9 = __webpack_require__(88);
var fsBlur13 = __webpack_require__(89);

var PassBlurBase = function (_Pass) {
	_inherits(PassBlurBase, _Pass);

	function PassBlurBase() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mDirection = arguments[1];
		var mWidth = arguments[2];
		var mHeight = arguments[3];
		var mParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

		_classCallCheck(this, PassBlurBase);

		var fs = void 0;
		switch (mQuality) {
			case 5:
			default:
				fs = fsBlur5;
				break;
			case 9:
				fs = fsBlur9;
				break;
			case 13:
				fs = fsBlur13;
				break;

		}

		var _this = _possibleConstructorReturn(this, (PassBlurBase.__proto__ || Object.getPrototypeOf(PassBlurBase)).call(this, fs, mWidth, mHeight, mParams));

		_this.uniform('uDirection', mDirection);
		_this.uniform('uResolution', [_GLTool2.default.width, _GLTool2.default.height]);
		return _this;
	}

	return PassBlurBase;
}(_Pass3.default);

exports.default = PassBlurBase;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassBlurBase2 = __webpack_require__(45);

var _PassBlurBase3 = _interopRequireDefault(_PassBlurBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassHBlur.js

var PassHBlur = function (_PassBlurBase) {
	_inherits(PassHBlur, _PassBlurBase);

	function PassHBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassHBlur);

		return _possibleConstructorReturn(this, (PassHBlur.__proto__ || Object.getPrototypeOf(PassHBlur)).call(this, mQuality, [1, 0], mWidth, mHeight, mParams));
	}

	return PassHBlur;
}(_PassBlurBase3.default);

exports.default = PassHBlur;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = "// fxaa.frag\n\n#define SHADER_NAME FXAA\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uResolution;\n\n\nfloat FXAA_SUBPIX_SHIFT = 1.0/4.0;\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\n\n\nvec4 applyFXAA(sampler2D tex) {\n    vec4 color;\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbM  = texture2D(tex, fragCoord  * uResolution).xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * uResolution;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * uResolution + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * uResolution + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, 1.0);\n    else\n        color = vec4(rgbB, 1.0);\n    return color;\n}\n\nvoid main(void) {\n \tvec4 color = applyFXAA(texture);\n    gl_FragColor = color;\n}"

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(113)(undefined);
// imports


// module
exports.push([module.i, "html, body {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n  position: static;\n  /* Permalink - use to edit and share this gradient: http://colorzilla.com/gradient-editor/#6d6d6d+0,000000+100 */\n  background: #333333;\n  /* Old browsers */\n  background: -moz-radial-gradient(center, ellipse cover, #333333 0%, #000000 100%);\n  /* FF3.6-15 */\n  background: -webkit-radial-gradient(center, ellipse cover, #333333 0%, #000000 100%);\n  /* Chrome10-25,Safari5.1-6 */\n  background: radial-gradient(ellipse at center, #333333 0%, #000000 100%);\n  /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */ }\n\nhtml {\n  -webkit-text-size-adjust: none;\n  -moz-text-size-adjust: none;\n  text-size-adjust: none; }\n\nh1, h2, h3, h4, text, p {\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-webkit-font-smoothing: antialiased;\n  font-family: 'Open Sans', sans-serif; }\n\n.Main-Canvas {\n  width: 100%;\n  height: 100%;\n  top: 0px;\n  left: 0px;\n  position: absolute;\n  user-select: none;\n  opacity: 1;\n  transition: opacity .5s ease-out .25s; }\n  .isLoading .Main-Canvas {\n    opacity: 0; }\n\n.Message {\n  position: absolute;\n  z-index: 999;\n  width: 100%;\n  top: calc(50% - 50px);\n  text-align: center;\n  letter-spacing: 11px;\n  color: white;\n  opacity: 0;\n  transition: opacity .5s ease-out, letter-spacing .5s ease-out; }\n  .isLoading .Message {\n    letter-spacing: 10px;\n    opacity: 1; }\n\n.Loading-Bar {\n  position: absolute;\n  z-index: 998;\n  width: 0%;\n  height: 1px;\n  top: 50%;\n  background: rgba(255, 255, 255, 0.5);\n  opacity: 0;\n  transition: width .5s ease-out, opacity .5s ease-out; }\n  .isLoading .Loading-Bar {\n    opacity: 1; }\n", ""]);

// exports


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["LDU"] = LDU;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    let a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];

  // Calculate the determinant
  let det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] =  a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] =  a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  let a0 = a[0];
  out[0] =  a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] =  a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2]/a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];
  let atx = a[4], aty = a[5];

  let det = aa * ad - ab * ac;
  if(!det){
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromXRotation"] = fromXRotation;
/* harmony export (immutable) */ __webpack_exports__["fromYRotation"] = fromYRotation;
/* harmony export (immutable) */ __webpack_exports__["fromZRotation"] = fromZRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslation"] = fromRotationTranslation;
/* harmony export (immutable) */ __webpack_exports__["getTranslation"] = getTranslation;
/* harmony export (immutable) */ __webpack_exports__["getScaling"] = getScaling;
/* harmony export (immutable) */ __webpack_exports__["getRotation"] = getRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScale"] = fromRotationTranslationScale;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScaleOrigin"] = fromRotationTranslationScaleOrigin;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["frustum"] = frustum;
/* harmony export (immutable) */ __webpack_exports__["perspective"] = perspective;
/* harmony export (immutable) */ __webpack_exports__["perspectiveFromFieldOfView"] = perspectiveFromFieldOfView;
/* harmony export (immutable) */ __webpack_exports__["ortho"] = ortho;
/* harmony export (immutable) */ __webpack_exports__["lookAt"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["targetTo"] = targetTo;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4x4 Matrix
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a03 = a[3];
    let a12 = a[6], a13 = a[7];
    let a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  let x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1], z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;
  let b00, b01, b02;
  let b10, b11, b12;
  let b20, b21, b22;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[0]  = a[0];
    out[1]  = a[1];
    out[2]  = a[2];
    out[3]  = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[4]  = a[4];
    out[5]  = a[5];
    out[6]  = a[6];
    out[7]  = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[8]  = a[8];
    out[9]  = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = 1;
  out[1]  = 0;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = 0;
  out[2]  = -s;
  out[3]  = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = s;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  let m11 = mat[0];
  let m12 = mat[1];
  let m13 = mat[2];
  let m21 = mat[4];
  let m22 = mat[5];
  let m23 = mat[6];
  let m31 = mat[8];
  let m32 = mat[9];
  let m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  let ox = o[0];
  let oy = o[1];
  let oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  let rl = 1 / (right - left);
  let tb = 1 / (top - bottom);
  let nf = 1 / (near - far);
  out[0] = (near * 2) * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = (near * 2) * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (far * near * 2) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2);
  let nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);
  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);
  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);
  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);
  let xScale = 2.0 / (leftTan + rightTan);
  let yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = ((upTan - downTan) * yScale * 0.5);
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = (far * near) / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  let lr = 1 / (left - right);
  let bt = 1 / (bottom - top);
  let nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyey - centery) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyez - centerz) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) {
    return mat4.identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  let eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  let z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  let len = z0*z0 + z1*z1 + z2*z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  let x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  out[9] = a[9] + (b[9] * scale);
  out[10] = a[10] + (b[10] * scale);
  out[11] = a[11] + (b[11] * scale);
  out[12] = a[12] + (b[12] * scale);
  out[13] = a[13] + (b[13] * scale);
  out[14] = a[14] + (b[14] * scale);
  out[15] = a[15] + (b[15] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];
  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];
  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];
  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];
  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];
  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];
  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
          Math.abs(a9 - b9) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
          Math.abs(a10 - b10) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
          Math.abs(a11 - b11) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
          Math.abs(a12 - b12) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
          Math.abs(a13 - b13) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
          Math.abs(a14 - b14) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
          Math.abs(a15 - b15) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["setAxisAngle"] = setAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["getAxisAngle"] = getAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["calculateW"] = calculateW;
/* harmony export (immutable) */ __webpack_exports__["slerp"] = slerp;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["conjugate"] = conjugate;
/* harmony export (immutable) */ __webpack_exports__["fromMat3"] = fromMat3;
/* harmony export (immutable) */ __webpack_exports__["fromEuler"] = fromEuler;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mat3__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vec3__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vec4__ = __webpack_require__(31);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */






/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  let rad = Math.acos(q[3]) * 2.0;
  let s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let by = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bz = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  let x = a[0], y = a[1], z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > 0.000001 ) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
  let invDot = dot ? 1.0/dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0*invDot;
  out[1] = -a1*invDot;
  out[2] = -a2*invDot;
  out[3] = a3*invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if ( fTrace > 0.0 ) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5/fRoot;  // 1/(4w)
    out[0] = (m[5]-m[7])*fRoot;
    out[1] = (m[6]-m[2])*fRoot;
    out[2] = (m[1]-m[3])*fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if ( m[4] > m[0] )
      i = 1;
    if ( m[8] > m[i*3+i] )
      i = 2;
    let j = (i+1)%3;
    let k = (i+2)%3;

    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
    let halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;

    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);

    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;

    return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
const clone = __WEBPACK_IMPORTED_MODULE_3__vec4__["clone"];
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;


/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
const fromValues = __WEBPACK_IMPORTED_MODULE_3__vec4__["fromValues"];
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;


/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
const copy = __WEBPACK_IMPORTED_MODULE_3__vec4__["copy"];
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;


/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
const set = __WEBPACK_IMPORTED_MODULE_3__vec4__["set"];
/* harmony export (immutable) */ __webpack_exports__["set"] = set;


/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
const add = __WEBPACK_IMPORTED_MODULE_3__vec4__["add"];
/* harmony export (immutable) */ __webpack_exports__["add"] = add;


/**
 * Alias for {@link quat.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
const scale = __WEBPACK_IMPORTED_MODULE_3__vec4__["scale"];
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;


/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
const dot = __WEBPACK_IMPORTED_MODULE_3__vec4__["dot"];
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;


/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
const lerp = __WEBPACK_IMPORTED_MODULE_3__vec4__["lerp"];
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;


/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
const length = __WEBPACK_IMPORTED_MODULE_3__vec4__["length"];
/* harmony export (immutable) */ __webpack_exports__["length"] = length;


/**
 * Alias for {@link quat.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
const squaredLength = __WEBPACK_IMPORTED_MODULE_3__vec4__["squaredLength"];
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;


/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const normalize = __WEBPACK_IMPORTED_MODULE_3__vec4__["normalize"];
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;


/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const exactEquals = __WEBPACK_IMPORTED_MODULE_3__vec4__["exactEquals"];
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;


/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const equals = __WEBPACK_IMPORTED_MODULE_3__vec4__["equals"];
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;


/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
const rotationTo = (function() {
  let tmpvec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["create"]();
  let xUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](1,0,0);
  let yUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](0,1,0);

  return function(out, a, b) {
    let dot = __WEBPACK_IMPORTED_MODULE_2__vec3__["dot"](a, b);
    if (dot < -0.999999) {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, xUnitVec3, a);
      if (__WEBPACK_IMPORTED_MODULE_2__vec3__["len"](tmpvec3) < 0.000001)
        __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, yUnitVec3, a);
      __WEBPACK_IMPORTED_MODULE_2__vec3__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
})();
/* harmony export (immutable) */ __webpack_exports__["rotationTo"] = rotationTo;


/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
const sqlerp = (function () {
  let temp1 = create();
  let temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());
/* harmony export (immutable) */ __webpack_exports__["sqlerp"] = sqlerp;


/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
const setAxes = (function() {
  let matr = __WEBPACK_IMPORTED_MODULE_1__mat3__["create"]();

  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
})();
/* harmony export (immutable) */ __webpack_exports__["setAxes"] = setAxes;



/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat2"] = transformMat2;
/* harmony export (immutable) */ __webpack_exports__["transformMat2d"] = transformMat2d;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
};

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round (out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x*x + y*y;
};

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1];
  return x*x + y*y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x*x + y*y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1];
  let b0 = b[0], b1 = b[1];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec2.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec2.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 2;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = getAndApplyExtension;
// VertexArrayObject.js

function getAndApplyExtension(gl, name) {
	var ext = gl.getExtension(name);
	if (!ext) {
		return false;
	}
	var suffix = name.split('_')[0];
	var suffixRE = new RegExp(suffix + '$');

	for (var key in ext) {
		var val = ext[key];
		if (typeof val === 'function') {
			var unsuffixedKey = key.replace(suffixRE, '');
			if (key.substring) {
				gl[unsuffixedKey] = ext[key].bind(ext);
				// console.log('Replacing :', key, '=>', unsuffixedKey);
			}
		}
	}

	return true;
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _WebglConst = __webpack_require__(32);

var _WebglConst2 = _interopRequireDefault(_WebglConst);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// exposeAttributes.js

var exposeAttributes = function exposeAttributes() {
	// GL.VERTEX_SHADER         = GL.gl.VERTEX_SHADER;
	// GL.FRAGMENT_SHADER       = GL.gl.FRAGMENT_SHADER;
	// GL.COMPILE_STATUS        = GL.gl.COMPILE_STATUS;
	// GL.DEPTH_TEST            = GL.gl.DEPTH_TEST;
	// GL.CULL_FACE             = GL.gl.CULL_FACE;
	// GL.BLEND                 = GL.gl.BLEND;
	// GL.POINTS                = GL.gl.POINTS;
	// GL.LINES                 = GL.gl.LINES;
	// GL.TRIANGLES             = GL.gl.TRIANGLES;

	// GL.LINEAR                	= GL.gl.LINEAR;
	// GL.NEAREST               	= GL.gl.NEAREST;
	// GL.LINEAR_MIPMAP_NEAREST 	= GL.gl.LINEAR_MIPMAP_NEAREST;
	// GL.NEAREST_MIPMAP_LINEAR 	= GL.gl.NEAREST_MIPMAP_LINEAR;
	// GL.LINEAR_MIPMAP_LINEAR 	= GL.gl.LINEAR_MIPMAP_LINEAR;
	// GL.NEAREST_MIPMAP_NEAREST 	= GL.gl.NEAREST_MIPMAP_NEAREST;
	// GL.MIRRORED_REPEAT       	= GL.gl.MIRRORED_REPEAT;
	// GL.CLAMP_TO_EDGE         	= GL.gl.CLAMP_TO_EDGE;
	// GL.SCISSOR_TEST		   	 	= GL.gl.SCISSOR_TEST;
	// GL.UNSIGNED_BYTE		 	= GL.gl.UNSIGNED_BYTE;
	for (var s in _WebglConst2.default) {
		if (!_GLTool2.default[s]) {
			_GLTool2.default[s] = _WebglConst2.default[s];
		} else {
			console.log('already exist : ', s);
		}
	}
};

exports.default = exposeAttributes;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	if (!hasChecked) {
		_float = checkFloat();
	}

	return _float;
};

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasChecked = false; // getFloat.js

var _float = void 0;

function checkFloat() {
	if (_GLTool2.default.webgl2) {
		return _GLTool2.default.gl.FLOAT;
	} else {
		var extFloat = _GLTool2.default.getExtension('OES_texture_float');
		if (extFloat) {
			return _GLTool2.default.gl.FLOAT;
		} else {
			console.warn('USING FLOAT BUT OES_texture_float NOT SUPPORTED');
			return _GLTool2.default.gl.UNSIGNED_BYTE;
		}
	}

	hasChecked = true;
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	if (!hasChecked) {
		halfFloat = checkHalfFloat();
	}

	return halfFloat;
};

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasChecked = false; // getHalfFloat.js

var halfFloat = void 0;

function checkHalfFloat() {
	if (_GLTool2.default.webgl2) {
		return _GLTool2.default.gl.HALF_FLOAT;
	} else {
		var extHalfFloat = _GLTool2.default.getExtension('OES_texture_half_float');
		if (extHalfFloat) {
			return extHalfFloat.HALF_FLOAT_OES;
		} else {
			console.warn('USING HALF FLOAT BUT OES_texture_half_float NOT SUPPORTED');
			return _GLTool2.default.gl.UNSIGNED_BYTE;
		}
	}

	hasChecked = true;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// ExtensionsList.js

exports.default = ['EXT_shader_texture_lod', 'EXT_sRGB', 'EXT_frag_depth', 'OES_texture_float', 'OES_texture_half_float', 'OES_texture_float_linear', 'OES_texture_half_float_linear', 'OES_standard_derivatives', 'WEBGL_depth_texture', 'EXT_texture_filter_anisotropic', 'OES_vertex_array_object', 'ANGLE_instanced_arrays', 'WEBGL_draw_buffers'];

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
} // getTextureParameters.js

;

var getTextureParameters = function getTextureParameters(mParams, mSource, mWidth, mHeight) {
	if (!mParams.minFilter) {
		var minFilter = _GLTool2.default.LINEAR;
		if (mWidth && mWidth) {
			if (isPowerOfTwo(mWidth) && isPowerOfTwo(mHeight)) {
				minFilter = _GLTool2.default.LINEAR_MIPMAP_NEAREST;
			}
		}

		mParams.minFilter = minFilter;
	}

	mParams.mipmap = mParams.mipmap || true;
	mParams.magFilter = mParams.magFilter || _GLTool2.default.LINEAR;
	mParams.wrapS = mParams.wrapS || _GLTool2.default.CLAMP_TO_EDGE;
	mParams.wrapT = mParams.wrapT || _GLTool2.default.CLAMP_TO_EDGE;
	mParams.internalFormat = mParams.internalFormat || _GLTool2.default.RGBA;
	mParams.format = mParams.format || _GLTool2.default.RGBA;
	mParams.premultiplyAlpha = mParams.premultiplyAlpha || false;
	mParams.level = mParams.level || 0;
	mParams.anisotropy = mParams.anisotropy || 0;

	return mParams;
};

exports.default = getTextureParameters;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
//
// DX10 Cubemap support based on
// https://github.com/dariomanesku/cmft/issues/7#issuecomment-69516844
// https://msdn.microsoft.com/en-us/library/windows/desktop/bb943983(v=vs.85).aspx
// https://github.com/playcanvas/engine/blob/master/src/resources/resources_texture.js

var DDS_MAGIC = 0x20534444
var DDSD_MIPMAPCOUNT = 0x20000
var DDPF_FOURCC = 0x4

var FOURCC_DXT1 = fourCCToInt32('DXT1')
var FOURCC_DXT3 = fourCCToInt32('DXT3')
var FOURCC_DXT5 = fourCCToInt32('DXT5')
var FOURCC_DX10 = fourCCToInt32('DX10')
var FOURCC_FP32F = 116 // DXGI_FORMAT_R32G32B32A32_FLOAT

var DDSCAPS2_CUBEMAP = 0x200
var D3D10_RESOURCE_DIMENSION_TEXTURE2D = 3
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2

// The header length in 32 bit ints
var headerLengthInt = 31

// Offsets into the header array
var off_magic = 0
var off_size = 1
var off_flags = 2
var off_height = 3
var off_width = 4
var off_mipmapCount = 7
var off_pfFlags = 20
var off_pfFourCC = 21
var off_caps2 = 28

module.exports = parseHeaders

function parseHeaders (arrayBuffer) {
  var header = new Int32Array(arrayBuffer, 0, headerLengthInt)

  if (header[off_magic] !== DDS_MAGIC) {
    throw new Error('Invalid magic number in DDS header')
  }

  if (!header[off_pfFlags] & DDPF_FOURCC) {
    throw new Error('Unsupported format, must contain a FourCC code')
  }

  var blockBytes
  var format
  var fourCC = header[off_pfFourCC]
  switch (fourCC) {
    case FOURCC_DXT1:
      blockBytes = 8
      format = 'dxt1'
      break
    case FOURCC_DXT3:
      blockBytes = 16
      format = 'dxt3'
      break
    case FOURCC_DXT5:
      blockBytes = 16
      format = 'dxt5'
      break
    case FOURCC_FP32F:
      format = 'rgba32f'
      break
    case FOURCC_DX10:
      var dx10Header = new Uint32Array(arrayBuffer.slice(128, 128 + 20))
      format = dx10Header[0]
      var resourceDimension = dx10Header[1]
      var miscFlag = dx10Header[2]
      var arraySize = dx10Header[3]
      var miscFlags2 = dx10Header[4]

      if (resourceDimension === D3D10_RESOURCE_DIMENSION_TEXTURE2D && format === DXGI_FORMAT_R32G32B32A32_FLOAT) {
        format = 'rgba32f'
      } else {
        throw new Error('Unsupported DX10 texture format ' + format)
      }
      break
    default:
      throw new Error('Unsupported FourCC code: ' + int32ToFourCC(fourCC))
  }

  var flags = header[off_flags]
  var mipmapCount = 1

  if (flags & DDSD_MIPMAPCOUNT) {
    mipmapCount = Math.max(1, header[off_mipmapCount])
  }

  var cubemap = false
  var caps2 = header[off_caps2]
  if (caps2 & DDSCAPS2_CUBEMAP) {
    cubemap = true
  }

  var width = header[off_width]
  var height = header[off_height]
  var dataOffset = header[off_size] + 4
  var texWidth = width
  var texHeight = height
  var images = []
  var dataLength

  if (fourCC === FOURCC_DX10) {
    dataOffset += 20
  }

  if (cubemap) {
    for (var f = 0; f < 6; f++) {
      if (format !== 'rgba32f') {
        throw new Error('Only RGBA32f cubemaps are supported')
      }
      var bpp = 4 * 32 / 8

      width = texWidth
      height = texHeight

      // cubemap should have all mipmap levels defined
      // Math.log2(width) + 1
      var requiredMipLevels = Math.log(width) / Math.log(2) + 1

      for (var i = 0; i < requiredMipLevels; i++) {
        dataLength = width * height * bpp
        images.push({
          offset: dataOffset,
          length: dataLength,
          shape: [ width, height ]
        })
        // Reuse data from the previous level if we are beyond mipmapCount
        // This is hack for CMFT not publishing full mipmap chain https://github.com/dariomanesku/cmft/issues/10
        if (i < mipmapCount) {
          dataOffset += dataLength
        }
        width = Math.floor(width / 2)
        height = Math.floor(height / 2)
      }
    }
  } else {
    for (var i = 0; i < mipmapCount; i++) {
      dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes

      images.push({
        offset: dataOffset,
        length: dataLength,
        shape: [ width, height ]
      })
      dataOffset += dataLength
      width = Math.floor(width / 2)
      height = Math.floor(height / 2)
    }
  }

  return {
    shape: [ texWidth, texHeight ],
    images: images,
    format: format,
    flags: flags,
    cubemap: cubemap
  }
}

function fourCCToInt32 (value) {
  return value.charCodeAt(0) +
    (value.charCodeAt(1) << 8) +
    (value.charCodeAt(2) << 16) +
    (value.charCodeAt(3) << 24)
}

function int32ToFourCC (value) {
  return String.fromCharCode(
    value & 0xff,
    (value >> 8) & 0xff,
    (value >> 16) & 0xff,
    (value >> 24) & 0xff
  )
}


/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}


/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = "// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// CubeFrameBuffer.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLCubeTexture = __webpack_require__(14);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var CubeFrameBuffer = function () {
	function CubeFrameBuffer(size) {
		var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, CubeFrameBuffer);

		gl = _GLTool2.default.gl;
		this._size = size;
		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

		this._init();
	}

	_createClass(CubeFrameBuffer, [{
		key: '_init',
		value: function _init() {
			this.texture = gl.createTexture();
			this.glTexture = new _GLCubeTexture2.default(this.texture, {}, true);

			gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);

			var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

			for (var i = 0; i < targets.length; i++) {
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				gl.texImage2D(targets[i], 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.FLOAT, null);
			}

			this._frameBuffers = [];
			for (var _i = 0; _i < targets.length; _i++) {
				var frameBuffer = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, targets[_i], this.texture, 0);

				var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
				if (status !== gl.FRAMEBUFFER_COMPLETE) {
					console.log('\'gl.checkFramebufferStatus() returned \'' + status);
				}

				this._frameBuffers.push(frameBuffer);
			}

			// gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		}
	}, {
		key: 'bind',
		value: function bind(mTargetIndex) {

			// if(Math.random() > .99) console.log('bind :', mTargetIndex, this._frameBuffers[mTargetIndex]);
			_GLTool2.default.viewport(0, 0, this.width, this.height);
			gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffers[mTargetIndex]);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
		}

		//	TEXTURES

	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this.glTexture;
		}

		//	GETTERS AND SETTERS

	}, {
		key: 'width',
		get: function get() {
			return this._size;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._size;
		}
	}]);

	return CubeFrameBuffer;
}();

exports.default = CubeFrameBuffer;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // MultisampleFrameBuffer.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

var MultisampleFrameBuffer = function () {
	function MultisampleFrameBuffer(mWidth, mHeight) {
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, MultisampleFrameBuffer);

		gl = _GLTool2.default.gl;

		this.width = mWidth;
		this.height = mHeight;

		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;
		this.useDepth = mParameters.useDepth || true;
		this.useStencil = mParameters.useStencil || false;
		this.texelType = mParameters.type;
		this._numSample = mParameters.numSample || 8;

		if (!isPowerOfTwo(this.width) || !isPowerOfTwo(this.height)) {
			this.wrapS = this.wrapT = gl.CLAMP_TO_EDGE;

			if (this.minFilter === gl.LINEAR_MIPMAP_NEAREST) {
				this.minFilter = gl.LINEAR;
			}
		}

		this._init();
	}

	_createClass(MultisampleFrameBuffer, [{
		key: '_init',
		value: function _init() {
			var texelType = gl.UNSIGNED_BYTE;
			if (this.texelType) {
				texelType = this.texelType;
			}

			this.texelType = texelType;

			this.frameBuffer = gl.createFramebuffer();
			this.frameBufferColor = gl.createFramebuffer();
			this.renderBufferColor = gl.createRenderbuffer();
			this.renderBufferDepth = gl.createRenderbuffer();
			this.glTexture = this._createTexture();
			this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);

			gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferColor);
			gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.RGBA8, this.width, this.height);

			gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
			gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.DEPTH_COMPONENT16, this.width, this.height);

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.renderBufferColor);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferColor);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.glTexture.texture, 0);
			// gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			// gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferDepth);
			// gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			// gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: '_createTexture',
		value: function _createTexture(mInternalformat, mTexelType, mFormat) {
			var forceNearest = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

			if (mInternalformat === undefined) {
				mInternalformat = gl.RGBA;
			}
			if (mTexelType === undefined) {
				mTexelType = this.texelType;
			}
			if (!mFormat) {
				mFormat = mInternalformat;
			}

			var t = gl.createTexture();
			var glt = new _GLTexture2.default(t, true);
			var magFilter = forceNearest ? _GLTool2.default.NEAREST : this.magFilter;
			var minFilter = forceNearest ? _GLTool2.default.NEAREST : this.minFilter;

			gl.bindTexture(gl.TEXTURE_2D, t);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapT);
			gl.texImage2D(gl.TEXTURE_2D, 0, mInternalformat, this.width, this.height, 0, mFormat, mTexelType, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			return glt;
		}
	}, {
		key: 'bind',
		value: function bind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, this.width, this.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
			}

			var width = this.width,
			    height = this.height;


			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferColor);
			gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 0.0]);
			gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, _GLTool2.default.NEAREST);
			// gl.blitFramebuffer(
			// 	0, 0, width, height,
			// 	0, 0, width, height,
			// 	gl.COLOR_BUFFER_BIT|gl.DEPTH_STENCIL, GL.NEAREST
			// );

			// gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
			// gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferDepth);
			// gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1.0, 0);
			// gl.blitFramebuffer(
			// 	0, 0, width, height,
			// 	0, 0, width, height,
			// 	gl.DEPTH_BUFFER_BIT, gl.NEAREST
			// );

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			var mIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			return this.glTexture;
		}
	}, {
		key: 'getDepthTexture',
		value: function getDepthTexture() {
			return this.glDepthTexture;
		}
	}]);

	return MultisampleFrameBuffer;
}();

exports.default = MultisampleFrameBuffer;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // TransformFeedbackObject.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var TransformFeedbackObject = function () {
	function TransformFeedbackObject(strVertexShader, strFragmentShader) {
		_classCallCheck(this, TransformFeedbackObject);

		gl = _GLTool2.default.gl;
		this._vs = strVertexShader;
		this._fs = strFragmentShader;

		this._init();
	}

	_createClass(TransformFeedbackObject, [{
		key: '_init',
		value: function _init() {
			this._geoCurrent = new _Geometry2.default();
			this._geoTarget = new _Geometry2.default();
			this._numPoints = -1;

			this._varyings = [];
			this.transformFeedback = gl.createTransformFeedback();
		}
	}, {
		key: 'bufferData',
		value: function bufferData(mData, mName, mVaryingName) {
			var isTransformFeedback = !!mVaryingName;
			console.log('is Transform feedback ?', mName, isTransformFeedback);
			this._geoCurrent.bufferData(mData, mName, null, gl.STREAM_COPY, false);
			this._geoTarget.bufferData(mData, mName, null, gl.STREAM_COPY, false);

			if (isTransformFeedback) {
				this._varyings.push(mVaryingName);

				if (this._numPoints < 0) {
					this._numPoints = mData.length;
				}
			}
		}
	}, {
		key: 'bufferIndex',
		value: function bufferIndex(mArrayIndices) {
			this._geoCurrent.bufferIndex(mArrayIndices);
			this._geoTarget.bufferIndex(mArrayIndices);
		}
	}, {
		key: 'uniform',
		value: function uniform(mName, mType, mValue) {
			if (this.shader) {
				this.shader.uniform(mName, mType, mValue);
			}
		}
	}, {
		key: 'generate',
		value: function generate() {
			this.shader = new _GLShader2.default(this._vs, this._fs, this._varyings);
		}
	}, {
		key: 'render',
		value: function render() {
			if (!this.shader) {
				this.generate();
			}

			this.shader.bind();
			_GLTool2.default.drawTransformFeedback(this);

			this._swap();
		}
	}, {
		key: '_swap',
		value: function _swap() {
			var tmp = this._geoCurrent;
			this._geoCurrent = this._geoTarget;
			this._geoTarget = tmp;
		}
	}, {
		key: 'numPoints',
		get: function get() {
			return this._numPoints;
		}
	}, {
		key: 'geoCurrent',
		get: function get() {
			return this._geoCurrent;
		}
	}, {
		key: 'geoTarget',
		get: function get() {
			return this._geoTarget;
		}
	}, {
		key: 'geoSource',
		get: function get() {
			return this._geoCurrent;
		}
	}, {
		key: 'geoDestination',
		get: function get() {
			return this._geoTarget;
		}
	}]);

	return TransformFeedbackObject;
}();

exports.default = TransformFeedbackObject;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// TweenNumber.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Easing = {
	Linear: {
		None: function None(k) {
			return k;
		}
	},
	Quadratic: {
		In: function In(k) {
			return k * k;
		},
		Out: function Out(k) {
			return k * (2 - k);
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}
			return -0.5 * (--k * (k - 2) - 1);
		}
	},
	Cubic: {
		In: function In(k) {
			return k * k * k;
		},
		Out: function Out(k) {
			return --k * k * k + 1;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}
			return 0.5 * ((k -= 2) * k * k + 2);
		}
	},
	Quartic: {
		In: function In(k) {
			return k * k * k * k;
		},
		Out: function Out(k) {
			return 1 - --k * k * k * k;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}
			return -0.5 * ((k -= 2) * k * k * k - 2);
		}
	},
	Quintic: {
		In: function In(k) {
			return k * k * k * k * k;
		},
		Out: function Out(k) {
			return --k * k * k * k * k + 1;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}
			return 0.5 * ((k -= 2) * k * k * k * k + 2);
		}
	},
	Sinusoidal: {
		In: function In(k) {
			return 1 - Math.cos(k * Math.PI / 2);
		},
		Out: function Out(k) {
			return Math.sin(k * Math.PI / 2);
		},
		InOut: function InOut(k) {
			return 0.5 * (1 - Math.cos(Math.PI * k));
		}
	},
	Exponential: {
		In: function In(k) {
			return k === 0 ? 0 : Math.pow(1024, k - 1);
		},
		Out: function Out(k) {
			return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
		},
		InOut: function InOut(k) {
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}
			return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
		}
	},
	Circular: {
		In: function In(k) {
			return 1 - Math.sqrt(1 - k * k);
		},
		Out: function Out(k) {
			return Math.sqrt(1 - --k * k);
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return -0.5 * (Math.sqrt(1 - k * k) - 1);
			}
			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
		}
	},
	Elastic: {
		In: function In(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
		},
		Out: function Out(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
		},
		InOut: function InOut(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			if ((k *= 2) < 1) {
				return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
			}
			return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
		}
	},
	Back: {
		In: function In(k) {
			var s = 1.70158;
			return k * k * ((s + 1) * k - s);
		},
		Out: function Out(k) {
			var s = 1.70158;
			return --k * k * ((s + 1) * k + s) + 1;
		},
		InOut: function InOut(k) {
			var s = 1.70158 * 1.525;
			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}
			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
		}
	},
	Bounce: {
		in: function _in(k) {
			return 1 - Easing.Bounce.out(1 - k);
		},
		out: function out(k) {
			if (k < 1 / 2.75) {
				return 7.5625 * k * k;
			} else if (k < 2 / 2.75) {
				return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
			} else if (k < 2.5 / 2.75) {
				return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
			} else {
				return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
			}
		},
		inOut: function inOut(k) {
			if (k < 0.5) {
				return Easing.Bounce.in(k * 2) * 0.5;
			}
			return Easing.Bounce.out(k * 2 - 1) * 0.5 + 0.5;
		}
	}
};

function getFunc(mEasing) {
	switch (mEasing) {
		default:
		case 'linear':
			return Easing.Linear.None;
		case 'expIn':
			return Easing.Exponential.In;
		case 'expOut':
			return Easing.Exponential.Out;
		case 'expInOut':
			return Easing.Exponential.InOut;

		case 'cubicIn':
			return Easing.Cubic.In;
		case 'cubicOut':
			return Easing.Cubic.Out;
		case 'cubicInOut':
			return Easing.Cubic.InOut;

		case 'quarticIn':
			return Easing.Quartic.In;
		case 'quarticOut':
			return Easing.Quartic.Out;
		case 'quarticInOut':
			return Easing.Quartic.InOut;

		case 'quinticIn':
			return Easing.Quintic.In;
		case 'quinticOut':
			return Easing.Quintic.Out;
		case 'quinticInOut':
			return Easing.Quintic.InOut;

		case 'sinusoidalIn':
			return Easing.Sinusoidal.In;
		case 'sinusoidalOut':
			return Easing.Sinusoidal.Out;
		case 'sinusoidalInOut':
			return Easing.Sinusoidal.InOut;

		case 'circularIn':
			return Easing.Circular.In;
		case 'circularOut':
			return Easing.Circular.Out;
		case 'circularInOut':
			return Easing.Circular.InOut;

		case 'elasticIn':
			return Easing.Elastic.In;
		case 'elasticOut':
			return Easing.Elastic.Out;
		case 'elasticInOut':
			return Easing.Elastic.InOut;

		case 'backIn':
			return Easing.Back.In;
		case 'backOut':
			return Easing.Back.Out;
		case 'backInOut':
			return Easing.Back.InOut;

		case 'bounceIn':
			return Easing.Bounce.in;
		case 'bounceOut':
			return Easing.Bounce.out;
		case 'bounceInOut':
			return Easing.Bounce.inOut;
	}
}

var TweenNumber = function () {
	function TweenNumber(mValue) {
		var _this = this;

		var mEasing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'expOut';
		var mSpeed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.01;

		_classCallCheck(this, TweenNumber);

		this._value = mValue;
		this._startValue = mValue;
		this._targetValue = mValue;
		this._counter = 1;
		this.speed = mSpeed;
		this.easing = mEasing;
		this._needUpdate = true;

		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._update();
		});
	}

	_createClass(TweenNumber, [{
		key: '_update',
		value: function _update() {
			var newCounter = this._counter + this.speed;
			if (newCounter > 1) {
				newCounter = 1;
			}
			if (this._counter === newCounter) {
				this._needUpdate = false;
				return;
			}

			this._counter = newCounter;
			this._needUpdate = true;
		}
	}, {
		key: 'limit',
		value: function limit(mMin, mMax) {
			if (mMin > mMax) {
				this.limit(mMax, mMin);
				return;
			}

			this._min = mMin;
			this._max = mMax;

			this._checkLimit();
		}
	}, {
		key: 'setTo',
		value: function setTo(mValue) {
			this._value = mValue;
			this._targetValue = mValue;
			this._counter = 1;
		}
	}, {
		key: '_checkLimit',
		value: function _checkLimit() {
			if (this._min !== undefined && this._targetValue < this._min) {
				this._targetValue = this._min;
			}

			if (this._max !== undefined && this._targetValue > this._max) {
				this._targetValue = this._max;
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			_scheduling2.default.removeEF(this._efIndex);
		}

		//	GETTERS / SETTERS

	}, {
		key: 'value',
		set: function set(mValue) {
			this._startValue = this._value;
			this._targetValue = mValue;
			this._checkLimit();
			this._counter = 0;
		},
		get: function get() {
			if (this._needUpdate) {
				var f = getFunc(this.easing);
				var p = f(this._counter);
				this._value = this._startValue + p * (this._targetValue - this._startValue);
				this._needUpdate = false;
			}
			return this._value;
		}
	}, {
		key: 'targetValue',
		get: function get() {
			return this._targetValue;
		}
	}]);

	return TweenNumber;
}();

exports.default = TweenNumber;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// QuatRotation.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _glMatrix = __webpack_require__(2);

var _glMatrix2 = _interopRequireDefault(_glMatrix);

var _EaseNumber = __webpack_require__(19);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getMouse = function getMouse(mEvent, mTarget) {

	var o = mTarget || {};
	if (mEvent.touches) {
		o.x = mEvent.touches[0].pageX;
		o.y = mEvent.touches[0].pageY;
	} else {
		o.x = mEvent.clientX;
		o.y = mEvent.clientY;
	}

	return o;
};

var QuatRotation = function () {
	function QuatRotation(mTarget) {
		var _this = this;

		var mListenerTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
		var mEasing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;

		_classCallCheck(this, QuatRotation);

		this._target = mTarget;
		this._listenerTarget = mListenerTarget;

		this.matrix = _glMatrix2.default.mat4.create();
		this.m = _glMatrix2.default.mat4.create();
		this._vZaxis = _glMatrix2.default.vec3.clone([0, 0, 0]);
		this._zAxis = _glMatrix2.default.vec3.clone([0, 0, 1]);
		this.preMouse = { x: 0, y: 0 };
		this.mouse = { x: 0, y: 0 };
		this._isMouseDown = false;
		this._rotation = _glMatrix2.default.quat.create();
		this.tempRotation = _glMatrix2.default.quat.create();
		this._rotateZMargin = 0;
		this._offset = 0.004;
		this._slerp = -1;
		this._isLocked = false;

		this._diffX = new _EaseNumber2.default(0, mEasing);
		this._diffY = new _EaseNumber2.default(0, mEasing);

		this._listenerTarget.addEventListener('mousedown', function (e) {
			return _this._onDown(e);
		});
		this._listenerTarget.addEventListener('touchstart', function (e) {
			return _this._onDown(e);
		});
		this._listenerTarget.addEventListener('mousemove', function (e) {
			return _this._onMove(e);
		});
		this._listenerTarget.addEventListener('touchmove', function (e) {
			return _this._onMove(e);
		});
		window.addEventListener('touchend', function () {
			return _this._onUp();
		});
		window.addEventListener('mouseup', function () {
			return _this._onUp();
		});

		_scheduling2.default.addEF(function () {
			return _this._loop();
		});
	}

	// 	PUBLIC METHODS

	_createClass(QuatRotation, [{
		key: 'inverseControl',
		value: function inverseControl() {
			var isInvert = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isInvert = isInvert;
		}
	}, {
		key: 'lock',
		value: function lock() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLocked = mValue;
		}
	}, {
		key: 'setCameraPos',
		value: function setCameraPos(mQuat) {
			var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;

			this.easing = speed;
			if (this._slerp > 0) {
				return;
			}

			var tempRotation = _glMatrix2.default.quat.clone(this._rotation);
			this._updateRotation(tempRotation);
			this._rotation = _glMatrix2.default.quat.clone(tempRotation);
			this._currDiffX = this.diffX = 0;
			this._currDiffY = this.diffY = 0;

			this._isMouseDown = false;
			this._isRotateZ = 0;

			this._targetQuat = _glMatrix2.default.quat.clone(mQuat);
			this._slerp = 1;
		}
	}, {
		key: 'resetQuat',
		value: function resetQuat() {
			this._rotation = _glMatrix2.default.quat.clone([0, 0, 1, 0]);
			this.tempRotation = _glMatrix2.default.quat.clone([0, 0, 0, 0]);
			this._targetQuat = undefined;
			this._slerp = -1;
		}

		//	EVENT HANDLER

	}, {
		key: '_onDown',
		value: function _onDown(mEvent) {
			if (this._isLocked) {
				return;
			}

			var mouse = getMouse(mEvent);
			var tempRotation = _glMatrix2.default.quat.clone(this._rotation);
			this._updateRotation(tempRotation);
			this._rotation = tempRotation;

			this._isMouseDown = true;
			this._isRotateZ = 0;
			this.preMouse = { x: mouse.x, y: mouse.y };

			if (mouse.y < this._rotateZMargin || mouse.y > window.innerHeight - this._rotateZMargin) {
				this._isRotateZ = 1;
			} else if (mouse.x < this._rotateZMargin || mouse.x > window.innerWidth - this._rotateZMargin) {
				this._isRotateZ = 2;
			}

			this._diffX.setTo(0);
			this._diffY.setTo(0);
		}
	}, {
		key: '_onMove',
		value: function _onMove(mEvent) {
			if (this._isLocked) {
				return;
			}
			getMouse(mEvent, this.mouse);
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			if (this._isLocked) {
				return;
			}
			this._isMouseDown = false;
		}

		//	PRIVATE METHODS

	}, {
		key: '_updateRotation',
		value: function _updateRotation(mTempRotation) {
			if (this._isMouseDown && !this._isLocked) {
				this._diffX.value = -(this.mouse.x - this.preMouse.x);
				this._diffY.value = this.mouse.y - this.preMouse.y;

				if (this._isInvert) {
					this._diffX.value = -this._diffX.targetValue;
					this._diffY.value = -this._diffY.targetValue;
				}
			}

			var angle = void 0,
			    _quat = void 0;

			if (this._isRotateZ > 0) {
				if (this._isRotateZ === 1) {
					angle = -this._diffX.value * this._offset;
					angle *= this.preMouse.y < this._rotateZMargin ? -1 : 1;
					_quat = _glMatrix2.default.quat.clone([0, 0, Math.sin(angle), Math.cos(angle)]);
					_glMatrix2.default.quat.multiply(_quat, mTempRotation, _quat);
				} else {
					angle = -this._diffY.value * this._offset;
					angle *= this.preMouse.x < this._rotateZMargin ? 1 : -1;
					_quat = _glMatrix2.default.quat.clone([0, 0, Math.sin(angle), Math.cos(angle)]);
					_glMatrix2.default.quat.multiply(_quat, mTempRotation, _quat);
				}
			} else {
				var v = _glMatrix2.default.vec3.clone([this._diffX.value, this._diffY.value, 0]);
				var axis = _glMatrix2.default.vec3.create();
				_glMatrix2.default.vec3.cross(axis, v, this._zAxis);
				_glMatrix2.default.vec3.normalize(axis, axis);
				angle = _glMatrix2.default.vec3.length(v) * this._offset;
				_quat = _glMatrix2.default.quat.clone([Math.sin(angle) * axis[0], Math.sin(angle) * axis[1], Math.sin(angle) * axis[2], Math.cos(angle)]);
				_glMatrix2.default.quat.multiply(mTempRotation, _quat, mTempRotation);
			}
		}
	}, {
		key: '_loop',
		value: function _loop() {
			_glMatrix2.default.mat4.identity(this.m);

			if (this._targetQuat === undefined) {
				_glMatrix2.default.quat.set(this.tempRotation, this._rotation[0], this._rotation[1], this._rotation[2], this._rotation[3]);
				this._updateRotation(this.tempRotation);
			} else {
				this._slerp += (0 - this._slerp) * 0.1;

				if (this._slerp < 0.0005) {
					_glMatrix2.default.quat.copy(this._rotation, this._targetQuat);
					_glMatrix2.default.quat.copy(this.tempRotation, this._targetQuat);
					this._targetQuat = undefined;
					this._diffX.setTo(0);
					this._diffY.setTo(0);
					this._slerp = -1;
				} else {
					_glMatrix2.default.quat.set(this.tempRotation, 0, 0, 0, 0);
					_glMatrix2.default.quat.slerp(this.tempRotation, this._targetQuat, this._rotation, this._slerp);
				}
			}

			_glMatrix2.default.vec3.transformQuat(this._vZaxis, this._vZaxis, this.tempRotation);

			_glMatrix2.default.mat4.fromQuat(this.matrix, this.tempRotation);
		}

		//	GETTER AND SETTER

	}, {
		key: 'easing',
		set: function set(mValue) {
			this._diffX.easing = mValue;
			this._diffY.easing = mValue;
		},
		get: function get() {
			return this._diffX.easing;
		}
	}]);

	return QuatRotation;
}();

exports.default = QuatRotation;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _EventDispatcher2 = __webpack_require__(35);

var _EventDispatcher3 = _interopRequireDefault(_EventDispatcher2);

var _Ray = __webpack_require__(20);

var _Ray2 = _interopRequireDefault(_Ray);

var _getMouse = __webpack_require__(69);

var _getMouse2 = _interopRequireDefault(_getMouse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // TouchDetector.js


function distance(a, b) {
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	return Math.sqrt(dx * dx + dy * dy);
}

var TouchDetector = function (_EventDispatcher) {
	_inherits(TouchDetector, _EventDispatcher);

	function TouchDetector(mGeometry, mCamera) {
		var mSkipMoveCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		var mListenerTarget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;

		_classCallCheck(this, TouchDetector);

		var _this = _possibleConstructorReturn(this, (TouchDetector.__proto__ || Object.getPrototypeOf(TouchDetector)).call(this));

		_this._geometry = mGeometry;
		_this._geometry.generateFaces();
		_this._camera = mCamera;
		_this.faceVertices = mGeometry.faces.map(function (face) {
			return face.vertices;
		});
		_this.clickTolerance = 8;

		_this._ray = new _Ray2.default([0, 0, 0], [0, 0, -1]);
		_this._hit = vec3.fromValues(-999, -999, -999);
		_this._lastPos;
		_this._firstPos;
		_this.mtxModel = mat4.create();

		_this._listenerTarget = mListenerTarget;
		_this._skippingMove = mSkipMoveCheck;

		_this._onMoveBind = function (e) {
			return _this._onMove(e);
		};
		_this._onDownBind = function (e) {
			return _this._onDown(e);
		};
		_this._onUpBind = function () {
			return _this._onUp();
		};

		_this.connect();
		return _this;
	}

	_createClass(TouchDetector, [{
		key: 'connect',
		value: function connect() {
			this._listenerTarget.addEventListener('mousedown', this._onDownBind);
			this._listenerTarget.addEventListener('mousemove', this._onMoveBind);
			this._listenerTarget.addEventListener('mouseup', this._onUpBind);
		}
	}, {
		key: 'disconnect',
		value: function disconnect() {
			this._listenerTarget.removeEventListener('mousedown', this._onDownBind);
			this._listenerTarget.removeEventListener('mousemove', this._onMoveBind);
			this._listenerTarget.removeEventListener('mouseup', this._onUpBind);
		}
	}, {
		key: '_checkHit',
		value: function _checkHit() {
			var _this2 = this;

			var mType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'onHit';

			var camera = this._camera;
			if (!camera) {
				return;
			}

			var mx = this._lastPos.x / _GLTool2.default.width * 2.0 - 1.0;
			var my = -(this._lastPos.y / _GLTool2.default.height) * 2.0 + 1.0;

			camera.generateRay([mx, my, 0], this._ray);

			var hit = void 0;
			var v0 = vec3.create();
			var v1 = vec3.create();
			var v2 = vec3.create();
			var dist = 0;

			var getVector = function getVector(v, target) {
				vec3.transformMat4(target, v, _this2.mtxModel);
			};

			for (var i = 0; i < this.faceVertices.length; i++) {
				var vertices = this.faceVertices[i];
				getVector(vertices[0], v0);
				getVector(vertices[1], v1);
				getVector(vertices[2], v2);
				var t = this._ray.intersectTriangle(v0, v1, v2);

				if (t) {
					if (hit) {
						var distToCam = vec3.dist(t, camera.position);
						if (distToCam < dist) {
							hit = vec3.clone(t);
							dist = distToCam;
						}
					} else {
						hit = vec3.clone(t);
						dist = vec3.dist(hit, camera.position);
					}
				}
			}

			if (hit) {
				this._hit = vec3.clone(hit);
				this.dispatchCustomEvent(mType, { hit: hit });
			} else {
				this.dispatchCustomEvent('onUp');
			}
		}
	}, {
		key: '_onDown',
		value: function _onDown(e) {
			this._firstPos = (0, _getMouse2.default)(e);
			this._lastPos = (0, _getMouse2.default)(e);
			this._checkHit('onDown');
		}
	}, {
		key: '_onMove',
		value: function _onMove(e) {
			this._lastPos = (0, _getMouse2.default)(e);
			if (!this._skippingMove) {
				this._checkHit();
			}
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			var dist = distance(this._firstPos, this._lastPos);
			if (dist < this.clickTolerance) {
				this._checkHit();
			}
		}
	}]);

	return TouchDetector;
}(_EventDispatcher3.default);

exports.default = TouchDetector;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (e) {
	var x = void 0,
	    y = void 0;

	if (e.touches) {
		x = e.touches[0].pageX;
		y = e.touches[0].pageY;
	} else {
		x = e.clientX;
		y = e.clientY;
	}

	return {
		x: x, y: y
	};
};

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = "#define SHADER_NAME gltf_vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\n\n#ifdef HAS_UV\nattribute vec2 aTextureCoord;\n#endif\n\n#ifdef HAS_NORMALS\nattribute vec3 aNormal;\n#endif\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform mat3 uModelViewMatrixInverse;\n\n\nvarying vec3 vPosition;\nvarying vec2 vTextureCoord;\n\n#ifdef HAS_NORMALS\nvarying vec3 vNormal;\n#endif\n\n\nvoid main(void) {\n\tvec4 position = uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvPosition     = position.xyz / position.w;\n\t\n\t#ifdef HAS_UV\n\tvTextureCoord = vec2(aTextureCoord.x, 1.0 - aTextureCoord.y);\n\t#else\n\tvTextureCoord = vec2(0.,0.);\n\t#endif\n\n\t#ifdef HAS_NORMALS\n\tvNormal       = normalize(vec3(uModelMatrix * vec4(aNormal, 0.0)));\n\t#endif\n\t\n\tgl_Position   = uProjectionMatrix * uViewMatrix * position;\n}\n"

/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = "#define SHADER_NAME gltf_frag\n\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D \tuBRDFMap;\nuniform samplerCube uRadianceMap;\nuniform samplerCube uIrradianceMap;\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D uColorMap;\n#endif\n\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D uMetallicRoughnessMap;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D uAoMap;\nuniform float uOcclusionStrength;\n#endif\n\n#ifdef HAS_NORMALMAP\nuniform sampler2D uNormalMap;\nuniform float uNormalScale;\n#endif\n\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D uEmissiveMap;\nuniform vec3 uEmissiveFactor;\n#endif\n\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\nuniform vec3 uCameraPos;\n\nuniform vec4 uScaleDiffBaseMR;\nuniform vec4 uScaleFGDSpec;\nuniform vec4 uScaleIBLAmbient;\n\nuniform vec3 uBaseColor;\nuniform float uRoughness;\nuniform float uMetallic;\nuniform float uGamma;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vPosition;\n\n#ifdef HAS_NORMALS\nvarying vec3 vNormal;\n#endif\n\n\n//\tFrom GLTF WebGL PBR :\n//\thttps://github.com/KhronosGroup/glTF-WebGL-PBR\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n\tfloat NdotL;                  // cos angle between normal and light direction\n\tfloat NdotV;                  // cos angle between normal and view direction\n\tfloat NdotH;                  // cos angle between normal and half vector\n\tfloat LdotH;                  // cos angle between light direction and half vector\n\tfloat VdotH;                  // cos angle between view direction and half vector\n\tfloat perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n\tfloat metalness;              // metallic value at the surface\n\tvec3 reflectance0;            // full reflectance color (normal incidence angle)\n\tvec3 reflectance90;           // reflectance color at grazing angle\n\tfloat alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n\tvec3 diffuseColor;            // color contribution from diffuse lighting\n\tvec3 specularColor;           // color contribution from specular lighting\n};\n\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n\t#ifdef MANUAL_SRGB\n\t#ifdef SRGB_FAST_APPROXIMATION\n\tvec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n\t#else //SRGB_FAST_APPROXIMATION\n\tvec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n\tvec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n\t#endif //SRGB_FAST_APPROXIMATION\n\treturn vec4(linOut,srgbIn.w);;\n\t#else //MANUAL_SRGB\n\treturn srgbIn;\n\t#endif //MANUAL_SRGB\n}\n\n\nvec3 getNormal() {\n\tvec3 pos_dx = dFdx(vPosition);\n\tvec3 pos_dy = dFdy(vPosition);\n\tvec3 tex_dx = dFdx(vec3(vTextureCoord, 0.0));\n\tvec3 tex_dy = dFdy(vec3(vTextureCoord, 0.0));\n\tvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n\t\n#ifdef HAS_NORMALS\n\tvec3 ng = normalize(vNormal);\n#else\n\tvec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n\tt = normalize(t - ng * dot(ng, t));\n\tvec3 b = normalize(cross(ng, t));\n\tmat3 tbn = mat3(t, b, ng);\n\n#ifdef HAS_NORMALMAP\n\tvec3 n = texture2D(uNormalMap, vTextureCoord).rgb;\n\tn = normalize(tbn * ((2.0 * n - 1.0) * vec3(uNormalScale, uNormalScale, 1.0)));\n#else\n\t// The tbn matrix is linearly interpolated, so we need to re-normalize\n\tvec3 n = normalize(tbn[2].xyz);\n#endif\n\n\treturn n;\n}\n\n\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n\tfloat mipCount = 7.0; // resolution of 512x512\n\tfloat lod = (pbrInputs.perceptualRoughness * mipCount);\n\t// retrieve a scale and bias to F0. See [1], Figure 3\n\tvec3 brdf = SRGBtoLINEAR(texture2D(uBRDFMap, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n\tvec3 diffuseLight = SRGBtoLINEAR(textureCube(uIrradianceMap, n)).rgb;\n\n\tvec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(uRadianceMap, reflection, lod)).rgb;\n\n\tvec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n\tvec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n\n\t// For presentation, this allows us to disable IBL terms\n\tdiffuse *= uScaleIBLAmbient.x;\n\tspecular *= uScaleIBLAmbient.y;\n\n\treturn diffuse + specular;\n}\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.diffuseColor / M_PI;\n}\n\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n\tfloat NdotL = pbrInputs.NdotL;\n\tfloat NdotV = pbrInputs.NdotV;\n\tfloat r = pbrInputs.alphaRoughness;\n\n\tfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n\tfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n\treturn attenuationL * attenuationV;\n}\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n\tfloat roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n\tfloat f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n\treturn roughnessSq / (M_PI * f * f);\n}\n\nvoid main() {\n\n\tfloat perceptualRoughness   = uRoughness;\n\tfloat metallic              = uMetallic;\n#ifdef HAS_METALROUGHNESSMAP\n\t// Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n\t// This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n\tvec4 mrSample = texture2D(uMetallicRoughnessMap, vTextureCoord);\n\tperceptualRoughness = mrSample.g * perceptualRoughness;\n\tmetallic = mrSample.b * metallic;\n#endif\t\n\tperceptualRoughness         = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n\tmetallic                    = clamp(metallic, 0.0, 1.0);\n\tfloat alphaRoughness        = perceptualRoughness * perceptualRoughness;\n\n#ifdef HAS_BASECOLORMAP\t\n\tvec4 baseColor = SRGBtoLINEAR(texture2D(uColorMap, vTextureCoord));\n#else\n\tvec4 baseColor              = vec4(uBaseColor, 1.0);\n#endif\t\n\t\n\tvec3 f0                     = vec3(0.04);\n\tvec3 diffuseColor           = baseColor.rgb * (vec3(1.0) - f0);\n\tdiffuseColor                *= 1.0 - metallic;\n\tvec3 specularColor          = mix(f0, baseColor.rgb, metallic);\n\t\n\t// Compute reflectance.\n\tfloat reflectance           = max(max(specularColor.r, specularColor.g), specularColor.b);\n\t\n\t// For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n\t// For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n\tfloat reflectance90         = clamp(reflectance * 25.0, 0.0, 1.0);\n\tvec3 specularEnvironmentR0  = specularColor.rgb;\n\tvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\t\n\tvec3 n                      = getNormal();                             // normal at surface point\n\tvec3 v                      = normalize(uCameraPos - vPosition);        // Vector from surface point to camera\n\tvec3 l                      = normalize(uLightDirection);             // Vector from surface point to light\n\tvec3 h                      = normalize(l+v);                          // Half vector between both l and v\n\tvec3 reflection             = -normalize(reflect(v, n));\n\t\n\tfloat NdotL                 = clamp(dot(n, l), 0.001, 1.0);\n\tfloat NdotV                 = abs(dot(n, v)) + 0.001;\n\tfloat NdotH                 = clamp(dot(n, h), 0.0, 1.0);\n\tfloat LdotH                 = clamp(dot(l, h), 0.0, 1.0);\n\tfloat VdotH                 = clamp(dot(v, h), 0.0, 1.0);\n\n\tPBRInfo pbrInputs = PBRInfo(\n\t\tNdotL,\n\t\tNdotV,\n\t\tNdotH,\n\t\tLdotH,\n\t\tVdotH,\n\t\tperceptualRoughness,\n\t\tmetallic,\n\t\tspecularEnvironmentR0,\n\t\tspecularEnvironmentR90,\n\t\talphaRoughness,\n\t\tdiffuseColor,\n\t\tspecularColor\n\t);\n\n\t// Calculate the shading terms for the microfacet specular shading model\n\tvec3 F              = specularReflection(pbrInputs);\n\tfloat G             = geometricOcclusion(pbrInputs);\n\tfloat D             = microfacetDistribution(pbrInputs);\n\t\n\t// Calculation of analytical lighting contribution\n\tvec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n\tvec3 specContrib    = F * G * D / (4.0 * NdotL * NdotV);\n\t// Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n\tvec3 color          = NdotL * uLightColor * (diffuseContrib + specContrib);\n\t\n#ifdef USE_IBL\n\tcolor += getIBLContribution(pbrInputs, n, reflection);\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\t\n\tfloat ao            = texture2D(uAoMap, vTextureCoord).r;\n\tcolor               = mix(color, color * ao, uOcclusionStrength);\n#endif\t\n\n#ifdef HAS_EMISSIVEMAP\n\tvec3 emissive = SRGBtoLINEAR(texture2D(uEmissiveMap, vTextureCoord)).rgb * uEmissiveFactor;\n\tcolor += emissive;\n#endif\n\t\n\t// This section uses mix to override final color for reference app visualization\n\t// of various parameters in the lighting equation.\n\tcolor               = mix(color, F, uScaleFGDSpec.x);\n\tcolor               = mix(color, vec3(G), uScaleFGDSpec.y);\n\tcolor               = mix(color, vec3(D), uScaleFGDSpec.z);\n\tcolor               = mix(color, specContrib, uScaleFGDSpec.w);\n\t\n\tcolor               = mix(color, diffuseContrib, uScaleDiffBaseMR.x);\n\tcolor               = mix(color, baseColor.rgb, uScaleDiffBaseMR.y);\n\tcolor               = mix(color, vec3(metallic), uScaleDiffBaseMR.z);\n\tcolor               = mix(color, vec3(perceptualRoughness), uScaleDiffBaseMR.w);\n\t\n\t// output the fragment color\n\tgl_FragColor        = vec4(pow(color,vec3(1.0/uGamma)), baseColor.a);\n\t// gl_FragColor        = vec4(vec3(metallic), 1.0);\n\n}"

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = "// debug.frag\n\n#define SHADER_NAME debug_frag\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec3 uEmissiveFactor;\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D uColorMap;\n#endif\n\n#ifdef HAS_NORMALMAP\nuniform sampler2D uNormalMap;\nuniform float uNormalScale;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D uAoMap;\nuniform float uOcclusionStrength;\n#endif\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvec3 getNormal() {\n\tvec3 pos_dx = dFdx(vPosition);\n\tvec3 pos_dy = dFdy(vPosition);\n\tvec3 tex_dx = dFdx(vec3(vTextureCoord, 0.0));\n\tvec3 tex_dy = dFdy(vec3(vTextureCoord, 0.0));\n\tvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n\tvec3 ng = normalize(vNormal);\n\n\tt = normalize(t - ng * dot(ng, t));\n\tvec3 b = normalize(cross(ng, t));\n\tmat3 tbn = mat3(t, b, ng);\n\n#ifdef HAS_NORMALMAP\n\tvec3 n = texture2D(uNormalMap, vTextureCoord).rgb;\n\tn = normalize(tbn * ((2.0 * n - 1.0) * vec3(uNormalScale, uNormalScale, 1.0)));\n#else\n\t// The tbn matrix is linearly interpolated, so we need to re-normalize\n\tvec3 n = normalize(tbn[2].xyz);\n#endif\n\n\treturn n;\n}\n\n\nvoid main(void) {\n    // gl_FragColor = vec4(vNormal * .5 + .5, 1.0);\n\n    vec3 color = getNormal() * .5 + .5;\n\n#ifdef HAS_BASECOLORMAP\n\tcolor = texture2D(uColorMap, vTextureCoord).rgb;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\t\n\tfloat ao            = texture2D(uAoMap, vTextureCoord).r;\n\tcolor               = mix(color, color * ao, uOcclusionStrength);\n#endif\t\n\n    gl_FragColor = vec4(color, 1.0);\n}"

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// CameraCube.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CameraPerspective2 = __webpack_require__(25);

var _CameraPerspective3 = _interopRequireDefault(_CameraPerspective2);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CAMERA_SETTINGS = [[_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(1, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(-1, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 1, 0), _glMatrix.vec3.fromValues(0, 0, 1)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0), _glMatrix.vec3.fromValues(0, 0, -1)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 0, 1), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 0, -1), _glMatrix.vec3.fromValues(0, -1, 0)]];

var CameraCube = function (_CameraPerspective) {
	_inherits(CameraCube, _CameraPerspective);

	function CameraCube() {
		_classCallCheck(this, CameraCube);

		var _this = _possibleConstructorReturn(this, (CameraCube.__proto__ || Object.getPrototypeOf(CameraCube)).call(this));

		_this.setPerspective(Math.PI / 2, 1, 0.1, 1000);
		return _this;
	}

	_createClass(CameraCube, [{
		key: 'face',
		value: function face(mIndex) {
			var o = CAMERA_SETTINGS[mIndex];
			this.lookAt(o[0], o[1], o[2]);
		}
	}]);

	return CameraCube;
}(_CameraPerspective3.default);

exports.default = CameraCube;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ObjLoader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BinaryLoader2 = __webpack_require__(26);

var _BinaryLoader3 = _interopRequireDefault(_BinaryLoader2);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ObjLoader = function (_BinaryLoader) {
	_inherits(ObjLoader, _BinaryLoader);

	function ObjLoader() {
		_classCallCheck(this, ObjLoader);

		return _possibleConstructorReturn(this, (ObjLoader.__proto__ || Object.getPrototypeOf(ObjLoader)).apply(this, arguments));
	}

	_createClass(ObjLoader, [{
		key: 'load',
		value: function load(url, callback) {
			var drawType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

			this._drawType = drawType;
			_get(ObjLoader.prototype.__proto__ || Object.getPrototypeOf(ObjLoader.prototype), 'load', this).call(this, url, callback);
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			this.parseObj(this._req.response);
		}
	}, {
		key: 'parseObj',
		value: function parseObj(objStr) {
			var lines = objStr.split('\n');

			var positions = [];
			var coords = [];
			var finalNormals = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			var count = 0;
			var result = void 0;

			// v float float float
			var vertexPattern = /v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// vn float float float
			var normalPattern = /vn( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// vt float float
			var uvPattern = /vt( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// f vertex vertex vertex ...
			var facePattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/;

			// f vertex/uv vertex/uv vertex/uv ...
			var facePattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/;

			// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...
			var facePattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/;

			// f vertex//normal vertex//normal vertex//normal ... 
			var facePattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/;

			function parseVertexIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + vertices.length / 3) * 3;
			}

			function parseNormalIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + normals.length / 3) * 3;
			}

			function parseUVIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + uvs.length / 2) * 2;
			}

			function addVertex(a, b, c) {
				positions.push([vertices[a], vertices[a + 1], vertices[a + 2]]);
				positions.push([vertices[b], vertices[b + 1], vertices[b + 2]]);
				positions.push([vertices[c], vertices[c + 1], vertices[c + 2]]);

				indices.push(count * 3 + 0);
				indices.push(count * 3 + 1);
				indices.push(count * 3 + 2);

				count++;
			}

			function addUV(a, b, c) {
				coords.push([uvs[a], uvs[a + 1]]);
				coords.push([uvs[b], uvs[b + 1]]);
				coords.push([uvs[c], uvs[c + 1]]);
			}

			function addNormal(a, b, c) {
				finalNormals.push([normals[a], normals[a + 1], normals[a + 2]]);
				finalNormals.push([normals[b], normals[b + 1], normals[b + 2]]);
				finalNormals.push([normals[c], normals[c + 1], normals[c + 2]]);
			}

			function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
				var ia = parseVertexIndex(a);
				var ib = parseVertexIndex(b);
				var ic = parseVertexIndex(c);
				var id = void 0;

				if (d === undefined) {

					addVertex(ia, ib, ic);
				} else {

					id = parseVertexIndex(d);

					addVertex(ia, ib, id);
					addVertex(ib, ic, id);
				}

				if (ua !== undefined) {

					ia = parseUVIndex(ua);
					ib = parseUVIndex(ub);
					ic = parseUVIndex(uc);

					if (d === undefined) {

						addUV(ia, ib, ic);
					} else {

						id = parseUVIndex(ud);

						addUV(ia, ib, id);
						addUV(ib, ic, id);
					}
				}

				if (na !== undefined) {

					ia = parseNormalIndex(na);
					ib = parseNormalIndex(nb);
					ic = parseNormalIndex(nc);

					if (d === undefined) {

						addNormal(ia, ib, ic);
					} else {

						id = parseNormalIndex(nd);

						addNormal(ia, ib, id);
						addNormal(ib, ic, id);
					}
				}
			}

			for (var i = 0; i < lines.length; i++) {
				var line = lines[i];
				line = line.trim();

				if (line.length === 0 || line.charAt(0) === '#') {

					continue;
				} else if ((result = vertexPattern.exec(line)) !== null) {

					vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
				} else if ((result = normalPattern.exec(line)) !== null) {

					normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
				} else if ((result = uvPattern.exec(line)) !== null) {

					uvs.push(parseFloat(result[1]), parseFloat(result[2]));
				} else if ((result = facePattern1.exec(line)) !== null) {

					addFace(result[1], result[2], result[3], result[4]);
				} else if ((result = facePattern2.exec(line)) !== null) {

					addFace(result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
				} else if ((result = facePattern3.exec(line)) !== null) {
					addFace(result[2], result[6], result[10], result[14], result[3], result[7], result[11], result[15], result[4], result[8], result[12], result[16]);
				} else if ((result = facePattern4.exec(line)) !== null) {
					addFace(result[2], result[5], result[8], result[11], undefined, undefined, undefined, undefined, result[3], result[6], result[9], result[12]);
				}
			}

			return this._generateGeometry({
				positions: positions,
				coords: coords,
				normals: finalNormals,
				indices: indices
			});
		}
	}, {
		key: '_generateGeometry',
		value: function _generateGeometry(o) {
			var maxNumVertices = 65535;
			var hasNormals = o.normals.length > 0;
			var hasUVs = o.coords.length > 0;
			var geometry = void 0;

			if (o.positions.length > maxNumVertices) {
				var geometries = [];
				var lastIndex = 0;

				var oCopy = {};
				oCopy.positions = o.positions.concat();
				oCopy.coords = o.coords.concat();
				oCopy.indices = o.indices.concat();
				oCopy.normals = o.normals.concat();

				while (o.indices.length > 0) {

					var sliceNum = Math.min(maxNumVertices, o.positions.length);
					var indices = o.indices.splice(0, sliceNum);
					var positions = [];
					var coords = [];
					var normals = [];
					var index = void 0,
					    tmpIndex = 0;

					for (var i = 0; i < indices.length; i++) {
						if (indices[i] > tmpIndex) {
							tmpIndex = indices[i];
						}

						index = indices[i];

						positions.push(oCopy.positions[index]);
						if (hasUVs) {
							coords.push(oCopy.coords[index]);
						}
						if (hasNormals) {
							normals.push(oCopy.normals[index]);
						}

						indices[i] -= lastIndex;
					}

					lastIndex = tmpIndex + 1;

					geometry = new _Geometry2.default(this._drawType);
					geometry.bufferVertex(positions);
					if (hasUVs) {
						geometry.bufferTexCoord(coords);
					}

					geometry.bufferIndex(indices);
					if (hasNormals) {
						geometry.bufferNormal(normals);
					}

					geometries.push(geometry);
				}

				if (this._callback) {
					this._callback(geometries, oCopy);
				}

				return geometries;
			} else {
				geometry = new _Geometry2.default(this._drawType);
				geometry.bufferVertex(o.positions);
				if (hasUVs) {
					geometry.bufferTexCoord(o.coords);
				}
				geometry.bufferIndex(o.indices);
				if (hasNormals) {
					geometry.bufferNormal(o.normals);
				}

				if (this._callback) {
					this._callback(geometry, o);
				}

				return geometry;
			}

			return null;
		}
	}]);

	return ObjLoader;
}(_BinaryLoader3.default);

ObjLoader.parse = function (objStr) {
	var loader = new ObjLoader();
	return loader.parseObj(objStr);
};

exports.default = ObjLoader;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HDRLoader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BinaryLoader2 = __webpack_require__(26);

var _BinaryLoader3 = _interopRequireDefault(_BinaryLoader2);

var _HDRParser = __webpack_require__(76);

var _HDRParser2 = _interopRequireDefault(_HDRParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HDRLoader = function (_BinaryLoader) {
	_inherits(HDRLoader, _BinaryLoader);

	function HDRLoader() {
		_classCallCheck(this, HDRLoader);

		return _possibleConstructorReturn(this, (HDRLoader.__proto__ || Object.getPrototypeOf(HDRLoader)).call(this, true));
	}

	_createClass(HDRLoader, [{
		key: 'parse',
		value: function parse(mArrayBuffer) {
			return (0, _HDRParser2.default)(mArrayBuffer);
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			var o = this.parse(this._req.response);
			if (this._callback) {
				this._callback(o);
			}
		}
	}]);

	return HDRLoader;
}(_BinaryLoader3.default);

HDRLoader.parse = function (mArrayBuffer) {
	return (0, _HDRParser2.default)(mArrayBuffer);
};

exports.default = HDRLoader;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HDRParser.js



// Code ported by Marcin Ignac (2014)
// Based on Java implementation from
// https://code.google.com/r/cys12345-research/source/browse/hdr/image_processor/RGBE.java?r=7d84e9fd866b24079dbe61fa0a966ce8365f5726

Object.defineProperty(exports, "__esModule", {
	value: true
});
var radiancePattern = '#\\?RADIANCE';
var commentPattern = '#.*';
// let gammaPattern = 'GAMMA=';
var exposurePattern = 'EXPOSURE=\\s*([0-9]*[.][0-9]*)';
var formatPattern = 'FORMAT=32-bit_rle_rgbe';
var widthHeightPattern = '-Y ([0-9]+) \\+X ([0-9]+)';

// http://croquetweak.blogspot.co.uk/2014/08/deconstructing-floats-frexp-and-ldexp.html
// function ldexp(mantissa, exponent) {
//     return exponent > 1023 ? mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023) : exponent < -1074 ? mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074) : mantissa * Math.pow(2, exponent);
// }

function readPixelsRawRLE(buffer, data, offset, fileOffset, scanlineWidth, numScanlines) {
	var rgbe = new Array(4);
	var scanlineBuffer = null;
	var ptr = void 0;
	var ptrEnd = void 0;
	var count = void 0;
	var buf = new Array(2);
	var bufferLength = buffer.length;

	function readBuf(buf) {
		var bytesRead = 0;
		do {
			buf[bytesRead++] = buffer[fileOffset];
		} while (++fileOffset < bufferLength && bytesRead < buf.length);
		return bytesRead;
	}

	function readBufOffset(buf, offset, length) {
		var bytesRead = 0;
		do {
			buf[offset + bytesRead++] = buffer[fileOffset];
		} while (++fileOffset < bufferLength && bytesRead < length);
		return bytesRead;
	}

	function readPixelsRaw(buffer, data, offset, numpixels) {
		var numExpected = 4 * numpixels;
		var numRead = readBufOffset(data, offset, numExpected);
		if (numRead < numExpected) {
			throw new Error('Error reading raw pixels: got ' + numRead + ' bytes, expected ' + numExpected);
		}
	}

	while (numScanlines > 0) {
		if (readBuf(rgbe) < rgbe.length) {
			throw new Error('Error reading bytes: expected ' + rgbe.length);
		}

		if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
			// this file is not run length encoded
			data[offset++] = rgbe[0];
			data[offset++] = rgbe[1];
			data[offset++] = rgbe[2];
			data[offset++] = rgbe[3];
			readPixelsRaw(buffer, data, offset, scanlineWidth * numScanlines - 1);
			return;
		}

		if (((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) !== scanlineWidth) {
			throw new Error('Wrong scanline width ' + ((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) + ', expected ' + scanlineWidth);
		}

		if (scanlineBuffer === null) {
			scanlineBuffer = new Array(4 * scanlineWidth);
		}

		ptr = 0;
		/* read each of the four channels for the scanline into the buffer */
		for (var i = 0; i < 4; i++) {
			ptrEnd = (i + 1) * scanlineWidth;
			while (ptr < ptrEnd) {
				if (readBuf(buf) < buf.length) {
					throw new Error('Error reading 2-byte buffer');
				}
				if ((buf[0] & 0xFF) > 128) {
					/* a run of the same value */
					count = (buf[0] & 0xFF) - 128;
					if (count === 0 || count > ptrEnd - ptr) {
						throw new Error('Bad scanline data');
					}
					while (count-- > 0) {
						scanlineBuffer[ptr++] = buf[1];
					}
				} else {
					/* a non-run */
					count = buf[0] & 0xFF;
					if (count === 0 || count > ptrEnd - ptr) {
						throw new Error('Bad scanline data');
					}
					scanlineBuffer[ptr++] = buf[1];
					if (--count > 0) {
						if (readBufOffset(scanlineBuffer, ptr, count) < count) {
							throw new Error('Error reading non-run data');
						}
						ptr += count;
					}
				}
			}
		}

		/* copy byte data to output */
		for (var _i = 0; _i < scanlineWidth; _i++) {
			data[offset + 0] = scanlineBuffer[_i];
			data[offset + 1] = scanlineBuffer[_i + scanlineWidth];
			data[offset + 2] = scanlineBuffer[_i + 2 * scanlineWidth];
			data[offset + 3] = scanlineBuffer[_i + 3 * scanlineWidth];
			offset += 4;
		}

		numScanlines--;
	}
}

// Returns data as floats and flipped along Y by default
function parseHdr(buffer) {
	if (buffer instanceof ArrayBuffer) {
		buffer = new Uint8Array(buffer);
	}

	var fileOffset = 0;
	var bufferLength = buffer.length;

	var NEW_LINE = 10;

	function readLine() {
		var buf = '';
		do {
			var b = buffer[fileOffset];
			if (b === NEW_LINE) {
				++fileOffset;
				break;
			}
			buf += String.fromCharCode(b);
		} while (++fileOffset < bufferLength);
		return buf;
	}

	var width = 0;
	var height = 0;
	var exposure = 1;
	var gamma = 1;
	var rle = false;

	for (var i = 0; i < 20; i++) {
		var line = readLine();
		var match = void 0;
		if (match = line.match(radiancePattern)) {} else if (match = line.match(formatPattern)) {
			rle = true;
		} else if (match = line.match(exposurePattern)) {
			exposure = Number(match[1]);
		} else if (match = line.match(commentPattern)) {} else if (match = line.match(widthHeightPattern)) {
			height = Number(match[1]);
			width = Number(match[2]);
			break;
		}
	}

	if (!rle) {
		throw new Error('File is not run length encoded!');
	}

	var data = new Uint8Array(width * height * 4);
	var scanlineWidth = width;
	var numScanlines = height;

	readPixelsRawRLE(buffer, data, 0, fileOffset, scanlineWidth, numScanlines);

	// TODO: Should be Float16
	var floatData = new Float32Array(width * height * 4);
	for (var offset = 0; offset < data.length; offset += 4) {
		var r = data[offset + 0] / 255;
		var g = data[offset + 1] / 255;
		var b = data[offset + 2] / 255;
		var e = data[offset + 3];
		var f = Math.pow(2.0, e - 128.0);

		r *= f;
		g *= f;
		b *= f;

		var floatOffset = offset;

		floatData[floatOffset + 0] = r;
		floatData[floatOffset + 1] = g;
		floatData[floatOffset + 2] = b;
		floatData[floatOffset + 3] = 1.0;
	}

	return {
		shape: [width, height],
		exposure: exposure,
		gamma: gamma,
		data: floatData
	};
}

exports.default = parseHdr;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _colladaParser = __webpack_require__(78);

var _colladaParser2 = _interopRequireDefault(_colladaParser);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ColladaParser.js

var generateGeometry = function generateGeometry(meshes) {
	var caches = {};

	meshes.forEach(function (mesh) {
		var _mesh$mesh = mesh.mesh,
		    vertices = _mesh$mesh.vertices,
		    normals = _mesh$mesh.normals,
		    coords = _mesh$mesh.coords,
		    triangles = _mesh$mesh.triangles,
		    name = _mesh$mesh.name;

		if (!caches[name]) {
			var glGeometry = new _Geometry2.default().bufferFlattenData(vertices, 'aVertexPosition', 3).bufferFlattenData(coords, 'aTextureCoord', 2).bufferFlattenData(normals, 'aNormal', 3).bufferIndex(triangles);

			caches[name] = glGeometry;
		}

		mesh.glGeometry = caches[name];
	});
};

var parse = function parse(mData) {
	var meshes = _colladaParser2.default.parse(mData);
	generateGeometry(meshes);

	return meshes;
};

var load = function load(mPath, mCallback) {
	_colladaParser2.default.load(mPath, function (meshes) {
		generateGeometry(meshes);
		mCallback(meshes);
	});
};

var ColladaParser = {
	parse: parse,
	load: load
};

exports.default = ColladaParser;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Collada = __webpack_require__(79);

var _Collada2 = _interopRequireDefault(_Collada);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ColladaParser.js

var parseData = function parseData(mData) {
	var materials = mData.materials,
	    meshes = mData.meshes;


	var finalMeshes = [];
	var meshObjs = [];
	var allMeshes = [];

	//	getting all meshes' buffers
	for (var s in meshes) {
		var oMesh = meshes[s];
		var vertices = oMesh.vertices,
		    normals = oMesh.normals,
		    coords = oMesh.coords,
		    triangles = oMesh.triangles;

		var buffers = {
			vertices: vertices, normals: normals, coords: coords, triangles: triangles
		};
		allMeshes.push({
			id: s,
			buffers: buffers
		});
	}

	function getMaterial(id) {
		var mat = void 0;
		for (var _s in materials) {
			if (_s === id) {
				mat = materials[_s];
			}
		}

		var oMaterial = {};
		if (mat.diffuse) {
			oMaterial.diffuseColor = mat.diffuse;
		}

		oMaterial.diffuseColor = mat.diffuse || [0, 0, 0];
		oMaterial.shininess = mat.shininess || 0;
		if (mat.textures) {
			if (mat.textures.diffuse) {
				oMaterial.diffuseMapID = mat.textures.diffuse.map_id;
			}

			if (mat.textures.normal) {
				oMaterial.normalMapID = mat.textures.normal.map_id;
			}
		}

		return oMaterial;
	}

	function walk(node, mtxParent) {
		var m = _glMatrix.mat4.create();
		if (node.model) {
			_glMatrix.mat4.multiply(m, mtxParent, node.model);
		} else {
			_glMatrix.mat4.copy(m, mtxParent);
		}

		if (node.children.length > 0) {
			node.children.forEach(function (child) {
				walk(child, m);
			});
		}

		if (node.mesh) {
			var _oMesh = {};
			_oMesh.modelMatrix = m;
			_oMesh.mesh = meshes[node.mesh];
			_oMesh.id = node.id;
			_oMesh.name = node.name;
			_oMesh.material = getMaterial(node.material);
			meshObjs.push(_oMesh);
		}
	}

	var mtx = _glMatrix.mat4.create();
	walk(mData.root, mtx);

	return meshObjs;
};

var parse = function parse(mFile) {
	var o = _Collada2.default.parse(mFile);
	return parseData(o);
};

var load = function load(mPath, mCallBack) {
	_Collada2.default.load(mPath, function (mData) {
		mCallBack(parseData(mData));
	});
};

var ColladaParser = {
	load: load,
	parse: parse
};

exports.default = ColladaParser;
module.exports = exports['default'];
//# sourceMappingURL=ColladaParser.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _glMatrix = __webpack_require__(2);

var isWorker = global.document === undefined; // Collada.js

var DEG2RAD = Math.PI * 2 / 360;

//global temporal variables
var temp_mat4 = null;
var temp_vec2 = null;
var temp_vec3 = null;
var temp_vec4 = null;
var temp_quat = null;

function request(url, callback) {
	var req = new XMLHttpRequest();
	req.onload = function () {
		var response = this.response;
		if (this.status != 200) return;
		if (callback) callback(this.response);
	};
	req.open("get", url, true);
	req.send();
}

var Collada = {

	libsPath: "./",
	workerPath: "./",
	no_flip: true,
	use_transferables: true, //for workers
	onerror: null,
	verbose: false,
	config: { forceParser: false },

	init: function init(config) {
		config = config || {};
		for (var i in config) {
			this[i] = config[i];
		}this.config = config;

		if (isWorker) {
			try {
				importScripts(this.libsPath + "gl-matrix-min.js", this.libsPath + "tinyxml.js");
			} catch (err) {
				Collada.throwException(Collada.LIBMISSING_ERROR);
			}
		}

		//init glMatrix
		temp_mat4 = _glMatrix.mat4.create();
		temp_vec2 = vec3.create();
		temp_vec3 = vec3.create();
		temp_vec4 = vec3.create();
		temp_quat = _glMatrix.quat.create();

		if (isWorker) console.log("Collada worker ready");
	},

	load: function load(url, callback) {
		request(url, function (data) {
			if (!data) callback(null);else callback(Collada.parse(data));
		});
	},

	_xmlroot: null,
	_nodes_by_id: null,
	_transferables: null,
	_controllers_found: null,
	_geometries_found: null,

	safeString: function safeString(str) {
		if (!str) return "";

		if (this.convertID) return this.convertID(str);

		return str.replace(/ /g, "_");
	},

	LIBMISSING_ERROR: "Libraries loading error, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath",
	NOXMLPARSER_ERROR: "TinyXML not found, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath (Workers do not allow to access the native XML DOMParser)",
	throwException: function throwException(msg) {
		if (isWorker) self.postMessage({ action: "exception", msg: msg });else if (Collada.onerror) Collada.onerror(msg);
		throw msg;
	},

	getFilename: function getFilename(filename) {
		var pos = filename.lastIndexOf("\\");
		if (pos != -1) filename = filename.substr(pos + 1);
		//strip unix slashes
		pos = filename.lastIndexOf("/");
		if (pos != -1) filename = filename.substr(pos + 1);
		return filename;
	},

	last_name: 0,

	generateName: function generateName(v) {
		v = v || "name_";
		var name = v + this.last_name;
		this.last_name++;
		return name;
	},

	parse: function parse(data, options, filename) {
		options = options || {};
		filename = filename || "_dae_" + Date.now() + ".dae";

		//console.log("Parsing collada");
		var flip = false;

		var xmlparser = null;
		var root = null;
		this._transferables = [];

		if (this.verbose) console.log(" - XML parsing...");

		if (global["DOMParser"] && !this.config.forceParser) {
			xmlparser = new DOMParser();
			root = xmlparser.parseFromString(data, "text/xml");
			if (this.verbose) console.log(" - XML parsed");
		} else //USING JS XML PARSER IMPLEMENTATION (much slower)
			{
				if (!global["DOMImplementation"]) return Collada.throwException(Collada.NOXMLPARSER_ERROR);
				//use tinyxmlparser
				try {
					xmlparser = new DOMImplementation();
				} catch (err) {
					return Collada.throwException(Collada.NOXMLPARSER_ERROR);
				}

				root = xmlparser.loadXML(data);
				if (this.verbose) console.log(" - XML parsed");

				//for every node...
				var by_ids = root._nodes_by_id = {};
				for (var i = 0, l = root.all.length; i < l; ++i) {
					var node = root.all[i];
					by_ids[node.id] = node;
					if (node.getAttribute("sid")) by_ids[node.getAttribute("sid")] = node;
				}

				if (!this.extra_functions) {
					this.extra_functions = true;
					//these methods are missing so here is a lousy implementation
					DOMDocument.prototype.querySelector = DOMElement.prototype.querySelector = function (selector) {
						var tags = selector.split(" ");
						var current_element = this;

						while (tags.length) {
							var current = tags.shift();
							var tokens = current.split("#");
							var tagname = tokens[0];
							var id = tokens[1];
							var elements = tagname ? current_element.getElementsByTagName(tagname) : current_element.childNodes;
							if (!id) //no id filter
								{
									if (tags.length == 0) return elements.item(0);
									current_element = elements.item(0);
									continue;
								}

							//has id? check for all to see if one matches the id
							for (var i = 0; i < elements.length; i++) {
								if (elements.item(i).getAttribute("id") == id) {
									if (tags.length == 0) return elements.item(i);
									current_element = elements.item(i);
									break;
								}
							}
						}
						return null;
					};

					DOMDocument.prototype.querySelectorAll = DOMElement.prototype.querySelectorAll = function (selector) {
						var tags = selector.split(" ");
						if (tags.length == 1) return this.getElementsByTagName(selector);

						var current_element = this;
						var result = [];

						inner(this, tags);

						function inner(root, tags) {
							if (!tags) return;

							var current = tags.shift();
							var elements = root.getElementsByTagName(current);
							if (tags.length == 0) {
								for (var i = 0; i < elements.length; i++) {
									result.push(elements.item(i));
								}return;
							}

							for (var i = 0; i < elements.length; i++) {
								inner(elements.item(i), tags.concat());
							}
						}

						var list = new DOMNodeList(this.documentElement);
						list._nodes = result;
						list.length = result.length;

						return list;
					};

					Object.defineProperty(DOMElement.prototype, "textContent", {
						get: function get() {
							var nodes = this.getChildNodes();
							return nodes.item(0).toString();
						},
						set: function set() {}
					});
				}
			}
		this._xmlroot = root;
		var xmlcollada = root.querySelector("COLLADA");
		if (xmlcollada) {
			this._current_DAE_version = xmlcollada.getAttribute("version");
			console.log("DAE Version:" + this._current_DAE_version);
		}

		//var xmlvisual_scene = root.querySelector("visual_scene");
		var xmlvisual_scene = root.getElementsByTagName("visual_scene").item(0);
		if (!xmlvisual_scene) throw "visual_scene XML node not found in DAE";

		//hack to avoid problems with bones with spaces in names
		this._nodes_by_id = {}; //clear
		this._controllers_found = {}; //we need to check what controllers had been found, in case we miss one at the end
		this._geometries_found = {};

		//Create a scene tree
		var scene = {
			object_type: "SceneTree",
			light: null,
			materials: {},
			meshes: {},
			resources: {}, //used to store animation tracks
			root: { children: [] },
			external_files: {} //store info about external files mentioned in this 
		};

		//scene metadata (like author, tool, up vector, dates, etc)
		var xmlasset = root.getElementsByTagName("asset")[0];
		if (xmlasset) scene.metadata = this.readAsset(xmlasset);

		//parse nodes tree to extract names and ierarchy only
		var xmlnodes = xmlvisual_scene.childNodes;
		for (var i = 0; i < xmlnodes.length; i++) {
			if (xmlnodes.item(i).localName != "node") continue;

			var node = this.readNodeTree(xmlnodes.item(i), scene, 0, flip);
			if (node) scene.root.children.push(node);
		}

		//parse nodes content (two steps so we have first all the scene tree info)
		for (var i = 0; i < xmlnodes.length; i++) {
			if (xmlnodes.item(i).localName != "node") continue;
			this.readNodeInfo(xmlnodes.item(i), scene, 0, flip);
		}

		//read remaining controllers (in some cases some controllers are not linked from the nodes or the geometries)
		this.readLibraryControllers(scene);

		//read animations
		var animations = this.readAnimations(root, scene);
		if (animations) {
			var animations_name = "#animations_" + filename.substr(0, filename.indexOf("."));
			scene.resources[animations_name] = animations;
			scene.root.animations = animations_name;
		}

		//read external files (images)
		scene.images = this.readImages(root);

		//clear memory
		this._nodes_by_id = {};
		this._controllers_found = {};
		this._geometries_found = {};
		this._xmlroot = null;

		//console.log(scene);
		return scene;
	},

	/* Collect node ids, in case there is bones (with spaces in name) I need to know the nodenames in advance */
	/*
 readAllNodeNames: function(xmlnode)
 {
 	var node_id = this.safeString( xmlnode.getAttribute("id") );
 	if(node_id)
 		this._nodes_by_id[node_id] = true; //node found
 	//nodes seem to have to possible ids, id and sid, I guess one is unique, the other user-defined
 	var node_sid = this.safeString( xmlnode.getAttribute("sid") );
 	if(node_sid)
 		this._nodes_by_id[node_sid] = true; //node found
 
 	for( var i = 0; i < xmlnode.childNodes.length; i++ )
 	{
 		var xmlchild = xmlnode.childNodes.item(i);
 			//children
 		if(xmlchild.localName != "node")
 			continue;
 		this.readAllNodeNames(xmlchild);
 	}
 },
 	*/

	readAsset: function readAsset(xmlasset) {
		var metadata = {};

		for (var i = 0; i < xmlasset.childNodes.length; i++) {
			var xmlchild = xmlasset.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;
			switch (xmlchild.localName) {
				case "contributor":
					var tool = xmlchild.querySelector("authoring_tool");
					if (tool) metadata["authoring_tool"] = tool.textContext;
					break;
				case "unit":
					metadata["unit"] = xmlchild.getAttribute("name");break;
				default:
					metadata[xmlchild.localName] = xmlchild.textContent;break;
			}
		}

		return metadata;
	},

	readNodeTree: function readNodeTree(xmlnode, scene, level, flip) {
		var node_id = this.safeString(xmlnode.getAttribute("id"));
		var node_sid = this.safeString(xmlnode.getAttribute("sid"));

		if (!node_id && !node_sid) return null;

		//here we create the node
		var node = {
			id: node_sid || node_id,
			children: [],
			_depth: level
		};

		var node_type = xmlnode.getAttribute("type");
		if (node_type) node.type = node_type;

		var node_name = xmlnode.getAttribute("name");
		if (node_name) node.name = node_name;
		this._nodes_by_id[node.id] = node;
		if (node_id) this._nodes_by_id[node_id] = node;
		if (node_sid) this._nodes_by_id[node_sid] = node;

		//transform
		node.model = this.readTransform(xmlnode, level, flip);

		//node elements
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xmlchild = xmlnode.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;

			//children
			if (xmlchild.localName == "node") {
				var child_node = this.readNodeTree(xmlchild, scene, level + 1, flip);
				if (child_node) node.children.push(child_node);
				continue;
			}
		}

		return node;
	},

	readNodeInfo: function readNodeInfo(xmlnode, scene, level, flip, parent) {
		var node_id = this.safeString(xmlnode.getAttribute("id"));
		var node_sid = this.safeString(xmlnode.getAttribute("sid"));

		/*
  if(!node_id && !node_sid)
  {
  	console.warn("Collada: node without id, creating a random one");
  	node_id = this.generateName("node_");
  	return null;
  }
  */

		var node;
		if (!node_id && !node_sid) {
			//if there is no id, then either all of this node's properties 
			//should be assigned directly to its parent node, or the node doesn't
			//have a parent node, in which case its a light or something. 
			//So we get the parent by its id, and if there is no parent, we return null
			if (parent) node = this._nodes_by_id[parent.id || parent.sid];else return null;
		} else node = this._nodes_by_id[node_id || node_sid];

		if (!node) {
			console.warn("Collada: Node not found by id: " + (node_id || node_sid));
			return null;
		}

		//node elements
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xmlchild = xmlnode.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;

			//children
			if (xmlchild.localName == "node") {
				//pass parent node in case child node is a 'dead' node (has no id or sid)
				this.readNodeInfo(xmlchild, scene, level + 1, flip, xmlnode);
				continue;
			}

			//geometry
			if (xmlchild.localName == "instance_geometry") {
				var url = xmlchild.getAttribute("url");
				var mesh_id = url.toString().substr(1);
				node.mesh = mesh_id;

				if (!scene.meshes[url]) {
					var mesh_data = this.readGeometry(url, flip);
					if (mesh_data) {
						mesh_data.name = mesh_id;
						scene.meshes[mesh_id] = mesh_data;
					}
				}

				//binded material
				var xmlmaterials = xmlchild.querySelectorAll("instance_material");
				if (xmlmaterials) {
					for (var iMat = 0; iMat < xmlmaterials.length; ++iMat) {
						var xmlmaterial = xmlmaterials.item(iMat);
						if (!xmlmaterial) {
							console.warn("instance_material not found: " + i);
							continue;
						}

						var matname = xmlmaterial.getAttribute("target").toString().substr(1);
						//matname = matname.replace(/ /g,"_"); //names cannot have spaces
						if (!scene.materials[matname]) {

							var material = this.readMaterial(matname);
							if (material) {
								material.id = matname;
								scene.materials[material.id] = material;
							}
						}
						if (iMat == 0) node.material = matname;else {
							if (!node.materials) node.materials = [];
							node.materials.push(matname);
						}
					}
				}
			}

			//this node has a controller: skinning, morph targets or even multimaterial are controllers
			//warning: I detected that some nodes could have a controller but they are not referenced here.  ??
			if (xmlchild.localName == "instance_controller") {
				var url = xmlchild.getAttribute("url");
				var xmlcontroller = this._xmlroot.querySelector("controller" + url);

				if (xmlcontroller) {

					var mesh_data = this.readController(xmlcontroller, flip, scene);

					//binded materials
					var xmlbind_material = xmlchild.querySelector("bind_material");
					if (xmlbind_material) {
						//removed readBindMaterials up here for consistency
						var xmltechniques = xmlbind_material.querySelectorAll("technique_common");
						for (var iTec = 0; iTec < xmltechniques.length; iTec++) {
							var xmltechnique = xmltechniques.item(iTec);
							var xmlinstance_materials = xmltechnique.querySelectorAll("instance_material");
							for (var iMat = 0; iMat < xmlinstance_materials.length; iMat++) {
								var xmlinstance_material = xmlinstance_materials.item(iMat);
								if (!xmlinstance_material) {
									console.warn("instance_material for controller not found: " + xmlinstance_material);
									continue;
								}
								var matname = xmlinstance_material.getAttribute("target").toString().substr(1);
								if (!scene.materials[matname]) {

									var material = this.readMaterial(matname);
									if (material) {
										material.id = matname;
										scene.materials[material.id] = material;
									}
								}
								if (iMat == 0) node.material = matname;else {
									if (!node.materials) node.materials = [];
									node.materials.push(matname);
								}
							}
						}
					}

					if (mesh_data) {
						var mesh = mesh_data;
						if (mesh_data.type == "morph") {
							mesh = mesh_data.mesh;
							node.morph_targets = mesh_data.morph_targets;
						}

						mesh.name = url.toString();
						node.mesh = url.toString();
						scene.meshes[url] = mesh;
					}
				}
			}

			//light
			if (xmlchild.localName == "instance_light") {
				var url = xmlchild.getAttribute("url");
				this.readLight(node, url);
			}

			//camera
			if (xmlchild.localName == "instance_camera") {
				var url = xmlchild.getAttribute("url");
				this.readCamera(node, url);
			}

			//other possible tags?
		}
	},

	//if you want to rename some material names
	material_translate_table: {
		/*
  transparency: "opacity",
  reflectivity: "reflection_factor",
  specular: "specular_factor",
  shininess: "specular_gloss",
  emission: "emissive",
  diffuse: "color"
  */
	},

	light_translate_table: {

		point: "omni",
		directional: "directional",
		spot: "spot"
	},

	camera_translate_table: {
		xfov: "fov",
		aspect_ratio: "aspect",
		znear: "near",
		zfar: "far"
	},

	//used when id have spaces (regular selector do not support spaces)
	querySelectorAndId: function querySelectorAndId(root, selector, id) {
		var nodes = root.querySelectorAll(selector);
		for (var i = 0; i < nodes.length; i++) {
			var attr_id = nodes.item(i).getAttribute("id");
			if (!attr_id) continue;
			attr_id = attr_id.toString();
			if (attr_id == id) return nodes.item(i);
		}
		return null;
	},

	//returns the first element that matches a tag name, if not tagname is specified then the first tag element
	getFirstChildElement: function getFirstChildElement(root, localName) {
		var c = root.childNodes;
		for (var i = 0; i < c.length; ++i) {
			var item = c.item(i);
			if (item.localName && !localName || localName && localName == item.localName) return item;
		}
		return null;
	},

	readMaterial: function readMaterial(url) {
		var xmlmaterial = this.querySelectorAndId(this._xmlroot, "library_materials material", url);

		if (!xmlmaterial) return null;

		//get effect name
		var xmleffect = xmlmaterial.querySelector("instance_effect");
		if (!xmleffect) return null;

		var effect_url = xmleffect.getAttribute("url").substr(1);

		//get effect
		var xmleffects = this.querySelectorAndId(this._xmlroot, "library_effects effect", effect_url);

		if (!xmleffects) return null;

		//get common
		var xmltechnique = xmleffects.querySelector("technique");
		if (!xmltechnique) return null;

		//get newparams and convert to js object
		var xmlnewparams = xmleffects.querySelectorAll("newparam");
		var newparams = {};
		for (var i = 0; i < xmlnewparams.length; i++) {

			var init_from = xmlnewparams[i].querySelector("init_from");
			var parent;
			if (init_from) parent = init_from.innerHTML;else {
				var source = xmlnewparams[i].querySelector("source");
				parent = source.innerHTML;
			}

			newparams[xmlnewparams[i].getAttribute("sid")] = {
				parent: parent
			};
		}

		var material = {};

		//read the images here because we need to access them to assign texture names
		var images = this.readImages(this._xmlroot);

		var xmlphong = xmltechnique.querySelector("phong");
		if (!xmlphong) xmlphong = xmltechnique.querySelector("blinn");
		if (!xmlphong) xmlphong = xmltechnique.querySelector("lambert");
		if (!xmlphong) return null;

		//for every tag of properties
		for (var i = 0; i < xmlphong.childNodes.length; ++i) {
			var xmlparam = xmlphong.childNodes.item(i);

			if (!xmlparam.localName) //text tag
				continue;

			//translate name
			var param_name = xmlparam.localName.toString();
			if (this.material_translate_table[param_name]) param_name = this.material_translate_table[param_name];

			//value
			var xmlparam_value = this.getFirstChildElement(xmlparam);
			if (!xmlparam_value) continue;

			if (xmlparam_value.localName.toString() == "color") {
				var value = this.readContentAsFloats(xmlparam_value);
				if (xmlparam.getAttribute("opaque") == "RGB_ZERO") material[param_name] = value.subarray(0, 4);else material[param_name] = value.subarray(0, 3);
				continue;
			} else if (xmlparam_value.localName.toString() == "float") {
				material[param_name] = this.readContentAsFloats(xmlparam_value)[0];
				continue;
			} else if (xmlparam_value.localName.toString() == "texture") {
				if (!material.textures) material.textures = {};
				var map_id = xmlparam_value.getAttribute("texture");
				if (!map_id) continue;

				// if map_id is not a filename, lets go and look for it.
				if (map_id.indexOf('.') === -1) {
					//check effect parents
					map_id = this.getParentParam(newparams, map_id);

					if (images[map_id]) map_id = images[map_id].path;
				}

				//now get the texture filename from images

				var map_info = { map_id: map_id };
				var uvs = xmlparam_value.getAttribute("texcoord");
				map_info.uvs = uvs;
				material.textures[param_name] = map_info;
			}
		}

		material.object_type = "Material";
		return material;
	},

	getParentParam: function getParentParam(newparams, param) {
		if (!newparams[param]) return param;

		if (newparams[param].parent) return this.getParentParam(newparams, newparams[param].parent);else return param;
	},

	readLight: function readLight(node, url) {
		var light = {};

		var xmlnode = null;

		if (url.length > 1) //weird cases with id == #
			xmlnode = this._xmlroot.querySelector("library_lights " + url);else {
			var xmlliblights = this._xmlroot.querySelector("library_lights");
			xmlnode = this.getFirstChildElement(xmlliblights, "light");
		}

		if (!xmlnode) return null;

		//pack
		var children = [];
		var xml = xmlnode.querySelector("technique_common");
		if (xml) for (var i = 0; i < xml.childNodes.length; i++) {
			if (xml.childNodes.item(i).nodeType == 1) //tag
				children.push(xml.childNodes.item(i));
		}var xmls = xmlnode.querySelectorAll("technique");
		for (var i = 0; i < xmls.length; i++) {
			var xml2 = xmls.item(i);
			for (var j = 0; j < xml2.childNodes.length; j++) {
				if (xml2.childNodes.item(j).nodeType == 1) //tag
					children.push(xml2.childNodes.item(j));
			}
		}

		//get
		for (var i = 0; i < children.length; i++) {
			var xml = children[i];
			switch (xml.localName) {
				case "point":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;
				case "directional":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;
				case "spot":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;

				case "intensity":
					light.intensity = this.readContentAsFloats(xml)[0];
					break;
			}
		}

		function parse_params(light, xml) {
			for (var i = 0; i < xml.childNodes.length; i++) {
				var child = xml.childNodes.item(i);
				if (!child || child.nodeType != 1) //tag
					continue;

				switch (child.localName) {
					case "color":
						light.color = Collada.readContentAsFloats(child);break;
					case "falloff_angle":
						light.angle_end = Collada.readContentAsFloats(child)[0];
						light.angle = light.angle_end - 10;
						break;
				}
			}
		}

		if (node.model) {
			//light position is final column of model
			light.position = [node.model[12], node.model[13], node.model[14]];
			//light forward vector is reverse of third column of model
			var forward = [-node.model[8], -node.model[9], -node.model[10]];
			//so light target is position + forward
			light.target = [light.position[0] + forward[0], light.position[1] + forward[1], light.position[2] + forward[2]];
		} else {
			console.warn("Could not read light position for light: " + node.name + ". Setting defaults.");
			light.position = [0, 0, 0];
			light.target = [0, -1, 0];
		}

		node.light = light;
	},

	readCamera: function readCamera(node, url) {
		var camera = {};

		var xmlnode = this._xmlroot.querySelector("library_cameras " + url);
		if (!xmlnode) return null;

		//pack
		var children = [];
		var xml = xmlnode.querySelector("technique_common");
		if (xml) //grab all internal stuff
			for (var i = 0; i < xml.childNodes.length; i++) {
				if (xml.childNodes.item(i).nodeType == 1) //tag
					children.push(xml.childNodes.item(i));
			} //
		for (var i = 0; i < children.length; i++) {
			var tag = children[i];
			parse_params(camera, tag);
		}

		function parse_params(camera, xml) {
			for (var i = 0; i < xml.childNodes.length; i++) {
				var child = xml.childNodes.item(i);
				if (!child || child.nodeType != 1) //tag
					continue;
				var translated = Collada.camera_translate_table[child.localName] || child.localName;
				camera[translated] = parseFloat(child.textContent);
			}
		}

		//parse to convert yfov to standard (x) fov
		if (camera.yfov && !camera.fov) {
			if (camera.aspect) {
				camera.fov = camera.yfov * camera.aspect;
			} else console.warn("Could not convert camera yfov to xfov because aspect ratio not set");
		}

		node.camera = camera;
	},

	readTransform: function readTransform(xmlnode, level, flip) {
		//identity
		var matrix = _glMatrix.mat4.create();
		var temp = _glMatrix.mat4.create();
		var tmpq = _glMatrix.quat.create();

		var flip_fix = false;

		//search for the matrix
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xml = xmlnode.childNodes.item(i);
			if (!xml || xml.nodeType != 1) //tag
				continue;

			if (xml.localName == "matrix") {
				var matrix = this.readContentAsFloats(xml);
				//console.log("Nodename: " + xmlnode.getAttribute("id"));
				//console.log(matrix);
				this.transformMatrix(matrix, level == 0);
				//console.log(matrix);
				return matrix;
			}

			if (xml.localName == "translate") {
				var values = this.readContentAsFloats(xml);
				if (flip && level > 0) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}

				_glMatrix.mat4.translate(matrix, matrix, values);
				continue;
			}

			//rotate
			if (xml.localName == "rotate") {
				var values = this.readContentAsFloats(xml);
				if (values.length == 4) //x,y,z, angle
					{
						var id = xml.getAttribute("sid");
						if (id == "jointOrientX") {
							values[3] += 90;
							flip_fix = true;
						}
						//rotateX & rotateY & rotateZ done below

						if (flip) {
							var tmp = values[1];
							values[1] = values[2];
							values[2] = -tmp; //swap coords
						}

						if (values[3] != 0.0) {
							_glMatrix.quat.setAxisAngle(tmpq, values.subarray(0, 3), values[3] * DEG2RAD);
							_glMatrix.mat4.fromQuat(temp, tmpq);
							_glMatrix.mat4.multiply(matrix, matrix, temp);
						}
					}
				continue;
			}

			//scale
			if (xml.localName == "scale") {
				var values = this.readContentAsFloats(xml);
				if (flip) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}
				_glMatrix.mat4.scale(matrix, matrix, values);
			}
		}

		return matrix;
	},

	readTransform2: function readTransform2(xmlnode, level, flip) {
		//identity
		var matrix = _glMatrix.mat4.create();
		var rotation = _glMatrix.quat.create();
		var tmpmatrix = _glMatrix.mat4.create();
		var tmpq = _glMatrix.quat.create();
		var translate = vec3.create();
		var scale = vec3.fromValues(1, 1, 1);

		var flip_fix = false;

		//search for the matrix
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xml = xmlnode.childNodes.item(i);

			if (xml.localName == "matrix") {
				var matrix = this.readContentAsFloats(xml);
				//console.log("Nodename: " + xmlnode.getAttribute("id"));
				//console.log(matrix);
				this.transformMatrix(matrix, level == 0);
				//console.log(matrix);
				return matrix;
			}

			if (xml.localName == "translate") {
				var values = this.readContentAsFloats(xml);
				translate.set(values);
				continue;
			}

			//rotate
			if (xml.localName == "rotate") {
				var values = this.readContentAsFloats(xml);
				if (values.length == 4) //x,y,z, angle
					{
						var id = xml.getAttribute("sid");
						if (id == "jointOrientX") {
							values[3] += 90;
							flip_fix = true;
						}
						//rotateX & rotateY & rotateZ done below

						if (flip) {
							var tmp = values[1];
							values[1] = values[2];
							values[2] = -tmp; //swap coords
						}

						if (values[3] != 0.0) {
							_glMatrix.quat.setAxisAngle(tmpq, values.subarray(0, 3), values[3] * DEG2RAD);
							_glMatrix.quat.multiply(rotation, rotation, tmpq);
						}
					}
				continue;
			}

			//scale
			if (xml.localName == "scale") {
				var values = this.readContentAsFloats(xml);
				if (flip) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}
				scale.set(values);
			}
		}

		if (flip && level > 0) {
			var tmp = translate[1];
			translate[1] = translate[2];
			translate[2] = -tmp; //swap coords
		}
		_glMatrix.mat4.translate(matrix, matrix, translate);

		_glMatrix.mat4.fromQuat(tmpmatrix, rotation);
		//mat4.rotateX(tmpmatrix, tmpmatrix, Math.PI * 0.5);
		_glMatrix.mat4.multiply(matrix, matrix, tmpmatrix);
		_glMatrix.mat4.scale(matrix, matrix, scale);

		return matrix;
	},

	//for help read this: https://www.khronos.org/collada/wiki/Using_accessors
	readGeometry: function readGeometry(id, flip, scene) {
		//already read, could happend if several controllers point to the same mesh
		if (this._geometries_found[id] !== undefined) return this._geometries_found[id];

		//var xmlgeometry = this._xmlroot.querySelector("geometry" + id);
		var xmlgeometry = this._xmlroot.getElementById(id.substr(1));
		if (!xmlgeometry) {
			console.warn("readGeometry: geometry not found: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//if the geometry has morph targets then instead of storing it in a geometry, it is in a controller
		if (xmlgeometry.localName == "controller") {
			var geometry = this.readController(xmlgeometry, flip, scene);
			this._geometries_found[id] = geometry;
			return geometry;
		}

		if (xmlgeometry.localName != "geometry") {
			console.warn("readGeometry: tag should be geometry, instead it was found: " + xmlgeometry.localName);
			this._geometries_found[id] = null;
			return null;
		}

		var xmlmesh = xmlgeometry.querySelector("mesh");
		if (!xmlmesh) {
			console.warn("readGeometry: mesh not found in geometry: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//get data sources
		var sources = {};
		var xmlsources = xmlmesh.querySelectorAll("source");
		for (var i = 0; i < xmlsources.length; i++) {
			var xmlsource = xmlsources.item(i);
			if (!xmlsource.querySelector) continue;
			var float_array = xmlsource.querySelector("float_array");
			if (!float_array) continue;
			var floats = this.readContentAsFloats(float_array);

			var xmlaccessor = xmlsource.querySelector("accessor");
			var stride = parseInt(xmlaccessor.getAttribute("stride"));

			sources[xmlsource.getAttribute("id")] = { stride: stride, data: floats };
		}

		//get streams
		var xmlvertices = xmlmesh.querySelector("vertices input");
		var vertices_source = sources[xmlvertices.getAttribute("source").substr(1)];
		sources[xmlmesh.querySelector("vertices").getAttribute("id")] = vertices_source;

		var mesh = null;
		var xmlpolygons = xmlmesh.querySelector("polygons");
		if (xmlpolygons) mesh = this.readTriangles(xmlpolygons, sources);

		if (!mesh) {
			var xmltriangles = xmlmesh.querySelectorAll("triangles");
			if (xmltriangles && xmltriangles.length) mesh = this.readTriangles(xmltriangles, sources);
		}

		if (!mesh) {
			//polylist = true;
			//var vcount = null;
			//var xmlvcount = xmlpolygons.querySelector("vcount");
			//var vcount = this.readContentAsUInt32( xmlvcount );
			var xmlpolylist = xmlmesh.querySelector("polylist");
			if (xmlpolylist) mesh = this.readPolylist(xmlpolylist, sources);
		}

		if (!mesh) {
			var xmllinestrip = xmlmesh.querySelector("linestrips");
			if (xmllinestrip) mesh = this.readLineStrip(sources, xmllinestrip);
		}

		if (!mesh) {
			console.log("no polygons or triangles in mesh: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//swap coords (X,Y,Z) -> (X,Z,-Y)
		if (flip && !this.no_flip) {
			var tmp = 0;
			var array = mesh.vertices;
			for (var i = 0, l = array.length; i < l; i += 3) {
				tmp = array[i + 1];
				array[i + 1] = array[i + 2];
				array[i + 2] = -tmp;
			}

			array = mesh.normals;
			for (var i = 0, l = array.length; i < l; i += 3) {
				tmp = array[i + 1];
				array[i + 1] = array[i + 2];
				array[i + 2] = -tmp;
			}
		}

		//transferables for worker
		if (isWorker && this.use_transferables) {
			for (var i in mesh) {
				var data = mesh[i];
				if (data && data.buffer && data.length > 100) {
					this._transferables.push(data.buffer);
				}
			}
		}

		//extra info
		mesh.filename = id;
		mesh.object_type = "Mesh";

		this._geometries_found[id] = mesh;
		return mesh;
	},

	readTriangles: function readTriangles(xmltriangles, sources) {
		var use_indices = false;

		var groups = [];
		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = []; //maps DAE vertex index to Mesh vertex index (because when meshes are triangulated indices are changed
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		//for every triangles set (warning, some times they are repeated...)
		for (var tris = 0; tris < xmltriangles.length; tris++) {
			var xml_shape_root = xmltriangles.item(tris);
			var triangles = xml_shape_root.localName == "triangles";

			material_name = xml_shape_root.getAttribute("material");

			//for each buffer (input) build the structure info
			if (tris == 0) buffers = this.readShapeInputs(xml_shape_root, sources);

			//assuming buffers are ordered by offset

			//iterate data
			var xmlps = xml_shape_root.querySelectorAll("p");
			var num_data_vertex = buffers.length; //one value per input buffer

			//for every polygon (could be one with all the indices, could be several, depends on the program)
			for (var i = 0; i < xmlps.length; i++) {
				var xmlp = xmlps.item(i);
				if (!xmlp || !xmlp.textContent) break;

				var data = xmlp.textContent.trim().split(" ");

				//used for triangulate polys
				var first_index = -1;
				var current_index = -1;
				var prev_index = -1;

				//discomment to force 16bits indices
				//if(use_indices && last_index >= 256*256)
				//	break;

				var num_values_per_vertex = 1;
				for (var b in buffers) {
					num_values_per_vertex = Math.max(num_values_per_vertex, buffers[b][4] + 1);
				} //for every pack of indices in the polygon (vertex, normal, uv, ... )
				var current_data_pos = 0;
				for (var k = 0, l = data.length; k < l; k += num_values_per_vertex) {
					var vertex_id = data.slice(k, k + num_values_per_vertex).join(" "); //generate unique id

					prev_index = current_index;
					if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
						current_index = facemap[vertex_id];else {
						//for every data buffer associated to this vertex
						for (var j = 0; j < buffers.length; ++j) {
							var buffer = buffers[j];
							var array = buffer[1]; //array where we accumulate the final data as we extract if from sources
							var source = buffer[3]; //where to read the data from

							//compute the index inside the data source array
							//var index = parseInt(data[k + j]);
							var index = parseInt(data[k + buffer[4]]);
							//current_data_pos += buffer[4];

							//remember this index in case we need to remap
							if (j == 0) vertex_remap[array.length / buffer[2]] = index; //not sure if buffer[2], it should be number of floats per vertex (usually 3)
							//vertex_remap[ array.length / num_data_vertex ] = index;

							//compute the position inside the source buffer where the final data is located
							index *= buffer[2]; //this works in most DAEs (not all)
							//index = index * buffer[2] + buffer[4]; //stride(2) offset(4)
							//index += buffer[4]; //stride(2) offset(4)
							//extract every value of this element and store it in its final array (every x,y,z, etc)
							for (var x = 0; x < buffer[2]; ++x) {
								if (source[index + x] === undefined) throw "UNDEFINED!"; //DEBUG
								array.push(source[index + x]);
							}
						}

						current_index = last_index;
						last_index += 1;
						facemap[vertex_id] = current_index;
					}

					if (!triangles) //the xml element is not triangles? then split polygons in triangles
						{
							if (k == 0) first_index = current_index;
							//if(k > 2 * num_data_vertex) //not sure if use this or the next line, the next one works in some DAEs but not sure if it works in all
							if (k > 2) //triangulate polygons: ensure this works
								{
									indicesArray.push(first_index);
									indicesArray.push(prev_index);
								}
						}

					indicesArray.push(current_index);
				} //per vertex
			} //per polygon

			var group = {
				name: group_name || "group" + tris,
				start: last_start,
				length: indicesArray.length - last_start,
				material: material_name || ""
			};
			last_start = indicesArray.length;
			groups.push(group);
		} //per triangles group

		var mesh = {
			vertices: new Float32Array(buffers[0][1]),
			info: { groups: groups },
			_remap: new Uint32Array(vertex_remap)
		};

		this.transformMeshInfo(mesh, buffers, indicesArray);

		return mesh;
	},

	readPolylist: function readPolylist(xml_shape_root, sources) {
		var use_indices = false;

		var groups = [];
		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = [];
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		material_name = xml_shape_root.getAttribute("material");
		buffers = this.readShapeInputs(xml_shape_root, sources);

		var xmlvcount = xml_shape_root.querySelector("vcount");
		var vcount = this.readContentAsUInt32(xmlvcount);

		var xmlp = xml_shape_root.querySelector("p");
		var data = this.readContentAsUInt32(xmlp);

		var num_data_vertex = buffers.length;

		var pos = 0;
		for (var i = 0, l = vcount.length; i < l; ++i) {
			var num_vertices = vcount[i];

			var first_index = -1;
			var current_index = -1;
			var prev_index = -1;

			//iterate vertices of this polygon
			for (var k = 0; k < num_vertices; ++k) {
				var vertex_id = data.subarray(pos, pos + num_data_vertex).join(" ");

				prev_index = current_index;
				if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
					current_index = facemap[vertex_id];else {
					for (var j = 0; j < buffers.length; ++j) {
						var buffer = buffers[j];
						var index = parseInt(data[pos + j]); //p
						var array = buffer[1]; //array with all the data
						var source = buffer[3]; //where to read the data from
						if (j == 0) vertex_remap[array.length / num_data_vertex] = index;
						index *= buffer[2]; //stride
						for (var x = 0; x < buffer[2]; ++x) {
							array.push(source[index + x]);
						}
					}

					current_index = last_index;
					last_index += 1;
					facemap[vertex_id] = current_index;
				}

				if (num_vertices > 3) //split polygons then
					{
						if (k == 0) first_index = current_index;
						//if(k > 2 * num_data_vertex) //not sure if use this or the next line, the next one works in some DAEs but not sure if it works in all
						if (k > 2) //triangulate polygons: tested, this works
							{
								indicesArray.push(first_index);
								indicesArray.push(prev_index);
							}
					}

				indicesArray.push(current_index);
				pos += num_data_vertex;
			} //per vertex
		} //per polygon

		var mesh = {
			vertices: new Float32Array(buffers[0][1]),
			info: {},
			_remap: new Uint32Array(vertex_remap)
		};

		this.transformMeshInfo(mesh, buffers, indicesArray);

		return mesh;
	},

	readShapeInputs: function readShapeInputs(xml_shape_root, sources) {
		var buffers = [];

		var xmlinputs = xml_shape_root.querySelectorAll("input");
		for (var i = 0; i < xmlinputs.length; i++) {
			var xmlinput = xmlinputs.item(i);
			if (!xmlinput.getAttribute) continue;
			var semantic = xmlinput.getAttribute("semantic").toUpperCase();
			var stream_source = sources[xmlinput.getAttribute("source").substr(1)];
			var offset = parseInt(xmlinput.getAttribute("offset"));
			var data_set = 0;
			if (xmlinput.getAttribute("set")) data_set = parseInt(xmlinput.getAttribute("set"));
			buffers.push([semantic, [], stream_source.stride, stream_source.data, offset, data_set]);
		}

		return buffers;
	},

	transformMeshInfo: function transformMeshInfo(mesh, buffers, indicesArray) {
		//rename buffers (DAE has other names)
		var translator = {
			"normal": "normals",
			"texcoord": "coords"
		};
		for (var i = 1; i < buffers.length; ++i) {
			var name = buffers[i][0].toLowerCase();
			var data = buffers[i][1];
			if (!data.length) continue;

			if (translator[name]) name = translator[name];
			if (mesh[name]) name = name + buffers[i][5];
			mesh[name] = new Float32Array(data); //are they always float32? I think so
		}

		if (indicesArray && indicesArray.length) {
			if (mesh.vertices.length > 256 * 256) mesh.triangles = new Uint32Array(indicesArray);else mesh.triangles = new Uint16Array(indicesArray);
		}

		return mesh;
	},

	readLineStrip: function readLineStrip(sources, xmllinestrip) {
		var use_indices = false;

		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = [];
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		var tris = 0; //used in case there are several strips

		//for each buffer (input) build the structure info
		var xmlinputs = xmllinestrip.querySelectorAll("input");
		if (tris == 0) //first iteration, create buffers
			for (var i = 0; i < xmlinputs.length; i++) {
				var xmlinput = xmlinputs.item(i);
				if (!xmlinput.getAttribute) continue;
				var semantic = xmlinput.getAttribute("semantic").toUpperCase();
				var stream_source = sources[xmlinput.getAttribute("source").substr(1)];
				var offset = parseInt(xmlinput.getAttribute("offset"));
				var data_set = 0;
				if (xmlinput.getAttribute("set")) data_set = parseInt(xmlinput.getAttribute("set"));

				buffers.push([semantic, [], stream_source.stride, stream_source.data, offset, data_set]);
			}
		//assuming buffers are ordered by offset

		//iterate data
		var xmlps = xmllinestrip.querySelectorAll("p");
		var num_data_vertex = buffers.length; //one value per input buffer

		//for every polygon (could be one with all the indices, could be several, depends on the program)
		for (var i = 0; i < xmlps.length; i++) {
			var xmlp = xmlps.item(i);
			if (!xmlp || !xmlp.textContent) break;

			var data = xmlp.textContent.trim().split(" ");

			//used for triangulate polys
			var first_index = -1;
			var current_index = -1;
			var prev_index = -1;

			//if(use_indices && last_index >= 256*256)
			//	break;

			//for every pack of indices in the polygon (vertex, normal, uv, ... )
			for (var k = 0, l = data.length; k < l; k += num_data_vertex) {
				var vertex_id = data.slice(k, k + num_data_vertex).join(" "); //generate unique id

				prev_index = current_index;
				if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
					current_index = facemap[vertex_id];else {
					for (var j = 0; j < buffers.length; ++j) {
						var buffer = buffers[j];
						var index = parseInt(data[k + j]);
						var array = buffer[1]; //array with all the data
						var source = buffer[3]; //where to read the data from
						if (j == 0) vertex_remap[array.length / num_data_vertex] = index;
						index *= buffer[2]; //stride
						for (var x = 0; x < buffer[2]; ++x) {
							array.push(source[index + x]);
						}
					}

					current_index = last_index;
					last_index += 1;
					facemap[vertex_id] = current_index;
				}

				indicesArray.push(current_index);
			} //per vertex
		} //per polygon

		var mesh = {
			primitive: "line_strip",
			vertices: new Float32Array(buffers[0][1]),
			info: {}
		};

		return this.transformMeshInfo(mesh, buffers, indicesArray);
	},

	//like querySelector but allows spaces in names because COLLADA allows space in names
	findXMLNodeById: function findXMLNodeById(root, nodename, id) {
		//precomputed
		if (this._xmlroot._nodes_by_id) {
			var n = this._xmlroot._nodes_by_id[id];
			if (n && n.localName == nodename) return n;
		} else //for the native parser
			{
				var n = this._xmlroot.getElementById(id);
				if (n) return n;
			}

		//recursive: slow
		var childs = root.childNodes;
		for (var i = 0; i < childs.length; ++i) {
			var xmlnode = childs.item(i);
			if (xmlnode.nodeType != 1) //no tag
				continue;
			if (xmlnode.localName != nodename) continue;
			var node_id = xmlnode.getAttribute("id");
			if (node_id == id) return xmlnode;
		}
		return null;
	},

	readImages: function readImages(root) {
		var xmlimages = root.querySelector("library_images");
		if (!xmlimages) return null;

		var images = {};

		var xmlimages_childs = xmlimages.childNodes;
		for (var i = 0; i < xmlimages_childs.length; ++i) {
			var xmlimage = xmlimages_childs.item(i);
			if (xmlimage.nodeType != 1) //no tag
				continue;

			var xmlinitfrom = xmlimage.querySelector("init_from");
			if (!xmlinitfrom) continue;
			if (xmlinitfrom.textContent) {
				var filename = this.getFilename(xmlinitfrom.textContent);
				var id = xmlimage.getAttribute("id");
				images[id] = { filename: filename, map: id, name: xmlimage.getAttribute("name"), path: xmlinitfrom.textContent };
			}
		}

		return images;
	},

	readAnimations: function readAnimations(root, scene) {
		var xmlanimations = root.querySelector("library_animations");
		if (!xmlanimations) return null;

		var xmlanimation_childs = xmlanimations.childNodes;

		var animations = {
			object_type: "Animation",
			takes: {}
		};

		var default_take = { tracks: [] };
		var tracks = default_take.tracks;

		for (var i = 0; i < xmlanimation_childs.length; ++i) {
			var xmlanimation = xmlanimation_childs.item(i);
			if (xmlanimation.nodeType != 1 || xmlanimation.localName != "animation") //no tag
				continue;

			var anim_id = xmlanimation.getAttribute("id");
			if (!anim_id) //nested animation (DAE 1.5)
				{
					var xmlanimation2_childs = xmlanimation.querySelectorAll("animation");
					if (xmlanimation2_childs.length) {
						for (var j = 0; j < xmlanimation2_childs.length; ++j) {
							var xmlanimation2 = xmlanimation2_childs.item(j);
							this.readAnimation(xmlanimation2, tracks);
						}
					} else //source tracks?
						this.readAnimation(xmlanimation, tracks);
				} else //no nested (DAE 1.4)
				this.readAnimation(xmlanimation, tracks);
		}

		if (!tracks.length) return null; //empty animation

		//compute animation duration
		var max_time = 0;
		for (var i = 0; i < tracks.length; ++i) {
			if (max_time < tracks[i].duration) max_time = tracks[i].duration;
		}default_take.name = "default";
		default_take.duration = max_time;
		animations.takes[default_take.name] = default_take;
		return animations;
	},

	//animation xml
	readAnimation: function readAnimation(xmlanimation, result) {
		if (xmlanimation.localName != "animation") return null;

		//this could be missing when there are lots of anims packed in one <animation>
		var anim_id = xmlanimation.getAttribute("id");

		//channels are like animated properties
		var xmlchannel_list = xmlanimation.querySelectorAll("channel");
		if (!xmlchannel_list.length) return null;

		var tracks = result || [];

		for (var i = 0; i < xmlchannel_list.length; ++i) {
			var anim = this.readChannel(xmlchannel_list.item(i), xmlanimation);
			if (anim) tracks.push(anim);
		}

		return tracks;
	},

	readChannel: function readChannel(xmlchannel, xmlanimation) {
		if (xmlchannel.localName != "channel" || xmlanimation.localName != "animation") return null;

		var source = xmlchannel.getAttribute("source");
		var target = xmlchannel.getAttribute("target");

		//sampler, is in charge of the interpolation
		//var xmlsampler = xmlanimation.querySelector("sampler" + source);
		var xmlsampler = this.findXMLNodeById(xmlanimation, "sampler", source.substr(1));
		if (!xmlsampler) {
			console.error("Error DAE: Sampler not found in " + source);
			return null;
		}

		var inputs = {};
		var params = {};
		var sources = {};
		var xmlinputs = xmlsampler.querySelectorAll("input");

		var time_data = null;

		//iterate inputs: collada separates the keyframe info in independent streams, like time, interpolation method, value )
		for (var j = 0; j < xmlinputs.length; j++) {
			var xmlinput = xmlinputs.item(j);
			var source_name = xmlinput.getAttribute("source");

			//there are three 
			var semantic = xmlinput.getAttribute("semantic");

			//Search for source
			var xmlsource = this.findXMLNodeById(xmlanimation, "source", source_name.substr(1));
			if (!xmlsource) continue;

			var xmlparam = xmlsource.querySelector("param");
			if (!xmlparam) continue;

			var type = xmlparam.getAttribute("type");
			inputs[semantic] = { source: source_name, type: type };

			var data_array = null;

			if (type == "float" || type == "float4x4") {
				var xmlfloatarray = xmlsource.querySelector("float_array");
				var floats = this.readContentAsFloats(xmlfloatarray);
				sources[source_name] = floats;
				data_array = floats;
			} else //only floats and matrices are supported in animation
				continue;

			var param_name = xmlparam.getAttribute("name");
			if (param_name == "TIME") time_data = data_array;
			if (semantic == "OUTPUT") param_name = semantic;
			if (param_name) params[param_name] = type;else console.warn("Collada: <param> without name attribute in <animation>");
		}

		if (!time_data) {
			console.error("Error DAE: no TIME info found in <channel>: " + xmlchannel.getAttribute("source"));
			return null;
		}

		//construct animation
		var path = target.split("/");

		var anim = {};
		var nodename = path[0]; //safeString ?
		var node = this._nodes_by_id[nodename];
		var locator = node.id + "/" + path[1];
		//anim.nodename = this.safeString( path[0] ); //where it goes
		anim.name = path[1];
		anim.property = locator;
		var type = "number";
		var element_size = 1;
		var param_type = params["OUTPUT"];
		switch (param_type) {
			case "float":
				element_size = 1;break;
			case "float3x3":
				element_size = 9;type = "mat3";break;
			case "float4x4":
				element_size = 16;type = "mat4";break;
			default:
				break;
		}

		anim.type = type;
		anim.value_size = element_size;
		anim.duration = time_data[time_data.length - 1]; //last sample

		var value_data = sources[inputs["OUTPUT"].source];
		if (!value_data) return null;

		//Pack data ****************
		var num_samples = time_data.length;
		var sample_size = element_size + 1;
		var anim_data = new Float32Array(num_samples * sample_size);
		//for every sample
		for (var j = 0; j < time_data.length; ++j) {
			anim_data[j * sample_size] = time_data[j]; //set time
			var value = value_data.subarray(j * element_size, (j + 1) * element_size);
			if (param_type == "float4x4") {
				this.transformMatrix(value, node ? node._depth == 0 : 0);
				//mat4.transpose(value, value);
			}
			anim_data.set(value, j * sample_size + 1); //set data
		}

		if (isWorker && this.use_transferables) {
			var data = anim_data;
			if (data && data.buffer && data.length > 100) this._transferables.push(data.buffer);
		}

		anim.data = anim_data;
		return anim;
	},

	findNode: function findNode(root, id) {
		if (root.id == id) return root;
		if (root.children) for (var i in root.children) {
			var ret = this.findNode(root.children[i], id);
			if (ret) return ret;
		}
		return null;
	},

	//reads controllers and stores them in 
	readLibraryControllers: function readLibraryControllers(scene) {
		var xmllibrarycontrollers = this._xmlroot.querySelector("library_controllers");
		if (!xmllibrarycontrollers) return null;

		var xmllibrarycontrollers_childs = xmllibrarycontrollers.childNodes;

		for (var i = 0; i < xmllibrarycontrollers_childs.length; ++i) {
			var xmlcontroller = xmllibrarycontrollers_childs.item(i);
			if (xmlcontroller.nodeType != 1 || xmlcontroller.localName != "controller") //no tag
				continue;
			var id = xmlcontroller.getAttribute("id");
			//we have already processed this controller
			if (this._controllers_found[id]) continue;

			//read it (we wont use the returns, we will get it from this._controllers_found
			this.readController(xmlcontroller, null, scene);
		}
	},

	//used for skinning and morphing
	readController: function readController(xmlcontroller, flip, scene) {
		if (!xmlcontroller.localName == "controller") {
			console.warn("readController: not a controller: " + xmlcontroller.localName);
			return null;
		}

		var id = xmlcontroller.getAttribute("id");
		//use cached
		if (this._controllers_found[id]) return this._controllers_found[id];

		//AGUILA
		//TODO: does this work?
		// if (this._controllers_found[ id ])
		// 	return this._controllers_found[ id ];

		var use_indices = false;
		var mesh = null;
		var xmlskin = xmlcontroller.querySelector("skin");
		if (xmlskin) {
			mesh = this.readSkinController(xmlskin, flip, scene);
		}

		var xmlmorph = xmlcontroller.querySelector("morph");
		if (xmlmorph) mesh = this.readMorphController(xmlmorph, flip, scene, mesh);

		//cache and return
		if (this._controllers_found[id]) {
			id += "_1blah"; //??? this doesnt do anything
		} else this._controllers_found[id] = mesh;

		return mesh;
	},

	//read this to more info about DAE and skinning https://collada.org/mediawiki/index.php/Skinning
	readSkinController: function readSkinController(xmlskin, flip, scene) {
		//base geometry
		var id_geometry = xmlskin.getAttribute("source");

		var mesh = this.readGeometry(id_geometry, flip, scene);
		if (!mesh) return null;

		var sources = this.readSources(xmlskin, flip);
		if (!sources) return null;

		//matrix
		var bind_matrix = null;
		var xmlbindmatrix = xmlskin.querySelector("bind_shape_matrix");
		if (xmlbindmatrix) {
			bind_matrix = this.readContentAsFloats(xmlbindmatrix);
			this.transformMatrix(bind_matrix, true, true);
		} else bind_matrix = _glMatrix.mat4.create(); //identity

		//joints
		var joints = [];
		var xmljoints = xmlskin.querySelector("joints");
		if (xmljoints) {
			var joints_source = null; //which bones
			var inv_bind_source = null; //bind matrices
			var xmlinputs = xmljoints.querySelectorAll("input");
			for (var i = 0; i < xmlinputs.length; i++) {
				var xmlinput = xmlinputs[i];
				var sem = xmlinput.getAttribute("semantic").toUpperCase();
				var src = xmlinput.getAttribute("source");
				var source = sources[src.substr(1)];
				if (sem == "JOINT") joints_source = source;else if (sem == "INV_BIND_MATRIX") inv_bind_source = source;
			}

			//save bone names and inv matrix
			if (!inv_bind_source || !joints_source) {
				console.error("Error DAE: no joints or inv_bind sources found");
				return null;
			}

			for (var i in joints_source) {
				//get the inverse of the bind pose
				var inv_mat = inv_bind_source.subarray(i * 16, i * 16 + 16);
				var nodename = joints_source[i];
				var node = this._nodes_by_id[nodename];
				if (!node) {
					console.warn("Node " + nodename + " not found");
					continue;
				}
				this.transformMatrix(inv_mat, node._depth == 0, true);
				joints.push([nodename, inv_mat]);
			}
		}

		//weights
		var xmlvertexweights = xmlskin.querySelector("vertex_weights");
		if (xmlvertexweights) {

			//here we see the order 
			var weights_indexed_array = null;
			var xmlinputs = xmlvertexweights.querySelectorAll("input");
			for (var i = 0; i < xmlinputs.length; i++) {
				if (xmlinputs[i].getAttribute("semantic").toUpperCase() == "WEIGHT") weights_indexed_array = sources[xmlinputs.item(i).getAttribute("source").substr(1)];
			}

			if (!weights_indexed_array) throw "no weights found";

			var xmlvcount = xmlvertexweights.querySelector("vcount");
			var vcount = this.readContentAsUInt32(xmlvcount);

			var xmlv = xmlvertexweights.querySelector("v");
			var v = this.readContentAsUInt32(xmlv);

			var num_vertices = mesh.vertices.length / 3; //3 components per vertex
			var weights_array = new Float32Array(4 * num_vertices); //4 bones per vertex
			var bone_index_array = new Uint8Array(4 * num_vertices); //4 bones per vertex

			var pos = 0;
			var remap = mesh._remap;
			var max_bone = 0; //max bone affected

			for (var i = 0, l = vcount.length; i < l; ++i) {
				var num_bones = vcount[i]; //num bones influencing this vertex

				//find 4 with more influence
				//var v_tuplets = v.subarray(offset, offset + num_bones*2);

				var offset = pos;
				var b = bone_index_array.subarray(i * 4, i * 4 + 4);
				var w = weights_array.subarray(i * 4, i * 4 + 4);

				var sum = 0;
				for (var j = 0; j < num_bones && j < 4; ++j) {
					b[j] = v[offset + j * 2];
					if (b[j] > max_bone) max_bone = b[j];

					w[j] = weights_indexed_array[v[offset + j * 2 + 1]];
					sum += w[j];
				}

				//normalize weights
				if (num_bones > 4 && sum < 1.0) {
					var inv_sum = 1 / sum;
					for (var j = 0; j < 4; ++j) {
						w[j] *= inv_sum;
					}
				}

				pos += num_bones * 2;
			}

			//remap: because vertices order is now changed after parsing the mesh
			var final_weights = new Float32Array(4 * num_vertices); //4 bones per vertex
			var final_bone_indices = new Uint8Array(4 * num_vertices); //4 bones per vertex
			var used_joints = [];

			//for every vertex in the mesh, process bone indices and weights
			for (var i = 0; i < num_vertices; ++i) {
				var p = remap[i] * 4;
				var w = weights_array.subarray(p, p + 4);
				var b = bone_index_array.subarray(p, p + 4);

				//sort by weight so relevant ones goes first
				for (var k = 0; k < 3; ++k) {
					var max_pos = k;
					var max_value = w[k];
					for (var j = k + 1; j < 4; ++j) {
						if (w[j] <= max_value) continue;
						max_pos = j;
						max_value = w[j];
					}
					if (max_pos != k) {
						var tmp = w[k];
						w[k] = w[max_pos];
						w[max_pos] = tmp;
						tmp = b[k];
						b[k] = b[max_pos];
						b[max_pos] = tmp;
					}
				}

				//store
				final_weights.set(w, i * 4);
				final_bone_indices.set(b, i * 4);

				//mark bones used
				if (w[0]) used_joints[b[0]] = true;
				if (w[1]) used_joints[b[1]] = true;
				if (w[2]) used_joints[b[2]] = true;
				if (w[3]) used_joints[b[3]] = true;
			}

			if (max_bone >= joints.length) console.warn("Mesh uses higher bone index than bones found");

			//trim unused bones (collada could give you 100 bones for an object that only uses a fraction of them)
			if (1) {
				var new_bones = [];
				var bones_translation = {};
				for (var i = 0; i < used_joints.length; ++i) {
					if (used_joints[i]) {
						bones_translation[i] = new_bones.length;
						new_bones.push(joints[i]);
					}
				} //in case there are less bones in use...
				if (new_bones.length < joints.length) {
					//remap
					for (var i = 0; i < final_bone_indices.length; i++) {
						final_bone_indices[i] = bones_translation[final_bone_indices[i]];
					}joints = new_bones;
				}
				//console.log("Bones: ", joints.length, " used:", num_used_joints );
			}

			//console.log("Bones: ", joints.length, "Max bone: ", max_bone);

			mesh.weights = final_weights;
			mesh.bone_indices = final_bone_indices;
			mesh.bones = joints;
			mesh.bind_matrix = bind_matrix;

			//delete mesh["_remap"];
		}

		return mesh;
	},

	//NOT TESTED
	readMorphController: function readMorphController(xmlmorph, flip, scene, mesh) {
		var id_geometry = xmlmorph.getAttribute("source");
		var base_mesh = this.readGeometry(id_geometry, flip, scene);
		if (!base_mesh) return null;

		//read sources with blend shapes info (which ones, and the weight)
		var sources = this.readSources(xmlmorph, flip);

		var morphs = [];

		//targets
		var xmltargets = xmlmorph.querySelector("targets");
		if (!xmltargets) return null;

		var xmlinputs = xmltargets.querySelectorAll("input");
		var targets = null;
		var weights = null;

		for (var i = 0; i < xmlinputs.length; i++) {
			var xmlinput = xmlinputs.item(i);
			var semantic = xmlinput.getAttribute("semantic").toUpperCase();
			var data = sources[xmlinput.getAttribute("source").substr(1)];
			if (semantic == "MORPH_TARGET") targets = data;else if (semantic == "MORPH_WEIGHT") weights = data;
		}

		if (!targets || !weights) {
			console.warn("Morph controller without targets or weights. Skipping it.");
			return null;
		}

		//get targets
		for (var i in targets) {
			var id = "#" + targets[i];
			var geometry = this.readGeometry(id, flip, scene);
			scene.meshes[id] = geometry;
			morphs.push({ mesh: id, weight: weights[i] });
		}

		base_mesh.morph_targets = morphs;
		return base_mesh;
	},

	readBindMaterials: function readBindMaterials(xmlbind_material, mesh) {
		var materials = [];

		var xmltechniques = xmlbind_material.querySelectorAll("technique_common");
		for (var i = 0; i < xmltechniques.length; i++) {
			var xmltechnique = xmltechniques.item(i);
			var xmlinstance_materials = xmltechnique.querySelectorAll("instance_material");
			for (var j = 0; j < xmlinstance_materials.length; j++) {
				var xmlinstance_material = xmlinstance_materials.item(j);
				if (xmlinstance_material) materials.push(xmlinstance_material.getAttribute("symbol"));
			}
		}

		return materials;
	},

	readSources: function readSources(xmlnode, flip) {
		//for data sources
		var sources = {};
		var xmlsources = xmlnode.querySelectorAll("source");
		for (var i = 0; i < xmlsources.length; i++) {
			var xmlsource = xmlsources.item(i);
			if (!xmlsource.querySelector) //??
				continue;

			var float_array = xmlsource.querySelector("float_array");
			if (float_array) {
				var floats = this.readContentAsFloats(xmlsource);
				sources[xmlsource.getAttribute("id")] = floats;
				continue;
			}

			var name_array = xmlsource.querySelector("Name_array");
			if (name_array) {
				var names = this.readContentAsStringsArray(name_array);
				if (!names) continue;
				sources[xmlsource.getAttribute("id")] = names;
				continue;
			}

			var ref_array = xmlsource.querySelector("IDREF_array");
			if (ref_array) {
				var names = this.readContentAsStringsArray(ref_array);
				if (!names) continue;
				sources[xmlsource.getAttribute("id")] = names;
				continue;
			}
		}

		return sources;
	},

	readContentAsUInt32: function readContentAsUInt32(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.trim(); //remove empty spaces
		if (text.length == 0) return null;
		var numbers = text.split(" "); //create array
		var floats = new Uint32Array(numbers.length);
		for (var k = 0; k < numbers.length; k++) {
			floats[k] = parseInt(numbers[k]);
		}return floats;
	},

	readContentAsFloats: function readContentAsFloats(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.replace(/\s\s+/gi, " ");
		text = text.replace(/\t/gi, "");
		text = text.trim(); //remove empty spaces
		var numbers = text.split(" "); //create array
		var count = xmlnode.getAttribute("count");
		var length = count ? parseInt(count) : numbers.length;
		var floats = new Float32Array(length);
		for (var k = 0; k < numbers.length; k++) {
			floats[k] = parseFloat(numbers[k]);
		}return floats;
	},

	readContentAsStringsArray: function readContentAsStringsArray(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.replace(/\s\s/gi, " ");
		text = text.trim(); //remove empty spaces
		var words = text.split(" "); //create array
		for (var k = 0; k < words.length; k++) {
			words[k] = words[k].trim();
		}if (xmlnode.getAttribute("count") && parseInt(xmlnode.getAttribute("count")) != words.length) {
			var merged_words = [];
			var name = "";
			for (var i in words) {
				if (!name) name = words[i];else name += " " + words[i];
				if (!this._nodes_by_id[this.safeString(name)]) continue;
				merged_words.push(this.safeString(name));
				name = "";
			}

			var count = parseInt(xmlnode.getAttribute("count"));
			if (merged_words.length == count) return merged_words;

			console.error("Error: bone names have spaces, avoid using spaces in names");
			return null;
		}
		return words;
	},

	max3d_matrix_0: new Float32Array([0, -1, 0, 0, 0, 0, -1, 0, 1, 0, 0, -0, 0, 0, 0, 1]),
	//max3d_matrix_other: new Float32Array([0, -1, 0, 0, 0, 0, -1, 0, 1, 0, 0, -0, 0, 0, 0, 1]),

	transformMatrix: function transformMatrix(matrix, first_level, inverted) {
		_glMatrix.mat4.transpose(matrix, matrix);

		if (this.no_flip) return matrix;

		//WARNING: DO NOT CHANGE THIS FUNCTION, THE SKY WILL FALL
		if (first_level) {

			//flip row two and tree
			var temp = new Float32Array(matrix.subarray(4, 8)); //swap rows
			matrix.set(matrix.subarray(8, 12), 4);
			matrix.set(temp, 8);

			//reverse Z
			temp = matrix.subarray(8, 12);
			vec4.scale(temp, temp, -1);
		} else {
			var M = _glMatrix.mat4.create();
			var m = matrix;

			//if(inverted) mat4.invert(m,m);

			/* non trasposed
   M.set([m[0],m[8],-m[4]], 0);
   M.set([m[2],m[10],-m[6]], 4);
   M.set([-m[1],-m[9],m[5]], 8);
   M.set([m[3],m[11],-m[7]], 12);
   */

			M.set([m[0], m[2], -m[1]], 0);
			M.set([m[8], m[10], -m[9]], 4);
			M.set([-m[4], -m[6], m[5]], 8);
			M.set([m[12], m[14], -m[13]], 12);

			m.set(M);

			//if(inverted) mat4.invert(m,m);
		}
		return matrix;
	}
};

exports.default = Collada;
module.exports = exports['default'];
//# sourceMappingURL=Collada.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27)))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _xhr = __webpack_require__(81);

var _xhr2 = _interopRequireDefault(_xhr);

var _loadImages = __webpack_require__(41);

var _loadImages2 = _interopRequireDefault(_loadImages);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _Material = __webpack_require__(34);

var _Material2 = _interopRequireDefault(_Material);

var _Mesh = __webpack_require__(13);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _ShaderLibs = __webpack_require__(21);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

var _Shaders = __webpack_require__(16);

var _Shaders2 = _interopRequireDefault(_Shaders);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _Object3D = __webpack_require__(8);

var _Object3D2 = _interopRequireDefault(_Object3D);

var _promisePolyfill = __webpack_require__(42);

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

var _objectAssign = __webpack_require__(17);

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _WebglNumber = __webpack_require__(10);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ARRAY_CTOR_MAP = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
}; // GltfLoader.js

var SIZE_MAP = {
	SCALAR: 1,
	VEC2: 2,
	VEC3: 3,
	VEC4: 4,
	MAT2: 4,
	MAT3: 9,
	MAT4: 16
};

var semanticAttributeMap = {
	NORMAL: 'aNormal',
	POSITION: 'aVertexPosition',
	// 'TANGENT': 'aTangent',
	TEXCOORD_0: 'aTextureCoord',
	// TEXCOORD_1: 'aTextureCoord1',
	WEIGHTS_0: 'aWeight',
	JOINTS_0: 'aJoint',
	COLOR: 'aColor'
};

var base = void 0;

var load = function load(mSource) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		if (typeof mSource === 'string') {
			base = mSource.substring(0, mSource.lastIndexOf('/') + 1);
		} else {
			base = '';
		}

		_loadGltf(mSource).then(_loadBin).then(_loadTextures).then(_getBufferViewData).then(_parseMaterials).then(_parseMesh).then(_parseNodes).then(function (gltfInfo) {
			resolve(gltfInfo);
		}).catch(function (e) {
			console.log('Error:', e);
		});
	});
};

var _parseNodes = function _parseNodes(gltf) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var nodes = gltf.nodes,
		    scenes = gltf.scenes;


		var getTree = function getTree(nodeIndex) {
			var node = nodes[nodeIndex];
			var obj3D = node.mesh === undefined ? new _Object3D2.default() : gltf.output.meshes[node.mesh];

			if (node.scale) {
				obj3D.scaleX = node.scale[0];
				obj3D.scaleY = node.scale[1];
				obj3D.scaleZ = node.scale[2];
			}

			if (node.rotation) {
				obj3D.setRotationFromQuaternion(node.rotation);
			}

			if (node.translation) {
				obj3D.x = node.translation[0];
				obj3D.y = node.translation[1];
				obj3D.z = node.translation[2];
			}

			if (node.children) {
				node.children.forEach(function (child) {
					var _child = getTree(child);
					obj3D.addChild(_child);
				});
			}

			return obj3D;
		};

		gltf.output.scenes = scenes.map(function (scene) {
			var container = new _Object3D2.default();
			scene.nodes.forEach(function (nodeIndex) {
				var childTree = getTree(nodeIndex);
				container.addChild(childTree);
			});

			return container;
		});

		resolve(gltf);
	});
};

var _parseMesh = function _parseMesh(gltf) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var meshes = gltf.meshes;


		meshes.forEach(function (mesh) {
			var primitives = mesh.primitives;


			var geometryInfo = {};

			primitives.forEach(function (primitiveInfo) {
				var semantics = Object.keys(primitiveInfo.attributes);
				var defines = {};

				semantics.forEach(function (semantic) {
					var accessorIdx = primitiveInfo.attributes[semantic];
					var attributeInfo = gltf.accessors[accessorIdx];
					var attributeName = semanticAttributeMap[semantic];
					if (!attributeName) {
						return;
					}
					if (semantic === 'NORMAL') {
						defines.HAS_NORMALS = 1;
					}
					if (semantic.indexOf('TEXCOORD') > -1) {
						defines.HAS_UV = 1;
					}

					var size = SIZE_MAP[attributeInfo.type];
					var attributeArray = _getAccessorData(gltf, accessorIdx);
					if (attributeArray instanceof Uint32Array) {
						attributeArray = new Float32Array(attributeArray);
					}

					if (semantic === 'TEXCOORD_1') {
						console.log(size, attributeArray);
					}

					geometryInfo[attributeName] = {
						value: attributeArray,
						size: size
					};
					// console.log('attribute', attributeName, geometry[attributeName]);
				});

				//	parse index
				if (primitiveInfo.indices != null) {
					var attributeArray = _getAccessorData(gltf, primitiveInfo.indices, true);
					geometryInfo.indices = {
						value: attributeArray,
						size: 1
					};
				}

				var geometry = new _Geometry2.default();

				for (var s in geometryInfo) {
					var data = geometryInfo[s];
					if (s !== 'indices') {
						geometry.bufferFlattenData(data.value, s, data.size);
					} else {
						geometry.bufferIndex(data.value);
					}
				}

				var materialInfo = gltf.output.materialInfo[primitiveInfo.material];
				defines = (0, _objectAssign2.default)(defines, materialInfo.defines);

				var emissiveFacotr = materialInfo.emissiveFacotr,
				    normalTexture = materialInfo.normalTexture,
				    occlusionTexture = materialInfo.occlusionTexture,
				    pbrMetallicRoughness = materialInfo.pbrMetallicRoughness;
				var baseColorTexture = pbrMetallicRoughness.baseColorTexture,
				    metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;


				var uniforms = {
					uEmissiveFactor: emissiveFacotr || [0, 0, 0],
					uBaseColor: pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1],
					uRoughness: pbrMetallicRoughness.roughnessFactor || 1,
					uMetallic: pbrMetallicRoughness.metallicFactor || 1,
					uScaleDiffBaseMR: [0, 0, 0, 0],
					uScaleFGDSpec: [0, 0, 0, 0],
					uScaleIBLAmbient: [1, 1, 1, 1],
					uLightDirection: [1, 1, 1],
					uLightColor: [1, 1, 1],
					uGamma: 1
				};

				if (baseColorTexture) {
					uniforms.uColorMap = baseColorTexture.glTexture;
				}

				if (metallicRoughnessTexture) {
					uniforms.uMetallicRoughnessMap = metallicRoughnessTexture.glTexture;
				}

				if (normalTexture) {
					uniforms.uNormalScale = normalTexture.scale || 1;
					uniforms.uNormalMap = normalTexture.glTexture;
				}

				if (occlusionTexture) {
					uniforms.uAoMap = occlusionTexture.glTexture;
					uniforms.uOcclusionStrength = occlusionTexture.strength || 1;
				}

				var material = new _Material2.default(_ShaderLibs2.default.gltfVert, _ShaderLibs2.default.gltfFrag, uniforms, defines);
				var mesh = new _Mesh2.default(geometry, material);
				gltf.output.meshes.push(mesh);
			});
		});

		resolve(gltf);
	});
};

var _getBufferViewData = function _getBufferViewData(gltfInfo) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var bufferViews = gltfInfo.bufferViews,
		    buffers = gltfInfo.buffers;


		bufferViews.forEach(function (bufferViewInfo, i) {
			var buffer = buffers[bufferViewInfo.buffer].data;
			bufferViewInfo.data = buffer.slice(bufferViewInfo.byteOffset || 0, (bufferViewInfo.byteOffset || 0) + (bufferViewInfo.byteLength || 0));
		});
		resolve(gltfInfo);
	});
};

var _loadGltf = function _loadGltf(mSource) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		if (typeof mSource !== 'string') {
			resolve(mSource);
		} else {
			(0, _xhr2.default)(mSource).then(function (o) {
				var gltfInfo = JSON.parse(o);
				gltfInfo.output = {
					meshes: [],
					scenes: [],
					textures: [],
					material: [],
					materialInfo: []
				};

				resolve(gltfInfo);
			}, function (e) {
				reject(e);
			});
		}
	});
};

var _loadBin = function _loadBin(gltfInfo) {
	return new _promisePolyfill2.default(function (resolve, reject) {

		if (gltfInfo.buffers) {
			var count = gltfInfo.buffers.length;

			gltfInfo.buffers.forEach(function (buffer) {

				var urlBin = '' + base + gltfInfo.buffers[0].uri;
				(0, _xhr2.default)(urlBin, true).then(function (o) {
					buffer.data = o;

					count--;
					if (count === 0) {
						resolve(gltfInfo);
					}
				}, function (e) {
					reject(e);
				});
			});
		} else {
			resolve(gltfInfo);
		}
	});
};

var _loadTextures = function _loadTextures(gltfInfo) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var textures = gltfInfo.textures,
		    images = gltfInfo.images,
		    samplers = gltfInfo.samplers;

		if (!images) {
			resolve(gltfInfo);
		}

		var imagesToLoad = images.map(function (img) {
			return '' + base + img.uri;
		});

		(0, _loadImages2.default)(imagesToLoad).then(function (o) {
			gltfInfo.output.textures = o.map(function (img, i) {
				var settings = (0, _objectAssign2.default)({}, samplers ? samplers[textures[i].sampler] : {});
				return new _GLTexture2.default(img, settings);
			});
			resolve(gltfInfo);
		}, function (e) {
			reject(e);
		});
	});
};

var _parseMaterials = function _parseMaterials(gltfInfo) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var materials = gltfInfo.materials;
		var textures = gltfInfo.output.textures;


		gltfInfo.output.materialInfo = materials.map(function (material) {
			material.defines = {
				USE_IBL: 1
			};

			if (material.normalTexture) {
				material.defines.HAS_NORMALMAP = 1;
				material.normalTexture.glTexture = textures[material.normalTexture.index];
			}

			if (material.occlusionTexture) {
				material.defines.HAS_OCCLUSIONMAP = 1;
				material.occlusionTexture.glTexture = textures[material.occlusionTexture.index];
			}

			// if(material.pbrMetallicRoughness) {
			if (material.pbrMetallicRoughness.baseColorTexture) {
				material.defines.HAS_BASECOLORMAP = 1;
				material.pbrMetallicRoughness.baseColorTexture.glTexture = textures[material.pbrMetallicRoughness.baseColorTexture.index];
			}

			if (material.pbrMetallicRoughness.metallicRoughnessTexture) {
				material.defines.HAS_METALROUGHNESSMAP = 1;
				material.pbrMetallicRoughness.metallicRoughnessTexture.glTexture = textures[material.pbrMetallicRoughness.metallicRoughnessTexture.index];
			}

			// }

			return material;
		});

		resolve(gltfInfo);
	});
};

var parse = function parse(mGltfInfo, mBin) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		resolve(mSource);
	});
};

var _getAccessorData = function _getAccessorData(gltf, accessorIdx) {
	var isIndices = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	var accessorInfo = gltf.accessors[accessorIdx];
	var buffer = gltf.bufferViews[accessorInfo.bufferView].data;
	var byteOffset = accessorInfo.byteOffset || 0;
	var ArrayCtor = ARRAY_CTOR_MAP[accessorInfo.componentType] || Float32Array;
	var size = SIZE_MAP[accessorInfo.type];
	if (size == null && isIndices) {
		size = 1;
	}
	var arr = new ArrayCtor(buffer, byteOffset, size * accessorInfo.count);
	var quantizeExtension = accessorInfo.extensions && accessorInfo.extensions['WEB3D_quantized_attributes'];
	if (quantizeExtension) {
		var decodedArr = new Float32Array(size * accessorInfo.count);
		var decodeMatrix = quantizeExtension.decodeMatrix;
		var decodeOffset = new Array(size);
		var decodeScale = new Array(size);
		for (var k = 0; k < size; k++) {
			decodeOffset[k] = decodeMatrix[size * (size + 1) + k];
			decodeScale[k] = decodeMatrix[k * (size + 1) + k];
		}
		for (var i = 0; i < accessorInfo.count; i++) {
			for (var _k = 0; _k < size; _k++) {
				decodedArr[i * size + _k] = arr[i * size + _k] * decodeScale[_k] + decodeOffset[_k];
			}
		}

		arr = decodedArr;
	}

	// console.log({buffer, byteOffset, ArrayCtor, size, arr});

	return arr;
};

exports.default = {
	load: load,
	parse: parse
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// xhr.js

var load = function load(mPath, isArrayBuffer) {
	return new Promise(function (resolve, reject) {
		var req = new XMLHttpRequest();
		req.addEventListener('load', function (e) {
			resolve(req.response);
		});

		req.addEventListener('error', function (e) {
			reject(e);
		});

		if (isArrayBuffer) {
			req.responseType = 'arraybuffer';
		}

		req.open('GET', mPath);
		req.send();
	});
};

exports.default = load;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(83);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27), __webpack_require__(84)))

/***/ }),
/* 84 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // EffectComposer.js

var _Pass = __webpack_require__(12);

var _Pass2 = _interopRequireDefault(_Pass);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _FrameBuffer = __webpack_require__(18);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EffectComposer = function () {
	function EffectComposer(mWidth, mHeight) {
		var mParmas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, EffectComposer);

		this._width = mWidth || _GLTool2.default.width;
		this._height = mHeight || _GLTool2.default.height;

		this._params = {};
		this.setSize(mWidth, mHeight);
		this._geometry = _Geom2.default.bigTriangle();
		this._passes = [];
		this._returnTexture;
	}

	_createClass(EffectComposer, [{
		key: 'addPass',
		value: function addPass(pass) {
			if (pass.passes) {
				this.addPass(pass.passes);
				return;
			}

			if (pass.length) {
				for (var i = 0; i < pass.length; i++) {
					this._passes.push(pass[i]);
				}
			} else {
				this._passes.push(pass);
			}
		}
	}, {
		key: 'render',
		value: function render(mSource) {
			var _this = this;

			var source = mSource;
			var fboTarget = void 0;

			this._passes.forEach(function (pass) {

				//	get target
				if (pass.hasFbo) {
					fboTarget = pass.fbo;
				} else {
					fboTarget = _this._fboTarget;
				}

				//	render
				fboTarget.bind();
				_GLTool2.default.clear(0, 0, 0, 0);
				pass.render(source);
				_GLTool2.default.draw(_this._geometry);
				fboTarget.unbind();

				//	reset source
				if (pass.hasFbo) {
					source = pass.fbo.getTexture();
				} else {
					_this._swap();
					source = _this._fboCurrent.getTexture();
				}
			});

			this._returnTexture = source;

			return source;
		}
	}, {
		key: '_swap',
		value: function _swap() {
			var tmp = this._fboCurrent;
			this._fboCurrent = this._fboTarget;
			this._fboTarget = tmp;

			this._current = this._fboCurrent;
			this._target = this._fboTarget;
		}
	}, {
		key: 'setSize',
		value: function setSize(mWidth, mHeight) {
			this._width = mWidth;
			this._height = mHeight;
			this._fboCurrent = new _FrameBuffer2.default(this._width, this._height, this._params);
			this._fboTarget = new _FrameBuffer2.default(this._width, this._height, this._params);
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this._returnTexture;
		}
	}, {
		key: 'passes',
		get: function get() {
			return this._passes;
		}
	}]);

	return EffectComposer;
}();

exports.default = EffectComposer;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassVBlur = __webpack_require__(44);

var _PassVBlur2 = _interopRequireDefault(_PassVBlur);

var _PassHBlur = __webpack_require__(46);

var _PassHBlur2 = _interopRequireDefault(_PassHBlur);

var _PassMacro2 = __webpack_require__(43);

var _PassMacro3 = _interopRequireDefault(_PassMacro2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassBlur.js

var PassBlur = function (_PassMacro) {
	_inherits(PassBlur, _PassMacro);

	function PassBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassBlur);

		var _this = _possibleConstructorReturn(this, (PassBlur.__proto__ || Object.getPrototypeOf(PassBlur)).call(this));

		var vBlur = new _PassVBlur2.default(mQuality, mWidth, mHeight, mParams);
		var hBlur = new _PassHBlur2.default(mQuality, mWidth, mHeight, mParams);

		_this.addPass(vBlur);
		_this.addPass(hBlur);
		return _this;
	}

	return PassBlur;
}(_PassMacro3.default);

exports.default = PassBlur;

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = "// blur5.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_5\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3333333333333333) * direction;\n\tcolor += texture2D(image, uv) * 0.29411764705882354;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;\n\treturn color; \n}\n\n\nvoid main(void) {\n    gl_FragColor = blur5(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = "// blur9.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_9\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3846153846) * direction;\n\tvec2 off2 = vec2(3.2307692308) * direction;\n\tcolor += texture2D(image, uv) * 0.2270270270;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur9(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = "// blur13.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_13\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.411764705882353) * direction;\n\tvec2 off2 = vec2(3.2941176470588234) * direction;\n\tvec2 off3 = vec2(5.176470588235294) * direction;\n\tcolor += texture2D(image, uv) * 0.1964825501511404;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;\n\tcolor += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur13(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Pass2 = __webpack_require__(12);

var _Pass3 = _interopRequireDefault(_Pass2);

var _fxaa = __webpack_require__(47);

var _fxaa2 = _interopRequireDefault(_fxaa);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassFxaa.js

var PassFxaa = function (_Pass) {
	_inherits(PassFxaa, _Pass);

	function PassFxaa() {
		_classCallCheck(this, PassFxaa);

		var _this = _possibleConstructorReturn(this, (PassFxaa.__proto__ || Object.getPrototypeOf(PassFxaa)).call(this, _fxaa2.default));

		_this.uniform('uResolution', [1 / _GLTool2.default.width, 1 / _GLTool2.default.height]);
		return _this;
	}

	return PassFxaa;
}(_Pass3.default);

exports.default = PassFxaa;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchCopy.js

var vs = __webpack_require__(22);
var fs = __webpack_require__(23);

var BatchCopy = function (_Batch) {
	_inherits(BatchCopy, _Batch);

	function BatchCopy() {
		_classCallCheck(this, BatchCopy);

		var mesh = _Geom2.default.bigTriangle();
		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchCopy.__proto__ || Object.getPrototypeOf(BatchCopy)).call(this, mesh, shader));

		shader.bind();
		shader.uniform('texture', 'uniform1i', 0);
		return _this;
	}

	_createClass(BatchCopy, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchCopy.prototype.__proto__ || Object.getPrototypeOf(BatchCopy.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchCopy;
}(_Batch3.default);

exports.default = BatchCopy;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchAxis.js

var vs = __webpack_require__(93);
var fs = __webpack_require__(94);

var BatchAxis = function (_Batch) {
	_inherits(BatchAxis, _Batch);

	function BatchAxis() {
		_classCallCheck(this, BatchAxis);

		var positions = [];
		var colors = [];
		var indices = [0, 1, 2, 3, 4, 5];
		var r = 9999;

		positions.push([-r, 0, 0]);
		positions.push([r, 0, 0]);
		positions.push([0, -r, 0]);
		positions.push([0, r, 0]);
		positions.push([0, 0, -r]);
		positions.push([0, 0, r]);

		colors.push([1, 0, 0]);
		colors.push([1, 0, 0]);
		colors.push([0, 1, 0]);
		colors.push([0, 1, 0]);
		colors.push([0, 0, 1]);
		colors.push([0, 0, 1]);

		var mesh = new _Geometry2.default(_GLTool2.default.LINES);
		mesh.bufferVertex(positions);
		mesh.bufferIndex(indices);
		mesh.bufferData(colors, 'aColor', 3);

		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchAxis.__proto__ || Object.getPrototypeOf(BatchAxis)).call(this, mesh, shader));
	}

	return BatchAxis;
}(_Batch3.default);

exports.default = BatchAxis;

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = "// axis.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aColor;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vColor = aColor;\n    vNormal = aNormal;\n}"

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = "// axis.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\t// vec3 color = vNormal;\n\tvec3 color = vColor + vNormal * 0.0001;\n    gl_FragColor = vec4(color, 1.0);\n}"

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchBall.js

var vs = __webpack_require__(37);
var fs = __webpack_require__(11);

var BatchBall = function (_Batch) {
	_inherits(BatchBall, _Batch);

	function BatchBall() {
		_classCallCheck(this, BatchBall);

		var geometry = _Geom2.default.sphere(1, 24);
		var shader = new _GLShader2.default(vs, fs);
		return _possibleConstructorReturn(this, (BatchBall.__proto__ || Object.getPrototypeOf(BatchBall)).call(this, geometry, shader));
	}

	_createClass(BatchBall, [{
		key: 'draw',
		value: function draw() {
			var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
			var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1];
			var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1];
			var opacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

			this.shader.bind();
			this.shader.uniform('position', 'uniform3fv', position);
			this.shader.uniform('scale', 'uniform3fv', scale);
			this.shader.uniform('color', 'uniform3fv', color);
			this.shader.uniform('opacity', 'uniform1f', opacity);
			_get(BatchBall.prototype.__proto__ || Object.getPrototypeOf(BatchBall.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchBall;
}(_Batch3.default);

exports.default = BatchBall;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchDotsPlane.js

var vs = __webpack_require__(97);
var fs = __webpack_require__(11);

var BatchDotsPlane = function (_Batch) {
	_inherits(BatchDotsPlane, _Batch);

	function BatchDotsPlane() {
		_classCallCheck(this, BatchDotsPlane);

		var positions = [];
		var indices = [];
		var index = 0;
		var size = 100;
		var i = void 0,
		    j = void 0;

		for (i = -size; i < size; i += 1) {
			for (j = -size; j < size; j += 1) {
				positions.push([i, j, 0]);
				indices.push(index);
				index++;

				positions.push([i, 0, j]);
				indices.push(index);
				index++;
			}
		}

		var geometry = new _Geometry2.default(_GLTool2.default.POINTS);
		geometry.bufferVertex(positions);
		geometry.bufferIndex(indices);

		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchDotsPlane.__proto__ || Object.getPrototypeOf(BatchDotsPlane)).call(this, geometry, shader));

		_this.color = [1, 1, 1];
		_this.opacity = 0.5;
		return _this;
	}

	_createClass(BatchDotsPlane, [{
		key: 'draw',
		value: function draw() {
			this.shader.bind();
			this.shader.uniform('color', 'uniform3fv', this.color);
			this.shader.uniform('opacity', 'uniform1f', this.opacity);
			_get(BatchDotsPlane.prototype.__proto__ || Object.getPrototypeOf(BatchDotsPlane.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchDotsPlane;
}(_Batch3.default);

exports.default = BatchDotsPlane;

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME DOTS_PLANE_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition + aNormal * 0.000001, 1.0);\n    gl_PointSize = 1.0;\n    vNormal = aNormal;\n}"

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchLine.js


var vs = __webpack_require__(15);
var fs = __webpack_require__(11);

var BatchAxis = function (_Batch) {
	_inherits(BatchAxis, _Batch);

	function BatchAxis() {
		_classCallCheck(this, BatchAxis);

		var positions = [];
		var indices = [0, 1];
		var coords = [[0, 0], [1, 1]];
		positions.push([0, 0, 0]);
		positions.push([0, 0, 0]);

		var geometry = new _Geometry2.default(_GLTool2.default.LINES);
		geometry.bufferVertex(positions);
		geometry.bufferTexCoord(coords);
		geometry.bufferIndex(indices);

		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchAxis.__proto__ || Object.getPrototypeOf(BatchAxis)).call(this, geometry, shader));
	}

	_createClass(BatchAxis, [{
		key: 'draw',
		value: function draw(mPositionA, mPositionB) {
			var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1];
			var opacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;

			this._geometry.bufferVertex([mPositionA, mPositionB]);

			this._shader.bind();
			this._shader.uniform('color', 'vec3', color);
			this._shader.uniform('opacity', 'float', opacity);
			_get(BatchAxis.prototype.__proto__ || Object.getPrototypeOf(BatchAxis.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchAxis;
}(_Batch3.default);

exports.default = BatchAxis;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchSkybox.js

var vs = __webpack_require__(38);
var fs = __webpack_require__(39);

var BatchSkybox = function (_Batch) {
	_inherits(BatchSkybox, _Batch);

	function BatchSkybox() {
		var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;

		_classCallCheck(this, BatchSkybox);

		var geometry = _Geom2.default.skybox(size);
		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchSkybox.__proto__ || Object.getPrototypeOf(BatchSkybox)).call(this, geometry, shader));
	}

	_createClass(BatchSkybox, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchSkybox.prototype.__proto__ || Object.getPrototypeOf(BatchSkybox.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchSkybox;
}(_Batch3.default);

exports.default = BatchSkybox;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchSky.js

var vs = __webpack_require__(101);
var fs = __webpack_require__(23);

var BatchSky = function (_Batch) {
	_inherits(BatchSky, _Batch);

	function BatchSky() {
		var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
		var seg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;

		_classCallCheck(this, BatchSky);

		var geometry = _Geom2.default.sphere(size, seg, true);
		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchSky.__proto__ || Object.getPrototypeOf(BatchSky)).call(this, geometry, shader));
	}

	_createClass(BatchSky, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchSky.prototype.__proto__ || Object.getPrototypeOf(BatchSky.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchSky;
}(_Batch3.default);

exports.default = BatchSky;

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = "// sky.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n    gl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchFXAA.js


var vs = __webpack_require__(22);
var fs = __webpack_require__(47);

var BatchFXAA = function (_Batch) {
	_inherits(BatchFXAA, _Batch);

	function BatchFXAA() {
		_classCallCheck(this, BatchFXAA);

		var geometry = _Geom2.default.bigTriangle();
		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchFXAA.__proto__ || Object.getPrototypeOf(BatchFXAA)).call(this, geometry, shader));

		shader.bind();
		shader.uniform('texture', 'uniform1i', 0);
		return _this;
	}

	_createClass(BatchFXAA, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			this.shader.uniform('uResolution', 'vec2', [1 / _GLTool2.default.width, 1 / _GLTool2.default.height]);
			_get(BatchFXAA.prototype.__proto__ || Object.getPrototypeOf(BatchFXAA.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchFXAA;
}(_Batch3.default);

exports.default = BatchFXAA;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Scene.js

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _CameraPerspective = __webpack_require__(25);

var _CameraPerspective2 = _interopRequireDefault(_CameraPerspective);

var _CameraOrtho = __webpack_require__(40);

var _CameraOrtho2 = _interopRequireDefault(_CameraOrtho);

var _OrbitalControl = __webpack_require__(36);

var _OrbitalControl2 = _interopRequireDefault(_OrbitalControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scene = function () {
	function Scene() {
		var _this = this;

		_classCallCheck(this, Scene);

		this._children = [];
		this._matrixIdentity = mat4.create();
		_GLTool2.default.enableAlphaBlending();

		this._init();
		this._initTextures();
		this._initViews();

		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._loop();
		});
		window.addEventListener('resize', function () {
			return _this.resize();
		});
	}

	//	PUBLIC METHODS

	_createClass(Scene, [{
		key: 'update',
		value: function update() {}
	}, {
		key: 'render',
		value: function render() {}
	}, {
		key: 'stop',
		value: function stop() {
			if (this._efIndex === -1) {
				return;
			}
			this._efIndex = _scheduling2.default.removeEF(this._efIndex);
		}
	}, {
		key: 'start',
		value: function start() {
			var _this2 = this;

			if (this._efIndex !== -1) {
				return;
			}

			this._efIndex = _scheduling2.default.addEF(function () {
				return _this2._loop();
			});
		}
	}, {
		key: 'resize',
		value: function resize() {
			_GLTool2.default.setSize(window.innerWidth, window.innerHeight);
			this.camera.setAspectRatio(_GLTool2.default.aspectRatio);
		}
	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}

		//	PROTECTED METHODS TO BE OVERRIDEN BY CHILDREN

	}, {
		key: '_initTextures',
		value: function _initTextures() {}
	}, {
		key: '_initViews',
		value: function _initViews() {}
	}, {
		key: '_renderChildren',
		value: function _renderChildren() {
			var child = void 0;
			for (var i = 0; i < this._children.length; i++) {
				child = this._children[i];
				child.toRender();
			}

			_GLTool2.default.rotate(this._matrixIdentity);
		}

		//	PRIVATE METHODS

	}, {
		key: '_init',
		value: function _init() {
			this.camera = new _CameraPerspective2.default();
			this.camera.setPerspective(45 * Math.PI / 180, _GLTool2.default.aspectRatio, 0.1, 100);
			this.orbitalControl = new _OrbitalControl2.default(this.camera, window, 15);
			this.orbitalControl.radius.value = 10;

			this.cameraOrtho = new _CameraOrtho2.default();
		}
	}, {
		key: '_loop',
		value: function _loop() {

			//	RESET VIEWPORT
			_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);

			//	RESET CAMERA
			_GLTool2.default.setMatrices(this.camera);

			this.update();
			this._renderChildren();
			this.render();
		}
	}]);

	return Scene;
}();

exports.default = Scene;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // View.js

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var View = function () {
	function View(mStrVertex, mStrFrag) {
		_classCallCheck(this, View);

		this.shader = new _GLShader2.default(mStrVertex, mStrFrag);

		this._init();
	}

	//	PROTECTED METHODS

	_createClass(View, [{
		key: '_init',
		value: function _init() {}

		// 	PUBLIC METHODS

	}, {
		key: 'render',
		value: function render() {}
	}]);

	return View;
}();

exports.default = View;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Object3D2 = __webpack_require__(8);

var _Object3D3 = _interopRequireDefault(_Object3D2);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // View3D.js

var View3D = function (_Object3D) {
	_inherits(View3D, _Object3D);

	function View3D(mStrVertex, mStrFrag) {
		_classCallCheck(this, View3D);

		var _this = _possibleConstructorReturn(this, (View3D.__proto__ || Object.getPrototypeOf(View3D)).call(this));

		_this._children = [];
		_this.shader = new _GLShader2.default(mStrVertex, mStrFrag);
		_this._init();
		_this._matrixTemp = mat4.create();
		return _this;
	}

	//	PROTECTED METHODS

	_createClass(View3D, [{
		key: '_init',
		value: function _init() {}

		// 	PUBLIC METHODS

	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}
	}, {
		key: 'toRender',
		value: function toRender(matrix) {
			if (matrix === undefined) {
				matrix = mat4.create();
			}
			mat4.mul(this._matrixTemp, matrix, this.matrix);
			_GLTool2.default.rotate(this._matrixTemp);
			this.render();

			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				child.toRender(this.matrix);
			}
		}
	}, {
		key: 'render',
		value: function render() {}
	}]);

	return View3D;
}(_Object3D3.default);

exports.default = View3D;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _assetList = __webpack_require__(107);

var _assetList2 = _interopRequireDefault(_assetList);

var _alfrid = __webpack_require__(28);

var _alfrid2 = _interopRequireDefault(_alfrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Assets.js

var Assets = {};
var _assets = [];

var getAsset = function getAsset(id) {
	return assets.find(function (a) {
		return a.id === id;
	}).file;
};

var getExtension = function getExtension(mFile) {
	var ary = mFile.split('.');
	return ary[ary.length - 1];
};

Assets.init = function () {
	var hdrCubemaps = {};
	_assets = _assetList2.default.map(function (o) {
		var ext = getExtension(o.url);
		var file = getAsset(o.id);
		var texture = void 0;

		switch (ext) {
			case 'jpg':
			case 'png':
				texture = new _alfrid.GLTexture(file);
				return {
					id: o.id,
					file: texture
				};
				break;

			case 'hdr':
				var cubemapName = o.id.split('_')[0];
				texture = _alfrid2.default.HDRLoader.parse(file);

				var oAsset = {
					id: o.id,
					file: texture
				};

				if (!hdrCubemaps[cubemapName]) {
					hdrCubemaps[cubemapName] = [];
				}

				hdrCubemaps[cubemapName].push(oAsset);
				return oAsset;

				break;
			case 'dds':
				texture = _alfrid.GLCubeTexture.parseDDS(file);
				return {
					id: o.id,
					file: texture
				};
				break;

			case 'obj':
				var mesh = _alfrid.ObjLoader.parse(file);
				return {
					id: o.id,
					file: mesh
				};
				break;
		}
	});

	for (var s in hdrCubemaps) {
		if (hdrCubemaps[s].length == 6) {
			console.log('Generate Cubemap :', s);

			var ary = [Assets.get(s + '_posx'), Assets.get(s + '_negx'), Assets.get(s + '_posy'), Assets.get(s + '_negy'), Assets.get(s + '_posz'), Assets.get(s + '_negz')];

			var texture = new _alfrid2.default.GLCubeTexture(ary);
			_assets.push({
				id: s,
				file: texture
			});
		}
	}

	if (_assets.length > 0) {
		console.debug('ASSETS:');
		console.table(_assets);
	}
};

Assets.get = function (mId) {
	return _assets.find(function (a) {
		return a.id === mId;
	}).file;
};

exports.default = Assets;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var assetsToLoad = [{ "id": "albedo", "url": "assets/img/albedo.jpg", "type": "jpg" }, { "id": "ao", "url": "assets/img/ao.jpg", "type": "jpg" }, { "id": "brdfLUT", "url": "assets/img/brdfLUT.png", "type": "png" }, { "id": "metalGloss", "url": "assets/img/metalGloss.jpg", "type": "jpg" }, { "id": "normal", "url": "assets/img/normal.jpg", "type": "jpg" }, { "id": "pisa_irradiance", "url": "assets/img/pisa_irradiance.dds", "type": "binary" }, { "id": "pisa_radiance", "url": "assets/img/pisa_radiance.dds", "type": "binary" }, { "id": "studio10_irradiance", "url": "assets/img/studio10_irradiance.dds", "type": "binary" }, { "id": "studio10_radiance", "url": "assets/img/studio10_radiance.dds", "type": "binary" }, { "id": "studio11_irradiance", "url": "assets/img/studio11_irradiance.dds", "type": "binary" }, { "id": "studio11_radiance", "url": "assets/img/studio11_radiance.dds", "type": "binary" }, { "id": "studio12_irradiance", "url": "assets/img/studio12_irradiance.dds", "type": "binary" }, { "id": "studio12_radiance", "url": "assets/img/studio12_radiance.dds", "type": "binary" }, { "id": "studio1_irradiance", "url": "assets/img/studio1_irradiance.dds", "type": "binary" }, { "id": "studio1_radiance", "url": "assets/img/studio1_radiance.dds", "type": "binary" }, { "id": "studio2_irradiance", "url": "assets/img/studio2_irradiance.dds", "type": "binary" }, { "id": "studio2_radiance", "url": "assets/img/studio2_radiance.dds", "type": "binary" }, { "id": "studio3_irradiance", "url": "assets/img/studio3_irradiance.dds", "type": "binary" }, { "id": "studio3_radiance", "url": "assets/img/studio3_radiance.dds", "type": "binary" }, { "id": "studio4_irradiance", "url": "assets/img/studio4_irradiance.dds", "type": "binary" }, { "id": "studio4_radiance", "url": "assets/img/studio4_radiance.dds", "type": "binary" }, { "id": "studio5_irradiance", "url": "assets/img/studio5_irradiance.dds", "type": "binary" }, { "id": "studio5_radiance", "url": "assets/img/studio5_radiance.dds", "type": "binary" }, { "id": "studio6_irradiance", "url": "assets/img/studio6_irradiance.dds", "type": "binary" }, { "id": "studio6_radiance", "url": "assets/img/studio6_radiance.dds", "type": "binary" }, { "id": "studio7_irradiance", "url": "assets/img/studio7_irradiance.dds", "type": "binary" }, { "id": "studio7_radiance", "url": "assets/img/studio7_radiance.dds", "type": "binary" }, { "id": "studio8_irradiance", "url": "assets/img/studio8_irradiance.dds", "type": "binary" }, { "id": "studio8_radiance", "url": "assets/img/studio8_radiance.dds", "type": "binary" }, { "id": "studio9_irradiance", "url": "assets/img/studio9_irradiance.dds", "type": "binary" }, { "id": "studio9_radiance", "url": "assets/img/studio9_radiance.dds", "type": "binary" }, { "id": "vatican_irradiance", "url": "assets/img/vatican_irradiance.dds", "type": "binary" }, { "id": "vatican_radiance", "url": "assets/img/vatican_radiance.dds", "type": "binary" }];

exports.default = assetsToLoad;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// Config.js

exports.default = {};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var EventEmitter = __webpack_require__(129).EventEmitter;

function Emitter() {
    EventEmitter.call(this);
    this.setMaxListeners(20);
}

Emitter.prototype = Object.create(EventEmitter.prototype);
Emitter.prototype.constructor = Emitter;

Emitter.prototype.off = function(type, listener) {
    if (listener) {
        return this.removeListener(type, listener);
    }
    if (type) {
        return this.removeAllListeners(type);
    }
    return this.removeAllListeners();
};

module.exports = Emitter;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
    mbs: 0,
    secs: 0,
    update: function(request, startTime, url, log) {
        var length;
        var headers = request.getAllResponseHeaders();
        if (headers) {
            var match = headers.match(/content-length: (\d+)/i);
            if (match && match.length) {
                length = match[1];
            }
        }
        // var length = request.getResponseHeader('Content-Length');
        if (length) {
            length = parseInt(length, 10);
            var mbs = length / 1024 / 1024;
            var secs = (Date.now() - startTime) / 1000;
            this.secs += secs;
            this.mbs += mbs;
            if (log) {
                this.log(url, mbs, secs);
            }
        } else if(log) {
            console.warn.call(console, 'Can\'t get Content-Length:', url);
        }
    },
    log: function(url, mbs, secs) {
        if (url) {
            var file = 'File loaded: ' +
                url.substr(url.lastIndexOf('/') + 1) +
                ' size:' + mbs.toFixed(2) + 'mb' +
                ' time:' + secs.toFixed(2) + 's' +
                ' speed:' + (mbs / secs).toFixed(2) + 'mbps';

            console.log.call(console, file);
        }
        var total = 'Total loaded: ' + this.mbs.toFixed(2) + 'mb' +
            ' time:' + this.secs.toFixed(2) + 's' +
            ' speed:' + this.getMbps().toFixed(2) + 'mbps';
        console.log.call(console, total);
    },
    getMbps: function() {
        return this.mbs / this.secs;
    }
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(112);

var _debugPolyfill = __webpack_require__(116);

var _debugPolyfill2 = _interopRequireDefault(_debugPolyfill);

var _alfrid = __webpack_require__(28);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _SceneApp = __webpack_require__(117);

var _SceneApp2 = _interopRequireDefault(_SceneApp);

var _assetsLoader = __webpack_require__(127);

var _assetsLoader2 = _interopRequireDefault(_assetsLoader);

var _assetList = __webpack_require__(107);

var _assetList2 = _interopRequireDefault(_assetList);

var _Assets = __webpack_require__(106);

var _Assets2 = _interopRequireDefault(_Assets);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (document.body) {
	_init();
} else {
	window.addEventListener('DOMContentLoaded', _init);
}

function _init() {

	//	LOADING ASSETS
	if (_assetList2.default.length > 0) {
		document.body.classList.add('isLoading');

		var loader = new _assetsLoader2.default({
			assets: _assetList2.default
		}).on('error', function (error) {
			console.log('Error :', error);
		}).on('progress', function (p) {
			// console.log('Progress : ', p);
			var loader = document.body.querySelector('.Loading-Bar');
			if (loader) loader.style.width = p * 100 + '%';
		}).on('complete', _onImageLoaded).start();
	} else {
		_init3D();
	}
}

function _onImageLoaded(o) {
	//	ASSETS
	console.log('Image Loaded : ', o);
	window.assets = o;
	var loader = document.body.querySelector('.Loading-Bar');
	console.log('Loader :', loader);
	loader.style.width = '100%';

	_init3D();

	setTimeout(function () {
		document.body.classList.remove('isLoading');
	}, 250);
}

function _init3D() {
	//	CREATE CANVAS
	var canvas = document.createElement('canvas');
	canvas.className = 'Main-Canvas';
	document.body.appendChild(canvas);

	//	INIT 3D TOOL
	_alfrid.GL.init(canvas, { ignoreWebgl2: true });

	//	INIT ASSETS
	_Assets2.default.init();

	//	CREATE SCENE
	var scene = new _SceneApp2.default();
}

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(48);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(114)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(true) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept(48, function() {
			var newContent = __webpack_require__(48);
			if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 113 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(115);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 115 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// debugPolyfill.js

window.gui = {
	add: function add() {}
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _alfrid = __webpack_require__(28);

var _alfrid2 = _interopRequireDefault(_alfrid);

var _Assets = __webpack_require__(106);

var _Assets2 = _interopRequireDefault(_Assets);

var _Settings = __webpack_require__(118);

var _Settings2 = _interopRequireDefault(_Settings);

var _Config = __webpack_require__(108);

var _Config2 = _interopRequireDefault(_Config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // SceneApp.js

var SceneApp = function (_Scene) {
	_inherits(SceneApp, _Scene);

	function SceneApp() {
		_classCallCheck(this, SceneApp);

		_Settings2.default.init();

		var _this = _possibleConstructorReturn(this, (SceneApp.__proto__ || Object.getPrototypeOf(SceneApp)).call(this));

		_this.resize();
		_alfrid.GL.enableAlphaBlending();
		_this.orbitalControl.rx.value = _this.orbitalControl.ry.value = 0.3;
		_this.orbitalControl.radius.value = 5;
		return _this;
	}

	_createClass(SceneApp, [{
		key: '_initTextures',
		value: function _initTextures() {
			var _this2 = this;

			this.textureBrdf = _Assets2.default.get('brdfLUT');
			this.env = 'studio1';

			var envs = ['pisa', 'vatican'];
			for (var i = 1; i <= 12; i++) {
				envs.push('studio' + i);
			}

			this._updateEnvMap();

			gui.add(this, 'env', envs).onFinishChange(function () {
				return _this2._updateEnvMap();
			});
		}
	}, {
		key: '_initViews',
		value: function _initViews() {
			var _this3 = this;

			console.log('init views');

			this._bCopy = new _alfrid2.default.BatchCopy();
			this._bAxis = new _alfrid2.default.BatchAxis();
			this._bDots = new _alfrid2.default.BatchDotsPlane();
			this._bSky = new _alfrid2.default.BatchSkybox();

			var url = 'assets/gltf/FlightHelmet.gltf';
			_alfrid.GLTFLoader.load(url).then(function (gltfInfo) {
				_this3.gltf = gltfInfo;
				var meshes = gltfInfo.output.meshes;

				_this3.scenes = gltfInfo.output.scenes;

				meshes.forEach(function (mesh) {
					mesh.material.uniforms.uBRDFMap = _this3.textureBrdf;
					mesh.material.uniforms.uIrradianceMap = _this3.textureIrr;
					mesh.material.uniforms.uRadianceMap = _this3.textureRad;
				});
			}).catch(function (e) {
				console.log('Error loading gltf:', e);
			});
		}
	}, {
		key: '_updateEnvMap',
		value: function _updateEnvMap() {
			var _this4 = this;

			this.textureIrr = _Assets2.default.get(this.env + '_irradiance');
			this.textureRad = _Assets2.default.get(this.env + '_radiance');

			if (this.gltf) {
				var meshes = this.gltf.output.meshes;


				meshes.forEach(function (mesh) {
					mesh.material.uniforms.uBRDFMap = _this4.textureBrdf;
					mesh.material.uniforms.uIrradianceMap = _this4.textureIrr;
					mesh.material.uniforms.uRadianceMap = _this4.textureRad;
				});
			}
		}
	}, {
		key: 'render',
		value: function render() {
			_alfrid.GL.clear(0, 0, 0, 0);

			this._bSky.draw(this.textureRad);

			if (this.scenes) {
				this.scenes.forEach(function (scene) {
					_alfrid.GL.draw(scene);
				});
			}
		}
	}, {
		key: 'resize',
		value: function resize() {
			var _window = window,
			    innerWidth = _window.innerWidth,
			    innerHeight = _window.innerHeight,
			    devicePixelRatio = _window.devicePixelRatio;

			_alfrid.GL.setSize(innerWidth, innerHeight);
			this.camera.setAspectRatio(_alfrid.GL.aspectRatio);
		}
	}]);

	return SceneApp;
}(_alfrid.Scene);

exports.default = SceneApp;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Config = __webpack_require__(108);

var _Config2 = _interopRequireDefault(_Config);

var _fastUrlParser = __webpack_require__(119);

var _fastUrlParser2 = _interopRequireDefault(_fastUrlParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Settings.js

_fastUrlParser2.default.queryString = __webpack_require__(125);

var enabled = true;

var reload = function reload() {
	if (!enabled) {
		return;
	}
	window.location.href = window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config2.default);
};

var refresh = function refresh() {
	if (!enabled) {
		return;
	}
	window.history.pushState('experiment', 'Title', window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config2.default));
};

var delayIndex = -1;

var delayReload = function delayReload() {
	if (!enabled) {
		return;
	}
	window.clearTimeout(delayIndex);

	delayIndex = window.setTimeout(function () {
		window.location.href = window.location.origin + window.location.pathname + '?config=' + JSON.stringify(_Config2.default);
	}, 500);
};

var init = function init() {
	var mEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	enabled = mEnabled;
	var parsed = _fastUrlParser2.default.parse(window.location.search, true);

	if (parsed.query.config) {
		var oConfig = JSON.parse(parsed.query.config);

		for (var key in oConfig) {
			_Config2.default[key] = oConfig[key];
		}
	}

	console.log('Config :', _Config2.default);
	refresh();
};

exports.default = {
	enabled: enabled,
	reload: reload,
	refresh: refresh,
	delayReload: delayReload,
	init: init
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
Copyright (c) 2014 Petka Antonov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
function Url() {
    //For more efficient internal representation and laziness.
    //The non-underscore versions of these properties are accessor functions
    //defined on the prototype.
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;

    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;

    this._prependSlash = false;
}

var querystring = __webpack_require__(120);

Url.queryString = querystring;

Url.prototype.parse =
function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " +
            typeof str);
    }
    var start = 0;
    var end = str.length - 1;

    //Trim leading and trailing ws
    while (str.charCodeAt(start) <= 0x20 /*' '*/) start++;
    while (str.charCodeAt(end) <= 0x20 /*' '*/) end--;

    start = this._parseProtocol(str, start, end);

    //Javascript doesn't have host
    if (this._protocol !== "javascript") {
        start = this._parseHost(str, start, end, hostDenotesSlash);
        var proto = this._protocol;
        if (!this.hostname &&
            (this.slashes || (proto && !slashProtocols[proto]))) {
            this.hostname = this.host = "";
        }
    }

    if (start <= end) {
        var ch = str.charCodeAt(start);

        if (ch === 0x2F /*'/'*/ || ch === 0x5C /*'\'*/) {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, start, end, disableAutoEscapeChars);
        }
        else if (ch === 0x23 /*'#'*/) {
          this._parseHash(str, start, end, disableAutoEscapeChars);
        }
        else if (this._protocol !== "javascript") {
            this._parsePath(str, start, end, disableAutoEscapeChars);
        }
        else { //For javascript the pathname is just the rest of it
            this.pathname = str.slice(start, end + 1 );
        }

    }

    if (!this.pathname && this.hostname &&
        this._slashProtocols[this._protocol]) {
        this.pathname = "/";
    }

    if (parseQueryString) {
        var search = this.search;
        if (search == null) {
            search = this.search = "";
        }
        if (search.charCodeAt(0) === 0x3F /*'?'*/) {
            search = search.slice(1);
        }
        //This calls a setter function, there is no .query data property
        this.query = Url.queryString.parse(search);
    }
};

Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
};

Url.prototype.format = function Url$format() {
    var auth = this.auth || "";

    if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
    }

    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";

    //Cache the result of the getter function
    var q = this.query;
    if (q && typeof q === "object") {
        query = Url.queryString.stringify(q);
    }

    if (!search) {
        search = query ? "?" + query : "";
    }

    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/)
        protocol += ":";

    if (this.host) {
        host = auth + this.host;
    }
    else if (hostname) {
        var ip6 = hostname.indexOf(":") > -1;
        if (ip6) hostname = "[" + hostname + "]";
        host = auth + hostname + (port ? ":" + port : "");
    }

    var slashes = this.slashes ||
        ((!protocol ||
        slashProtocols[protocol]) && host !== false);


    if (protocol) scheme = protocol + (slashes ? "//" : "");
    else if (slashes) scheme = "//";

    if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/) {
        pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 0x3F /*'?'*/)
        search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/)
        hash = "#" + hash;

    pathname = escapePathName(pathname);
    search = escapeSearch(search);

    return scheme + (host === false ? "" : host) + pathname + search + hash;
};

Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
        relative = Url.parse(relative, false, true);

    var result = this._clone();

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there"s nothing left to do here.
    if (!relative.href) {
        result._href = "";
        return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative._protocol) {
        relative._copyPropsTo(result, true);

        if (slashProtocols[result._protocol] &&
            result.hostname && !result.pathname) {
            result.pathname = "/";
        }
        result._href = "";
        return result;
    }

    if (relative._protocol && relative._protocol !== result._protocol) {
        // if it"s a known url protocol, then changing
        // the protocol does weird things
        // first, if it"s not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that"s known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashProtocols[relative._protocol]) {
            relative._copyPropsTo(result, false);
            result._href = "";
            return result;
        }

        result._protocol = relative._protocol;
        if (!relative.host && relative._protocol !== "javascript") {
            var relPath = (relative.pathname || "").split("/");
            while (relPath.length && !(relative.host = relPath.shift()));
            if (!relative.host) relative.host = "";
            if (!relative.hostname) relative.hostname = "";
            if (relPath[0] !== "") relPath.unshift("");
            if (relPath.length < 2) relPath.unshift("");
            result.pathname = relPath.join("/");
        } else {
            result.pathname = relative.pathname;
        }

        result.search = relative.search;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result._port = relative._port;
        result.slashes = result.slashes || relative.slashes;
        result._href = "";
        return result;
    }

    var isSourceAbs =
        (result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/);
    var isRelAbs = (
            relative.host ||
            (relative.pathname &&
            relative.pathname.charCodeAt(0) === 0x2F /*'/'*/)
        );
    var mustEndAbs = (isRelAbs || isSourceAbs ||
                        (result.host && relative.pathname));

    var removeAllDots = mustEndAbs;

    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];

    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
        result.hostname = "";
        result._port = -1;
        if (result.host) {
            if (srcPath[0] === "") srcPath[0] = result.host;
            else srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative._protocol) {
            relative.hostname = "";
            relative._port = -1;
            if (relative.host) {
                if (relPath[0] === "") relPath[0] = relative.host;
                else relPath.unshift(relative.host);
            }
            relative.host = "";
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }

    if (isRelAbs) {
        // it"s absolute.
        result.host = relative.host ?
            relative.host : result.host;
        result.hostname = relative.hostname ?
            relative.hostname : result.hostname;
        result.search = relative.search;
        srcPath = relPath;
        // fall through to the dot-handling below.
    } else if (relPath.length) {
        // it"s relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
    } else if (relative.search) {
        // just pull out the search.
        // like href="?foo".
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            //occationaly the auth can get stuck only in host
            //this especialy happens in cases like
            //url.resolveObject("mailto:local1@domain1", "local2@domain2")
            var authInHost = result.host && result.host.indexOf("@") > 0 ?
                result.host.split("@") : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        result.search = relative.search;
        result._href = "";
        return result;
    }

    if (!srcPath.length) {
        // no path at all.  easy.
        // we"ve already handled the other stuff above.
        result.pathname = null;
        result._href = "";
        return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (
        (result.host || relative.host) && (last === "." || last === "..") ||
        last === "");

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
            srcPath.splice(i, 1);
        } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
        } else if (up) {
            srcPath.splice(i, 1);
            up--;
        }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
            srcPath.unshift("..");
        }
    }

    if (mustEndAbs && srcPath[0] !== "" &&
        (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/)) {
        srcPath.unshift("");
    }

    if (hasTrailingSlash && (srcPath.join("/").substr(-1) !== "/")) {
        srcPath.push("");
    }

    var isAbsolute = srcPath[0] === "" ||
        (srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/);

    // put the host back
    if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" :
            srcPath.length ? srcPath.shift() : "";
        //occationaly the auth can get stuck only in host
        //this especialy happens in cases like
        //url.resolveObject("mailto:local1@domain1", "local2@domain2")
        var authInHost = result.host && result.host.indexOf("@") > 0 ?
            result.host.split("@") : false;
        if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
        }
    }

    mustEndAbs = mustEndAbs || (result.host && srcPath.length);

    if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
    }

    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
};

var punycode = __webpack_require__(123);
Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    // IDNA Support: Returns a punycoded representation of "domain".
    // It only converts parts of the domain name that
    // have non-ASCII characters, i.e. it doesn't matter if
    // you call it with a domain that already is ASCII-only.
    return punycode.toASCII(hostname);
};

var escapePathName = Url.prototype._escapePathName =
function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 0x23 /*'#'*/, 0x3F /*'?'*/)) {
        return pathname;
    }
    //Avoid closure creation to keep this inlinable
    return _escapePath(pathname);
};

var escapeSearch = Url.prototype._escapeSearch =
function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 0x23 /*'#'*/, -1)) return search;
    //Avoid closure creation to keep this inlinable
    return _escapeSearch(search);
};

Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            var protocol = str.slice(start, i);
            if (doLowerCase) protocol = protocol.toLowerCase();
            this._protocol = protocol;
            return i + 1;
        }
        else if (protocolCharacters[ch] === 1) {
            if (ch < 0x61 /*'a'*/)
                doLowerCase = true;
        }
        else {
            return start;
        }

    }
    return start;
};

Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
        auth = decodeURIComponent(auth);
    }
    this.auth = auth;
};

Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    //Internal format is integer for more efficient parsing
    //and for efficient trimming of leading zeros
    var port = 0;
    //Distinguish between :0 and : (no port number at all)
    var hadChars = false;
    var validPort = true;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/) {
            port = (10 * port) + (ch - 0x30 /*'0'*/);
            hadChars = true;
        }
        else {
            validPort = false;
            if (ch === 0x5C/*'\'*/ || ch === 0x2F/*'/'*/) {
                validPort = true;
            }
            break;
        }

    }
    if ((port === 0 && !hadChars) || !validPort) {
        if (!validPort) {
            this._port = -2;
        }
        return 0;
    }

    this._port = port;
    return i - start;
};

Url.prototype._parseHost =
function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 0x2F /*'/'*/ || first === 0x5C /*'\'*/) &&
        (second === 0x2F /*'/'*/ || second === 0x5C /*'\'*/)) {
        this.slashes = true;

        //The string starts with //
        if (start === 0) {
            //The string is just "//"
            if (end < 2) return start;
            //If slashes do not denote host and there is no auth,
            //there is no host when the string starts with //
            var hasAuth =
                containsCharacter(str, 0x40 /*'@'*/, 2, hostEndingCharacters);
            if (!hasAuth && !slashesDenoteHost) {
                this.slashes = null;
                return start;
            }
        }
        //There is a host that starts after the //
        start += 2;
    }
    //If there is no slashes, there is no hostname if
    //1. there was no protocol at all
    else if (!this._protocol ||
        //2. there was a protocol that requires slashes
        //e.g. in 'http:asd' 'asd' is not a hostname
        slashProtocols[this._protocol]
    ) {
        return start;
    }

    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;

    var j = -1;

    //Find the last occurrence of an @-sign until hostending character is met
    //also mark if decoding is needed for the auth portion
    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x40 /*'@'*/) {
            j = i;
        }
        //This check is very, very cheap. Unneeded decodeURIComponent is very
        //very expensive
        else if (ch === 0x25 /*'%'*/) {
            authNeedsDecoding = true;
        }
        else if (hostEndingCharacters[ch] === 1) {
            break;
        }
    }

    //@-sign was found at index j, everything to the left from it
    //is auth part
    if (j > -1) {
        this._parseAuth(str, start, j - 1, authNeedsDecoding);
        //hostname starts after the last @-sign
        start = hostNameStart = j + 1;
    }

    //Host name is starting with a [
    if (str.charCodeAt(start) === 0x5B /*'['*/) {
        for (var i = start + 1; i <= end; ++i) {
            var ch = str.charCodeAt(i);

            //Assume valid IP6 is between the brackets
            if (ch === 0x5D /*']'*/) {
                if (str.charCodeAt(i + 1) === 0x3A /*':'*/) {
                    portLength = this._parsePort(str, i + 2, end) + 1;
                }
                var hostname = str.slice(start + 1, i).toLowerCase();
                this.hostname = hostname;
                this.host = this._port > 0 ?
                    "[" + hostname + "]:" + this._port :
                    "[" + hostname + "]";
                this.pathname = "/";
                return i + portLength + 1;
            }
        }
        //Empty hostname, [ starts a path
        return start;
    }

    for (var i = start; i <= end; ++i) {
        if (charsAfterDot > 62) {
            this.hostname = this.host = str.slice(start, i);
            return i;
        }
        var ch = str.charCodeAt(i);

        if (ch === 0x3A /*':'*/) {
            portLength = this._parsePort(str, i + 1, end) + 1;
            hostNameEnd = i - 1;
            break;
        }
        else if (ch < 0x61 /*'a'*/) {
            if (ch === 0x2E /*'.'*/) {
                //Node.js ignores this error
                /*
                if (lastCh === DOT || lastCh === -1) {
                    this.hostname = this.host = "";
                    return start;
                }
                */
                charsAfterDot = -1;
            }
            else if (0x41 /*'A'*/ <= ch && ch <= 0x5A /*'Z'*/) {
                doLowerCase = true;
            }
            //Valid characters other than ASCII letters -, _, +, 0-9
            else if (!(ch === 0x2D /*'-'*/ ||
                       ch === 0x5F /*'_'*/ ||
                       ch === 0x2B /*'+'*/ ||
                       (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/))
                ) {
                if (hostEndingCharacters[ch] === 0 &&
                    this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
        }
        else if (ch >= 0x7B /*'{'*/) {
            if (ch <= 0x7E /*'~'*/) {
                if (this._noPrependSlashHostEnders[ch] === 0) {
                    this._prependSlash = true;
                }
                hostNameEnd = i - 1;
                break;
            }
            idna = true;
        }
        lastCh = ch;
        charsAfterDot++;
    }

    //Node.js ignores this error
    /*
    if (lastCh === DOT) {
        hostNameEnd--;
    }
    */

    if (hostNameEnd + 1 !== start &&
        hostNameEnd - hostNameStart <= 256) {
        var hostname = str.slice(hostNameStart, hostNameEnd + 1);
        if (doLowerCase) hostname = hostname.toLowerCase();
        if (idna) hostname = this._hostIdna(hostname);
        this.hostname = hostname;
        this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }

    return hostNameEnd + 1 + portLength;

};

Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
        input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
};

Url.prototype._clone = function Url$_clone() {
    var ret = new Url();
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
};

Url.prototype._getComponentEscaped =
function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i = start;
    var ret = "";
    var autoEscapeMap = isAfterQuery ?
        this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        var escaped = autoEscapeMap[ch];

        if (escaped !== "" && escaped !== undefined) {
            if (cur < i) ret += str.slice(cur, i);
            ret += escaped;
            cur = i + 1;
        }
    }
    if (cur < i + 1) ret += str.slice(cur, i);
    return ret;
};

Url.prototype._parsePath =
function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);
        if (ch === 0x23 /*'#'*/) {
          this._parseHash(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        }
        else if (ch === 0x3F /*'?'*/) {
            this._parseQuery(str, i, end, disableAutoEscapeChars);
            pathEnd = i - 1;
            break;
        }
        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (pathStart > pathEnd) {
        this.pathname = prePath === "" ? "/" : prePath;
        return;
    }

    var path;
    if (escape) {
        path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    }
    else {
        path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === ""
        ? (this._prependSlash ? "/" + path : path)
        : prePath + path;
};

Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;

    for (var i = start; i <= end; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 0x23 /*'#'*/) {
            this._parseHash(str, i, end, disableAutoEscapeChars);
            queryEnd = i - 1;
            break;
        }
        else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
            escape = true;
        }
    }

    if (queryStart > queryEnd) {
        this.search = "";
        return;
    }

    var query;
    if (escape) {
        query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    }
    else {
        query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
};

Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
        this.hash = "";
        return;
    }

    this.hash = disableAutoEscapeChars ?
        str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
};

Object.defineProperty(Url.prototype, "port", {
    get: function() {
        if (this._port >= 0) {
            return ("" + this._port);
        }
        return null;
    },
    set: function(v) {
        if (v == null) {
            this._port = -1;
        }
        else {
            this._port = parseInt(v, 10);
        }
    }
});

Object.defineProperty(Url.prototype, "query", {
    get: function() {
        var query = this._query;
        if (query != null) {
            return query;
        }
        var search = this.search;

        if (search) {
            if (search.charCodeAt(0) === 0x3F /*'?'*/) {
                search = search.slice(1);
            }
            if (search !== "") {
                this._query = search;
                return search;
            }
        }
        return search;
    },
    set: function(v) {
        this._query = v;
    }
});

Object.defineProperty(Url.prototype, "path", {
    get: function() {
        var p = this.pathname || "";
        var s = this.search || "";
        if (p || s) {
            return p + s;
        }
        return (p == null && s) ? ("/" + s) : null;
    },
    set: function() {}
});

Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
        var proto = this._protocol;
        return proto ? proto + ":" : proto;
    },
    set: function(v) {
        if (typeof v === "string") {
            var end = v.length - 1;
            if (v.charCodeAt(end) === 0x3A /*':'*/) {
                this._protocol = v.slice(0, end);
            }
            else {
                this._protocol = v;
            }
        }
        else if (v == null) {
            this._protocol = null;
        }
    }
});

Object.defineProperty(Url.prototype, "href", {
    get: function() {
        var href = this._href;
        if (!href) {
            href = this._href = this.format();
        }
        return href;
    },
    set: function(v) {
        this._href = v;
    }
});

Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url) return str;
    var ret = new Url();
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
};

Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
        obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
    }
    return obj.format();
};

Url.resolve = function Url$Resolve(source, relative) {
    return Url.parse(source, false, true).resolve(relative);
};

Url.resolveObject = function Url$ResolveObject(source, relative) {
    if (!source) return relative;
    return Url.parse(source, false, true).resolveObject(relative);
};

function _escapePath(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
    });
}

function _escapeSearch(search) {
    return search.replace(/#/g, function(match) {
        return encodeURIComponent(match);
    });
}

//Search `char1` (integer code for a character) in `string`
//starting from `fromIndex` and ending at `string.length - 1`
//or when a stop character is found
function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
    var len = string.length;
    for (var i = fromIndex; i < len; ++i) {
        var ch = string.charCodeAt(i);

        if (ch === char1) {
            return true;
        }
        else if (stopCharacterTable[ch] === 1) {
            return false;
        }
    }
    return false;
}

//See if `char1` or `char2` (integer codes for characters)
//is contained in `string`
function containsCharacter2(string, char1, char2) {
    for (var i = 0, len = string.length; i < len; ++i) {
        var ch = string.charCodeAt(i);
        if (ch === char1 || ch === char2) return true;
    }
    return false;
}

//Makes an array of 128 uint8's which represent boolean values.
//Spec is an array of ascii code points or ascii code point ranges
//ranges are expressed as [start, end]

//Create a table with the characters 0x30-0x39 (decimals '0' - '9') and
//0x7A (lowercaseletter 'z') as `true`:
//
//var a = makeAsciiTable([[0x30, 0x39], 0x7A]);
//a[0x30]; //1
//a[0x15]; //0
//a[0x35]; //1
function makeAsciiTable(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item){
        if (typeof item === "number") {
            ret[item] = 1;
        }
        else {
            var start = item[0];
            var end = item[1];
            for (var j = start; j <= end; ++j) {
                ret[j] = 1;
            }
        }
    });

    return ret;
}


var autoEscape = ["<", ">", "\"", "`", " ", "\r", "\n",
    "\t", "{", "}", "|", "\\", "^", "`", "'"];

var autoEscapeMap = new Array(128);



for (var i = 0, len = autoEscapeMap.length; i < len; ++i) {
    autoEscapeMap[i] = "";
}

for (var i = 0, len = autoEscape.length; i < len; ++i) {
    var c = autoEscape[i];
    var esc = encodeURIComponent(c);
    if (esc === c) {
        esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
}
var afterQueryAutoEscapeMap = autoEscapeMap.slice();
autoEscapeMap[0x5C /*'\'*/] = "/";

var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,

    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
};

//Optimize back from normalized object caused by non-identifier keys
function f(){}
f.prototype = slashProtocols;

Url.prototype._protocolCharacters = makeAsciiTable([
    [0x61 /*'a'*/, 0x7A /*'z'*/],
    [0x41 /*'A'*/, 0x5A /*'Z'*/],
    0x2E /*'.'*/, 0x2B /*'+'*/, 0x2D /*'-'*/
]);

Url.prototype._hostEndingCharacters = makeAsciiTable([
    0x23 /*'#'*/, 0x3F /*'?'*/, 0x2F /*'/'*/, 0x5C /*'\'*/
]);

Url.prototype._autoEscapeCharacters = makeAsciiTable(
    autoEscape.map(function(v) {
        return v.charCodeAt(0);
    })
);

//If these characters end a host name, the path will not be prepended a /
Url.prototype._noPrependSlashHostEnders = makeAsciiTable(
    [
        "<", ">", "'", "`", " ", "\r",
        "\n", "\t", "{", "}", "|",
        "^", "`", "\"", "%", ";"
    ].map(function(v) {
        return v.charCodeAt(0);
    })
);

Url.prototype._autoEscapeMap = autoEscapeMap;
Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;

module.exports = Url;

Url.replace = function Url$Replace() {
    __webpack_require__.c.url = {
        exports: Url
    };
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(121);
exports.encode = exports.stringify = __webpack_require__(122);


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(124)(module), __webpack_require__(27)))

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var QueryStringSerializer = __webpack_require__(126);
module.exports = QueryStringParser;

var rplus = /\+/g;
var rint = /^[0-9]+$/;
var isArray = Array.isArray;
var haveProp = {}.hasOwnProperty;

function QueryStringParser() {
    this.containsSparse = false;
    this.cacheKey = "";
    this.cacheVal = null;
}

QueryStringParser.maxLength = 32768;
QueryStringParser.maxDepth = 4;
QueryStringParser.maxKeys = 256;

QueryStringParser.parse = function QueryStringParser$Parse(str) {
    if (typeof str === "string") {
        var maxLength = QueryStringParser.maxLength;
        if (str.length > maxLength) {
            throw new RangeError(
                "str is too large (" +
                "QueryStringParser.maxLength=" + maxLength + ")"
            );
        }
        var parser = new QueryStringParser();
        return parser.parseString(str, false);
    }
    else if (str !== null && typeof str === "object") {
        var parser = new QueryStringParser();
        return parser.parseObject(str);
    }
    return {};
};

QueryStringParser.stringify =
function QueryStringParser$Stringify(value) {
    var serializer = new QueryStringSerializer();
    return serializer.serialize(value);
};

QueryStringParser.prototype.decode =
function QueryStringParser$decode(str, shouldDecode, containsPlus) {
    if (shouldDecode === false) return str;
    if (containsPlus === true) str = str.replace(rplus, " ");
    try {
        return decodeURIComponent(str);
    }
    catch (e) {
        return str;
    }
};

QueryStringParser.prototype.maybeArrayIndex =
function QueryStringParser$maybeArrayIndex(str, arrayLength) {
    var len = str.length;
    if (len === 0) {
        return arrayLength;
    }
    var ch = str.charCodeAt(0);

    if (ch === 48) {
        return len > 1 ? -1 : 0;
    }
    else if (48 <= ch && ch <= 57) {
        if (len === 1) {
            return ch - 48;
        }
        else if (rint.test(str)) {
            var v = parseInt(str, 10);
            if (0 < v && v <= 1073741822) {
                return v;
            }
        }
    }
    return -1;
};

QueryStringParser.prototype.getSlot =
function QueryStringParser$getSlot(dictionary, prevKey, curKey) {
    var slot;
    if (!(haveProp.call(dictionary, prevKey))) {
        var index = this.maybeArrayIndex(curKey, 0);
        if (index > -1) {
            slot = [];
        }
        else {
            slot = {};
        }
        dictionary[prevKey] = slot;
    }
    else {
        slot = dictionary[prevKey];
    }
    return slot;
};

QueryStringParser.prototype.placeNestedValue =
function QueryStringParser$placeNestedValue
(dictionary, key, value, i, prevKey, curKey) {
    var slot = this.getSlot(dictionary, prevKey, curKey);
    var index = -1;

    if (isArray(slot)) {
        index = this.maybeArrayIndex(curKey, slot.length);
    }

    var len = key.length;
    var depth = 2;
    var maxDepth = QueryStringParser.maxDepth;
    var start = -1;
    for (; i < len; ++i) {
        var ch = key.charCodeAt(i);
        if (ch === 91) {
            start = i + 1;
        }
        else if (ch === 93 &&
                start > -1) {
            prevKey = curKey;
            curKey = start === i ? "" : key.substring(start, i);
            start = -1;
            depth++;
            if (depth > maxDepth) {
                throw new RangeError("Nesting depth of keys is too large " +
                    "(QueryStringParser.maxDepth="+maxDepth+")" );
            }
            slot = this.getSlot(slot, prevKey, curKey);

            index = isArray(slot)
                ? this.maybeArrayIndex(curKey, slot.length)
                : -1;
        }
    }

    if(index > -1) {
        if (value !== "") {
            if (index === slot.length) {
                slot.push(value);
            }
            else {
                this.containsSparse = true;
                slot[index] = value;
            }
        }
    }
    else {
        this.insert(slot, curKey, value);
    }
};

QueryStringParser.prototype.insert =
function QueryStringParser$insert(dictionary, key, value) {
    var ret = null;
    if (haveProp.call(dictionary, key)) {
        var prev = dictionary[key];
        if( isArray(prev) ) {
            prev.push(value);
            ret = prev;
        }
        else {
            ret = [prev, value];
            dictionary[key] = ret;
        }
    }
    else {
        dictionary[key] = value;
    }
    return ret;
};

QueryStringParser.prototype.push =
function QueryStringParser$push(dictionary, key, value) {
    var ret = null;
    if (haveProp.call(dictionary, key)) {
        var prev = dictionary[key];
        prev.push(value);
        ret = prev;
    }
    else {
        ret = [value];
        dictionary[key] = ret;
    }
    return ret;
};

QueryStringParser.prototype.maybePlaceNestedValue =
function QueryStringParser$maybePlaceNestedValue(dictionary, key, value) {
    var len = key.length;
    if (key.charCodeAt(len - 1) !== 93) {
        this.placeValue(dictionary, key, value, false);
        return;
    }
    var start = -1;

    var i = 0;
    var curKey;
    var prevKey;

    for (; i < len; ++i) {
        var ch = key.charCodeAt(i);

        if (ch === 91) {
            start = i + 1;
            prevKey = key.slice(0, i);
        }
        else if (ch === 93) {
            if (start < 0) {
                this.placeValue(dictionary, key, value, false);
                return;
            }
            curKey = start === i ? "" : key.slice(start, i);
            i++;
            break;
        }
    }

    if (curKey === void 0) {
        this.placeValue(dictionary, key, value, false);
        return;
    }

    if (curKey === "" && value !== "" && i === len) {
        if (key === this.cacheKey) {
            this.cacheVal.push(value);
        }
        else {
            this.cacheKey = key;
            this.cacheVal = this.push(dictionary, prevKey, value);
        }
    }
    else {
        this.placeNestedValue(dictionary, key, value, i, prevKey, curKey);
    }
};

QueryStringParser.prototype.placeValue =
function QueryStringParser$placeValue(dictionary, key, value, possiblyNested) {
    if (possiblyNested === true) {
        this.maybePlaceNestedValue(dictionary, key, value);
        return;
    }
    if (key === this.cacheKey) {
        this.cacheVal.push(value);
        return;
    }
    var cache = this.insert(dictionary, key, value);
    if (cache !== null) {
        this.cacheKey = key;
        this.cacheVal = cache;
    }
};

QueryStringParser.prototype.compact =
function QueryStringParser$compact(obj) {
    if (isArray(obj)) {
        var ret = [];
        var keys = Object.keys(obj);
        for( var i = 0, len = keys.length; i < len; ++i ) {
            ret.push(obj[keys[i]]);
        }
        return ret;
    }
    else if (typeof obj === "object") {
        var keys = Object.keys(obj);
        for( var i = 0, len = keys.length; i < len; ++i ) {
            var key = keys[i];
            obj[key] = this.compact(obj[key]);
        }
    }
    else {
        return obj;
    }
};

QueryStringParser.prototype.parseObject =
function QueryStringParser$parseObject(obj) {
    var keys = Object.keys(obj);
    var len = keys.length;
    if (len === 0) {
        return {};
    }
    len--;
    var ret = "";
    var key;
    for( var i = 0; i < len; ++i ) {
        key = keys[i];
        ret += key + "=" + obj[key] + "&";
    }
    key = keys[i];
    ret += key + "=" + obj[key];
    return this.parseString(ret, true);
};

QueryStringParser.prototype.parseString =
function QueryStringParser$parseString(str, noDecode) {
    var maxKeys = QueryStringParser.maxKeys;
    var keys = 0;
    var decodeKey = false;
    var decodeValue = false;
    var possiblyNested = false;
    var len = str.length;
    var i = 0;
    var dictionary = {};
    var keyStart = 0;
    var keyEnd = 0;
    var valueStart = 0;
    var valueEnd = 0;
    var left = 0;
    var lastIndex = len - 1;
    var containsPlus = false;


    for (; i < len; ++i) {
        var ch = str.charCodeAt(i);

        if (ch === 91) {
            left++;
        }
        else if (left > 0 && ch === 93) {
            possiblyNested = true;
            left--;
        }
        else if (left === 0 && ch === 61) {
            var j = i + 1;

            keyEnd = i - 1;
            valueEnd = valueStart = j;
            var key = str.slice(keyStart, keyEnd + 1);
            key = this.decode(key, decodeKey, containsPlus);
            decodeKey = false;

            for (; j < len; ++j) {
                ch = str.charCodeAt(j);
                if ((ch === 43 || ch === 37) && !noDecode) {
                    if (ch === 43) containsPlus = true;
                    decodeValue = true;
                }
                if (ch === 38 || j === lastIndex) {
                    valueEnd = j;
                    i = j;

                    if (ch === 38) {
                        valueEnd--;
                    }

                    var value = str.slice(valueStart, valueEnd + 1);
                    value = this.decode(value, decodeValue, containsPlus);

                    this.placeValue(dictionary, key, value, possiblyNested);

                    containsPlus = decodeValue = false;
                    possiblyNested = false;

                    keyStart = j + 1;
                    keys++;
                    if (keys > maxKeys) {
                        throw new RangeError("Amount of keys is too large " +
                            "(QueryStringParser.maxKeys=" + maxKeys + ")");
                    }
                    break;
                }
            }
        }
        else if ((ch === 43 || ch === 37) && !noDecode) {
            if (ch === 43) containsPlus = true;
            decodeKey = true;
        }
    }
    if (keyStart !== len) {
        var value = "";
        var key = str.slice(keyStart, len);
        key = this.decode(key, decodeKey, containsPlus);
        this.placeValue(dictionary, key, value, possiblyNested);
    }


    if (this.containsSparse) {
        this.compact(dictionary);
    }

    return dictionary;
};


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

module.exports = QueryStringSerializer;
var enc = encodeURIComponent;
var ARRAY = [];
var isArray = Array.isArray;
var getProto = Object.getPrototypeOf;
var oProto = getProto({});

function isObject(obj) {
    if (isArray(obj)) {
        return true;
    }
    if (obj === null || typeof obj !== "object") {
        return false;
    }
    var proto = getProto(obj);

    return proto === oProto || proto === null;
}

function QueryStringSerializer() {

}

QueryStringSerializer.prototype.serialize =
function QueryStringSerializer$serialize(obj) {
    if (obj === null ||
        typeof obj !== "object") {
        throw new TypeError("the obj to stringify must be an object");
    }
    var keys = Object.keys(obj);
    var len = keys.length;
    var array = ARRAY;
    var stack = [];
    var ret = [];
    var cur = obj;
    var keyPrefix = "";

    for (var i = 0; i < len; ++i) {
        var key = keys === array ? i : keys[i];
        var value = cur[key];
        if (isObject(value)) {
            stack.push(keyPrefix, cur, keys, len, i);

            if (keyPrefix === "") {
                keyPrefix = key;
            }
            else {
                keyPrefix = keyPrefix + "[" + enc(key) + "]";
            }

            if (isArray(value)) {
                keys = array;
                len = value.length;
            }
            else {
                keys = Object.keys(value);
                len = keys.length;
            }
            i = -1;
            cur = value;
        }
        else {
            if (typeof value !== "string") {
                value = "" + value;
            }

            var serializedKey = keyPrefix === ""
                                ? enc(key)
                                : keyPrefix + "[" + enc(key) + "]";
            ret.push(serializedKey + "=" + enc(value));
        }

        if(i === len - 1 && stack.length > 0) {
            i = stack.pop();
            len = stack.pop();
            keys = stack.pop();
            cur = stack.pop();
            keyPrefix = stack.pop();
        }
    }

    return ret.join("&");
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assetsLoader = __webpack_require__(128);
assetsLoader.stats = __webpack_require__(110);

module.exports = assetsLoader;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(109);
var createLoader = __webpack_require__(130);
var autoId = 0;

module.exports = function createGroup(config) {
    var group;
    var map = {};
    var assets = [];
    var queue = [];
    var numLoaded = 0;
    var numTotal = 0;
    var loaders = {};

    var add = function(options) {
        // console.debug('add', options);
        if (Array.isArray(options)) {
            options.forEach(add);
            return group;
        }
        var isGroup = !!options.assets && Array.isArray(options.assets);
        // console.debug('isGroup', isGroup);
        var loader;
        if (isGroup) {
            loader = createGroup(configure(options, config));
        } else {
            loader = createLoader(configure(options, config));
        }
        loader.once('destroy', destroyHandler);
        queue.push(loader);
        loaders[loader.id] = loader;
        return group;
    };

    var get = function(id) {
        if (!arguments.length) {
            return assets;
        }
        if (map[id]) {
            return map[id];
        }
        return loaders[id];
    };

    var find = function(id) {
        if (get(id)) {
            return get(id);
        }
        var found = null;
        Object.keys(loaders).some(function(key) {
            found = loaders[key].find && loaders[key].find(id);
            return !!found;
        });
        return found;
    };

    var getExtension = function(url) {
        return url && url.split('?')[0].split('.').pop().toLowerCase();
    };

    var configure = function(options, defaults) {
        if (typeof options === 'string') {
            var url = options;
            options = {
                url: url
            };
        }

        if (options.isTouchLocked === undefined) {
            options.isTouchLocked = defaults.isTouchLocked;
        }

        if (options.blob === undefined) {
            options.blob = defaults.blob;
        }

        if (options.basePath === undefined) {
            options.basePath = defaults.basePath;
        }

        options.id = options.id || options.url || String(++autoId);
        options.type = options.type || getExtension(options.url);
        options.crossOrigin = options.crossOrigin || defaults.crossOrigin;
        options.webAudioContext = options.webAudioContext || defaults.webAudioContext;
        options.log = defaults.log;

        return options;
    };

    var start = function() {
        numTotal = queue.length;

        queue.forEach(function(loader) {
            loader
                .on('progress', progressHandler)
                .once('complete', completeHandler)
                .once('error', errorHandler)
                .start();
        });

        queue = [];

        return group;
    };

    var progressHandler = function(progress) {
        var loaded = numLoaded + progress;
        group.emit('progress', loaded / numTotal);
    };

    var completeHandler = function(asset, id, type) {
        if (Array.isArray(asset)) {
            asset = { id: id, file: asset, type: type };
        }
        numLoaded++;
        group.emit('progress', numLoaded / numTotal);
        map[asset.id] = asset.file;
        assets.push(asset);
        group.emit('childcomplete', asset);
        checkComplete();
    };

    var errorHandler = function(err) {
        numTotal--;
        if (group.listeners('error').length) {
            group.emit('error', err);
        } else {
            console.error(err);
        }
        checkComplete();
    };

    var destroyHandler = function(id) {
        loaders[id] = null;
        delete loaders[id];

        map[id] = null;
        delete map[id];

        assets.some(function(asset, i) {
            if (asset.id === id) {
                assets.splice(i, 1);
                return true;
            }
        });
    };

    var checkComplete = function() {
        if (numLoaded >= numTotal) {
            group.emit('complete', assets, map, config.id, 'group');
        }
    };

    var destroy = function() {
        while (queue.length) {
            queue.pop().destroy();
        }
        group.off('error');
        group.off('progress');
        group.off('complete');
        assets = [];
        map = {};
        config.webAudioContext = null;
        numTotal = 0;
        numLoaded = 0;

        Object.keys(loaders).forEach(function(key) {
            loaders[key].destroy();
        });
        loaders = {};

        group.emit('destroy', group.id);

        return group;
    };

    // emits: progress, error, complete, destroy

    group = Object.create(Emitter.prototype, {
        _events: {
            value: {}
        },
        id: {
            get: function() {
                return config.id;
            }
        },
        add: {
            value: add
        },
        start: {
            value: start
        },
        get: {
            value: get
        },
        find: {
            value: find
        },
        getLoader: {
            value: function(id) {
                return loaders[id];
            }
        },
        loaded: {
            get: function() {
                return numLoaded >= numTotal;
            }
        },
        file: {
            get: function() {
                return assets;
            }
        },
        destroy: {
            value: destroy
        }
    });

    config = configure(config || {}, {
        basePath: '',
        blob: false,
        touchLocked: false,
        crossOrigin: null,
        webAudioContext: null,
        log: false
    });

    if (Array.isArray(config.assets)) {
        add(config.assets);
    }

    return Object.freeze(group);
};


/***/ }),
/* 129 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Emitter = __webpack_require__(109);
var browserHasBlob = __webpack_require__(131);
var stats = __webpack_require__(110);

module.exports = function(options) {
    var id = options.id;
    var basePath = options.basePath || '';
    var url = options.url;
    var type = options.type;
    var crossOrigin = options.crossOrigin;
    var isTouchLocked = options.isTouchLocked;
    var blob = options.blob && browserHasBlob;
    var webAudioContext = options.webAudioContext;
    var log = options.log;

    var loader;
    var loadHandler;
    var request;
    var startTime;
    var timeout;
    var file;

    var start = function() {
        startTime = Date.now();

        switch (type) {
            case 'json':
                loadJSON();
                break;
            case 'jpg':
            case 'png':
            case 'gif':
            case 'webp':
                loadImage();
                break;
            case 'mp3':
            case 'ogg':
            case 'opus':
            case 'wav':
            case 'm4a':
                loadAudio();
                break;
            case 'ogv':
            case 'mp4':
            case 'webm':
            case 'hls':
                loadVideo();
                break;
            case 'bin':
            case 'binary':
                loadXHR('arraybuffer');
                break;
            case 'txt':
            case 'text':
                loadXHR('text');
                break;
            default:
                throw 'AssetsLoader ERROR: Unknown type for file with URL: ' + basePath + url + ' (' + type + ')';
        }
    };

    var dispatchComplete = function(data) {
        if (!data) {
            return;
        }
        file = {id: id, file: data, type: type};
        loader.emit('progress', 1);
        loader.emit('complete', file, id, type);
        removeListeners();
    };

    var loadXHR = function(responseType, customLoadHandler) {
        loadHandler = customLoadHandler || completeHandler;

        request = new XMLHttpRequest();
        request.open('GET', basePath + url, true);
        request.responseType = responseType;
        request.addEventListener('progress', progressHandler);
        request.addEventListener('load', loadHandler);
        request.addEventListener('error', errorHandler);
        request.send();
    };

    var progressHandler = function(event) {
        if (event.lengthComputable) {
            loader.emit('progress', event.loaded / event.total);
        }
    };

    var completeHandler = function() {
        if (success()) {
            dispatchComplete(request.response);
        }
    };

    var success = function() {
        // console.log('success', url, request.status);
        if (request && request.status < 400) {
            stats.update(request, startTime, url, log);
            return true;
        }
        errorHandler(request && request.statusText);
        return false;
    };

    // json

    var loadJSON = function() {
        loadXHR('json', function() {
            if (success()) {
                var data = request.response;
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }
                dispatchComplete(data);
            }
        });
    };

    // image

    var loadImage = function() {
        if (blob) {
            loadImageBlob();
        } else {
            loadImageElement();
        }
    };

    var loadImageElement = function() {
        request = new Image();
        if (crossOrigin) {
            request.crossOrigin = 'anonymous';
        }
        request.addEventListener('error', errorHandler, false);
        request.addEventListener('load', elementLoadHandler, false);
        request.src = basePath + url;
    };

    var elementLoadHandler = function(event) {
        window.clearTimeout(timeout);
        if (!event && (request.error || !request.readyState)) {
            errorHandler();
            return;
        }
        dispatchComplete(request);
    };

    var loadImageBlob = function() {
        loadXHR('blob', function() {
            if (success()) {
                request = new Image();
                request.addEventListener('error', errorHandler, false);
                request.addEventListener('load', imageBlobHandler, false);
                request.src = window.URL.createObjectURL(request.response);
            }
        });
    };

    var imageBlobHandler = function() {
        window.URL.revokeObjectURL(request.src);
        dispatchComplete(request);
    };

    // audio

    var loadAudio = function() {
        if (webAudioContext) {
            loadAudioBuffer();
        } else {
            loadMediaElement('audio');
        }
    };

    // video

    var loadVideo = function() {
        if (blob) {
            loadXHR('blob');
        } else {
            loadMediaElement('video');
        }
    };

    // audio buffer

    var loadAudioBuffer = function() {
        loadXHR('arraybuffer', function() {
            if (success()) {
                webAudioContext.decodeAudioData(
                    request.response,
                    function(buffer) {
                        request = null;
                        dispatchComplete(buffer);
                    },
                    function(e) {
                        errorHandler(e);
                    }
                );
            }
        });
    };

    // media element

    var loadMediaElement = function(tagName) {
        request = document.createElement(tagName);

        if (!isTouchLocked) {
            // timeout because sometimes canplaythrough doesn't fire
            window.clearTimeout(timeout);
            timeout = window.setTimeout(elementLoadHandler, 2000);
            request.addEventListener('canplaythrough', elementLoadHandler, false);
        }

        request.addEventListener('error', errorHandler, false);
        request.preload = 'auto';
        request.src = basePath + url;
        request.load();

        if (isTouchLocked) {
            dispatchComplete(request);
        }
    };

    // error

    var errorHandler = function(err) {
        // console.log('errorHandler', url, err);
        window.clearTimeout(timeout);

        var message = err;

        if (request && request.tagName && request.error) {
            var ERROR_STATE = ['', 'ABORTED', 'NETWORK', 'DECODE', 'SRC_NOT_SUPPORTED'];
            message = 'MediaError: ' + ERROR_STATE[request.error.code] + ' ' + request.src;
        } else if (request && request.statusText) {
            message = request.statusText;
        } else if (err && err.message) {
            message = err.message;
        } else if (err && err.type) {
            message = err.type;
        }

        loader.emit('error', 'Error loading "' + basePath + url + '" ' + message);

        destroy();
    };

    // clean up

    var removeListeners = function() {
        loader.off('error');
        loader.off('progress');
        loader.off('complete');

        if (request) {
            request.removeEventListener('progress', progressHandler);
            request.removeEventListener('load', loadHandler);
            request.removeEventListener('error', errorHandler);
            request.removeEventListener('load', elementLoadHandler);
            request.removeEventListener('canplaythrough', elementLoadHandler);
            request.removeEventListener('load', imageBlobHandler);
        }
    };

    var destroy = function() {
        removeListeners();

        if (request && request.abort && request.readyState < 4) {
            request.abort();
        }

        request = null;
        webAudioContext = null;
        file = null;

        window.clearTimeout(timeout);

        loader.emit('destroy', id);
    };

    // emits: progress, error, complete

    loader = Object.create(Emitter.prototype, {
        _events: {
            value: {}
        },
        id: {
            value: options.id
        },
        start: {
            value: start
        },
        loaded: {
            get: function() {
                return !!file;
            }
        },
        file: {
            get: function() {
                return file;
            }
        },
        destroy: {
            value: destroy
        }
    });

    return Object.freeze(loader);
};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (function() {
    try {
        return !!new Blob();
    } catch (e) {
        return false;
    }
}());


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOGFlZDdhZDhmYTE5MWI0NjMwZTciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUb29sLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0dMU2hhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9HZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0JhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY2hlZHVsaW5nL3NyYy9zY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR2VvbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9vYmplY3RzL09iamVjdDNELmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0dMVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9XZWJnbE51bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL3NpbXBsZUNvbG9yLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL01lc2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xDdWJlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2Jhc2ljLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9TaGFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0ZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0Vhc2VOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbWF0aC9SYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9TaGFkZXJMaWJzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYmlnVHJpYW5nbGUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2NvcHkuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYVBlcnNwZWN0aXZlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvQmluYXJ5TG9hZGVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvV2ViZ2xDb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRBdHRyaWJMb2MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvTWF0ZXJpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL09yYml0YWxDb250cm9sLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvZ2VuZXJhbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvc2t5Ym94LnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9za3lib3guZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYU9ydGhvLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvbG9hZEltYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzTWFjcm8uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzVkJsdXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzQmx1ckJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzSEJsdXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9meGFhLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvZ2xvYmFsLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldEFuZEFwcGx5RXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2V4cG9zZUF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0RmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0SGFsZkZsb2F0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0V4dGVuc2lvbnNMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldFRleHR1cmVQYXJhbWV0ZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1kZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsc2xpZnkvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2Jhc2ljLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvVHdlZW5OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0TW91c2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9nbHRmLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9nbHRmLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9kZWJ1Zy5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2NhbWVyYXMvQ2FtZXJhQ3ViZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL09iakxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0hEUkxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9IRFJQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9Db2xsYWRhUGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb2xsYWRhLXBhcnNlci9saWIvQ29sbGFkYVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29sbGFkYS1wYXJzZXIvbGliL0NvbGxhZGEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9HbHRmTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMveGhyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9FZmZlY3RDb21wb3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NCbHVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYmx1cjUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2JsdXI5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9ibHVyMTMuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NGeGFhLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hDb3B5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hBeGlzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYXhpcy52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYXhpcy5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hCYWxsLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hEb3RzUGxhbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9kb3RzUGxhbmUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoU2t5Ym94LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3kuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9za3kudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoRlhBQS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1NjZW5lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1ZpZXczRC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvQXNzZXRzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9hc3NldC1saXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2VtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL3N0YXRzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvZ2xvYmFsLnNjc3M/OTczNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2RlYnVnL2RlYnVnUG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1NjZW5lQXBwLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9TZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmFzdC11cmwtcGFyc2VyL3NyYy91cmxwYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdwYXJzZXIvanMvcXVlcnlzdHJpbmdwYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5ncGFyc2VyL2pzL3F1ZXJ5c3RyaW5nc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2dyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2Jyb3dzZXItaGFzLWJsb2IuanMiXSwibmFtZXMiOlsiZ2wiLCJHTFRvb2wiLCJjYW52YXMiLCJfdmlld3BvcnQiLCJfZW5hYmxlZFZlcnRleEF0dHJpYnV0ZSIsImlkZW50aXR5TWF0cml4IiwiY3JlYXRlIiwiX25vcm1hbE1hdHJpeCIsIl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4IiwiX21vZGVsTWF0cml4IiwiX21hdHJpeCIsIl9tYXRyaXhTdGFja3MiLCJfbGFzdE1lc2giLCJfdXNlV2ViR0wyIiwiX2hhc0FycmF5SW5zdGFuY2UiLCJfZXh0QXJyYXlJbnN0YW5jZSIsIl9oYXNDaGVja2VkRXh0IiwiaWRlbnRpdHkiLCJpc01vYmlsZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJtQ2FudmFzIiwibVBhcmFtZXRlcnMiLCJ1bmRlZmluZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJkZXN0cm95Iiwic2V0U2l6ZSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInVzZVdlYmdsMiIsImN0eCIsImdldENvbnRleHQiLCJsb2ciLCJ3ZWJnbDIiLCJpbml0V2l0aEdMIiwiZXh0ZW5zaW9ucyIsImkiLCJsZW5ndGgiLCJnZXRFeHRlbnNpb24iLCJlbmFibGUiLCJERVBUSF9URVNUIiwiQ1VMTF9GQUNFIiwiQkxFTkQiLCJlbmFibGVBbHBoYUJsZW5kaW5nIiwieCIsInkiLCJ3IiwiaCIsImhhc0NoYW5nZWQiLCJ2aWV3cG9ydCIsInNjaXNzb3IiLCJyIiwiZyIsImIiLCJhIiwiY2xlYXJDb2xvciIsImNsZWFyIiwiQ09MT1JfQlVGRkVSX0JJVCIsIkRFUFRIX0JVRkZFUl9CSVQiLCJtVmFsdWUiLCJjdWxsRmFjZSIsIm1DYW1lcmEiLCJjYW1lcmEiLCJyb3RhdGUiLCJtU2hhZGVyIiwic2hhZGVyIiwic2hhZGVyUHJvZ3JhbSIsIm1Sb3RhdGlvbiIsImNvcHkiLCJtdWx0aXBseSIsIm1hdHJpeCIsImZyb21NYXQ0IiwiaW52ZXJ0IiwidHJhbnNwb3NlIiwibUdlb21ldHJ5IiwibW9kZWxNYXRyaXgiLCJkcmF3IiwiYmluZCIsInVuaWZvcm0iLCJwcm9qZWN0aW9uIiwicG9zaXRpb24iLCJkcmF3VHlwZSIsImlzSW5zdGFuY2VkIiwiZHJhd0VsZW1lbnRzSW5zdGFuY2VkIiwiaUJ1ZmZlciIsIm51bUl0ZW1zIiwiVU5TSUdORURfU0hPUlQiLCJudW1JbnN0YW5jZSIsIlBPSU5UUyIsImRyYXdBcnJheXMiLCJ2ZXJ0ZXhTaXplIiwiZHJhd0VsZW1lbnRzIiwidW5iaW5kIiwibU1lc2giLCJtYXRlcmlhbCIsImdlb21ldHJ5IiwiZG91YmxlU2lkZWQiLCJkaXNhYmxlIiwiR0wiLCJ1cGRhdGUiLCJkcmF3R2VvbWV0cnkiLCJtT2JqIiwiZHJhd01lc2giLCJ1cGRhdGVNYXRyaXgiLCJjaGlsZHJlbiIsImZvckVhY2giLCJjaGlsZCIsIm1UcmFuc2Zvcm1PYmplY3QiLCJtZXNoU291cmNlIiwibWVzaERlc3RpbmF0aW9uIiwibnVtUG9pbnRzIiwidHJhbnNmb3JtRmVlZGJhY2siLCJnZW5lcmF0ZUJ1ZmZlcnMiLCJiaW5kVHJhbnNmb3JtRmVlZGJhY2siLCJUUkFOU0ZPUk1fRkVFREJBQ0siLCJhdHRyaWJ1dGVzIiwiYXR0ciIsImJpbmRCdWZmZXJCYXNlIiwiVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUiIsImJ1ZmZlciIsIlJBU1RFUklaRVJfRElTQ0FSRCIsImJlZ2luVHJhbnNmb3JtRmVlZGJhY2siLCJlbmRUcmFuc2Zvcm1GZWVkYmFjayIsInVzZVByb2dyYW0iLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwibVdpZHRoIiwibUhlaWdodCIsIl93aWR0aCIsIl9oZWlnaHQiLCJ3aWR0aCIsImhlaWdodCIsIl9hc3BlY3RSYXRpbyIsImV4dCIsIm1FeHRlbnNpb24iLCJibGVuZEZ1bmMiLCJTUkNfQUxQSEEiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiT05FIiwibXR4IiwiY2xvbmUiLCJwdXNoIiwicG9wIiwibVBhcmFtZXRlciIsInNldFZpZXdwb3J0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZSIsImdsc2xpZnkiLCJyZXF1aXJlIiwiaXNTYW1lIiwiYXJyYXkxIiwiYXJyYXkyIiwiYWRkTGluZU51bWJlcnMiLCJzdHJpbmciLCJsaW5lcyIsInNwbGl0Iiwiam9pbiIsImNsb25lQXJyYXkiLCJtQXJyYXkiLCJzbGljZSIsIkZsb2F0MzJBcnJheSIsImRlZmF1bHRWZXJ0ZXhTaGFkZXIiLCJkZWZhdWx0RnJhZ21lbnRTaGFkZXIiLCJ1bmlmb3JtTWFwcGluZyIsImZsb2F0IiwidmVjMiIsInZlYzMiLCJ2ZWM0IiwiaW50IiwibWF0MyIsIm1hdDQiLCJHTFNoYWRlciIsInN0clZlcnRleFNoYWRlciIsInN0ckZyYWdtZW50U2hhZGVyIiwibVZhcnlpbmdzIiwicGFyYW1ldGVycyIsIl91bmlmb3JtVGV4dHVyZXMiLCJfdmFyeWluZ3MiLCJ2c1NoYWRlciIsIl9jcmVhdGVTaGFkZXJQcm9ncmFtIiwiZnNTaGFkZXIiLCJfYXR0YWNoU2hhZGVyUHJvZ3JhbSIsInVzZVNoYWRlciIsIm1OYW1lIiwibVR5cGUiLCJ1bmlmb3JtT2JqZWN0IiwidW5pZm9ybVR5cGUiLCJoYXNVbmlmb3JtIiwib1VuaWZvcm0iLCJwYXJhbWV0ZXJJbmRleCIsIm5hbWUiLCJpc051bWJlciIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInR5cGUiLCJ2YWx1ZSIsInVuaWZvcm1Mb2MiLCJpbmRleE9mIiwibmVlZFVwZGF0ZSIsIm1Vbmlmb3JtT2JqIiwidW5pZm9ybU5hbWUiLCJ0ZXh0dXJlIiwidGV4dHVyZUluZGV4IiwidXQiLCJ1bmlmb3JtVmFsdWUiLCJnZXRVbmlmb3JtVHlwZSIsImNvbmNhdCIsInRtcCIsIm1TaGFkZXJTdHIiLCJpc1ZlcnRleFNoYWRlciIsInNoYWRlclR5cGUiLCJWRVJURVhfU0hBREVSIiwiRlJBR01FTlRfU0hBREVSIiwiY3JlYXRlU2hhZGVyIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwid2FybiIsImdldFNoYWRlckluZm9Mb2ciLCJtVmVydGV4U2hhZGVyIiwibUZyYWdtZW50U2hhZGVyIiwiY3JlYXRlUHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImRlbGV0ZVNoYWRlciIsInRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3MiLCJTRVBBUkFURV9BVFRSSUJTIiwibGlua1Byb2dyYW0iLCJpc0FycmF5IiwiZ2V0QXJyYXlVbmlmb3JtVHlwZSIsIlNUQVRJQ19EUkFXIiwiZ2V0QnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwiZm9ybUJ1ZmZlciIsIm1EYXRhIiwibU51bSIsImFyeSIsIm8iLCJqIiwiR2VvbWV0cnkiLCJtRHJhd2luZ1R5cGUiLCJtVXNlVmFvIiwiX2F0dHJpYnV0ZXMiLCJfbnVtSW5zdGFuY2UiLCJfaW5kaWNlcyIsIl9mYWNlcyIsIl9idWZmZXJDaGFuZ2VkIiwiX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCIsIl9oYXNWQU8iLCJfaXNJbnN0YW5jZWQiLCJfZXh0VkFPIiwiY3JlYXRlVmVydGV4QXJyYXkiLCJfdXNlVkFPIiwibUFycmF5VmVydGljZXMiLCJtRHJhd1R5cGUiLCJidWZmZXJEYXRhIiwibm9ybWFscyIsInZlcnRpY2VzIiwiYnVmZmVyTm9ybWFsIiwibUFycmF5VGV4Q29vcmRzIiwibU5vcm1hbHMiLCJtQXJyYXlJbmRpY2VzIiwiaXNEeW5hbWljIiwiX2RyYXdUeXBlIiwiRFlOQU1JQ19EUkFXIiwiQXJyYXkiLCJVaW50MTZBcnJheSIsIl9udW1JdGVtcyIsIm1JdGVtU2l6ZSIsImRhdGEiLCJkYXRhQXJyYXkiLCJhdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJpdGVtU2l6ZSIsInNvdXJjZSIsInZlcnRleEF0dHJpYkRpdmlzb3IiLCJtU2hhZGVyUHJvZ3JhbSIsImhhc1ZBTyIsImJpbmRWZXJ0ZXhBcnJheSIsInZhbyIsImF0dHJQb3NpdGlvbiIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiX3ZhbyIsImF0dHJPYmoiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsIl91cGRhdGVJbmRleEJ1ZmZlciIsInVzaW5nRmFjZU5vcm1hbHMiLCJnZW5lcmF0ZUZhY2VzIiwiX2NvbXB1dGVGYWNlTm9ybWFscyIsIl9jb21wdXRlVmVydGV4Tm9ybWFscyIsImZhY2VJbmRleCIsImZhY2UiLCJOIiwibm9ybWFsIiwiaW5kaWNlcyIsInN1bU5vcm1hbCIsInNldCIsIm5vcm1hbGl6ZSIsImlhIiwiaWIiLCJpYyIsImMiLCJ2YmEiLCJ2Y2EiLCJ2Tm9ybWFsIiwiZmluZCIsImdldFNvdXJjZSIsIkJhdGNoIiwiX2dlb21ldHJ5IiwiX3NoYWRlciIsIkdlb20iLCJtZXNoVHJpIiwicGxhbmUiLCJudW1TZWdtZW50cyIsImF4aXMiLCJwb3NpdGlvbnMiLCJjb29yZHMiLCJnYXBYIiwiZ2FwWSIsImdhcFVWIiwic3giLCJzeSIsImluZGV4IiwidHgiLCJ0eSIsInUiLCJ2IiwibWVzaCIsImJ1ZmZlclZlcnRleCIsImJ1ZmZlclRleENvb3JkIiwiYnVmZmVySW5kZXgiLCJzcGhlcmUiLCJzaXplIiwiaXNJbnZlcnQiLCJnZXRQb3NpdGlvbiIsImlzTm9ybWFsIiwicngiLCJNYXRoIiwiUEkiLCJyeSIsInBvcyIsInNpbiIsInQiLCJjb3MiLCJwcmVjaXNpb24iLCJmbG9vciIsInJldmVyc2UiLCJjdWJlIiwiZCIsInoiLCJjb3VudCIsInNreWJveCIsImJpZ1RyaWFuZ2xlIiwiT2JqZWN0M0QiLCJfbmVlZFVwZGF0ZSIsIl94IiwiX3kiLCJfeiIsIl9zeCIsIl9zeSIsIl9zeiIsIl9yeCIsIl9yeSIsIl9yeiIsIl9wb3NpdGlvbiIsIl9zY2FsZSIsImZyb21WYWx1ZXMiLCJfcm90YXRpb24iLCJfbWF0cml4UGFyZW50IiwiX21hdHJpeFJvdGF0aW9uIiwiX21hdHJpeFNjYWxlIiwiX21hdHJpeFRyYW5zbGF0aW9uIiwiX21hdHJpeFF1YXRlcm5pb24iLCJfcXVhdCIsIl9jaGlsZHJlbiIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsImZyb21RdWF0IiwibXVsIiwic2NhbGUiLCJ0cmFuc2xhdGUiLCJ1cGRhdGVQYXJlbnRNYXRyaXgiLCJtUGFyZW50TWF0cml4IiwibVF1YXQiLCJtQ2hpbGQiLCJzcGxpY2UiLCJHTFRleHR1cmUiLCJtU291cmNlIiwibVBhcmFtIiwiX3NvdXJjZSIsIl9nZXREaW1lbnNpb24iLCJfc291cmNlVHlwZSIsImdldFNvdXJjZVR5cGUiLCJfY2hlY2tTb3VyY2UiLCJfdGV4ZWxUeXBlIiwiX2dldFRleGVsVHlwZSIsIl9pc1RleHR1cmVSZWFkeSIsIl9wYXJhbXMiLCJfY2hlY2tNaXBtYXAiLCJfY2hlY2tXcmFwcGluZyIsIl90ZXh0dXJlIiwiY3JlYXRlVGV4dHVyZSIsImFkZEVGIiwiX2xvb3AiLCJfdXBsb2FkVGV4dHVyZSIsInJlYWR5U3RhdGUiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJwaXhlbFN0b3JlaSIsIlVOUEFDS19GTElQX1lfV0VCR0wiLCJfaXNTb3VyY2VIdG1sRWxlbWVudCIsInRleEltYWdlMkQiLCJpbnRlcm5hbEZvcm1hdCIsImZvcm1hdCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01BR19GSUxURVIiLCJtYWdGaWx0ZXIiLCJURVhUVVJFX01JTl9GSUxURVIiLCJtaW5GaWx0ZXIiLCJURVhUVVJFX1dSQVBfUyIsIndyYXBTIiwiVEVYVFVSRV9XUkFQX1QiLCJ3cmFwVCIsIlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCIsInByZW11bHRpcGx5QWxwaGEiLCJhbmlzb3Ryb3B5IiwibWF4IiwiZ2V0UGFyYW1ldGVyIiwiTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUIiwibGV2ZWwiLCJtaW4iLCJ0ZXhQYXJhbWV0ZXJmIiwiVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQiLCJfZ2VuZXJhdGVNaXBtYXAiLCJnZW5lcmF0ZU1pcG1hcCIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsImJsYWNrVGV4dHVyZSIsIl9iaW5kSW5kZXgiLCJ0ZXhlbFR5cGUiLCJzIiwidmlkZW9XaWR0aCIsInNxcnQiLCJVTlNJR05FRF9CWVRFIiwiVWludDhBcnJheSIsIm1pcG1hcCIsImlzUG93ZXJPZlR3byIsIkNMQU1QX1RPX0VER0UiLCJIVE1MSW1hZ2VFbGVtZW50IiwiSFRNTENhbnZhc0VsZW1lbnQiLCJIVE1MVmlkZW9FbGVtZW50IiwiX3doaXRlVGV4dHVyZSIsIl9ncmV5VGV4dHVyZSIsIl9ibGFja1RleHR1cmUiLCJ3aGl0ZVRleHR1cmUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImdyZXlUZXh0dXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsIlBhc3MiLCJtUGFyYW1zIiwiYmlnVHJpYW5nbGVWZXJ0IiwiX3VuaWZvcm1zIiwiX2hhc093bkZibyIsIl9mYm8iLCJtUGFybWFzIiwiTWVzaCIsIkREU0RfTUlQTUFQQ09VTlQiLCJPRkZfTUlQTUFQQ09VTlQiLCJoZWFkZXJMZW5ndGhJbnQiLCJHTEN1YmVUZXh0dXJlIiwiaXNDdWJlVGV4dHVyZSIsImhhc01pcG1hcHMiLCJtaXBtYXBDb3VudCIsIkxJTkVBUiIsIkxJTkVBUl9NSVBNQVBfTElORUFSIiwiVEVYVFVSRV9DVUJFX01BUCIsInRhcmdldHMiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1giLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1giLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1kiLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1kiLCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1oiLCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1oiLCJudW1MZXZlbHMiLCJzaGFwZSIsIlJHQkEiLCJwYXJzZUREUyIsIm1BcnJheUJ1ZmZlciIsImNsYW1wIiwiZGRzSW5mb3MiLCJmbGFncyIsImhlYWRlciIsIkludDMyQXJyYXkiLCJzb3VyY2VzIiwiaW1hZ2VzIiwibWFwIiwiaW1nIiwiZmFjZURhdGEiLCJvZmZzZXQiLCJzaGFkZXJDYWNoZSIsImRlZmluZXNUb1N0cmluZyIsImRlZmluZXMiLCJvdXRTdHIiLCJkZWYiLCJhZGRVbmlmb3JtcyIsIm1PYmpVbmlmb3JtcyIsInN0clVuaWZvcm1zIiwicmVwbGFjZSIsImJpbmRVbmlmb3JtcyIsImluamVjdERlZmluZXMiLCJtRGVmaW5lcyIsImdldCIsInZzIiwiZnMiLCJfdnMiLCJfZnMiLCJnbFNoYWRlciIsIndlYmdsRGVwdGhUZXh0dXJlIiwiaGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCIsImV4dERyYXdCdWZmZXIiLCJjaGVja011bHRpUmVuZGVyIiwiRnJhbWVCdWZmZXIiLCJtTnVtVGFyZ2V0cyIsImNoZWNrRXh0ZW5zaW9uIiwiX251bVRhcmdldHMiLCJfbXVsdGlwbGVUYXJnZXRzIiwiX3BhcmFtZXRlcnMiLCJfY2hlY2tNYXhOdW1SZW5kZXJUYXJnZXQiLCJfaW5pdCIsIl9pbml0VGV4dHVyZXMiLCJmcmFtZUJ1ZmZlciIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJidWZmZXJzIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJEUkFXX0ZSQU1FQlVGRkVSIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJfdGV4dHVyZXMiLCJkcmF3QnVmZmVycyIsIkRFUFRIX0FUVEFDSE1FTlQiLCJnbERlcHRoVGV4dHVyZSIsImRyYXdCdWZmZXJzV0VCR0wiLCJGQk9zdGF0dXMiLCJjaGVja0ZyYW1lYnVmZmVyU3RhdHVzIiwiRlJBTUVCVUZGRVJfQ09NUExFVEUiLCJiaW5kUmVuZGVyYnVmZmVyIiwiUkVOREVSQlVGRkVSIiwibWF4TnVtRHJhd0J1ZmZlcnMiLCJNQVhfRFJBV19CVUZGRVJTX1dFQkdMIiwiZ2x0IiwiX2NyZWF0ZVRleHR1cmUiLCJERVBUSF9DT01QT05FTlQxNiIsIkRFUFRIX0NPTVBPTkVOVCIsIm1JbnRlcm5hbGZvcm1hdCIsIm1UZXhlbFR5cGUiLCJtRm9ybWF0IiwibUF1dG9TZXRWaWV3cG9ydCIsIm1JbmRleCIsInNob3dQYXJhbWV0ZXJzIiwiRWFzZU51bWJlciIsIm1FYXNpbmciLCJlYXNpbmciLCJfdmFsdWUiLCJfdGFyZ2V0VmFsdWUiLCJfZWZJbmRleCIsIl91cGRhdGUiLCJNSU5fRElGRiIsIl9jaGVja0xpbWl0IiwiYWJzIiwibUFkZCIsIm1NaW4iLCJtTWF4IiwibGltaXQiLCJfbWluIiwiX21heCIsInJlbW92ZUVGIiwidGFyZ2V0IiwiZWRnZTEiLCJlZGdlMiIsImRpZmYiLCJSYXkiLCJtT3JpZ2luIiwibURpcmVjdGlvbiIsIm9yaWdpbiIsImRpcmVjdGlvbiIsImFkZCIsIm1UYXJnZXQiLCJzdWIiLCJtUG9pbnQiLCJyZXN1bHQiLCJkaXJlY3Rpb25EaXN0YW5jZSIsImRvdCIsImRpc3RhbmNlU3FUb1BvaW50IiwidjEiLCJzcXVhcmVkRGlzdGFuY2UiLCJtQ2VudGVyIiwibVJhZGl1cyIsImRpc3RhbmNlVG9Qb2ludCIsInRjYSIsImQyIiwicmFkaXVzMiIsInRoYyIsInQwIiwidDEiLCJhdCIsIm1QbGFuZUNlbnRlciIsIm1Ob3JtYWwiLCJkZW5vbWluYXRvciIsIm1QQSIsIm1QQiIsIm1QQyIsImJhY2tmYWNlQ3VsbGluZyIsImNyb3NzIiwiRGROIiwic2lnbiIsIkRkUXhFMiIsIkRkRTF4USIsIlFkbiIsIlNoYWRlckxpYnMiLCJzaW1wbGVDb2xvckZyYWciLCJnZW5lcmFsVmVydCIsImNvcHlGcmFnIiwiYmFzaWNWZXJ0Iiwic2t5Ym94VmVydCIsInNreWJveEZyYWciLCJnbHRmVmVydCIsImdsdGZGcmFnIiwiZGVidWdGcmFnIiwiQ2FtZXJhIiwiX29yaWVudGF0aW9uIiwiX3Byb2plY3Rpb24iLCJhRXllIiwiYUNlbnRlciIsImFVcCIsIl9leWUiLCJfY2VudGVyIiwibG9va0F0IiwicG9zaXRpb25PZmZzZXQiLCJtUHJvaiIsIm1WaWV3Iiwic2V0VmlldyIsInNldFByb2plY3Rpb24iLCJtSW52ZXJzZVZpZXdQcm9qIiwiY2FtZXJhRGlyIiwiQ2FtZXJhUGVyc3BlY3RpdmUiLCJtRm92IiwibUFzcGVjdFJhdGlvIiwibU5lYXIiLCJtRmFyIiwiX2ZvdiIsIl9uZWFyIiwiX2ZhciIsInBlcnNwZWN0aXZlIiwibVNjcmVlblBvc2l0aW9uIiwibVJheSIsInByb2oiLCJwcm9qZWN0aW9uTWF0cml4IiwidmlldyIsInZpZXdNYXRyaXgiLCJ0cmFuc2Zvcm1NYXQ0IiwiQmluYXJ5TG9hZGVyIiwiaXNBcnJheUJ1ZmZlciIsIl9yZXEiLCJYTUxIdHRwUmVxdWVzdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfb25Mb2FkZWQiLCJfb25Qcm9ncmVzcyIsInJlc3BvbnNlVHlwZSIsInVybCIsImNhbGxiYWNrIiwiX2NhbGxiYWNrIiwib3BlbiIsInNlbmQiLCJyZXNwb25zZSIsIkdMTSIsIlZFUlNJT04iLCJBbGZyaWQiLCJnbG0iLCJNYXRlcmlhbCIsIkN1YmVGcmFtZUJ1ZmZlciIsIlNjaGVkdWxlciIsIkV2ZW50RGlzcGF0Y2hlciIsIlR3ZWVuTnVtYmVyIiwiQ2FtZXJhT3J0aG8iLCJDYW1lcmFDdWJlIiwiT3JiaXRhbENvbnRyb2wiLCJRdWF0Um90YXRpb24iLCJUb3VjaERldGVjdG9yIiwiT2JqTG9hZGVyIiwiQ29sbGFkYVBhcnNlciIsIkhEUkxvYWRlciIsIkdMVEZMb2FkZXIiLCJsb2FkSW1hZ2VzIiwiQmF0Y2hDb3B5IiwiQmF0Y2hBeGlzIiwiQmF0Y2hCYWxsIiwiQmF0Y2hMaW5lIiwiQmF0Y2hTa3lib3giLCJCYXRjaFNreSIsIkJhdGNoRlhBQSIsIkJhdGNoRG90c1BsYW5lIiwiU2NlbmUiLCJWaWV3IiwiVmlldzNEIiwiU2hhZGVycyIsIldlYmdsTnVtYmVyIiwiRWZmZWN0Q29tcG9zZXIiLCJQYXNzTWFjcm8iLCJQYXNzQmx1ciIsIlBhc3NWQmx1ciIsIlBhc3NIQmx1ciIsIlBhc3NGeGFhIiwiTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlciIsIlRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IiwiYWwiLCJBQ1RJVkVfQVRUUklCVVRFUyIsIkFDVElWRV9BVFRSSUJVVEVfTUFYX0xFTkdUSCIsIkFDVElWRV9URVhUVVJFIiwiQUNUSVZFX1VOSUZPUk1TIiwiQUNUSVZFX1VOSUZPUk1fTUFYX0xFTkdUSCIsIkFMSUFTRURfTElORV9XSURUSF9SQU5HRSIsIkFMSUFTRURfUE9JTlRfU0laRV9SQU5HRSIsIkFMUEhBIiwiQUxQSEFfQklUUyIsIkFMV0FZUyIsIkFSUkFZX0JVRkZFUl9CSU5ESU5HIiwiQVRUQUNIRURfU0hBREVSUyIsIkJBQ0siLCJCTEVORF9DT0xPUiIsIkJMRU5EX0RTVF9BTFBIQSIsIkJMRU5EX0RTVF9SR0IiLCJCTEVORF9FUVVBVElPTiIsIkJMRU5EX0VRVUFUSU9OX0FMUEhBIiwiQkxFTkRfRVFVQVRJT05fUkdCIiwiQkxFTkRfU1JDX0FMUEhBIiwiQkxFTkRfU1JDX1JHQiIsIkJMVUVfQklUUyIsIkJPT0wiLCJCT09MX1ZFQzIiLCJCT09MX1ZFQzMiLCJCT09MX1ZFQzQiLCJCUk9XU0VSX0RFRkFVTFRfV0VCR0wiLCJCVUZGRVJfU0laRSIsIkJVRkZFUl9VU0FHRSIsIkJZVEUiLCJDQ1ciLCJDT0xPUl9DTEVBUl9WQUxVRSIsIkNPTE9SX1dSSVRFTUFTSyIsIkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTIiwiQ09OU1RBTlRfQUxQSEEiLCJDT05TVEFOVF9DT0xPUiIsIkNPTlRFWFRfTE9TVF9XRUJHTCIsIkNVTExfRkFDRV9NT0RFIiwiQ1VSUkVOVF9QUk9HUkFNIiwiQ1VSUkVOVF9WRVJURVhfQVRUUklCIiwiQ1ciLCJERUNSIiwiREVDUl9XUkFQIiwiREVMRVRFX1NUQVRVUyIsIkRFUFRIX0JJVFMiLCJERVBUSF9DTEVBUl9WQUxVRSIsIlJFRCIsIkRFUFRIX0ZVTkMiLCJERVBUSF9SQU5HRSIsIkRFUFRIX1NURU5DSUwiLCJERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQiLCJERVBUSF9XUklURU1BU0siLCJESVRIRVIiLCJET05UX0NBUkUiLCJEU1RfQUxQSEEiLCJEU1RfQ09MT1IiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HIiwiRVFVQUwiLCJGQVNURVNUIiwiRkxPQVRfTUFUMiIsIkZMT0FUX01BVDMiLCJGTE9BVF9NQVQ0IiwiRkxPQVRfVkVDMiIsIkZMT0FUX1ZFQzMiLCJGTE9BVF9WRUM0IiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEUiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfQ1VCRV9NQVBfRkFDRSIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTCIsIkZSQU1FQlVGRkVSX0JJTkRJTkciLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCIsIkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEIiwiRlJPTlQiLCJGUk9OVF9BTkRfQkFDSyIsIkZST05UX0ZBQ0UiLCJGVU5DX0FERCIsIkZVTkNfUkVWRVJTRV9TVUJUUkFDVCIsIkZVTkNfU1VCVFJBQ1QiLCJHRU5FUkFURV9NSVBNQVBfSElOVCIsIkdFUVVBTCIsIkdSRUFURVIiLCJHUkVFTl9CSVRTIiwiSElHSF9GTE9BVCIsIkhJR0hfSU5UIiwiSU5DUiIsIklOQ1JfV1JBUCIsIklORk9fTE9HX0xFTkdUSCIsIklOVCIsIklOVF9WRUMyIiwiSU5UX1ZFQzMiLCJJTlRfVkVDNCIsIklOVkFMSURfRU5VTSIsIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OIiwiSU5WQUxJRF9PUEVSQVRJT04iLCJJTlZBTElEX1ZBTFVFIiwiSU5WRVJUIiwiS0VFUCIsIkxFUVVBTCIsIkxFU1MiLCJMSU5FQVJfTUlQTUFQX05FQVJFU1QiLCJMSU5FUyIsIkxJTkVfTE9PUCIsIkxJTkVfU1RSSVAiLCJMSU5FX1dJRFRIIiwiTElOS19TVEFUVVMiLCJMT1dfRkxPQVQiLCJMT1dfSU5UIiwiTFVNSU5BTkNFIiwiTFVNSU5BTkNFX0FMUEhBIiwiTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFIiwiTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyIsIk1BWF9SRU5ERVJCVUZGRVJfU0laRSIsIk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiTUFYX1RFWFRVUkVfU0laRSIsIk1BWF9WQVJZSU5HX1ZFQ1RPUlMiLCJNQVhfVkVSVEVYX0FUVFJJQlMiLCJNQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMiLCJNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyIsIk1BWF9WSUVXUE9SVF9ESU1TIiwiTUVESVVNX0ZMT0FUIiwiTUVESVVNX0lOVCIsIk1JUlJPUkVEX1JFUEVBVCIsIk5FQVJFU1QiLCJORUFSRVNUX01JUE1BUF9MSU5FQVIiLCJORUFSRVNUX01JUE1BUF9ORUFSRVNUIiwiTkVWRVIiLCJOSUNFU1QiLCJOT05FIiwiTk9URVFVQUwiLCJOT19FUlJPUiIsIk5VTV9DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyIsIk9ORV9NSU5VU19DT05TVEFOVF9BTFBIQSIsIk9ORV9NSU5VU19DT05TVEFOVF9DT0xPUiIsIk9ORV9NSU5VU19EU1RfQUxQSEEiLCJPTkVfTUlOVVNfRFNUX0NPTE9SIiwiT05FX01JTlVTX1NSQ19DT0xPUiIsIk9VVF9PRl9NRU1PUlkiLCJQQUNLX0FMSUdOTUVOVCIsIlBPTFlHT05fT0ZGU0VUX0ZBQ1RPUiIsIlBPTFlHT05fT0ZGU0VUX0ZJTEwiLCJQT0xZR09OX09GRlNFVF9VTklUUyIsIlJFRF9CSVRTIiwiUkVOREVSQlVGRkVSX0FMUEhBX1NJWkUiLCJSRU5ERVJCVUZGRVJfQklORElORyIsIlJFTkRFUkJVRkZFUl9CTFVFX1NJWkUiLCJSRU5ERVJCVUZGRVJfREVQVEhfU0laRSIsIlJFTkRFUkJVRkZFUl9HUkVFTl9TSVpFIiwiUkVOREVSQlVGRkVSX0hFSUdIVCIsIlJFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVQiLCJSRU5ERVJCVUZGRVJfUkVEX1NJWkUiLCJSRU5ERVJCVUZGRVJfU1RFTkNJTF9TSVpFIiwiUkVOREVSQlVGRkVSX1dJRFRIIiwiUkVOREVSRVIiLCJSRVBFQVQiLCJSRVBMQUNFIiwiUkdCIiwiUkdCNV9BMSIsIlJHQjU2NSIsIlJHQkE0IiwiU0FNUExFUl8yRCIsIlNBTVBMRVJfQ1VCRSIsIlNBTVBMRVMiLCJTQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UiLCJTQU1QTEVfQlVGRkVSUyIsIlNBTVBMRV9DT1ZFUkFHRSIsIlNBTVBMRV9DT1ZFUkFHRV9JTlZFUlQiLCJTQU1QTEVfQ09WRVJBR0VfVkFMVUUiLCJTQ0lTU09SX0JPWCIsIlNDSVNTT1JfVEVTVCIsIlNIQURFUl9DT01QSUxFUiIsIlNIQURFUl9TT1VSQ0VfTEVOR1RIIiwiU0hBREVSX1RZUEUiLCJTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04iLCJTSE9SVCIsIlNSQ19BTFBIQV9TQVRVUkFURSIsIlNSQ19DT0xPUiIsIlNURU5DSUxfQVRUQUNITUVOVCIsIlNURU5DSUxfQkFDS19GQUlMIiwiU1RFTkNJTF9CQUNLX0ZVTkMiLCJTVEVOQ0lMX0JBQ0tfUEFTU19ERVBUSF9GQUlMIiwiU1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfUEFTUyIsIlNURU5DSUxfQkFDS19SRUYiLCJTVEVOQ0lMX0JBQ0tfVkFMVUVfTUFTSyIsIlNURU5DSUxfQkFDS19XUklURU1BU0siLCJTVEVOQ0lMX0JJVFMiLCJTVEVOQ0lMX0JVRkZFUl9CSVQiLCJTVEVOQ0lMX0NMRUFSX1ZBTFVFIiwiU1RFTkNJTF9GQUlMIiwiU1RFTkNJTF9GVU5DIiwiU1RFTkNJTF9JTkRFWCIsIlNURU5DSUxfSU5ERVg4IiwiU1RFTkNJTF9QQVNTX0RFUFRIX0ZBSUwiLCJTVEVOQ0lMX1BBU1NfREVQVEhfUEFTUyIsIlNURU5DSUxfUkVGIiwiU1RFTkNJTF9URVNUIiwiU1RFTkNJTF9WQUxVRV9NQVNLIiwiU1RFTkNJTF9XUklURU1BU0siLCJTVFJFQU1fRFJBVyIsIlNVQlBJWEVMX0JJVFMiLCJURVhUVVJFIiwiVEVYVFVSRTEiLCJURVhUVVJFMiIsIlRFWFRVUkUzIiwiVEVYVFVSRTQiLCJURVhUVVJFNSIsIlRFWFRVUkU2IiwiVEVYVFVSRTciLCJURVhUVVJFOCIsIlRFWFRVUkU5IiwiVEVYVFVSRTEwIiwiVEVYVFVSRTExIiwiVEVYVFVSRTEyIiwiVEVYVFVSRTEzIiwiVEVYVFVSRTE0IiwiVEVYVFVSRTE1IiwiVEVYVFVSRTE2IiwiVEVYVFVSRTE3IiwiVEVYVFVSRTE4IiwiVEVYVFVSRTE5IiwiVEVYVFVSRTIwIiwiVEVYVFVSRTIxIiwiVEVYVFVSRTIyIiwiVEVYVFVSRTIzIiwiVEVYVFVSRTI0IiwiVEVYVFVSRTI1IiwiVEVYVFVSRTI2IiwiVEVYVFVSRTI3IiwiVEVYVFVSRTI4IiwiVEVYVFVSRTI5IiwiVEVYVFVSRTMwIiwiVEVYVFVSRTMxIiwiVEVYVFVSRV9CSU5ESU5HXzJEIiwiVEVYVFVSRV9CSU5ESU5HX0NVQkVfTUFQIiwiVFJJQU5HTEVTIiwiVFJJQU5HTEVfRkFOIiwiVFJJQU5HTEVfU1RSSVAiLCJVTlBBQ0tfQUxJR05NRU5UIiwiVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCIsIlVOU0lHTkVEX0lOVCIsIlVOU0lHTkVEX1NIT1JUXzRfNF80XzQiLCJVTlNJR05FRF9TSE9SVF81XzVfNV8xIiwiVU5TSUdORURfU0hPUlRfNV82XzUiLCJWQUxJREFURV9TVEFUVVMiLCJWRU5ET1IiLCJWRVJURVhfQVRUUklCX0FSUkFZX0JVRkZFUl9CSU5ESU5HIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9OT1JNQUxJWkVEIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9TSVpFIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9TVFJJREUiLCJWRVJURVhfQVRUUklCX0FSUkFZX1RZUEUiLCJWSUVXUE9SVCIsIlpFUk8iLCJSOCIsImNhY2hlQXR0cmliTG9jIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJ1bmlmb3JtcyIsInN1cHBvcnRzQ3VzdG9tRXZlbnRzIiwibmV3VGVzdEN1c3RvbUV2ZW50IiwiY3JlYXRlRXZlbnQiLCJfZXZlbnRMaXN0ZW5lcnMiLCJhRXZlbnRUeXBlIiwiYUZ1bmN0aW9uIiwiY3VycmVudEFycmF5IiwiY3VycmVudEFycmF5TGVuZ3RoIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFFdmVudCIsImV2ZW50VHlwZSIsImN1cnJlbnRUYXJnZXQiLCJ0aGVFcnJvciIsIm5ld0V2ZW50IiwiZGV0YWlsIiwiZGlzcGF0Y2hlciIsImRpc3BhdGNoRXZlbnQiLCJjdXJyZW50RXZlbnRMaXN0ZW5lcnMiLCJfY29weUFycmF5IiwiY3VycmVudEZ1bmN0aW9uIiwiY2FsbCIsImFEZXRhaWwiLCJpbml0Q3VzdG9tRXZlbnQiLCJkaXNwYXRjaEN1c3RvbUV2ZW50Iiwib2JqZWN0TmFtZSIsImhhc093blByb3BlcnR5IiwiYUFycmF5IiwiZ2V0TW91c2UiLCJtRXZlbnQiLCJ0b3VjaGVzIiwicGFnZVgiLCJwYWdlWSIsImNsaWVudFgiLCJjbGllbnRZIiwibUxpc3RlbmVyVGFyZ2V0IiwiX3RhcmdldCIsIl9saXN0ZW5lclRhcmdldCIsIl9tb3VzZSIsIl9wcmVNb3VzZSIsImNlbnRlciIsIl91cCIsInJhZGl1cyIsIl9wcmVSWCIsIl9wcmVSWSIsIl9pc0xvY2tab29tIiwiX2lzTG9ja1JvdGF0aW9uIiwiX2lzSW52ZXJ0Iiwic2Vuc2l0aXZpdHkiLCJfd2hlZWxCaW5kIiwiX29uV2hlZWwiLCJfZG93bkJpbmQiLCJfb25Eb3duIiwiX21vdmVCaW5kIiwiX29uTW92ZSIsIl91cEJpbmQiLCJfb25VcCIsImNvbm5lY3QiLCJkaXNjb25uZWN0IiwiX2lzTW91c2VEb3duIiwidGFyZ2V0VmFsdWUiLCJwcmV2ZW50RGVmYXVsdCIsImRpZmZYIiwiZGlmZlkiLCJ3aGVlbERlbHRhIiwiX3VwZGF0ZVBvc2l0aW9uIiwiX3VwZGF0ZUNhbWVyYSIsInRyIiwiZXllIiwidXAiLCJvcnRobyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsIm5lYXIiLCJmYXIiLCJyZXNvbHZlIiwicmVqZWN0IiwiSW1hZ2UiLCJvbmxvYWQiLCJvbkxvYWQiLCJvbmVycm9yIiwib25FcnJvciIsInNyYyIsInBhdGhzIiwiYWxsIiwiX3Bhc3NlcyIsInBhc3MiLCJtUXVhbGl0eSIsImZzQmx1cjUiLCJmc0JsdXI5IiwiZnNCbHVyMTMiLCJQYXNzQmx1ckJhc2UiLCJnZXRBbmRBcHBseUV4dGVuc2lvbiIsInN1ZmZpeCIsInN1ZmZpeFJFIiwiUmVnRXhwIiwia2V5IiwidmFsIiwidW5zdWZmaXhlZEtleSIsInN1YnN0cmluZyIsImV4cG9zZUF0dHJpYnV0ZXMiLCJoYXNDaGVja2VkIiwiX2Zsb2F0IiwiY2hlY2tGbG9hdCIsImV4dEZsb2F0IiwiaGFsZkZsb2F0IiwiY2hlY2tIYWxmRmxvYXQiLCJIQUxGX0ZMT0FUIiwiZXh0SGFsZkZsb2F0IiwiSEFMRl9GTE9BVF9PRVMiLCJnZXRUZXh0dXJlUGFyYW1ldGVycyIsIl9zaXplIiwiZ2xUZXh0dXJlIiwiX2ZyYW1lQnVmZmVycyIsInN0YXR1cyIsIm1UYXJnZXRJbmRleCIsInVzZURlcHRoIiwidXNlU3RlbmNpbCIsIl9udW1TYW1wbGUiLCJudW1TYW1wbGUiLCJmcmFtZUJ1ZmZlckNvbG9yIiwicmVuZGVyQnVmZmVyQ29sb3IiLCJjcmVhdGVSZW5kZXJidWZmZXIiLCJyZW5kZXJCdWZmZXJEZXB0aCIsInJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSIsIlJHQkE4IiwiZnJhbWVidWZmZXJSZW5kZXJidWZmZXIiLCJmb3JjZU5lYXJlc3QiLCJSRUFEX0ZSQU1FQlVGRkVSIiwiY2xlYXJCdWZmZXJmdiIsIkNPTE9SIiwiYmxpdEZyYW1lYnVmZmVyIiwiX2dlb0N1cnJlbnQiLCJfZ2VvVGFyZ2V0IiwiX251bVBvaW50cyIsImNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrIiwibVZhcnlpbmdOYW1lIiwiaXNUcmFuc2Zvcm1GZWVkYmFjayIsIlNUUkVBTV9DT1BZIiwiZ2VuZXJhdGUiLCJkcmF3VHJhbnNmb3JtRmVlZGJhY2siLCJfc3dhcCIsIkVhc2luZyIsIkxpbmVhciIsIk5vbmUiLCJrIiwiUXVhZHJhdGljIiwiSW4iLCJPdXQiLCJJbk91dCIsIkN1YmljIiwiUXVhcnRpYyIsIlF1aW50aWMiLCJTaW51c29pZGFsIiwiRXhwb25lbnRpYWwiLCJwb3ciLCJDaXJjdWxhciIsIkVsYXN0aWMiLCJwIiwiYXNpbiIsIkJhY2siLCJCb3VuY2UiLCJpbiIsIm91dCIsImluT3V0IiwiZ2V0RnVuYyIsIm1TcGVlZCIsIl9zdGFydFZhbHVlIiwiX2NvdW50ZXIiLCJzcGVlZCIsIm5ld0NvdW50ZXIiLCJmIiwibSIsIl92WmF4aXMiLCJfekF4aXMiLCJwcmVNb3VzZSIsIm1vdXNlIiwicXVhdCIsInRlbXBSb3RhdGlvbiIsIl9yb3RhdGVaTWFyZ2luIiwiX29mZnNldCIsIl9zbGVycCIsIl9pc0xvY2tlZCIsIl9kaWZmWCIsIl9kaWZmWSIsIl91cGRhdGVSb3RhdGlvbiIsIl9jdXJyRGlmZlgiLCJfY3VyckRpZmZZIiwiX2lzUm90YXRlWiIsIl90YXJnZXRRdWF0Iiwic2V0VG8iLCJtVGVtcFJvdGF0aW9uIiwiYW5nbGUiLCJzbGVycCIsInRyYW5zZm9ybVF1YXQiLCJkaXN0YW5jZSIsImR4IiwiZHkiLCJtU2tpcE1vdmVDaGVjayIsIl9jYW1lcmEiLCJmYWNlVmVydGljZXMiLCJmYWNlcyIsImNsaWNrVG9sZXJhbmNlIiwiX3JheSIsIl9oaXQiLCJfbGFzdFBvcyIsIl9maXJzdFBvcyIsIm10eE1vZGVsIiwiX3NraXBwaW5nTW92ZSIsIl9vbk1vdmVCaW5kIiwiX29uRG93bkJpbmQiLCJfb25VcEJpbmQiLCJteCIsIm15IiwiZ2VuZXJhdGVSYXkiLCJoaXQiLCJ2MCIsInYyIiwiZGlzdCIsImdldFZlY3RvciIsImludGVyc2VjdFRyaWFuZ2xlIiwiZGlzdFRvQ2FtIiwiX2NoZWNrSGl0IiwiQ0FNRVJBX1NFVFRJTkdTIiwic2V0UGVyc3BlY3RpdmUiLCJwYXJzZU9iaiIsIm9ialN0ciIsImZpbmFsTm9ybWFscyIsInV2cyIsInZlcnRleFBhdHRlcm4iLCJub3JtYWxQYXR0ZXJuIiwidXZQYXR0ZXJuIiwiZmFjZVBhdHRlcm4xIiwiZmFjZVBhdHRlcm4yIiwiZmFjZVBhdHRlcm4zIiwiZmFjZVBhdHRlcm40IiwicGFyc2VWZXJ0ZXhJbmRleCIsInBhcnNlSW50IiwicGFyc2VOb3JtYWxJbmRleCIsInBhcnNlVVZJbmRleCIsImFkZFZlcnRleCIsImFkZFVWIiwiYWRkTm9ybWFsIiwiYWRkRmFjZSIsInVhIiwidWIiLCJ1YyIsInVkIiwibmEiLCJuYiIsIm5jIiwibmQiLCJpZCIsImxpbmUiLCJ0cmltIiwiY2hhckF0IiwiZXhlYyIsInBhcnNlRmxvYXQiLCJfZ2VuZXJhdGVHZW9tZXRyeSIsIm1heE51bVZlcnRpY2VzIiwiaGFzTm9ybWFscyIsImhhc1VWcyIsImdlb21ldHJpZXMiLCJsYXN0SW5kZXgiLCJvQ29weSIsInNsaWNlTnVtIiwidG1wSW5kZXgiLCJwYXJzZSIsImxvYWRlciIsInJhZGlhbmNlUGF0dGVybiIsImNvbW1lbnRQYXR0ZXJuIiwiZXhwb3N1cmVQYXR0ZXJuIiwiZm9ybWF0UGF0dGVybiIsIndpZHRoSGVpZ2h0UGF0dGVybiIsInJlYWRQaXhlbHNSYXdSTEUiLCJmaWxlT2Zmc2V0Iiwic2NhbmxpbmVXaWR0aCIsIm51bVNjYW5saW5lcyIsInJnYmUiLCJzY2FubGluZUJ1ZmZlciIsInB0ciIsInB0ckVuZCIsImJ1ZiIsImJ1ZmZlckxlbmd0aCIsInJlYWRCdWYiLCJieXRlc1JlYWQiLCJyZWFkQnVmT2Zmc2V0IiwicmVhZFBpeGVsc1JhdyIsIm51bXBpeGVscyIsIm51bUV4cGVjdGVkIiwibnVtUmVhZCIsIkVycm9yIiwicGFyc2VIZHIiLCJBcnJheUJ1ZmZlciIsIk5FV19MSU5FIiwicmVhZExpbmUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJleHBvc3VyZSIsImdhbW1hIiwicmxlIiwibWF0Y2giLCJOdW1iZXIiLCJmbG9hdERhdGEiLCJmbG9hdE9mZnNldCIsImdlbmVyYXRlR2VvbWV0cnkiLCJtZXNoZXMiLCJjYWNoZXMiLCJ0cmlhbmdsZXMiLCJnbEdlb21ldHJ5IiwiYnVmZmVyRmxhdHRlbkRhdGEiLCJsb2FkIiwibVBhdGgiLCJtQ2FsbGJhY2siLCJBUlJBWV9DVE9SX01BUCIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIlNJWkVfTUFQIiwiU0NBTEFSIiwiVkVDMiIsIlZFQzMiLCJWRUM0IiwiTUFUMiIsIk1BVDMiLCJNQVQ0Iiwic2VtYW50aWNBdHRyaWJ1dGVNYXAiLCJOT1JNQUwiLCJQT1NJVElPTiIsIlRFWENPT1JEXzAiLCJXRUlHSFRTXzAiLCJKT0lOVFNfMCIsImJhc2UiLCJsYXN0SW5kZXhPZiIsIl9sb2FkR2x0ZiIsInRoZW4iLCJfbG9hZEJpbiIsIl9sb2FkVGV4dHVyZXMiLCJfZ2V0QnVmZmVyVmlld0RhdGEiLCJfcGFyc2VNYXRlcmlhbHMiLCJfcGFyc2VNZXNoIiwiX3BhcnNlTm9kZXMiLCJnbHRmSW5mbyIsImNhdGNoIiwiZ2x0ZiIsIm5vZGVzIiwic2NlbmVzIiwiZ2V0VHJlZSIsIm5vZGVJbmRleCIsIm5vZGUiLCJvYmozRCIsIm91dHB1dCIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlWiIsInJvdGF0aW9uIiwic2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiIsInRyYW5zbGF0aW9uIiwiX2NoaWxkIiwiYWRkQ2hpbGQiLCJjb250YWluZXIiLCJzY2VuZSIsImNoaWxkVHJlZSIsInByaW1pdGl2ZXMiLCJnZW9tZXRyeUluZm8iLCJzZW1hbnRpY3MiLCJPYmplY3QiLCJrZXlzIiwicHJpbWl0aXZlSW5mbyIsImFjY2Vzc29ySWR4Iiwic2VtYW50aWMiLCJhdHRyaWJ1dGVJbmZvIiwiYWNjZXNzb3JzIiwiYXR0cmlidXRlTmFtZSIsIkhBU19OT1JNQUxTIiwiSEFTX1VWIiwiYXR0cmlidXRlQXJyYXkiLCJfZ2V0QWNjZXNzb3JEYXRhIiwibWF0ZXJpYWxJbmZvIiwiZW1pc3NpdmVGYWNvdHIiLCJub3JtYWxUZXh0dXJlIiwib2NjbHVzaW9uVGV4dHVyZSIsInBick1ldGFsbGljUm91Z2huZXNzIiwiYmFzZUNvbG9yVGV4dHVyZSIsIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsInVFbWlzc2l2ZUZhY3RvciIsInVCYXNlQ29sb3IiLCJiYXNlQ29sb3JGYWN0b3IiLCJ1Um91Z2huZXNzIiwicm91Z2huZXNzRmFjdG9yIiwidU1ldGFsbGljIiwibWV0YWxsaWNGYWN0b3IiLCJ1U2NhbGVEaWZmQmFzZU1SIiwidVNjYWxlRkdEU3BlYyIsInVTY2FsZUlCTEFtYmllbnQiLCJ1TGlnaHREaXJlY3Rpb24iLCJ1TGlnaHRDb2xvciIsInVHYW1tYSIsInVDb2xvck1hcCIsInVNZXRhbGxpY1JvdWdobmVzc01hcCIsInVOb3JtYWxTY2FsZSIsInVOb3JtYWxNYXAiLCJ1QW9NYXAiLCJ1T2NjbHVzaW9uU3RyZW5ndGgiLCJzdHJlbmd0aCIsImJ1ZmZlclZpZXdzIiwiYnVmZmVyVmlld0luZm8iLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIkpTT04iLCJ0ZXh0dXJlcyIsInVybEJpbiIsInVyaSIsInNhbXBsZXJzIiwiaW1hZ2VzVG9Mb2FkIiwic2V0dGluZ3MiLCJzYW1wbGVyIiwibWF0ZXJpYWxzIiwiVVNFX0lCTCIsIkhBU19OT1JNQUxNQVAiLCJIQVNfT0NDTFVTSU9OTUFQIiwiSEFTX0JBU0VDT0xPUk1BUCIsIkhBU19NRVRBTFJPVUdITkVTU01BUCIsIm1HbHRmSW5mbyIsIm1CaW4iLCJpc0luZGljZXMiLCJhY2Nlc3NvckluZm8iLCJidWZmZXJWaWV3IiwiQXJyYXlDdG9yIiwiY29tcG9uZW50VHlwZSIsImFyciIsInF1YW50aXplRXh0ZW5zaW9uIiwiZGVjb2RlZEFyciIsImRlY29kZU1hdHJpeCIsImRlY29kZU9mZnNldCIsImRlY29kZVNjYWxlIiwiUHJvbWlzZSIsInJlcSIsIl9yZXR1cm5UZXh0dXJlIiwicGFzc2VzIiwiYWRkUGFzcyIsImZib1RhcmdldCIsImhhc0ZibyIsImZibyIsIl9mYm9UYXJnZXQiLCJyZW5kZXIiLCJnZXRUZXh0dXJlIiwiX2Zib0N1cnJlbnQiLCJfY3VycmVudCIsInZCbHVyIiwiaEJsdXIiLCJjb2xvcnMiLCJjb2xvciIsIm9wYWNpdHkiLCJtUG9zaXRpb25BIiwibVBvc2l0aW9uQiIsInNlZyIsIl9tYXRyaXhJZGVudGl0eSIsIl9pbml0Vmlld3MiLCJyZXNpemUiLCJzZXRBc3BlY3RSYXRpbyIsImFzcGVjdFJhdGlvIiwidG9SZW5kZXIiLCJvcmJpdGFsQ29udHJvbCIsImNhbWVyYU9ydGhvIiwic2V0TWF0cmljZXMiLCJfcmVuZGVyQ2hpbGRyZW4iLCJtU3RyVmVydGV4IiwibVN0ckZyYWciLCJfbWF0cml4VGVtcCIsIkFzc2V0cyIsIl9hc3NldHMiLCJnZXRBc3NldCIsImFzc2V0cyIsImZpbGUiLCJtRmlsZSIsImluaXQiLCJoZHJDdWJlbWFwcyIsImN1YmVtYXBOYW1lIiwib0Fzc2V0IiwiZGVidWciLCJ0YWJsZSIsIm1JZCIsImFzc2V0c1RvTG9hZCIsImJvZHkiLCJjbGFzc0xpc3QiLCJvbiIsInF1ZXJ5U2VsZWN0b3IiLCJzdHlsZSIsIl9vbkltYWdlTG9hZGVkIiwic3RhcnQiLCJfaW5pdDNEIiwic2V0VGltZW91dCIsInJlbW92ZSIsImNsYXNzTmFtZSIsImFwcGVuZENoaWxkIiwiaWdub3JlV2ViZ2wyIiwiZ3VpIiwiU2NlbmVBcHAiLCJ0ZXh0dXJlQnJkZiIsImVudiIsImVudnMiLCJfdXBkYXRlRW52TWFwIiwib25GaW5pc2hDaGFuZ2UiLCJfYkNvcHkiLCJfYkF4aXMiLCJfYkRvdHMiLCJfYlNreSIsInVCUkRGTWFwIiwidUlycmFkaWFuY2VNYXAiLCJ0ZXh0dXJlSXJyIiwidVJhZGlhbmNlTWFwIiwidGV4dHVyZVJhZCIsImRldmljZVBpeGVsUmF0aW8iLCJxdWVyeVN0cmluZyIsImVuYWJsZWQiLCJyZWxvYWQiLCJsb2NhdGlvbiIsImhyZWYiLCJwYXRobmFtZSIsInN0cmluZ2lmeSIsInJlZnJlc2giLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiZGVsYXlJbmRleCIsImRlbGF5UmVsb2FkIiwiY2xlYXJUaW1lb3V0IiwibUVuYWJsZWQiLCJwYXJzZWQiLCJzZWFyY2giLCJxdWVyeSIsImNvbmZpZyIsIm9Db25maWciXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQTJEO0FBQzNEO0FBQ0E7QUFDQSxXQUFHOztBQUVILG9EQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7OztBQUlBO0FBQ0Esc0RBQThDO0FBQzlDO0FBQ0E7QUFDQSxvQ0FBNEI7QUFDNUIscUNBQTZCO0FBQzdCLHlDQUFpQzs7QUFFakMsK0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUFzQztBQUN0QztBQUNBO0FBQ0EscUNBQTZCO0FBQzdCLHFDQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQSw0REFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtB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QUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hiQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDamRBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEI7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNs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Q0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN6TEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FB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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsVUFBVTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixVQUFVO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7OztBQUdBO0FBQ0EsWUFBWSxLQUFLOztBQUVqQjs7OztBQUlBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwaUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7c0RDcEZBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQUE7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7O0FDcGhCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVUsU0FBUztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsVUFBVSxTQUFTO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ3hHQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7OztBQ0xBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQzdTQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOzs7Ozs7OztBQ3hUQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiYXNzZXRzL2pzL2FwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdGZ1bmN0aW9uIGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKSB7XG4gXHRcdGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHR9XG4gXHR2YXIgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2sgPSB3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdO1xuIFx0d2luZG93W1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IFxyXG4gXHRmdW5jdGlvbiB3ZWJwYWNrSG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcclxuIFx0XHRpZihwYXJlbnRIb3RVcGRhdGVDYWxsYmFjaykgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHR9IDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcbiBcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiBcdFx0c2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xyXG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xyXG4gXHRcdHNjcmlwdC5zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzXCI7XHJcbiBcdFx0O1xyXG4gXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChyZXF1ZXN0VGltZW91dCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0cmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0VGltZW91dCB8fCAxMDAwMDtcclxuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiBcdFx0XHRpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdHJldHVybiByZWplY3QobmV3IEVycm9yKFwiTm8gYnJvd3NlciBzdXBwb3J0XCIpKTtcclxuIFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiBcdFx0XHRcdHZhciByZXF1ZXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNvblwiO1xyXG4gXHRcdFx0XHRyZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgcmVxdWVzdFBhdGgsIHRydWUpO1xyXG4gXHRcdFx0XHRyZXF1ZXN0LnRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcclxuIFx0XHRcdFx0cmVxdWVzdC5zZW5kKG51bGwpO1xyXG4gXHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChlcnIpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0cmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0aWYocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm47XHJcbiBcdFx0XHRcdGlmKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XHJcbiBcdFx0XHRcdFx0Ly8gdGltZW91dFxyXG4gXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiB0aW1lZCBvdXQuXCIpKTtcclxuIFx0XHRcdFx0fSBlbHNlIGlmKHJlcXVlc3Quc3RhdHVzID09PSA0MDQpIHtcclxuIFx0XHRcdFx0XHQvLyBubyB1cGRhdGUgYXZhaWxhYmxlXHJcbiBcdFx0XHRcdFx0cmVzb2x2ZSgpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XHJcbiBcdFx0XHRcdFx0Ly8gb3RoZXIgZmFpbHVyZVxyXG4gXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiBmYWlsZWQuXCIpKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHQvLyBzdWNjZXNzXHJcbiBcdFx0XHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0XHRcdHZhciB1cGRhdGUgPSBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcclxuIFx0XHRcdFx0XHRcdHJlamVjdChlKTtcclxuIFx0XHRcdFx0XHRcdHJldHVybjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0cmVzb2x2ZSh1cGRhdGUpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9O1xyXG4gXHRcdH0pO1xyXG4gXHR9XHJcblxuIFx0XHJcbiBcdFxyXG4gXHR2YXIgaG90QXBwbHlPblVwZGF0ZSA9IHRydWU7XHJcbiBcdHZhciBob3RDdXJyZW50SGFzaCA9IFwiOGFlZDdhZDhmYTE5MWI0NjMwZTdcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90UmVxdWVzdFRpbWVvdXQgPSAxMDAwMDtcclxuIFx0dmFyIGhvdEN1cnJlbnRNb2R1bGVEYXRhID0ge307XHJcbiBcdHZhciBob3RDdXJyZW50Q2hpbGRNb2R1bGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgbWUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRpZighbWUpIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fO1xyXG4gXHRcdHZhciBmbiA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuIFx0XHRcdGlmKG1lLmhvdC5hY3RpdmUpIHtcclxuIFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xyXG4gXHRcdFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKSA8IDApXHJcbiBcdFx0XHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMucHVzaChtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHJlcXVlc3Q7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYobWUuY2hpbGRyZW4uaW5kZXhPZihyZXF1ZXN0KSA8IDApXHJcbiBcdFx0XHRcdFx0bWUuY2hpbGRyZW4ucHVzaChyZXF1ZXN0KTtcclxuIFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIHJlcXVlc3QgKyBcIikgZnJvbSBkaXNwb3NlZCBtb2R1bGUgXCIgKyBtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW107XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhyZXF1ZXN0KTtcclxuIFx0XHR9O1xyXG4gXHRcdHZhciBPYmplY3RGYWN0b3J5ID0gZnVuY3Rpb24gT2JqZWN0RmFjdG9yeShuYW1lKSB7XHJcbiBcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcbiBcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX19bbmFtZV07XHJcbiBcdFx0XHRcdH0sXHJcbiBcdFx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuIFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdID0gdmFsdWU7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH07XHJcbiBcdFx0fTtcclxuIFx0XHRmb3IodmFyIG5hbWUgaW4gX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9fd2VicGFja19yZXF1aXJlX18sIG5hbWUpICYmIG5hbWUgIT09IFwiZVwiKSB7XHJcbiBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgT2JqZWN0RmFjdG9yeShuYW1lKSk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcdGZuLmUgPSBmdW5jdGlvbihjaHVua0lkKSB7XHJcbiBcdFx0XHRpZihob3RTdGF0dXMgPT09IFwicmVhZHlcIilcclxuIFx0XHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcclxuIFx0XHRcdGhvdENodW5rc0xvYWRpbmcrKztcclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmUoY2h1bmtJZCkudGhlbihmaW5pc2hDaHVua0xvYWRpbmcsIGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRmaW5pc2hDaHVua0xvYWRpbmcoKTtcclxuIFx0XHRcdFx0dGhyb3cgZXJyO1xyXG4gXHRcdFx0fSk7XHJcbiBcdFxyXG4gXHRcdFx0ZnVuY3Rpb24gZmluaXNoQ2h1bmtMb2FkaW5nKCkge1xyXG4gXHRcdFx0XHRob3RDaHVua3NMb2FkaW5nLS07XHJcbiBcdFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIpIHtcclxuIFx0XHRcdFx0XHRpZighaG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdKSB7XHJcbiBcdFx0XHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0aWYoaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcclxuIFx0XHRcdFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9O1xyXG4gXHRcdHJldHVybiBmbjtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgaG90ID0ge1xyXG4gXHRcdFx0Ly8gcHJpdmF0ZSBzdHVmZlxyXG4gXHRcdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXHJcbiBcdFx0XHRfc2VsZkFjY2VwdGVkOiBmYWxzZSxcclxuIFx0XHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXHJcbiBcdFx0XHRfbWFpbjogaG90Q3VycmVudENoaWxkTW9kdWxlICE9PSBtb2R1bGVJZCxcclxuIFx0XHJcbiBcdFx0XHQvLyBNb2R1bGUgQVBJXHJcbiBcdFx0XHRhY3RpdmU6IHRydWUsXHJcbiBcdFx0XHRhY2NlcHQ6IGZ1bmN0aW9uKGRlcCwgY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0aWYodHlwZW9mIGRlcCA9PT0gXCJ1bmRlZmluZWRcIilcclxuIFx0XHRcdFx0XHRob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2UgaWYodHlwZW9mIGRlcCA9PT0gXCJmdW5jdGlvblwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXHJcbiBcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcclxuIFx0XHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcF0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRlY2xpbmU6IGZ1bmN0aW9uKGRlcCkge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkRlY2xpbmVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxyXG4gXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlXHJcbiBcdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRkaXNwb3NlOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0cmVtb3ZlRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIGhvdC5fZGlzcG9zZUhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHJcbiBcdFx0XHQvLyBNYW5hZ2VtZW50IEFQSVxyXG4gXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxyXG4gXHRcdFx0YXBwbHk6IGhvdEFwcGx5LFxyXG4gXHRcdFx0c3RhdHVzOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdGlmKCFsKSByZXR1cm4gaG90U3RhdHVzO1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3RTdGF0dXNIYW5kbGVycy5pbmRleE9mKGwpO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90U3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxyXG4gXHRcdFx0ZGF0YTogaG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXHJcbiBcdFx0fTtcclxuIFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XHJcbiBcdFx0cmV0dXJuIGhvdDtcclxuIFx0fVxyXG4gXHRcclxuIFx0dmFyIGhvdFN0YXR1c0hhbmRsZXJzID0gW107XHJcbiBcdHZhciBob3RTdGF0dXMgPSBcImlkbGVcIjtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdFNldFN0YXR1cyhuZXdTdGF0dXMpIHtcclxuIFx0XHRob3RTdGF0dXMgPSBuZXdTdGF0dXM7XHJcbiBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGhvdFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0aG90U3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHQvLyB3aGlsZSBkb3dubG9hZGluZ1xyXG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzID0gMDtcclxuIFx0dmFyIGhvdENodW5rc0xvYWRpbmcgPSAwO1xyXG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90QXZhaWxhYmxlRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdERlZmVycmVkO1xyXG4gXHRcclxuIFx0Ly8gVGhlIHVwZGF0ZSBpbmZvXHJcbiBcdHZhciBob3RVcGRhdGUsIGhvdFVwZGF0ZU5ld0hhc2g7XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiB0b01vZHVsZUlkKGlkKSB7XHJcbiBcdFx0dmFyIGlzTnVtYmVyID0gKCtpZCkgKyBcIlwiID09PSBpZDtcclxuIFx0XHRyZXR1cm4gaXNOdW1iZXIgPyAraWQgOiBpZDtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90Q2hlY2soYXBwbHkpIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwiaWRsZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcclxuIFx0XHRob3RBcHBseU9uVXBkYXRlID0gYXBwbHk7XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiY2hlY2tcIik7XHJcbiBcdFx0cmV0dXJuIGhvdERvd25sb2FkTWFuaWZlc3QoaG90UmVxdWVzdFRpbWVvdXQpLnRoZW4oZnVuY3Rpb24odXBkYXRlKSB7XHJcbiBcdFx0XHRpZighdXBkYXRlKSB7XHJcbiBcdFx0XHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XHJcbiBcdFx0XHRcdHJldHVybiBudWxsO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcclxuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90QXZhaWxhYmxlRmlsZXNNYXAgPSB1cGRhdGUuYztcclxuIFx0XHRcdGhvdFVwZGF0ZU5ld0hhc2ggPSB1cGRhdGUuaDtcclxuIFx0XHJcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuIFx0XHRcdFx0aG90RGVmZXJyZWQgPSB7XHJcbiBcdFx0XHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcclxuIFx0XHRcdFx0XHRyZWplY3Q6IHJlamVjdFxyXG4gXHRcdFx0XHR9O1xyXG4gXHRcdFx0fSk7XHJcbiBcdFx0XHRob3RVcGRhdGUgPSB7fTtcclxuIFx0XHRcdHZhciBjaHVua0lkID0gMDtcclxuIFx0XHRcdHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lLWJsb2Nrc1xyXG4gXHRcdFx0XHQvKmdsb2JhbHMgY2h1bmtJZCAqL1xyXG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcclxuIFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0cmV0dXJuIHByb21pc2U7XHJcbiBcdFx0fSk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHRpZighaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gfHwgIWhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdKVxyXG4gXHRcdFx0cmV0dXJuO1xyXG4gXHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gZmFsc2U7XHJcbiBcdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0aG90VXBkYXRlW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFx0aWYoLS1ob3RXYWl0aW5nRmlsZXMgPT09IDAgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCkge1xyXG4gXHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdH1cclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCkge1xyXG4gXHRcdGlmKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSkge1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzKys7XHJcbiBcdFx0XHRob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdH1cclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90VXBkYXRlRG93bmxvYWRlZCgpIHtcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJyZWFkeVwiKTtcclxuIFx0XHR2YXIgZGVmZXJyZWQgPSBob3REZWZlcnJlZDtcclxuIFx0XHRob3REZWZlcnJlZCA9IG51bGw7XHJcbiBcdFx0aWYoIWRlZmVycmVkKSByZXR1cm47XHJcbiBcdFx0aWYoaG90QXBwbHlPblVwZGF0ZSkge1xyXG4gXHRcdFx0Ly8gV3JhcCBkZWZlcnJlZCBvYmplY3QgaW4gUHJvbWlzZSB0byBtYXJrIGl0IGFzIGEgd2VsbC1oYW5kbGVkIFByb21pc2UgdG9cclxuIFx0XHRcdC8vIGF2b2lkIHRyaWdnZXJpbmcgdW5jYXVnaHQgZXhjZXB0aW9uIHdhcm5pbmcgaW4gQ2hyb21lLlxyXG4gXHRcdFx0Ly8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ2NTY2NlxyXG4gXHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0cmV0dXJuIGhvdEFwcGx5KGhvdEFwcGx5T25VcGRhdGUpO1xyXG4gXHRcdFx0fSkudGhlbihcclxuIFx0XHRcdFx0ZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiBcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xyXG4gXHRcdFx0XHR9LFxyXG4gXHRcdFx0XHRmdW5jdGlvbihlcnIpIHtcclxuIFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3QoZXJyKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0KTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2godG9Nb2R1bGVJZChpZCkpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKG91dGRhdGVkTW9kdWxlcyk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RBcHBseShvcHRpb25zKSB7XHJcbiBcdFx0aWYoaG90U3RhdHVzICE9PSBcInJlYWR5XCIpIHRocm93IG5ldyBFcnJvcihcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1c1wiKTtcclxuIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuIFx0XHJcbiBcdFx0dmFyIGNiO1xyXG4gXHRcdHZhciBpO1xyXG4gXHRcdHZhciBqO1xyXG4gXHRcdHZhciBtb2R1bGU7XHJcbiBcdFx0dmFyIG1vZHVsZUlkO1xyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBnZXRBZmZlY3RlZFN0dWZmKHVwZGF0ZU1vZHVsZUlkKSB7XHJcbiBcdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW3VwZGF0ZU1vZHVsZUlkXTtcclxuIFx0XHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG4gXHRcclxuIFx0XHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpLm1hcChmdW5jdGlvbihpZCkge1xyXG4gXHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdGNoYWluOiBbaWRdLFxyXG4gXHRcdFx0XHRcdGlkOiBpZFxyXG4gXHRcdFx0XHR9O1xyXG4gXHRcdFx0fSk7XHJcbiBcdFx0XHR3aGlsZShxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiBcdFx0XHRcdHZhciBxdWV1ZUl0ZW0gPSBxdWV1ZS5wb3AoKTtcclxuIFx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xyXG4gXHRcdFx0XHR2YXIgY2hhaW4gPSBxdWV1ZUl0ZW0uY2hhaW47XHJcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRpZighbW9kdWxlIHx8IG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZClcclxuIFx0XHRcdFx0XHRjb250aW51ZTtcclxuIFx0XHRcdFx0aWYobW9kdWxlLmhvdC5fc2VsZkRlY2xpbmVkKSB7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxyXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxyXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXHJcbiBcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9tYWluKSB7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0XHRcdHR5cGU6IFwidW5hY2NlcHRlZFwiLFxyXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxyXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXHJcbiBcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbW9kdWxlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcclxuIFx0XHRcdFx0XHR2YXIgcGFyZW50ID0gaW5zdGFsbGVkTW9kdWxlc1twYXJlbnRJZF07XHJcbiBcdFx0XHRcdFx0aWYoIXBhcmVudCkgY29udGludWU7XHJcbiBcdFx0XHRcdFx0aWYocGFyZW50LmhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XHJcbiBcdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0XHR0eXBlOiBcImRlY2xpbmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXHJcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0cGFyZW50SWQ6IHBhcmVudElkXHJcbiBcdFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRpZihvdXRkYXRlZE1vZHVsZXMuaW5kZXhPZihwYXJlbnRJZCkgPj0gMCkgY29udGludWU7XHJcbiBcdFx0XHRcdFx0aWYocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XHJcbiBcdFx0XHRcdFx0XHRpZighb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdKVxyXG4gXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcclxuIFx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSwgW21vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXTtcclxuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChwYXJlbnRJZCk7XHJcbiBcdFx0XHRcdFx0cXVldWUucHVzaCh7XHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxyXG4gXHRcdFx0XHRcdFx0aWQ6IHBhcmVudElkXHJcbiBcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHJcbiBcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHR0eXBlOiBcImFjY2VwdGVkXCIsXHJcbiBcdFx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcclxuIFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzOiBvdXRkYXRlZE1vZHVsZXMsXHJcbiBcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzOiBvdXRkYXRlZERlcGVuZGVuY2llc1xyXG4gXHRcdFx0fTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcclxuIFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdHZhciBpdGVtID0gYltpXTtcclxuIFx0XHRcdFx0aWYoYS5pbmRleE9mKGl0ZW0pIDwgMClcclxuIFx0XHRcdFx0XHRhLnB1c2goaXRlbSk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBhdCBiZWdpbiBhbGwgdXBkYXRlcyBtb2R1bGVzIGFyZSBvdXRkYXRlZFxyXG4gXHRcdC8vIHRoZSBcIm91dGRhdGVkXCIgc3RhdHVzIGNhbiBwcm9wYWdhdGUgdG8gcGFyZW50cyBpZiB0aGV5IGRvbid0IGFjY2VwdCB0aGUgY2hpbGRyZW5cclxuIFx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcclxuIFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0dmFyIGFwcGxpZWRVcGRhdGUgPSB7fTtcclxuIFx0XHJcbiBcdFx0dmFyIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSA9IGZ1bmN0aW9uIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSgpIHtcclxuIFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIHJlc3VsdC5tb2R1bGVJZCArIFwiKSB0byBkaXNwb3NlZCBtb2R1bGVcIik7XHJcbiBcdFx0fTtcclxuIFx0XHJcbiBcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGVJZCA9IHRvTW9kdWxlSWQoaWQpO1xyXG4gXHRcdFx0XHR2YXIgcmVzdWx0O1xyXG4gXHRcdFx0XHRpZihob3RVcGRhdGVbaWRdKSB7XHJcbiBcdFx0XHRcdFx0cmVzdWx0ID0gZ2V0QWZmZWN0ZWRTdHVmZihtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0cmVzdWx0ID0ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxyXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IGlkXHJcbiBcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR2YXIgYWJvcnRFcnJvciA9IGZhbHNlO1xyXG4gXHRcdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xyXG4gXHRcdFx0XHR2YXIgZG9EaXNwb3NlID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBjaGFpbkluZm8gPSBcIlwiO1xyXG4gXHRcdFx0XHRpZihyZXN1bHQuY2hhaW4pIHtcclxuIFx0XHRcdFx0XHRjaGFpbkluZm8gPSBcIlxcblVwZGF0ZSBwcm9wYWdhdGlvbjogXCIgKyByZXN1bHQuY2hhaW4uam9pbihcIiAtPiBcIik7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0c3dpdGNoKHJlc3VsdC50eXBlKSB7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25EZWNsaW5lZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcclxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgY2hhaW5JbmZvKTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJkZWNsaW5lZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIgaW4gXCIgKyByZXN1bHQucGFyZW50SWQgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcInVuYWNjZXB0ZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25VbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uVW5hY2NlcHRlZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcclxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uQWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25BY2NlcHRlZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwiZGlzcG9zZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25EaXNwb3NlZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkRpc3Bvc2VkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRkb0Rpc3Bvc2UgPSB0cnVlO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0ZGVmYXVsdDpcclxuIFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhjZXB0aW9uIHR5cGUgXCIgKyByZXN1bHQudHlwZSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYoYWJvcnRFcnJvcikge1xyXG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xyXG4gXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihkb0FwcGx5KSB7XHJcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBob3RVcGRhdGVbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XHJcbiBcdFx0XHRcdFx0Zm9yKG1vZHVsZUlkIGluIHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG4gXHRcdFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XHJcbiBcdFx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSwgcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKGRvRGlzcG9zZSkge1xyXG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgW3Jlc3VsdC5tb2R1bGVJZF0pO1xyXG4gXHRcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBTdG9yZSBzZWxmIGFjY2VwdGVkIG91dGRhdGVkIG1vZHVsZXMgdG8gcmVxdWlyZSB0aGVtIGxhdGVyIGJ5IHRoZSBtb2R1bGUgc3lzdGVtXHJcbiBcdFx0dmFyIG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdGZvcihpID0gMDsgaSA8IG91dGRhdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0bW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZClcclxuIFx0XHRcdFx0b3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLnB1c2goe1xyXG4gXHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxyXG4gXHRcdFx0XHR9KTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImRpc3Bvc2VcIik7XHJcbiBcdFx0T2JqZWN0LmtleXMoaG90QXZhaWxhYmxlRmlsZXNNYXApLmZvckVhY2goZnVuY3Rpb24oY2h1bmtJZCkge1xyXG4gXHRcdFx0aWYoaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gPT09IGZhbHNlKSB7XHJcbiBcdFx0XHRcdGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9KTtcclxuIFx0XHJcbiBcdFx0dmFyIGlkeDtcclxuIFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcclxuIFx0XHR3aGlsZShxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiBcdFx0XHRtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRpZighbW9kdWxlKSBjb250aW51ZTtcclxuIFx0XHJcbiBcdFx0XHR2YXIgZGF0YSA9IHt9O1xyXG4gXHRcclxuIFx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xyXG4gXHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcclxuIFx0XHRcdGZvcihqID0gMDsgaiA8IGRpc3Bvc2VIYW5kbGVycy5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHRjYiA9IGRpc3Bvc2VIYW5kbGVyc1tqXTtcclxuIFx0XHRcdFx0Y2IoZGF0YSk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF0gPSBkYXRhO1xyXG4gXHRcclxuIFx0XHRcdC8vIGRpc2FibGUgbW9kdWxlICh0aGlzIGRpc2FibGVzIHJlcXVpcmVzIGZyb20gdGhpcyBtb2R1bGUpXHJcbiBcdFx0XHRtb2R1bGUuaG90LmFjdGl2ZSA9IGZhbHNlO1xyXG4gXHRcclxuIFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxyXG4gXHRcdFx0ZGVsZXRlIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcclxuIFx0XHRcdC8vIHdoZW4gZGlzcG9zaW5nIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBkaXNwb3NlIGhhbmRsZXJcclxuIFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cclxuIFx0XHRcdGZvcihqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHR2YXIgY2hpbGQgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZS5jaGlsZHJlbltqXV07XHJcbiBcdFx0XHRcdGlmKCFjaGlsZCkgY29udGludWU7XHJcbiBcdFx0XHRcdGlkeCA9IGNoaWxkLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSB7XHJcbiBcdFx0XHRcdFx0Y2hpbGQucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gcmVtb3ZlIG91dGRhdGVkIGRlcGVuZGVuY3kgZnJvbSBtb2R1bGUgY2hpbGRyZW5cclxuIFx0XHR2YXIgZGVwZW5kZW5jeTtcclxuIFx0XHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXM7XHJcbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0aWYobW9kdWxlKSB7XHJcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0Zm9yKGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcclxuIFx0XHRcdFx0XHRcdGlkeCA9IG1vZHVsZS5jaGlsZHJlbi5pbmRleE9mKGRlcGVuZGVuY3kpO1xyXG4gXHRcdFx0XHRcdFx0aWYoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIE5vdCBpbiBcImFwcGx5XCIgcGhhc2VcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJhcHBseVwiKTtcclxuIFx0XHJcbiBcdFx0aG90Q3VycmVudEhhc2ggPSBob3RVcGRhdGVOZXdIYXNoO1xyXG4gXHRcclxuIFx0XHQvLyBpbnNlcnQgbmV3IGNvZGVcclxuIFx0XHRmb3IobW9kdWxlSWQgaW4gYXBwbGllZFVwZGF0ZSkge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcGxpZWRVcGRhdGUsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gY2FsbCBhY2NlcHQgaGFuZGxlcnNcclxuIFx0XHR2YXIgZXJyb3IgPSBudWxsO1xyXG4gXHRcdGZvcihtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKG1vZHVsZSkge1xyXG4gXHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID0gb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcclxuIFx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2ldO1xyXG4gXHRcdFx0XHRcdFx0Y2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcclxuIFx0XHRcdFx0XHRcdGlmKGNiKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKGNhbGxiYWNrcy5pbmRleE9mKGNiKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goY2IpO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0XHRcdGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gXHRcdFx0XHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0XHRcdFx0Y2IobW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xyXG4gXHRcdFx0XHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XHJcbiBcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2ldLFxyXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxyXG4gXHRcdFx0XHRcdFx0XHRcdH0pO1xyXG4gXHRcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcclxuIFx0XHRmb3IoaSA9IDA7IGkgPCBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW2ldO1xyXG4gXHRcdFx0bW9kdWxlSWQgPSBpdGVtLm1vZHVsZTtcclxuIFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcclxuIFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xyXG4gXHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0aWYodHlwZW9mIGl0ZW0uZXJyb3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyKTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGVycjIpIHtcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25FcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxyXG4gXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcclxuIFx0XHRcdFx0XHRcdFx0XHRvcmdpbmFsRXJyb3I6IGVyciwgLy8gVE9ETyByZW1vdmUgaW4gd2VicGFjayA0XHJcbiBcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHRcdH0pO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnIyO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxyXG4gXHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxyXG4gXHRcdGlmKGVycm9yKSB7XHJcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xyXG4gXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XHJcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcclxuIFx0XHRcdHJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGhvdDogaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSxcbiBcdFx0XHRwYXJlbnRzOiAoaG90Q3VycmVudFBhcmVudHNUZW1wID0gaG90Q3VycmVudFBhcmVudHMsIGhvdEN1cnJlbnRQYXJlbnRzID0gW10sIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCksXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gX193ZWJwYWNrX2hhc2hfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5oID0gZnVuY3Rpb24oKSB7IHJldHVybiBob3RDdXJyZW50SGFzaDsgfTtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gaG90Q3JlYXRlUmVxdWlyZSgxMTEpKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDExMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOGFlZDdhZDhmYTE5MWI0NjMwZTciLCIvLyBHTFRvb2wuanNcblxuaW1wb3J0IHsgbWF0NCwgbWF0MyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCBnZXRBbmRBcHBseUV4dGVuc2lvbiBmcm9tICcuL3V0aWxzL2dldEFuZEFwcGx5RXh0ZW5zaW9uJztcbmltcG9ydCBleHBvc2VBdHRyaWJ1dGVzIGZyb20gJy4vdXRpbHMvZXhwb3NlQXR0cmlidXRlcyc7XG5pbXBvcnQgZ2V0RmxvYXQgZnJvbSAnLi91dGlscy9nZXRGbG9hdCc7XG5pbXBvcnQgZ2V0SGFsZkZsb2F0IGZyb20gJy4vdXRpbHMvZ2V0SGFsZkZsb2F0JztcbmltcG9ydCBnZXRBdHRyaWJMb2MgZnJvbSAnLi91dGlscy9nZXRBdHRyaWJMb2MnO1xuaW1wb3J0IEV4dGVuc2lvbnNMaXN0IGZyb20gJy4vdXRpbHMvRXh0ZW5zaW9uc0xpc3QnO1xuXG5pbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi9HZW9tZXRyeSc7XG5pbXBvcnQgTWVzaCBmcm9tICcuL01lc2gnO1xuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4vb2JqZWN0cy9PYmplY3QzRCc7XG5cbmxldCBnbDtcblxuY2xhc3MgR0xUb29sIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmNhbnZhcztcblx0XHR0aGlzLl92aWV3cG9ydCAgICAgICAgICAgICAgID0gWzAsIDAsIDAsIDBdO1xuXHRcdHRoaXMuX2VuYWJsZWRWZXJ0ZXhBdHRyaWJ1dGUgPSBbXTtcblx0XHR0aGlzLmlkZW50aXR5TWF0cml4ICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9ub3JtYWxNYXRyaXggICAgICAgICAgID0gbWF0My5jcmVhdGUoKTtcblx0XHR0aGlzLl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4ID0gbWF0My5jcmVhdGUoKTtcblx0XHR0aGlzLl9tb2RlbE1hdHJpeCAgICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXggICAgICAgICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhTdGFja3MgXHRcdFx0ID0gW107XG5cdFx0dGhpcy5fbGFzdE1lc2hcdFx0XHRcdCA9IG51bGw7XG5cdFx0dGhpcy5fdXNlV2ViR0wyIFx0XHRcdCA9IGZhbHNlO1xuXHRcdHRoaXMuX2hhc0FycmF5SW5zdGFuY2U7XG5cdFx0dGhpcy5fZXh0QXJyYXlJbnN0YW5jZTtcblx0XHR0aGlzLl9oYXNDaGVja2VkRXh0ID0gZmFsc2U7XG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLmlkZW50aXR5TWF0cml4LCB0aGlzLmlkZW50aXR5TWF0cml4KTtcblxuXHRcdHRoaXMuaXNNb2JpbGUgPSBmYWxzZTtcblx0XHRpZigvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0XHRcdHRoaXMuaXNNb2JpbGUgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8vXHRJTklUSUFMSVpFXG5cblx0aW5pdChtQ2FudmFzLCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cblx0XHRpZihtQ2FudmFzID09PSBudWxsIHx8IG1DYW52YXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignQ2FudmFzIG5vdCBleGlzdCcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRcblx0XHRpZih0aGlzLmNhbnZhcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY2FudmFzICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5jYW52YXMgPSBtQ2FudmFzO1xuXHRcdHRoaXMuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcblxuXHRcdG1QYXJhbWV0ZXJzLnVzZVdlYmdsMiA9IG1QYXJhbWV0ZXJzLnVzZVdlYmdsMiB8fCBmYWxzZTtcblxuXHRcdGxldCBjdHg7XG5cdFx0aWYobVBhcmFtZXRlcnMudXNlV2ViZ2wyKSB7XG5cdFx0XHRjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wyJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIG1QYXJhbWV0ZXJzKTtcblxuXHRcdFx0aWYoIWN0eCkge1xuXHRcdFx0XHRjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG1QYXJhbWV0ZXJzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBtUGFyYW1ldGVycyk7XHRcblx0XHRcdFx0dGhpcy5fdXNlV2ViR0wyID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl91c2VXZWJHTDIgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbDInLCBtUGFyYW1ldGVycykgfHwgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgbVBhcmFtZXRlcnMpO1xuXHRcdFx0Ly8gaWYoY3R4KSB7XG5cdFx0XHQvLyBcdHRoaXMuX3VzZVdlYkdMMiA9IHRydWU7XG5cdFx0XHQvLyB9IGVsc2Uge1xuXHRcdFx0Ly8gXHRjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG1QYXJhbWV0ZXJzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBtUGFyYW1ldGVycyk7XG5cdFx0XHQvLyB9XG5cblx0XHRcdGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG1QYXJhbWV0ZXJzKTtcdFxuXHRcdFx0dGhpcy5fdXNlV2ViR0wyID0gZmFsc2U7XG5cdFx0XHRcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygnVXNpbmcgV2ViR0wgMiA/JywgdGhpcy53ZWJnbDIpO1xuXG5cdFx0Ly9cdGV4dGVuc2lvbnNcblx0XHR0aGlzLmluaXRXaXRoR0woY3R4KTtcblx0fVxuXG5cdGluaXRXaXRoR0woY3R4KSB7XG5cdFx0aWYoIXRoaXMuY2FudmFzKSB7XHR0aGlzLmNhbnZhcyA9IGN0eC5jYW52YXM7XHR9XG5cdFx0Z2wgPSB0aGlzLmdsID0gY3R4O1xuXG5cdFx0dGhpcy5leHRlbnNpb25zID0ge307XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IEV4dGVuc2lvbnNMaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmV4dGVuc2lvbnNbRXh0ZW5zaW9uc0xpc3RbaV1dID0gZ2wuZ2V0RXh0ZW5zaW9uKEV4dGVuc2lvbnNMaXN0W2ldKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly9cdENvcHkgZ2wgQXR0cmlidXRlc1xuXHRcdGV4cG9zZUF0dHJpYnV0ZXMoKTtcblx0XHRnZXRBbmRBcHBseUV4dGVuc2lvbihnbCwgJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG5cdFx0Z2V0QW5kQXBwbHlFeHRlbnNpb24oZ2wsICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG5cdFx0Z2V0QW5kQXBwbHlFeHRlbnNpb24oZ2wsICdXRUJHTF9kcmF3X2J1ZmZlcnMnKTtcblx0XHRcblx0XHR0aGlzLmVuYWJsZSh0aGlzLkRFUFRIX1RFU1QpO1xuXHRcdHRoaXMuZW5hYmxlKHRoaXMuQ1VMTF9GQUNFKTtcblx0XHR0aGlzLmVuYWJsZSh0aGlzLkJMRU5EKTtcblx0XHR0aGlzLmVuYWJsZUFscGhhQmxlbmRpbmcoKTtcblx0fSBcblxuXG5cblx0Ly9cdFBVQkxJQyBNRVRIT0RTXG5cblx0c2V0Vmlld3BvcnQoeCwgeSwgdywgaCkge1xuXHRcdGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG5cdFx0aWYoeCAhPT0gdGhpcy5fdmlld3BvcnRbMF0pIHsgaGFzQ2hhbmdlZCA9IHRydWU7IH1cblx0XHRpZih5ICE9PSB0aGlzLl92aWV3cG9ydFsxXSkgeyBoYXNDaGFuZ2VkID0gdHJ1ZTsgfVxuXHRcdGlmKHcgIT09IHRoaXMuX3ZpZXdwb3J0WzJdKSB7IGhhc0NoYW5nZWQgPSB0cnVlOyB9XG5cdFx0aWYoaCAhPT0gdGhpcy5fdmlld3BvcnRbM10pIHsgaGFzQ2hhbmdlZCA9IHRydWU7IH1cblxuXHRcdGlmKGhhc0NoYW5nZWQpIHtcblx0XHRcdGdsLnZpZXdwb3J0KHgsIHksIHcsIGgpO1xuXHRcdFx0dGhpcy5fdmlld3BvcnQgPSBbeCwgeSwgdywgaF07XG5cdFx0fVxuXHR9XG5cblx0c2Npc3Nvcih4LCB5LCB3LCBoKSB7XG5cdFx0Z2wuc2Npc3Nvcih4LCB5LCB3LCBoKTtcblx0fVxuXG5cblx0Y2xlYXIociwgZywgYiwgYSkge1xuXHRcdGdsLmNsZWFyQ29sb3IociwgZywgYiwgYSk7XG5cdFx0Z2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuXHR9XG5cblxuXHRjdWxsRmFjZShtVmFsdWUpIHtcblx0XHRnbC5jdWxsRmFjZShtVmFsdWUpO1xuXHR9XG5cblxuXHRzZXRNYXRyaWNlcyhtQ2FtZXJhKSB7XG5cdFx0dGhpcy5jYW1lcmEgPSBtQ2FtZXJhO1xuXHRcdHRoaXMucm90YXRlKHRoaXMuaWRlbnRpdHlNYXRyaXgpO1xuXHR9XG5cblxuXHR1c2VTaGFkZXIobVNoYWRlcikge1xuXHRcdHRoaXMuc2hhZGVyID0gbVNoYWRlcjtcblx0XHR0aGlzLnNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlci5zaGFkZXJQcm9ncmFtO1xuXHR9XG5cblxuXHRyb3RhdGUobVJvdGF0aW9uKSB7XG5cdFx0bWF0NC5jb3B5KHRoaXMuX21vZGVsTWF0cml4LCBtUm90YXRpb24pO1xuXHRcdG1hdDQubXVsdGlwbHkodGhpcy5fbWF0cml4LCB0aGlzLmNhbWVyYS5tYXRyaXgsIHRoaXMuX21vZGVsTWF0cml4KTtcblx0XHRtYXQzLmZyb21NYXQ0KHRoaXMuX25vcm1hbE1hdHJpeCwgdGhpcy5fbWF0cml4KTtcblx0XHRtYXQzLmludmVydCh0aGlzLl9ub3JtYWxNYXRyaXgsIHRoaXMuX25vcm1hbE1hdHJpeCk7XG5cdFx0bWF0My50cmFuc3Bvc2UodGhpcy5fbm9ybWFsTWF0cml4LCB0aGlzLl9ub3JtYWxNYXRyaXgpO1xuXHRcdFxuXG5cdFx0bWF0My5mcm9tTWF0NCh0aGlzLl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4LCB0aGlzLl9tYXRyaXgpO1xuXHRcdG1hdDMuaW52ZXJ0KHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgsIHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgpO1xuXHR9XG5cblxuXHRkcmF3R2VvbWV0cnkobUdlb21ldHJ5LCBtb2RlbE1hdHJpeCkge1xuXHRcdGlmKG1HZW9tZXRyeS5sZW5ndGgpIHtcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBtR2VvbWV0cnkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5kcmF3KG1HZW9tZXRyeVtpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bUdlb21ldHJ5LmJpbmQodGhpcy5zaGFkZXJQcm9ncmFtKTtcblxuXHRcdC8vXHRERUZBVUxUIFVOSUZPUk1TXG5cdFx0aWYodGhpcy5jYW1lcmEgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCAnbWF0NCcsIHRoaXMuY2FtZXJhLnByb2plY3Rpb24pO1x0XG5cdFx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1Vmlld01hdHJpeCcsICdtYXQ0JywgdGhpcy5jYW1lcmEubWF0cml4KTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndUNhbWVyYVBvcycsICd2ZWMzJywgdGhpcy5jYW1lcmEucG9zaXRpb24pO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VNb2RlbE1hdHJpeCcsICdtYXQ0JywgbW9kZWxNYXRyaXggfHwgdGhpcy5fbW9kZWxNYXRyaXgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VOb3JtYWxNYXRyaXgnLCAnbWF0MycsIHRoaXMuX25vcm1hbE1hdHJpeCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndU1vZGVsVmlld01hdHJpeEludmVyc2UnLCAnbWF0MycsIHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgpO1xuXG5cdFx0Y29uc3QgZHJhd1R5cGUgPSBtR2VvbWV0cnkuZHJhd1R5cGU7XG5cblx0XHRpZihtR2VvbWV0cnkuaXNJbnN0YW5jZWQpIHtcblx0XHRcdGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZChtR2VvbWV0cnkuZHJhd1R5cGUsIG1HZW9tZXRyeS5pQnVmZmVyLm51bUl0ZW1zLCBnbC5VTlNJR05FRF9TSE9SVCwgMCwgbUdlb21ldHJ5Lm51bUluc3RhbmNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoZHJhd1R5cGUgPT09IGdsLlBPSU5UUykge1xuXHRcdFx0XHRnbC5kcmF3QXJyYXlzKGRyYXdUeXBlLCAwLCBtR2VvbWV0cnkudmVydGV4U2l6ZSk7XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLmRyYXdFbGVtZW50cyhkcmF3VHlwZSwgbUdlb21ldHJ5LmlCdWZmZXIubnVtSXRlbXMsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcdFxuXHRcdFx0fVx0XG5cdFx0fVxuXG5cdFx0bUdlb21ldHJ5LnVuYmluZCgpO1xuXHR9XG5cblxuXHRkcmF3TWVzaChtTWVzaCkge1xuXHRcdGNvbnN0IHsgbWF0ZXJpYWwsIGdlb21ldHJ5IH0gPSBtTWVzaDtcblxuXHRcdGlmKG1hdGVyaWFsLmRvdWJsZVNpZGVkKSB7XG5cdFx0XHR0aGlzLmRpc2FibGUoR0wuQ1VMTF9GQUNFKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lbmFibGUoR0wuQ1VMTF9GQUNFKTtcblx0XHR9XG5cblx0XHRtYXRlcmlhbC51cGRhdGUoKTtcblx0XHR0aGlzLmRyYXdHZW9tZXRyeShnZW9tZXRyeSwgbU1lc2gubWF0cml4KTtcblx0fVxuXG5cblx0ZHJhdyhtT2JqKSB7XG5cdFx0aWYobU9iaiBpbnN0YW5jZW9mIEdlb21ldHJ5KSB7XG5cdFx0XHR0aGlzLmRyYXdHZW9tZXRyeShtT2JqKTtcblx0XHR9IGVsc2UgaWYobU9iaiBpbnN0YW5jZW9mIE1lc2gpIHtcblx0XHRcdHRoaXMuZHJhd01lc2gobU9iaik7XG5cdFx0fSBlbHNlIGlmKG1PYmogaW5zdGFuY2VvZiBPYmplY3QzRCkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2hlcmUnKTtcblx0XHRcdG1PYmoudXBkYXRlTWF0cml4KCk7XG5cdFx0XHRtT2JqLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHR0aGlzLmRyYXcoY2hpbGQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblxuXHRkcmF3VHJhbnNmb3JtRmVlZGJhY2sobVRyYW5zZm9ybU9iamVjdCkge1xuXG5cdFx0Y29uc3QgeyBtZXNoU291cmNlLCBtZXNoRGVzdGluYXRpb24sIG51bVBvaW50cywgdHJhbnNmb3JtRmVlZGJhY2sgfSA9IG1UcmFuc2Zvcm1PYmplY3Q7XG5cdFx0XG5cdFx0Ly9cdEJJTkQgU09VUkNFIEJVRkZFUlMgLT4gc2V0dXBWZXJ0ZXhBdHRyKHNvdXJjZVZBTylcblx0XHRtZXNoU291cmNlLmJpbmQodGhpcy5zaGFkZXJQcm9ncmFtKTtcblx0XHRtZXNoRGVzdGluYXRpb24uZ2VuZXJhdGVCdWZmZXJzKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG5cblx0XHQvL1x0QklORCBERVNUSU5BVElPTiBCVUZGRVJTXG5cdFx0Z2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgdHJhbnNmb3JtRmVlZGJhY2spO1xuXG5cdFx0bWVzaERlc3RpbmF0aW9uLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ciwgaSk9PiB7XG5cdFx0XHRnbC5iaW5kQnVmZmVyQmFzZShnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBhdHRyLmJ1ZmZlcik7XG5cdFx0fSk7XG5cblx0XHRnbC5lbmFibGUoZ2wuUkFTVEVSSVpFUl9ESVNDQVJEKTtcblxuXHRcdGdsLmJlZ2luVHJhbnNmb3JtRmVlZGJhY2soZ2wuUE9JTlRTKTtcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgbnVtUG9pbnRzKTtcblx0XHRnbC5lbmRUcmFuc2Zvcm1GZWVkYmFjaygpO1x0XG5cdFx0XG5cblx0XHQvL1x0cmVzZXQgc3RhdGVcblx0XHRnbC5kaXNhYmxlKGdsLlJBU1RFUklaRVJfRElTQ0FSRCk7XG5cdFx0Z2wudXNlUHJvZ3JhbShudWxsKTtcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG5cdFx0bWVzaERlc3RpbmF0aW9uLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ciwgaSk9PiB7XG5cdFx0XHRnbC5iaW5kQnVmZmVyQmFzZShnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBudWxsKTtcblx0XHR9KTtcblx0XHRnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsKTtcblxuXHRcdG1lc2hTb3VyY2UudW5iaW5kKCk7XG5cdH1cblxuXG5cdHNldFNpemUobVdpZHRoLCBtSGVpZ2h0KSB7XG5cdFx0dGhpcy5fd2lkdGggICAgICAgID0gbVdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCAgICAgICA9IG1IZWlnaHQ7XG5cdFx0dGhpcy5jYW52YXMud2lkdGggID0gdGhpcy5fd2lkdGg7XG5cdFx0dGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXHRcdHRoaXMuX2FzcGVjdFJhdGlvICA9IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0O1xuXG5cdFx0aWYoZ2wpIHtcblx0XHRcdHRoaXMudmlld3BvcnQoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XHRcblx0XHR9XG5cdH1cblxuXG5cdHNob3dFeHRlbnNpb25zKCkge1xuXHRcdGNvbnNvbGUubG9nKCdFeHRlbnNpb25zIDogJywgdGhpcy5leHRlbnNpb25zKTtcblx0XHRmb3IoY29uc3QgZXh0IGluIHRoaXMuZXh0ZW5zaW9ucykge1xuXHRcdFx0aWYodGhpcy5leHRlbnNpb25zW2V4dF0pIHtcblx0XHRcdFx0Y29uc29sZS5sb2coZXh0LCAnOicsIHRoaXMuZXh0ZW5zaW9uc1tleHRdKTtcdFxuXHRcdFx0fVxuXHRcdH1cdFxuXHR9XG5cblx0Y2hlY2tFeHRlbnNpb24obUV4dGVuc2lvbikge1xuXHRcdHJldHVybiAhIXRoaXMuZXh0ZW5zaW9uc1ttRXh0ZW5zaW9uXTtcblx0fVxuXG5cblx0Z2V0RXh0ZW5zaW9uKG1FeHRlbnNpb24pIHtcblx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zW21FeHRlbnNpb25dO1xuXHR9XG5cblx0Ly9cdEJMRU5EIE1PREVTXG5cblx0ZW5hYmxlQWxwaGFCbGVuZGluZygpIHtcblx0XHRnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcdFxuXHR9XG5cblx0ZW5hYmxlQWRkaXRpdmVCbGVuZGluZygpIHtcblx0XHRnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuXHR9XG5cblx0Ly9cdG1hdHJpY2VzXG5cblx0cHVzaE1hdHJpeCgpIHtcblx0XHRjb25zdCBtdHggPSBtYXQ0LmNsb25lKHRoaXMuX21vZGVsTWF0cml4KTtcblx0XHR0aGlzLl9tYXRyaXhTdGFja3MucHVzaChtdHgpO1xuXHR9XG5cblxuXHRwb3BNYXRyaXgoKSB7XG5cdFx0aWYodGhpcy5fbWF0cml4U3RhY2tzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0Y29uc3QgbXR4ID0gdGhpcy5fbWF0cml4U3RhY2tzLnBvcCgpO1xuXHRcdHRoaXMucm90YXRlKG10eCk7XG5cdH1cblxuXG5cdC8vXHRHTCBOQVRJVkUgRlVOQ1RJT05TXG5cblx0ZW5hYmxlKG1QYXJhbWV0ZXIpIHtcdGdsLmVuYWJsZShtUGFyYW1ldGVyKTtcdFx0fVxuXG5cdGRpc2FibGUobVBhcmFtZXRlcikge1x0Z2wuZGlzYWJsZShtUGFyYW1ldGVyKTtcdH1cblxuXHR2aWV3cG9ydCh4LCB5LCB3LCBoKSB7XHR0aGlzLnNldFZpZXdwb3J0KHgsIHksIHcsIGgpO1x0fVxuXG5cblx0Ly9cdEdFVFRFUiBBTkQgU0VUVEVSU1xuXG5cdGdldCBGTE9BVCgpIHsgcmV0dXJuIGdldEZsb2F0KCk7IH1cblx0XG5cdGdldCBIQUxGX0ZMT0FUKCkgeyByZXR1cm4gZ2V0SGFsZkZsb2F0KCk7IH1cblxuXHRnZXQgd2lkdGgoKSB7XHRyZXR1cm4gdGhpcy5fd2lkdGg7XHRcdH1cblxuXHRnZXQgaGVpZ2h0KCkge1x0cmV0dXJuIHRoaXMuX2hlaWdodDtcdH1cblxuXHRnZXQgYXNwZWN0UmF0aW8oKSB7XHRyZXR1cm4gdGhpcy5fYXNwZWN0UmF0aW87XHR9XG5cblx0Z2V0IHdlYmdsMigpIHtcdHJldHVybiB0aGlzLl91c2VXZWJHTDI7XHR9XG5cblx0Ly9cdERFU1RST1lcblxuXHRkZXN0cm95KCkge1xuXHRcdFxuXHRcdGlmKHRoaXMuY2FudmFzLnBhcmVudE5vZGUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnRXJyb3IgOiAnLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmNhbnZhcyA9IG51bGw7XG5cdH1cbn1cblxuY29uc3QgR0wgPSBuZXcgR0xUb29sKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEdMO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUb29sLmpzIiwiLy8gR0xTaGFkZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuL0dMVGV4dHVyZSc7XG5pbXBvcnQgR0xDdWJlVGV4dHVyZSBmcm9tICcuL0dMQ3ViZVRleHR1cmUnO1xuXG5jb25zdCBnbHNsaWZ5ID0gcmVxdWlyZSgnZ2xzbGlmeScpO1xuY29uc3QgaXNTYW1lID0gKGFycmF5MSwgYXJyYXkyKSA9PiB7XG5cdGlmKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmb3IobGV0IGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGFkZExpbmVOdW1iZXJzID0gKHN0cmluZykgPT4ge1xuXHRjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdCgnXFxuJyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrKSB7XG5cdFx0bGluZXNbaV0gPSBgJHsoaSArIDEpfTogJHtsaW5lc1tpXX1gO1xuXHR9XG5cdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cblxuY29uc3QgY2xvbmVBcnJheSA9IChtQXJyYXkpID0+IHtcblx0aWYobUFycmF5LnNsaWNlKSB7XG5cdFx0cmV0dXJuIG1BcnJheS5zbGljZSgwKTsgXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobUFycmF5KTtcblx0fVxufTtcblxubGV0IGdsO1xuY29uc3QgZGVmYXVsdFZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vZ2xzbC9iYXNpYy52ZXJ0Jyk7XG5jb25zdCBkZWZhdWx0RnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuL2dsc2wvYmFzaWMuZnJhZycpO1xuXG5jb25zdCB1bmlmb3JtTWFwcGluZyA9IHtcblx0ZmxvYXQ6ICd1bmlmb3JtMWYnLFxuXHR2ZWMyOiAndW5pZm9ybTJmdicsXG5cdHZlYzM6ICd1bmlmb3JtM2Z2Jyxcblx0dmVjNDogJ3VuaWZvcm00ZnYnLFxuXHRpbnQ6ICd1bmlmb3JtMWknLFxuXHRtYXQzOiAndW5pZm9ybU1hdHJpeDNmdicsXG5cdG1hdDQ6ICd1bmlmb3JtTWF0cml4NGZ2J1xufTtcblxuY2xhc3MgR0xTaGFkZXIge1xuXHRjb25zdHJ1Y3RvcihzdHJWZXJ0ZXhTaGFkZXIgPSBkZWZhdWx0VmVydGV4U2hhZGVyLCBzdHJGcmFnbWVudFNoYWRlciA9IGRlZmF1bHRGcmFnbWVudFNoYWRlciwgbVZhcnlpbmdzKSB7XG5cblx0XHRnbCAgICAgICAgICAgICAgICAgICA9IEdMLmdsO1xuXHRcdHRoaXMucGFyYW1ldGVycyAgICAgID0gW107XG5cdFx0dGhpcy5fdW5pZm9ybVRleHR1cmVzID0gW107XG5cdFx0dGhpcy5fdmFyeWluZ3MgXHRcdCA9IG1WYXJ5aW5ncztcblxuXHRcdGlmKCFzdHJWZXJ0ZXhTaGFkZXIpIHsgc3RyVmVydGV4U2hhZGVyID0gZGVmYXVsdFZlcnRleFNoYWRlcjsgfVxuXHRcdGlmKCFzdHJGcmFnbWVudFNoYWRlcikgeyBzdHJGcmFnbWVudFNoYWRlciA9IGRlZmF1bHRWZXJ0ZXhTaGFkZXI7IH1cblxuXHRcdGNvbnN0IHZzU2hhZGVyID0gdGhpcy5fY3JlYXRlU2hhZGVyUHJvZ3JhbShzdHJWZXJ0ZXhTaGFkZXIsIHRydWUpO1xuXHRcdGNvbnN0IGZzU2hhZGVyID0gdGhpcy5fY3JlYXRlU2hhZGVyUHJvZ3JhbShzdHJGcmFnbWVudFNoYWRlciwgZmFsc2UpO1xuXHRcdHRoaXMuX2F0dGFjaFNoYWRlclByb2dyYW0odnNTaGFkZXIsIGZzU2hhZGVyKTtcblxuXHR9XG5cblxuXHRiaW5kKCkge1xuXG5cdFx0aWYoR0wuc2hhZGVyID09PSB0aGlzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGdsLnVzZVByb2dyYW0odGhpcy5zaGFkZXJQcm9ncmFtKTtcblx0XHRHTC51c2VTaGFkZXIodGhpcyk7XG5cdFx0Ly8gdGhpcy51bmlmb3JtVGV4dHVyZXMgPSBbXTtcblxuXHR9XG5cblxuXHR1bmlmb3JtKG1OYW1lLCBtVHlwZSwgbVZhbHVlKSB7XG5cdFx0aWYodHlwZW9mIG1OYW1lID09PSAnb2JqZWN0Jykge1xuXHRcdFx0dGhpcy51bmlmb3JtT2JqZWN0KG1OYW1lKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Lypcblx0XHRpZighIW1WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IG1WYWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdtVmFsdWUgRXJyb3I6JywgbU5hbWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0Ki9cblx0XHRjb25zdCB1bmlmb3JtVHlwZSA9IHVuaWZvcm1NYXBwaW5nW21UeXBlXSB8fCBtVHlwZTtcblx0XHRcblx0XHRsZXQgaGFzVW5pZm9ybSA9IGZhbHNlO1xuXHRcdGxldCBvVW5pZm9ybTtcblx0XHRsZXQgcGFyYW1ldGVySW5kZXggPSAtMTtcblxuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMucGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0b1VuaWZvcm0gPSB0aGlzLnBhcmFtZXRlcnNbaV07XG5cdFx0XHRpZihvVW5pZm9ybS5uYW1lID09PSBtTmFtZSkge1xuXHRcdFx0XHRoYXNVbmlmb3JtID0gdHJ1ZTtcblx0XHRcdFx0cGFyYW1ldGVySW5kZXggPSBpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgaXNOdW1iZXIgPSBmYWxzZTtcblxuXHRcdGlmKCFoYXNVbmlmb3JtKSB7XG5cdFx0XHRpc051bWJlciA9IHVuaWZvcm1UeXBlID09PSAndW5pZm9ybTFpJyB8fCB1bmlmb3JtVHlwZSA9PT0gJ3VuaWZvcm0xZic7XG5cdFx0XHR0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuc2hhZGVyUHJvZ3JhbSwgbU5hbWUpO1xuXHRcdFx0aWYoaXNOdW1iZXIpIHtcblx0XHRcdFx0dGhpcy5wYXJhbWV0ZXJzLnB1c2goeyBuYW1lIDogbU5hbWUsIHR5cGU6IHVuaWZvcm1UeXBlLCB2YWx1ZTogbVZhbHVlLCB1bmlmb3JtTG9jOiB0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdLCBpc051bWJlciB9KTtcdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wYXJhbWV0ZXJzLnB1c2goeyBuYW1lIDogbU5hbWUsIHR5cGU6IHVuaWZvcm1UeXBlLCB2YWx1ZTogY2xvbmVBcnJheShtVmFsdWUpLCB1bmlmb3JtTG9jOiB0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdLCBpc051bWJlciB9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cGFyYW1ldGVySW5kZXggPSB0aGlzLnBhcmFtZXRlcnMubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSA9IG9Vbmlmb3JtLnVuaWZvcm1Mb2M7XG5cdFx0XHRpc051bWJlciA9IG9Vbmlmb3JtLmlzTnVtYmVyO1xuXHRcdH1cblxuXG5cdFx0aWYoIXRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udW5pZm9ybUxvYykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXG5cdFx0aWYodW5pZm9ybVR5cGUuaW5kZXhPZignTWF0cml4JykgPT09IC0xKSB7XG5cdFx0XHRpZighaXNOdW1iZXIpIHtcblx0XHRcdFx0aWYoIWlzU2FtZSh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlLCBtVmFsdWUpIHx8ICFoYXNVbmlmb3JtKSB7XG5cdFx0XHRcdFx0Z2xbdW5pZm9ybVR5cGVdKHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0sIG1WYWx1ZSk7XHRcblx0XHRcdFx0XHR0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlID0gY2xvbmVBcnJheShtVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBuZWVkVXBkYXRlID0gKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUgIT09IG1WYWx1ZSB8fCAhaGFzVW5pZm9ybSk7XG5cdFx0XHRcdGlmKG5lZWRVcGRhdGUpIHtcblx0XHRcdFx0XHRnbFt1bmlmb3JtVHlwZV0odGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSwgbVZhbHVlKTtcdFxuXHRcdFx0XHRcdHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUgPSBtVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZighaXNTYW1lKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUsIG1WYWx1ZSkgfHwgIWhhc1VuaWZvcm0pIHtcblx0XHRcdFx0Z2xbdW5pZm9ybVR5cGVdKHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0sIGZhbHNlLCBtVmFsdWUpO1x0XG5cdFx0XHRcdHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUgPSBjbG9uZUFycmF5KG1WYWx1ZSk7XG5cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdHVuaWZvcm1PYmplY3QobVVuaWZvcm1PYmopIHtcblx0XHRmb3IoY29uc3QgdW5pZm9ybU5hbWUgaW4gbVVuaWZvcm1PYmopIHtcblx0XHRcdFxuXHRcdFx0aWYgKG1Vbmlmb3JtT2JqW3VuaWZvcm1OYW1lXSBpbnN0YW5jZW9mIEdMVGV4dHVyZSB8fCBtVW5pZm9ybU9ialt1bmlmb3JtTmFtZV0gaW5zdGFuY2VvZiBHTEN1YmVUZXh0dXJlKSB7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSBtVW5pZm9ybU9ialt1bmlmb3JtTmFtZV07XG5cblx0XHRcdFx0bGV0IHRleHR1cmVJbmRleCA9IC0xOyA7XG5cdFx0XHRcdHRoaXMuX3VuaWZvcm1UZXh0dXJlcy5mb3JFYWNoKCh1dCwgaSkgPT4ge1xuXHRcdFx0XHRcdGlmKHV0Lm5hbWUgPT09IHVuaWZvcm1OYW1lKSB7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlSW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0dXQudGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZih0ZXh0dXJlSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdFx0dGV4dHVyZUluZGV4ID0gdGhpcy5fdW5pZm9ybVRleHR1cmVzLmxlbmd0aDtcdFxuXHRcdFx0XHRcdHRoaXMuX3VuaWZvcm1UZXh0dXJlcy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6dW5pZm9ybU5hbWUsXG5cdFx0XHRcdFx0XHR0ZXh0dXJlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnVuaWZvcm0odW5pZm9ybU5hbWUsICd1bmlmb3JtMWknLCB0ZXh0dXJlSW5kZXgpO1xuXHRcdFx0XHR0ZXh0dXJlLmJpbmQodGV4dHVyZUluZGV4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCB1bmlmb3JtVmFsdWUgPSBtVW5pZm9ybU9ialt1bmlmb3JtTmFtZV07XG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1UeXBlID0gR0xTaGFkZXIuZ2V0VW5pZm9ybVR5cGUodW5pZm9ybVZhbHVlKTtcblxuXHRcdFx0XHRpZih1bmlmb3JtVmFsdWUuY29uY2F0ICYmIHVuaWZvcm1WYWx1ZVswXS5jb25jYXQpIHtcblx0XHRcdFx0XHRsZXQgdG1wID0gW107XG5cdFx0XHRcdFx0Zm9yKGxldCBpPTA7IGk8dW5pZm9ybVZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0bXAuY29uY2F0KHVuaWZvcm1WYWx1ZVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHVuaWZvcm1WYWx1ZSA9IHRtcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy51bmlmb3JtKHVuaWZvcm1OYW1lLCB1bmlmb3JtVHlwZSwgdW5pZm9ybVZhbHVlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblxuXHR9XG5cblxuXHRfY3JlYXRlU2hhZGVyUHJvZ3JhbShtU2hhZGVyU3RyLCBpc1ZlcnRleFNoYWRlcikge1xuXHRcdFxuXHRcdGNvbnN0IHNoYWRlclR5cGUgPSBpc1ZlcnRleFNoYWRlciA/IEdMLlZFUlRFWF9TSEFERVIgOiBHTC5GUkFHTUVOVF9TSEFERVI7XG5cdFx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKHNoYWRlciwgbVNoYWRlclN0cik7XG5cdFx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG5cdFx0aWYoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdFcnJvciBpbiBTaGFkZXIgOiAnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuXHRcdFx0Y29uc29sZS5sb2coYWRkTGluZU51bWJlcnMobVNoYWRlclN0cikpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNoYWRlcjtcblx0fVxuXG5cdF9hdHRhY2hTaGFkZXJQcm9ncmFtKG1WZXJ0ZXhTaGFkZXIsIG1GcmFnbWVudFNoYWRlcikge1xuXG5cdFx0dGhpcy5zaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIG1WZXJ0ZXhTaGFkZXIpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIG1GcmFnbWVudFNoYWRlcik7XG5cblx0XHRnbC5kZWxldGVTaGFkZXIobVZlcnRleFNoYWRlcik7XG5cdFx0Z2wuZGVsZXRlU2hhZGVyKG1GcmFnbWVudFNoYWRlcik7XG5cblx0XHRpZih0aGlzLl92YXJ5aW5ncykge1xuXHRcdFx0Y29uc29sZS5sb2coJ1RyYW5zZm9ybSBmZWVkYmFjayBzZXR1cCA6ICcsIHRoaXMuX3ZhcnlpbmdzKTtcblx0XHRcdGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3ModGhpcy5zaGFkZXJQcm9ncmFtLCB0aGlzLl92YXJ5aW5ncywgZ2wuU0VQQVJBVEVfQVRUUklCUyk7XG5cdFx0fVxuXG5cdFx0Z2wubGlua1Byb2dyYW0odGhpcy5zaGFkZXJQcm9ncmFtKTtcblxuXHR9XG5cbn1cblxuR0xTaGFkZXIuZ2V0VW5pZm9ybVR5cGUgPSBmdW5jdGlvbiAobVZhbHVlKSB7XG5cdGNvbnN0IGlzQXJyYXkgPSAhIW1WYWx1ZS5jb25jYXQ7XG5cblx0Y29uc3QgZ2V0QXJyYXlVbmlmb3JtVHlwZSA9IGZ1bmN0aW9uIChtVmFsdWUpIHtcblx0XHRpZihtVmFsdWUubGVuZ3RoID09PSA5KSB7XG5cdFx0XHRyZXR1cm4gJ3VuaWZvcm1NYXRyaXgzZnYnO1xuXHRcdH0gZWxzZSBpZihtVmFsdWUubGVuZ3RoID09PSAxNikge1xuXHRcdFx0cmV0dXJuICd1bmlmb3JtTWF0cml4NGZ2Jztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGB2ZWMke21WYWx1ZS5sZW5ndGh9YDtcdFxuXHRcdH1cblx0fTtcblxuXHRpZighaXNBcnJheSkge1xuXHRcdHJldHVybiAnZmxvYXQnO1xuXHR9IGVsc2Uge1xuXHRcdGlmICghbVZhbHVlWzBdLmNvbmNhdCkge1xuXHRcdFx0cmV0dXJuIGdldEFycmF5VW5pZm9ybVR5cGUobVZhbHVlKTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZ2V0QXJyYXlVbmlmb3JtVHlwZShtVmFsdWVbMF0pO1xuXHRcdH1cblx0fVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBHTFNoYWRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9HTFNoYWRlci5qcyIsIi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cbi8vIEVORCBIRUFERVJcblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vZ2wtbWF0cml4L2NvbW1vblwiO1xuaW1wb3J0ICogYXMgbWF0MiBmcm9tIFwiLi9nbC1tYXRyaXgvbWF0MlwiO1xuaW1wb3J0ICogYXMgbWF0MmQgZnJvbSBcIi4vZ2wtbWF0cml4L21hdDJkXCI7XG5pbXBvcnQgKiBhcyBtYXQzIGZyb20gXCIuL2dsLW1hdHJpeC9tYXQzXCI7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCIuL2dsLW1hdHJpeC9tYXQ0XCI7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gXCIuL2dsLW1hdHJpeC9xdWF0XCI7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gXCIuL2dsLW1hdHJpeC92ZWMyXCI7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gXCIuL2dsLW1hdHJpeC92ZWMzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL2dsLW1hdHJpeC92ZWM0XCI7XG5cbmV4cG9ydCB7XG4gIGdsTWF0cml4LFxuICBtYXQyLCBtYXQyZCwgbWF0MywgbWF0NCxcbiAgcXVhdCxcbiAgdmVjMiwgdmVjMywgdmVjNCxcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgZ2V0QXR0cmliTG9jIGZyb20gJy4vdXRpbHMvZ2V0QXR0cmliTG9jJztcblxubGV0IGdsO1xuY29uc3QgU1RBVElDX0RSQVcgPSAzNTA0NDtcblxuY29uc3QgZ2V0QnVmZmVyID0gZnVuY3Rpb24gKGF0dHIpIHtcblx0bGV0IGJ1ZmZlcjtcblx0XG5cdGlmKGF0dHIuYnVmZmVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRidWZmZXIgPSBhdHRyLmJ1ZmZlcjtcdFxuXHR9IGVsc2Uge1xuXHRcdGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGF0dHIuYnVmZmVyID0gYnVmZmVyO1xuXHR9XG5cblx0cmV0dXJuIGJ1ZmZlcjtcbn07XG5cblxuY29uc3QgZm9ybUJ1ZmZlciA9IGZ1bmN0aW9uIChtRGF0YSwgbU51bSkge1xuXHRjb25zdCBhcnkgPSBbXTtcblxuXHRmb3IobGV0IGk9MDsgaTxtRGF0YS5sZW5ndGg7IGkrPSBtTnVtKSB7XG5cdFx0Y29uc3QgbyA9IFtdO1xuXHRcdGZvcihsZXQgaj0wOyBqPG1OdW07IGorKykge1xuXHRcdFx0by5wdXNoKG1EYXRhW2kral0pO1xuXHRcdH1cblxuXHRcdGFyeS5wdXNoKG8pO1xuXHR9XG5cblx0cmV0dXJuIGFyeTtcbn07XG5cbmNsYXNzIEdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IobURyYXdpbmdUeXBlID0gNCwgbVVzZVZhbyA9IHRydWUpIHtcblx0XHRnbCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gR0wuZ2w7XG5cdFx0dGhpcy5kcmF3VHlwZSAgICAgICAgICAgICAgICA9IG1EcmF3aW5nVHlwZTtcblx0XHR0aGlzLl9hdHRyaWJ1dGVzICAgICAgICAgICAgID0gW107XG5cdFx0dGhpcy5fbnVtSW5zdGFuY2UgXHRcdFx0ID0gLTE7XG5cdFx0dGhpcy5fZW5hYmxlZFZlcnRleEF0dHJpYnV0ZSA9IFtdO1xuXHRcdFxuXHRcdHRoaXMuX2luZGljZXMgICAgICAgICAgICAgICAgPSBbXTtcblx0XHR0aGlzLl9mYWNlcyAgICAgICAgICAgICAgICAgID0gW107XG5cdFx0dGhpcy5fYnVmZmVyQ2hhbmdlZCAgICAgICAgICA9IFtdO1xuXHRcdHRoaXMuX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCAgPSBmYWxzZTtcblx0XHR0aGlzLl9oYXNWQU8gICAgICAgICAgICAgICAgID0gZmFsc2U7XG5cdFx0dGhpcy5faXNJbnN0YW5jZWQgXHRcdFx0ID0gZmFsc2U7XG5cdFx0XG5cdFx0dGhpcy5fZXh0VkFPICAgICAgICAgICAgICAgICA9ICEhR0wuZ2wuY3JlYXRlVmVydGV4QXJyYXk7XG5cdFx0dGhpcy5fdXNlVkFPICAgICAgICAgICAgIFx0ID0gISF0aGlzLl9leHRWQU8gJiYgbVVzZVZhbztcblx0XHQvLyB0aGlzLl91c2VWQU8gPSBmYWxzZTtcblx0fVxuXG5cblx0YnVmZmVyVmVydGV4KG1BcnJheVZlcnRpY2VzLCBtRHJhd1R5cGUgPSBTVEFUSUNfRFJBVykge1xuXG5cdFx0dGhpcy5idWZmZXJEYXRhKG1BcnJheVZlcnRpY2VzLCAnYVZlcnRleFBvc2l0aW9uJywgMywgbURyYXdUeXBlKTtcblxuXHRcdGlmICh0aGlzLm5vcm1hbHMubGVuZ3RoIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuYnVmZmVyTm9ybWFsKG1BcnJheVZlcnRpY2VzLCBtRHJhd1R5cGUpO1x0XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdGJ1ZmZlclRleENvb3JkKG1BcnJheVRleENvb3JkcywgbURyYXdUeXBlID0gU1RBVElDX0RSQVcpIHtcblxuXHRcdHRoaXMuYnVmZmVyRGF0YShtQXJyYXlUZXhDb29yZHMsICdhVGV4dHVyZUNvb3JkJywgMiwgbURyYXdUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblxuXHRidWZmZXJOb3JtYWwobU5vcm1hbHMsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXKSB7XG5cblx0XHR0aGlzLmJ1ZmZlckRhdGEobU5vcm1hbHMsICdhTm9ybWFsJywgMywgbURyYXdUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblxuXHRidWZmZXJJbmRleChtQXJyYXlJbmRpY2VzLCBpc0R5bmFtaWMgPSBmYWxzZSkge1xuXHRcdHRoaXMuX2RyYXdUeXBlICAgICAgICA9IGlzRHluYW1pYyA/IGdsLkRZTkFNSUNfRFJBVyA6IGdsLlNUQVRJQ19EUkFXO1xuXHRcdGlmKG1BcnJheUluZGljZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dGhpcy5faW5kaWNlc1x0ICA9IG5ldyBVaW50MTZBcnJheShtQXJyYXlJbmRpY2VzKTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbmRpY2VzID0gbUFycmF5SW5kaWNlcztcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5fbnVtSXRlbXMgXHRcdCAgPSB0aGlzLl9pbmRpY2VzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YnVmZmVyRmxhdHRlbkRhdGEobURhdGEsIG1OYW1lLCBtSXRlbVNpemUsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXLCBpc0luc3RhbmNlZCA9IGZhbHNlKSB7XG5cdFx0XG5cdFx0Y29uc3QgZGF0YSA9IGZvcm1CdWZmZXIobURhdGEsIG1JdGVtU2l6ZSk7XG5cdFx0dGhpcy5idWZmZXJEYXRhKGRhdGEsIG1OYW1lLCBtSXRlbVNpemUsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXLCBpc0luc3RhbmNlZCA9IGZhbHNlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YnVmZmVyRGF0YShtRGF0YSwgbU5hbWUsIG1JdGVtU2l6ZSwgbURyYXdUeXBlID0gU1RBVElDX0RSQVcsIGlzSW5zdGFuY2VkID0gZmFsc2UpIHtcblx0XHRsZXQgaSA9IDA7XG5cdFx0Y29uc3QgZHJhd1R5cGUgICA9IG1EcmF3VHlwZTtcblx0XHRpZighZHJhd1R5cGUpIGRlYnVnZ2VyO1xuXG5cdFx0Y29uc3QgYnVmZmVyRGF0YSA9IFtdO1xuXHRcdGlmICghbUl0ZW1TaXplKSB7XHRtSXRlbVNpemUgPSBtRGF0YVswXS5sZW5ndGg7IH1cblx0XHR0aGlzLl9pc0luc3RhbmNlZCA9IGlzSW5zdGFuY2VkIHx8IHRoaXMuX2lzSW5zdGFuY2VkO1xuXG5cdFx0Ly9cdGZsYXR0ZW4gYnVmZmVyIGRhdGFcdFx0XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbURhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCBtRGF0YVtpXS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRidWZmZXJEYXRhLnB1c2gobURhdGFbaV1bal0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBkYXRhQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckRhdGEpO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKG1OYW1lKTtcblxuXHRcdFxuXHRcdGlmKGF0dHJpYnV0ZSkge1x0XG5cdFx0XHQvL1x0YXR0cmlidXRlIGV4aXN0ZWQsIHJlcGxhY2Ugd2l0aCBuZXcgZGF0YVxuXHRcdFx0YXR0cmlidXRlLml0ZW1TaXplID0gbUl0ZW1TaXplO1xuXHRcdFx0YXR0cmlidXRlLmRhdGFBcnJheSA9IGRhdGFBcnJheTtcblx0XHRcdGF0dHJpYnV0ZS5zb3VyY2UgPSBtRGF0YTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9cdGF0dHJpYnV0ZSBub3QgZXhpc3QgeWV0LCBjcmVhdGUgbmV3IGF0dHJpYnV0ZSBvYmplY3Rcblx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMucHVzaCh7IG5hbWU6bU5hbWUsIHNvdXJjZTptRGF0YSwgaXRlbVNpemU6IG1JdGVtU2l6ZSwgZHJhd1R5cGUsIGRhdGFBcnJheSwgaXNJbnN0YW5jZWQgfSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYnVmZmVyQ2hhbmdlZC5wdXNoKG1OYW1lKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGJ1ZmZlckluc3RhbmNlKG1EYXRhLCBtTmFtZSkge1xuXHRcdGlmICghR0wuZ2wudmVydGV4QXR0cmliRGl2aXNvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXh0ZW5zaW9uIDogQU5HTEVfaW5zdGFuY2VkX2FycmF5cyBpcyBub3Qgc3VwcG9ydGVkIHdpdGggdGhpcyBkZXZpY2UgIScpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGl0ZW1TaXplID0gbURhdGFbMF0ubGVuZ3RoO1xuXHRcdHRoaXMuX251bUluc3RhbmNlID0gbURhdGEubGVuZ3RoO1xuXHRcdHRoaXMuYnVmZmVyRGF0YShtRGF0YSwgbU5hbWUsIGl0ZW1TaXplLCBTVEFUSUNfRFJBVywgdHJ1ZSk7XG5cdH1cblxuXG5cdGJpbmQobVNoYWRlclByb2dyYW0pIHtcblx0XHR0aGlzLmdlbmVyYXRlQnVmZmVycyhtU2hhZGVyUHJvZ3JhbSk7XG5cblx0XHRpZih0aGlzLmhhc1ZBTykge1xuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KHRoaXMudmFvKTsgXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyaWJ1dGUpPT4ge1xuXHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYXR0cmlidXRlLmJ1ZmZlcik7XG5cdFx0XHRcdGNvbnN0IGF0dHJQb3NpdGlvbiA9IGF0dHJpYnV0ZS5hdHRyUG9zaXRpb247XG5cdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0clBvc2l0aW9uLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cblx0XHRcdFx0aWYoYXR0cmlidXRlLmlzSW5zdGFuY2VkKSB7XG5cdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyUG9zaXRpb24sIDEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXG5cdFx0XHQvL1x0QklORCBJTkRFWCBCVUZGRVJcblx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaUJ1ZmZlcik7XHRcblx0XHR9XG5cdH1cblxuXHRnZW5lcmF0ZUJ1ZmZlcnMobVNoYWRlclByb2dyYW0pIHtcblx0XHRpZih0aGlzLl9idWZmZXJDaGFuZ2VkLmxlbmd0aCA9PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0aWYodGhpcy5fdXNlVkFPKSB7IC8vXHRJRiBTVVBQT1JURUQsIENSRUFURSBWQU9cblxuXHRcdFx0Ly9cdENSRUFURSAmIEJJTkQgVkFPXG5cdFx0XHRpZighdGhpcy5fdmFvKSB7XG5cdFx0XHRcdHRoaXMuX3ZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XHRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KHRoaXMuX3Zhbyk7XG5cblx0XHRcdC8vXHRVUERBVEUgQlVGRkVSU1xuXHRcdFx0dGhpcy5fYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyT2JqKSA9PiB7XG5cblx0XHRcdFx0aWYodGhpcy5fYnVmZmVyQ2hhbmdlZC5pbmRleE9mKGF0dHJPYmoubmFtZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gZ2V0QnVmZmVyKGF0dHJPYmopO1xuXHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdFx0XHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyT2JqLmRhdGFBcnJheSwgYXR0ck9iai5kcmF3VHlwZSk7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyUG9zaXRpb24gPSBnZXRBdHRyaWJMb2MoZ2wsIG1TaGFkZXJQcm9ncmFtLCBhdHRyT2JqLm5hbWUpO1xuXHRcdFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJQb3NpdGlvbik7IFxuXHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0clBvc2l0aW9uLCBhdHRyT2JqLml0ZW1TaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXHRcdFx0XHRcdGF0dHJPYmouYXR0clBvc2l0aW9uID0gYXR0clBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0aWYoYXR0ck9iai5pc0luc3RhbmNlZCkge1xuXHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyUG9zaXRpb24sIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdC8vXHRjaGVjayBpbmRleCBidWZmZXJcblx0XHRcdHRoaXMuX3VwZGF0ZUluZGV4QnVmZmVyKCk7XG5cblx0XHRcdC8vXHRVTkJJTkQgVkFPXG5cdFx0XHRnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XHRcblx0XHRcdFxuXHRcdFx0dGhpcy5faGFzVkFPID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7IC8vXHRFTFNFLCBVU0UgVFJBRElUSU9OQUwgTUVUSE9EXG5cblx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ck9iaikgPT4ge1xuXHRcdFx0XHQvL1x0U0tJUCBJRiBCVUZGRVIgSEFTTidUIENIQU5HRURcblx0XHRcdFx0aWYodGhpcy5fYnVmZmVyQ2hhbmdlZC5pbmRleE9mKGF0dHJPYmoubmFtZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gZ2V0QnVmZmVyKGF0dHJPYmopO1xuXHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdFx0XHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyT2JqLmRhdGFBcnJheSwgYXR0ck9iai5kcmF3VHlwZSk7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyUG9zaXRpb24gPSBnZXRBdHRyaWJMb2MoZ2wsIG1TaGFkZXJQcm9ncmFtLCBhdHRyT2JqLm5hbWUpO1xuXHRcdFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJQb3NpdGlvbik7XG5cdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyUG9zaXRpb24sIGF0dHJPYmouaXRlbVNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cdFx0XHRcdFx0YXR0ck9iai5hdHRyUG9zaXRpb24gPSBhdHRyUG9zaXRpb247XG5cblx0XHRcdFx0XHRpZihhdHRyT2JqLmlzSW5zdGFuY2VkKSB7XG5cdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJQb3NpdGlvbiwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fdXBkYXRlSW5kZXhCdWZmZXIoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9oYXNJbmRleEJ1ZmZlckNoYW5nZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9idWZmZXJDaGFuZ2VkID0gW107XG5cdH1cblxuXG5cdHVuYmluZCgpIHtcblx0XHRpZih0aGlzLl91c2VWQU8pIHtcblx0XHRcdGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcdFxuXHRcdH1cblx0XHRcblx0XHR0aGlzLl9hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSk9PiB7XG5cdFx0XHRpZihhdHRyaWJ1dGUuaXNJbnN0YW5jZWQpIHtcblx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyaWJ1dGUuYXR0clBvc2l0aW9uLCAwKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cblx0X3VwZGF0ZUluZGV4QnVmZmVyKCkge1xuXHRcdGlmKCF0aGlzLl9oYXNJbmRleEJ1ZmZlckNoYW5nZWQpIHtcblx0XHRcdGlmICghdGhpcy5pQnVmZmVyKSB7IHRoaXMuaUJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1x0IH1cblx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaUJ1ZmZlcik7XG5cdFx0XHRnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9pbmRpY2VzLCB0aGlzLl9kcmF3VHlwZSk7XG5cdFx0XHR0aGlzLmlCdWZmZXIuaXRlbVNpemUgPSAxO1xuXHRcdFx0dGhpcy5pQnVmZmVyLm51bUl0ZW1zID0gdGhpcy5fbnVtSXRlbXM7XG5cdFx0fVxuXHR9XG5cblxuXHRjb21wdXRlTm9ybWFscyh1c2luZ0ZhY2VOb3JtYWxzID0gZmFsc2UpIHtcblxuXHRcdHRoaXMuZ2VuZXJhdGVGYWNlcygpO1xuXG5cdFx0aWYodXNpbmdGYWNlTm9ybWFscykge1xuXHRcdFx0dGhpcy5fY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cdFx0fVxuXHR9XG5cblx0Ly9cdFBSSVZBVEUgTUVUSE9EU1xuXG5cdF9jb21wdXRlRmFjZU5vcm1hbHMoKSB7XG5cblx0XHRsZXQgZmFjZUluZGV4O1xuXHRcdGxldCBmYWNlO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRmYWNlSW5kZXggPSBpIC8gMztcblx0XHRcdGZhY2UgPSB0aGlzLl9mYWNlc1tmYWNlSW5kZXhdO1xuXHRcdFx0Y29uc3QgTiA9IGZhY2Uubm9ybWFsO1xuXG5cdFx0XHRub3JtYWxzW2ZhY2UuaW5kaWNlc1swXV0gPSBOO1xuXHRcdFx0bm9ybWFsc1tmYWNlLmluZGljZXNbMV1dID0gTjtcblx0XHRcdG5vcm1hbHNbZmFjZS5pbmRpY2VzWzJdXSA9IE47XG5cdFx0fVxuXG5cdFx0dGhpcy5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cdH1cblxuXG5cdF9jb21wdXRlVmVydGV4Tm9ybWFscygpIHtcblx0XHQvL1x0bG9vcCB0aHJvdWdoIGFsbCB2ZXJ0aWNlc1xuXHRcdGxldCBmYWNlO1xuXHRcdGNvbnN0IHN1bU5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHsgdmVydGljZXMgfSA9IHRoaXM7XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0dmVjMy5zZXQoc3VtTm9ybWFsLCAwLCAwLCAwKTtcblxuXHRcdFx0Zm9yKGxldCBqID0gMDsgaiA8IHRoaXMuX2ZhY2VzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGZhY2UgPSB0aGlzLl9mYWNlc1tqXTtcblxuXHRcdFx0XHQvL1x0aWYgdmVydGV4IGV4aXN0IGluIHRoZSBmYWNlLCBhZGQgdGhlIG5vcm1hbCB0byBzdW0gbm9ybWFsXG5cdFx0XHRcdGlmKGZhY2UuaW5kaWNlcy5pbmRleE9mKGkpID49IDApIHtcblxuXHRcdFx0XHRcdHN1bU5vcm1hbFswXSArPSBmYWNlLm5vcm1hbFswXTtcblx0XHRcdFx0XHRzdW1Ob3JtYWxbMV0gKz0gZmFjZS5ub3JtYWxbMV07XG5cdFx0XHRcdFx0c3VtTm9ybWFsWzJdICs9IGZhY2Uubm9ybWFsWzJdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2ZWMzLm5vcm1hbGl6ZShzdW1Ob3JtYWwsIHN1bU5vcm1hbCk7XG5cdFx0XHRub3JtYWxzLnB1c2goW3N1bU5vcm1hbFswXSwgc3VtTm9ybWFsWzFdLCBzdW1Ob3JtYWxbMl1dKTtcblx0XHR9XG5cblx0XHR0aGlzLmJ1ZmZlck5vcm1hbChub3JtYWxzKTtcblxuXHR9XG5cblxuXHRnZW5lcmF0ZUZhY2VzKCkge1xuXHRcdGxldCBpYSwgaWIsIGljO1xuXHRcdGxldCBhLCBiLCBjO1xuXHRcdGNvbnN0IHZiYSA9IHZlYzMuY3JlYXRlKCksIHZjYSA9IHZlYzMuY3JlYXRlKCksIHZOb3JtYWwgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IHsgdmVydGljZXMgfSA9IHRoaXM7XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xuXG5cdFx0XHRpYSA9IHRoaXMuX2luZGljZXNbaV07XG5cdFx0XHRpYiA9IHRoaXMuX2luZGljZXNbaSArIDFdO1xuXHRcdFx0aWMgPSB0aGlzLl9pbmRpY2VzW2kgKyAyXTtcblxuXHRcdFx0YSA9IHZlcnRpY2VzW2lhXTtcblx0XHRcdGIgPSB2ZXJ0aWNlc1tpYl07XG5cdFx0XHRjID0gdmVydGljZXNbaWNdO1xuXG5cdFx0XHRjb25zdCBmYWNlID0ge1xuXHRcdFx0XHRpbmRpY2VzOltpYSwgaWIsIGljXSxcblx0XHRcdFx0dmVydGljZXM6W2EsIGIsIGNdLFxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5fZmFjZXMucHVzaChmYWNlKTtcblx0XHR9XG5cblx0fVxuXG5cblx0Z2V0QXR0cmlidXRlKG1OYW1lKSB7XHRyZXR1cm4gdGhpcy5fYXR0cmlidXRlcy5maW5kKChhKSA9PiBhLm5hbWUgPT09IG1OYW1lKTtcdH1cblx0Z2V0U291cmNlKG1OYW1lKSB7XG5cdFx0Y29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKG1OYW1lKTtcblx0XHRyZXR1cm4gYXR0ciA/IGF0dHIuc291cmNlIDogW107XG5cdH1cblxuXG5cdC8vXHRHRVRURVIgQU5EIFNFVFRFUlNcblxuXHRnZXQgdmVydGljZXMoKSB7XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoJ2FWZXJ0ZXhQb3NpdGlvbicpO1x0fVxuXG5cdGdldCBub3JtYWxzKCkge1x0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoJ2FOb3JtYWwnKTtcdH1cblxuXHRnZXQgY29vcmRzKCkge1x0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoJ2FUZXh0dXJlQ29vcmQnKTtcdH1cblxuXHRnZXQgaW5kaWNlcygpIHtcdFx0cmV0dXJuIHRoaXMuX2luZGljZXM7XHR9XG5cblx0Z2V0IHZlcnRleFNpemUoKSB7XHRyZXR1cm4gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHR9XG5cblx0Z2V0IGZhY2VzKCkge1x0cmV0dXJuIHRoaXMuX2ZhY2VzO1x0fVxuXG5cdGdldCBhdHRyaWJ1dGVzKCkge1x0cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXM7XHR9XG5cblx0Z2V0IGhhc1ZBTygpIHtcdHJldHVybiB0aGlzLl9oYXNWQU87XHR9XG5cblx0Z2V0IHZhbygpIHtcdHJldHVybiB0aGlzLl92YW87XHR9XG5cblx0Z2V0IG51bUluc3RhbmNlKCkge1x0cmV0dXJuIHRoaXMuX251bUluc3RhbmNlO1x0fVxuXG5cdGdldCBpc0luc3RhbmNlZCgpIHsgcmV0dXJuIHRoaXMuX2lzSW5zdGFuY2VkO1x0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgR2VvbWV0cnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR2VvbWV0cnkuanMiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG4vKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xuZXhwb3J0IGNvbnN0IEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCBsZXQgQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCBjb25zdCBSQU5ET00gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG5jb25zdCBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFuKGEpIHtcbiAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L2NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEJhdGNoLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5cbmNsYXNzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcihtR2VvbWV0cnksIG1TaGFkZXIpIHtcblx0XHR0aGlzLl9nZW9tZXRyeSA9IG1HZW9tZXRyeTtcblx0XHR0aGlzLl9zaGFkZXIgPSBtU2hhZGVyO1xuXHR9XG5cblxuXHQvL1x0UFVCTElDIE1FVEhPRFNcblxuXHRkcmF3KCkge1xuXHRcdHRoaXMuX3NoYWRlci5iaW5kKCk7XG5cdFx0R0wuZHJhdyh0aGlzLl9nZW9tZXRyeSk7XG5cdH1cblxuXG5cdC8vXHRHRVRURVIgQU5EIFNFVFRFUlxuXG5cdGdldCBnZW9tZXRyeSgpIHtcdHJldHVybiB0aGlzLl9nZW9tZXRyeTtcdH1cblxuXHRnZXQgc2hhZGVyKCkge1x0cmV0dXJuIHRoaXMuX3NoYWRlcjtcdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2g7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvQmF0Y2guanMiLCIvLyBTY2hlZHVsZXIuanNcblxuXG5jbGFzcyBTY2hlZHVsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2RlbGF5VGFza3MgPSBbXTtcblx0XHR0aGlzLl9uZXh0VGFza3MgPSBbXTtcblx0XHR0aGlzLl9kZWZlclRhc2tzID0gW107XG5cdFx0dGhpcy5faGlnaFRhc2tzID0gW107XG5cdFx0dGhpcy5fdXN1cnBUYXNrID0gW107XG5cdFx0dGhpcy5fZW50ZXJmcmFtZVRhc2tzID0gW107XG5cdFx0dGhpcy5faWRUYWJsZSA9IDA7XG5cdFx0dGhpcy5mcmFtZVJhdGUgPSA2MDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuXHRcdHRoaXMuX2RlbHRhVGltZSA9IDA7XG5cblx0XHR0aGlzLl9sb29wKCk7XG5cdH1cblxuXG5cdC8vICBQVUJMSUMgTUVUSE9EU1xuXG5cdGFkZEVGKGZ1bmMsIHBhcmFtcykge1xuXHRcdHBhcmFtcyA9IHBhcmFtcyB8fCBbXTtcblx0XHRjb25zdCBpZCA9IHRoaXMuX2lkVGFibGU7XG5cdFx0dGhpcy5fZW50ZXJmcmFtZVRhc2tzW2lkXSA9IHsgZnVuYywgcGFyYW1zIH07XG5cdFx0dGhpcy5faWRUYWJsZSArKztcblx0XHRyZXR1cm4gaWQ7XG5cdH1cblxuXHRyZW1vdmVFRihpZCkge1xuXHRcdGlmICh0aGlzLl9lbnRlcmZyYW1lVGFza3NbaWRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2VudGVyZnJhbWVUYXNrc1tpZF0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHRkZWxheShmdW5jLCBwYXJhbXMsIGRlbGF5KSB7XG5cdFx0Y29uc3QgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdGNvbnN0IHQgPSB7IGZ1bmMsIHBhcmFtcywgZGVsYXksIHRpbWUgfTtcblx0XHR0aGlzLl9kZWxheVRhc2tzLnB1c2godCk7XG5cdH1cblxuXHRkZWZlcihmdW5jLCBwYXJhbXMpIHtcblx0XHRjb25zdCB0ID0geyBmdW5jLCBwYXJhbXMgfTtcblx0XHR0aGlzLl9kZWZlclRhc2tzLnB1c2godCk7XG5cdH1cblxuXHRuZXh0KGZ1bmMsIHBhcmFtcykge1xuXHRcdGNvbnN0IHQgPSB7IGZ1bmMsIHBhcmFtcyB9O1xuXHRcdHRoaXMuX25leHRUYXNrcy5wdXNoKHQpO1xuXHR9XG5cblx0dXN1cnAoZnVuYywgcGFyYW1zKSB7XG5cdFx0Y29uc3QgdCA9IHsgZnVuYywgcGFyYW1zIH07XG5cdFx0dGhpcy5fdXN1cnBUYXNrLnB1c2godCk7XG5cdH1cblxuXG5cdC8vICBQUklWQVRFIE1FVEhPRFNcblxuXHRfcHJvY2VzcygpIHtcblx0XHRsZXQgaSA9IDA7XG5cdFx0bGV0IHRhc2s7XG5cdFx0bGV0IGludGVydmFsO1xuXHRcdGxldCBjdXJyZW50O1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9lbnRlcmZyYW1lVGFza3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9lbnRlcmZyYW1lVGFza3NbaV07XG5cdFx0XHRpZiAodGFzayAhPT0gbnVsbCAmJiB0YXNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAodGhpcy5faGlnaFRhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9oaWdoVGFza3MucG9wKCk7XG5cdFx0XHR0YXNrLmZ1bmModGFzay5wYXJhbXMpO1xuXHRcdH1cblxuXG5cdFx0bGV0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdHRoaXMuX2RlbHRhVGltZSA9IChzdGFydFRpbWUgLSB0aGlzLl9zdGFydFRpbWUpLzEwMDA7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fZGVsYXlUYXNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGFzayA9IHRoaXMuX2RlbGF5VGFza3NbaV07XG5cdFx0XHRpZiAoc3RhcnRUaW1lIC0gdGFzay50aW1lID4gdGFzay5kZWxheSkge1xuXHRcdFx0XHR0YXNrLmZ1bmModGFzay5wYXJhbXMpO1xuXHRcdFx0XHR0aGlzLl9kZWxheVRhc2tzLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHR0aGlzLl9kZWx0YVRpbWUgPSAoc3RhcnRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lKS8xMDAwO1xuXHRcdGludGVydmFsID0gMTAwMCAvIHRoaXMuZnJhbWVSYXRlO1xuXHRcdHdoaWxlICh0aGlzLl9kZWZlclRhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9kZWZlclRhc2tzLnNoaWZ0KCk7XG5cdFx0XHRjdXJyZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHRpZiAoY3VycmVudCAtIHN0YXJ0VGltZSA8IGludGVydmFsKSB7XG5cdFx0XHRcdHRhc2suZnVuYyh0YXNrLnBhcmFtcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9kZWZlclRhc2tzLnVuc2hpZnQodGFzayk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0c3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0dGhpcy5fZGVsdGFUaW1lID0gKHN0YXJ0VGltZSAtIHRoaXMuX3N0YXJ0VGltZSkvMTAwMDtcblx0XHRpbnRlcnZhbCA9IDEwMDAgLyB0aGlzLmZyYW1lUmF0ZTtcblx0XHR3aGlsZSAodGhpcy5fdXN1cnBUYXNrLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl91c3VycFRhc2suc2hpZnQoKTtcblx0XHRcdGN1cnJlbnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdGlmIChjdXJyZW50IC0gc3RhcnRUaW1lIDwgaW50ZXJ2YWwpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9oaWdoVGFza3MgPSB0aGlzLl9oaWdoVGFza3MuY29uY2F0KHRoaXMuX25leHRUYXNrcyk7XG5cdFx0dGhpcy5fbmV4dFRhc2tzID0gW107XG5cdFx0dGhpcy5fdXN1cnBUYXNrID0gW107XG5cdH1cblxuXG5cdF9sb29wKCkge1xuXHRcdHRoaXMuX3Byb2Nlc3MoKTtcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuX2xvb3AoKSk7XG5cdH1cblxuXHRnZXQgZGVsdGFUaW1lKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWx0YVRpbWU7XG5cdH1cbn1cblxuY29uc3Qgc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcigpO1xuXG5leHBvcnQgZGVmYXVsdCBzY2hlZHVsZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY2hlZHVsaW5nL3NyYy9zY2hlZHVsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHZW9tLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4vR2VvbWV0cnknO1xuXG5jb25zdCBHZW9tID0ge307XG5sZXQgbWVzaFRyaTtcblxuR2VvbS5wbGFuZSA9IGZ1bmN0aW9uIHBsYW5lKHdpZHRoLCBoZWlnaHQsIG51bVNlZ21lbnRzLCBheGlzID0gJ3h5JywgZHJhd1R5cGUgPSA0KSB7XG5cdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRjb25zdCBjb29yZHMgICAgPSBbXTtcblx0Y29uc3QgaW5kaWNlcyAgID0gW107XG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdO1xuXG5cdGNvbnN0IGdhcFggID0gd2lkdGggLyBudW1TZWdtZW50cztcblx0Y29uc3QgZ2FwWSAgPSBoZWlnaHQgLyBudW1TZWdtZW50cztcblx0Y29uc3QgZ2FwVVYgPSAxIC8gbnVtU2VnbWVudHM7XG5cdGNvbnN0IHN4ICAgID0gLXdpZHRoICogMC41O1xuXHRjb25zdCBzeSAgICA9IC1oZWlnaHQgKiAwLjU7XG5cdGxldCBpbmRleCA9IDA7XG5cblx0Zm9yKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG51bVNlZ21lbnRzOyBqKyspIHtcblx0XHRcdGNvbnN0IHR4ID0gZ2FwWCAqIGkgKyBzeDtcblx0XHRcdGNvbnN0IHR5ID0gZ2FwWSAqIGogKyBzeTtcblxuXHRcdFx0Y29uc3QgdSA9IGkgLyBudW1TZWdtZW50cztcblx0XHRcdGNvbnN0IHYgPSBqIC8gbnVtU2VnbWVudHM7XG5cblx0XHRcdGlmKGF4aXMgPT09ICd4eicpIHtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4LCBcdFx0MCwgXHQgdHkgKyBnYXBZXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCArIGdhcFgsIFx0MCwgXHQgdHkgKyBnYXBZXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCArIGdhcFgsIFx0MCwgXHQgdHldKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4LCBcdFx0MCwgXHQgdHldKTtcdFxuXG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1LCAxLjAgLSAodiArIGdhcFVWKV0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCAxLjAgLSAodiArIGdhcFVWKV0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCAxLjAgLSB2XSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1LCAxLjAgLSB2XSk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdFx0XHR9IGVsc2UgaWYoYXhpcyA9PT0gJ3l6Jykge1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbMCwgdHksIHR4XSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFswLCB0eSwgdHggKyBnYXBYXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFswLCB0eSArIGdhcFksIHR4ICsgZ2FwWF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbMCwgdHkgKyBnYXBZLCB0eF0pO1x0XG5cblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIHZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UgKyBnYXBVViwgdl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCB2ICsgZ2FwVVZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIHYgKyBnYXBVVl0pO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4LCBcdFx0dHksIFx0MF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHggKyBnYXBYLCBcdHR5LCBcdDBdKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4ICsgZ2FwWCwgXHR0eSArIGdhcFksIFx0MF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHgsIFx0XHR0eSArIGdhcFksIFx0MF0pO1x0XG5cblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIHZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UgKyBnYXBVViwgdl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCB2ICsgZ2FwVVZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIHYgKyBnYXBVVl0pO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRcdFx0fSBcblxuXG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMSk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMyk7XG5cblx0XHRcdGluZGV4Kys7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgbWVzaCA9IG5ldyBHZW9tZXRyeShkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLnNwaGVyZSA9IGZ1bmN0aW9uIHNwaGVyZShzaXplLCBudW1TZWdtZW50cywgaXNJbnZlcnQgPSBmYWxzZSwgZHJhd1R5cGUgPSA0KSB7XG5cdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRjb25zdCBjb29yZHMgICAgPSBbXTtcblx0Y29uc3QgaW5kaWNlcyAgID0gW107XG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdO1xuXHRjb25zdCBnYXBVViAgICAgPSAxIC8gbnVtU2VnbWVudHM7XG5cdGxldCBpbmRleCAgICAgXHQ9IDA7XG5cdFxuXG5cdGZ1bmN0aW9uIGdldFBvc2l0aW9uKGksIGosIGlzTm9ybWFsID0gZmFsc2UpIHtcdC8vXHRyeCA6IC05MCB+IDkwICwgcnkgOiAwIH4gMzYwXG5cdFx0Y29uc3QgcnggICAgICAgID0gaSAvIG51bVNlZ21lbnRzICogTWF0aC5QSSAtIE1hdGguUEkgKiAwLjU7XG5cdFx0Y29uc3QgcnkgICAgICAgID0gaiAvIG51bVNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0Y29uc3QgciAgICAgICAgID0gaXNOb3JtYWwgPyAxIDogc2l6ZTtcblx0XHRjb25zdCBwb3MgICAgICAgPSBbXTtcblx0XHRwb3NbMV0gICAgICAgIFx0PSBNYXRoLnNpbihyeCkgKiByO1xuXHRcdGNvbnN0IHQgICAgICAgICA9IE1hdGguY29zKHJ4KSAqIHI7XG5cdFx0cG9zWzBdICAgICAgICBcdD0gTWF0aC5jb3MocnkpICogdDtcblx0XHRwb3NbMl0gICAgICAgIFx0PSBNYXRoLnNpbihyeSkgKiB0O1xuXHRcdFxuXHRcdGNvbnN0IHByZWNpc2lvbiA9IDEwMDAwO1xuXHRcdHBvc1swXSAgICAgICAgPSBNYXRoLmZsb29yKHBvc1swXSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG5cdFx0cG9zWzFdICAgICAgICA9IE1hdGguZmxvb3IocG9zWzFdICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblx0XHRwb3NbMl0gICAgICAgID0gTWF0aC5mbG9vcihwb3NbMl0gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXG5cdFx0cmV0dXJuIHBvcztcblx0fTtcblxuXHRcblx0Zm9yKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRmb3IobGV0IGogPSAwOyBqIDwgbnVtU2VnbWVudHM7IGorKykge1xuXHRcdFx0cG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSwgaikpO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSArIDEsIGopKTtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGkgKyAxLCBqICsgMSkpO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSwgaiArIDEpKTtcblxuXHRcdFx0bm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGksIGosIHRydWUpKTtcblx0XHRcdG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpICsgMSwgaiwgdHJ1ZSkpO1xuXHRcdFx0bm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGkgKyAxLCBqICsgMSwgdHJ1ZSkpO1xuXHRcdFx0bm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGksIGogKyAxLCB0cnVlKSk7XG5cdFx0XHRcblxuXHRcdFx0Y29uc3QgdSA9IGogLyBudW1TZWdtZW50cztcblx0XHRcdGNvbnN0IHYgPSBpIC8gbnVtU2VnbWVudHM7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Y29vcmRzLnB1c2goWzEuMCAtIHUsIHZdKTtcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1LCB2ICsgZ2FwVVZdKTtcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1IC0gZ2FwVVYsIHYgKyBnYXBVVl0pO1xuXHRcdFx0Y29vcmRzLnB1c2goWzEuMCAtIHUgLSBnYXBVViwgdl0pO1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMSk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMyk7XG5cblx0XHRcdGluZGV4Kys7XG5cdFx0fVxuXHR9XG5cblxuXHRpZihpc0ludmVydCkge1xuXHRcdGluZGljZXMucmV2ZXJzZSgpO1xuXHR9XG5cblx0Y29uc3QgbWVzaCA9IG5ldyBHZW9tZXRyeShkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLmN1YmUgPSBmdW5jdGlvbiBjdWJlKHcsIGgsIGQsIGRyYXdUeXBlID0gNCkge1xuXHRoID0gaCB8fCB3O1xuXHRkID0gZCB8fCB3O1xuXG5cdGNvbnN0IHggPSB3IC8gMjtcblx0Y29uc3QgeSA9IGggLyAyO1xuXHRjb25zdCB6ID0gZCAvIDI7XG5cblx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRjb25zdCBpbmRpY2VzICAgPSBbXTsgXG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdOyBcblx0bGV0IGNvdW50ICAgICA9IDA7XG5cblxuXHQvLyBCQUNLXG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAgeSwgLXpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsIC15LCAtel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gUklHSFRcblx0cG9zaXRpb25zLnB1c2goW3gsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAtel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBGUk9OVFxuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgIHpdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblxuXHQvLyBMRUZUXG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBUT1Bcblx0cG9zaXRpb25zLnB1c2goW3gsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsICB5LCAgel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIEJPVFRPTVxuXHRwb3NpdGlvbnMucHVzaChbeCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgLXpdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cblx0Y29uc3QgbWVzaCA9IG5ldyBHZW9tZXRyeShkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLnNreWJveCA9IGZ1bmN0aW9uIHNreWJveChzaXplLCBkcmF3VHlwZSA9IDQpIHtcblx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRjb25zdCBpbmRpY2VzICAgPSBbXTsgXG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdOyBcblx0bGV0IGNvdW50ICAgICA9IDA7XG5cblx0Ly8gQkFDS1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgIHNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgLXNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgLXNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIFJJR0hUXG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgLXNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gRlJPTlRcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsICBzaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIExFRlRcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgIHNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIFRPUFxuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgIHNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgLXNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gQk9UVE9NXG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAgc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y29uc3QgbWVzaCA9IG5ldyBHZW9tZXRyeShkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLmJpZ1RyaWFuZ2xlID0gZnVuY3Rpb24gYmlnVHJpYW5nbGUoKSB7XG5cblx0aWYoIW1lc2hUcmkpIHtcblx0XHRjb25zdCBpbmRpY2VzID0gWzIsIDEsIDBdO1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtcblx0XHRcdFstMSwgLTFdLCBcblx0XHRcdFstMSwgNF0sIFxuXHRcdFx0WzQsIC0xXVxuXHRcdF07XG5cdFx0XG5cdFx0bWVzaFRyaSA9IG5ldyBHZW9tZXRyeSgpO1xuXHRcdG1lc2hUcmkuYnVmZmVyRGF0YShwb3NpdGlvbnMsICdhUG9zaXRpb24nLCAyKTtcblx0XHRtZXNoVHJpLmJ1ZmZlckluZGV4KGluZGljZXMpO1x0XG5cdH1cblx0XG5cblx0cmV0dXJuIG1lc2hUcmk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHZW9tO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL0dlb20uanMiLCIvLyBPYmplY3QzRC5qc1xuXG5pbXBvcnQgeyB2ZWMzLCBtYXQ0LCBxdWF0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY2xhc3MgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5feCA9IDA7XG5cdFx0dGhpcy5feSA9IDA7XG5cdFx0dGhpcy5feiA9IDA7XG5cblx0XHR0aGlzLl9zeCA9IDE7XG5cdFx0dGhpcy5fc3kgPSAxO1xuXHRcdHRoaXMuX3N6ID0gMTtcblxuXHRcdHRoaXMuX3J4ID0gMDtcblx0XHR0aGlzLl9yeSA9IDA7XG5cdFx0dGhpcy5fcnogPSAwO1xuXG5cdFx0dGhpcy5fcG9zaXRpb24gPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3NjYWxlID0gdmVjMy5mcm9tVmFsdWVzKDEsIDEsIDEpO1xuXHRcdHRoaXMuX3JvdGF0aW9uID0gdmVjMy5jcmVhdGUoKTtcblxuXHRcdHRoaXMuX21hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fbWF0cml4UGFyZW50ID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhSb3RhdGlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fbWF0cml4U2NhbGUgPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhRdWF0ZXJuaW9uID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9xdWF0ID0gcXVhdC5jcmVhdGUoKTtcblxuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdH1cblxuXHR1cGRhdGVNYXRyaXgoKSB7XG5cdFx0aWYoIXRoaXMuX25lZWRVcGRhdGUpIHtcdHJldHVybjsgfVxuXG5cdFx0dmVjMy5zZXQodGhpcy5fc2NhbGUsIHRoaXMuX3N4LCB0aGlzLl9zeSwgdGhpcy5fc3opO1xuXHRcdHZlYzMuc2V0KHRoaXMuX3JvdGF0aW9uLCB0aGlzLl9yeCwgdGhpcy5fcnksIHRoaXMuX3J6KTtcblx0XHR2ZWMzLnNldCh0aGlzLl9wb3NpdGlvbiwgdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feik7XG5cblx0XHRtYXQ0LmlkZW50aXR5KHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uLCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbik7XG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLl9tYXRyaXhTY2FsZSwgdGhpcy5fbWF0cml4U2NhbGUpO1xuXHRcdG1hdDQuaWRlbnRpdHkodGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uKTtcblxuXHRcdG1hdDQucm90YXRlWCh0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX3J4KTtcblx0XHRtYXQ0LnJvdGF0ZVkodGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9yeSk7XG5cdFx0bWF0NC5yb3RhdGVaKHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fcnopO1xuXG5cblx0XHRtYXQ0LmZyb21RdWF0KHRoaXMuX21hdHJpeFF1YXRlcm5pb24sIHRoaXMuX3F1YXQpO1xuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhRdWF0ZXJuaW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbik7XG5cblx0XHRtYXQ0LnNjYWxlKHRoaXMuX21hdHJpeFNjYWxlLCB0aGlzLl9tYXRyaXhTY2FsZSwgdGhpcy5fc2NhbGUpO1xuXHRcdG1hdDQudHJhbnNsYXRlKHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uLCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fcG9zaXRpb24pO1xuXG5cdFx0bWF0NC5tdWwodGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24pO1xuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeCwgdGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhTY2FsZSk7XG5cdFx0bWF0NC5tdWwodGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhQYXJlbnQsIHRoaXMuX21hdHJpeCk7XG5cblx0XHR0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdGNoaWxkLnVwZGF0ZVBhcmVudE1hdHJpeCh0aGlzLl9tYXRyaXgpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR9XG5cblx0dXBkYXRlUGFyZW50TWF0cml4KG1QYXJlbnRNYXRyaXgpIHtcblx0XHRtUGFyZW50TWF0cml4ID0gbVBhcmVudE1hdHJpeCB8fCBtYXQ0LmNyZWF0ZSgpO1xuXHRcdG1hdDQuY29weSh0aGlzLl9tYXRyaXhQYXJlbnQsIG1QYXJlbnRNYXRyaXgpO1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHR9XG5cblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbihtUXVhdCkge1xuXHRcdHF1YXQuY29weSh0aGlzLl9xdWF0LCBtUXVhdCk7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdH1cblxuXG5cdGFkZENoaWxkKG1DaGlsZCkge1xuXHRcdHRoaXMuX2NoaWxkcmVuLnB1c2gobUNoaWxkKTtcblx0fVxuXG5cdHJlbW92ZUNoaWxkKG1DaGlsZCkge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihtQ2hpbGQpO1xuXHRcdGlmKGluZGV4ID09IC0xKSB7XHRjb25zb2xlLndhcm4oJ0NoaWxkIG5vIGV4aXN0Jyk7IHJldHVybjtcdH1cblxuXHRcdHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXG5cdGdldCBtYXRyaXgoKSB7XG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9XG5cblx0Z2V0IHgoKSB7XHRyZXR1cm4gdGhpcy5feDtcdH1cblx0c2V0IHgobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5feCA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCB5KCkge1x0cmV0dXJuIHRoaXMuX3k7XHR9XG5cdHNldCB5KG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3kgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgeigpIHtcdHJldHVybiB0aGlzLl96O1x0fVxuXHRzZXQgeihtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl96ID0gbVZhbHVlO1xuXHR9XG5cblx0XG5cdGdldCBzY2FsZVgoKSB7XHRyZXR1cm4gdGhpcy5fc3g7XHR9XG5cdHNldCBzY2FsZVgobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fc3ggPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgc2NhbGVZKCkge1x0cmV0dXJuIHRoaXMuX3N5O1x0fVxuXHRzZXQgc2NhbGVZKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3N5ID0gbVZhbHVlO1xuXHR9XG5cblx0Z2V0IHNjYWxlWigpIHtcdHJldHVybiB0aGlzLl9zejtcdH1cblx0c2V0IHNjYWxlWihtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9zeiA9IG1WYWx1ZTtcblx0fVxuXG5cblx0Z2V0IHJvdGF0aW9uWCgpIHtcdHJldHVybiB0aGlzLl9yeDtcdH1cblx0c2V0IHJvdGF0aW9uWChtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9yeCA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCByb3RhdGlvblkoKSB7XHRyZXR1cm4gdGhpcy5fcnk7XHR9XG5cdHNldCByb3RhdGlvblkobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fcnkgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgcm90YXRpb25aKCkge1x0cmV0dXJuIHRoaXMuX3J6O1x0fVxuXHRzZXQgcm90YXRpb25aKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3J6ID0gbVZhbHVlO1xuXHR9XG5cblxuXHRnZXQgY2hpbGRyZW4oKSB7XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QzRDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9vYmplY3RzL09iamVjdDNELmpzIiwiLy8gR0xUZXh0dXJlLmpzXG5cbmltcG9ydCBnZXRUZXh0dXJlUGFyYW1ldGVycyBmcm9tICcuL3V0aWxzL2dldFRleHR1cmVQYXJhbWV0ZXJzJztcbmltcG9ydCBXZWJnbE51bWJlciBmcm9tICcuL3V0aWxzL1dlYmdsTnVtYmVyJztcbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJ3NjaGVkdWxpbmcnO1xuXG5sZXQgZ2w7XG5cbmNsYXNzIEdMVGV4dHVyZSB7XG5cblx0Y29uc3RydWN0b3IobVNvdXJjZSwgbVBhcmFtID0ge30sIG1XaWR0aCA9IDAsIG1IZWlnaHQgPSAwKSB7XG5cdFx0Z2wgPSBHTC5nbDtcblxuXHRcdHRoaXMuX3NvdXJjZSA9IG1Tb3VyY2U7XG5cdFx0dGhpcy5fZ2V0RGltZW5zaW9uKG1Tb3VyY2UsIG1XaWR0aCwgbUhlaWdodCk7XG5cdFx0dGhpcy5fc291cmNlVHlwZSA9IG1QYXJhbS50eXBlIHx8IGdldFNvdXJjZVR5cGUobVNvdXJjZSk7XG5cdFx0dGhpcy5fY2hlY2tTb3VyY2UoKTtcblx0XHR0aGlzLl90ZXhlbFR5cGUgPSB0aGlzLl9nZXRUZXhlbFR5cGUoKTtcblx0XHR0aGlzLl9pc1RleHR1cmVSZWFkeSA9IHRydWU7XG5cblx0XHR0aGlzLl9wYXJhbXMgPSBnZXRUZXh0dXJlUGFyYW1ldGVycyhtUGFyYW0sIG1Tb3VyY2UsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuXHRcdHRoaXMuX2NoZWNrTWlwbWFwKCk7XG5cdFx0dGhpcy5fY2hlY2tXcmFwcGluZygpO1xuXG5cdFx0Ly9cdHNldHVwIHRleHR1cmVcblx0XHR0aGlzLl90ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0aWYodGhpcy5fc291cmNlVHlwZSA9PT0gJ3ZpZGVvJykge1xuXHRcdFx0dGhpcy5faXNUZXh0dXJlUmVhZHkgPSBmYWxzZTtcblx0XHRcdFNjaGVkdWxlci5hZGRFRigoKT0+dGhpcy5fbG9vcCgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fdXBsb2FkVGV4dHVyZSgpO1x0XG5cdFx0fVxuXHRcdFxuXHR9XG5cblx0X2xvb3AoKSB7XG5cdFx0aWYodGhpcy5fc291cmNlLnJlYWR5U3RhdGUgPT0gNCkge1xuXHRcdFx0dGhpcy5faXNUZXh0dXJlUmVhZHkgPSB0cnVlO1xuXHRcdFx0dGhpcy5fdXBsb2FkVGV4dHVyZSgpO1xuXHRcdH1cblx0fVxuXG5cblx0X3VwbG9hZFRleHR1cmUoKSB7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cblx0XHRpZih0aGlzLl9pc1NvdXJjZUh0bWxFbGVtZW50KCkpIHtcblx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5fcGFyYW1zLmludGVybmFsRm9ybWF0LCB0aGlzLl9wYXJhbXMuZm9ybWF0LCB0aGlzLl90ZXhlbFR5cGUsIHRoaXMuX3NvdXJjZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5fcGFyYW1zLmludGVybmFsRm9ybWF0LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCAwLCB0aGlzLl9wYXJhbXMuZm9ybWF0LCB0aGlzLl90ZXhlbFR5cGUsIHRoaXMuX3NvdXJjZSk7XHRcblx0XHR9XG5cdFx0XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuX3BhcmFtcy5tYWdGaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9wYXJhbXMubWluRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9wYXJhbXMud3JhcFMpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX3BhcmFtcy53cmFwVCk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLl9wYXJhbXMucHJlbXVsdGlwbHlBbHBoYSk7XG5cblx0XHRpZih0aGlzLl9wYXJhbXMuYW5pc290cm9weSA+IDApIHtcblx0XHRcdGNvbnN0IGV4dCA9IEdMLmdldEV4dGVuc2lvbignRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyk7XG5cdFx0XHRpZihleHQpIHtcblx0XHRcdFx0Y29uc3QgbWF4ID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpO1xuXHRcdFx0XHRjb25zdCBsZXZlbCA9IE1hdGgubWluKG1heCwgdGhpcy5fcGFyYW1zLmFuaXNvdHJvcHkpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJmKGdsLlRFWFRVUkVfMkQsIGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgbGV2ZWwpO1xuXHRcdFx0fVx0XG5cdFx0fVxuXHRcdFxuXG5cdFx0aWYodGhpcy5fZ2VuZXJhdGVNaXBtYXApIHtcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1x0fVxuXG5cdFx0Ly9cdHVuYmluZCB0ZXh0dXJlXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXG5cdGJpbmQoaW5kZXgpIHtcblx0XHRpZihpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMDsgfVxuXHRcdGlmKCFHTC5zaGFkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaW5kZXgpO1xuXHRcdGlmKHRoaXMuX2lzVGV4dHVyZVJlYWR5KSB7XG5cdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBHTFRleHR1cmUuYmxhY2tUZXh0dXJlKCkudGV4dHVyZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuX2JpbmRJbmRleCA9IGluZGV4O1xuXHR9XG5cblxuXHR1cGRhdGVUZXh0dXJlKG1Tb3VyY2UpIHtcblx0XHR0aGlzLl9zb3VyY2UgPSBtU291cmNlO1xuXHRcdHRoaXMuX2NoZWNrU291cmNlKCk7XG5cdFx0dGhpcy5fdXBsb2FkVGV4dHVyZSgpO1xuXHR9XG5cblxuXHRnZW5lcmF0ZU1pcG1hcCgpIHtcblx0XHRpZiAoIXRoaXMuX2dlbmVyYXRlTWlwbWFwKSB7IHJldHVybjsgfVxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblx0c2hvd1BhcmFtZXRlcnMoKSB7XG5cdFx0Y29uc29sZS5sb2coJ1NvdXJjZSB0eXBlIDogJywgV2ViZ2xOdW1iZXJbdGhpcy5fc291cmNlVHlwZV0gfHwgdGhpcy5fc291cmNlVHlwZSk7XG5cdFx0Y29uc29sZS5sb2coJ1RleGVsIHR5cGU6JywgV2ViZ2xOdW1iZXJbdGhpcy50ZXhlbFR5cGVdKTtcblx0XHRjb25zb2xlLmxvZygnRGltZW5zaW9uIDonLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcblx0XHRmb3IoY29uc3QgcyBpbiB0aGlzLl9wYXJhbXMpIHtcblx0XHRcdGNvbnNvbGUubG9nKHMsIFdlYmdsTnVtYmVyW3RoaXMuX3BhcmFtc1tzXV0gfHwgdGhpcy5fcGFyYW1zW3NdKTtcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygnTWlwbWFwcGluZyA6JywgdGhpcy5fZ2VuZXJhdGVNaXBtYXApO1xuXHR9XG5cblx0X2dldERpbWVuc2lvbihtU291cmNlLCBtV2lkdGgsIG1IZWlnaHQpIHtcblx0XHRpZihtU291cmNlKSB7XG5cdFx0XHQvL1x0Zm9yIGh0bWwgaW1hZ2UgLyB2aWRlbyBlbGVtZW50XG5cdFx0XHR0aGlzLl93aWR0aCA9IG1Tb3VyY2Uud2lkdGggfHwgbVNvdXJjZS52aWRlb1dpZHRoO1xuXHRcdFx0dGhpcy5faGVpZ2h0ID0gbVNvdXJjZS5oZWlnaHQgfHwgbVNvdXJjZS52aWRlb1dpZHRoO1xuXG5cdFx0XHQvL1x0Zm9yIG1hbnVhbCB3aWR0aCAvIGhlaWdodCBzZXR0aW5nc1xuXHRcdFx0dGhpcy5fd2lkdGggPSB0aGlzLl93aWR0aCB8fCBtV2lkdGg7XG5cdFx0XHR0aGlzLl9oZWlnaHQgPSB0aGlzLl9oZWlnaHQgfHwgbUhlaWdodDtcblxuXHRcdFx0Ly9cdGF1dG8gZGV0ZWN0ICggZGF0YSBhcnJheSkgPyBub3Qgc3VyZSBpcyBnb29kIGlkZWEgPyBcblx0XHRcdC8vXHR0b2RvIDogY2hlY2sgSERSIFxuXHRcdFx0aWYoIXRoaXMuX3dpZHRoIHx8ICF0aGlzLl9oZWlnaHQpIHtcblx0XHRcdFx0dGhpcy5fd2lkdGggPSB0aGlzLl9oZWlnaHQgPSBNYXRoLnNxcnQobVNvdXJjZS5sZW5ndGggLyA0KTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ0F1dG8gZGV0ZWN0LCBkYXRhIGRpbWVuc2lvbiA6ICcsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1x0XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fd2lkdGggPSBtV2lkdGg7XG5cdFx0XHR0aGlzLl9oZWlnaHQgPSBtSGVpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdF9jaGVja1NvdXJjZSgpIHtcblx0XHRpZighdGhpcy5fc291cmNlKSB7XHRyZXR1cm47IH1cblxuXHRcdGlmKHRoaXMuX3NvdXJjZVR5cGUgPT09IEdMLlVOU0lHTkVEX0JZVEUpIHtcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdDb252ZXJ0aW5nIHRvIFVpbnQ4QXJyYXknKTtcblx0XHRcdFx0dGhpcy5fc291cmNlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fc291cmNlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYodGhpcy5fc291cmNlVHlwZSA9PT0gR0wuRkxPQVQpIHtcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ0NvbnZlcnRpbmcgdG8gRmxvYXQzMkFycmF5Jyk7XG5cdFx0XHRcdHRoaXMuX3NvdXJjZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdF9nZXRUZXhlbFR5cGUoKSB7XG5cdFx0aWYodGhpcy5faXNTb3VyY2VIdG1sRWxlbWVudCgpKSB7XG5cdFx0XHRyZXR1cm4gR0wuVU5TSUdORURfQllURTtcdFxuXHRcdH1cblxuXHRcdC8vXHRiYWQgY29kZSBoZXJlLCBpZiB0aGUgdHlwZSBpcyBub3Qgb24gdGhlIHdlYmdsTnVtYmVyIGxpc3QsIGl0IGRvZXNuJ3Qgd29ya1xuXHRcdHJldHVybiBHTFtXZWJnbE51bWJlclt0aGlzLl9zb3VyY2VUeXBlXV0gfHwgdGhpcy5fc291cmNlVHlwZTtcblx0fVxuXG5cdF9jaGVja01pcG1hcCgpIHtcblx0XHR0aGlzLl9nZW5lcmF0ZU1pcG1hcCA9IHRoaXMuX3BhcmFtcy5taXBtYXA7XG5cblx0XHRpZighKGlzUG93ZXJPZlR3byh0aGlzLl93aWR0aCkgJiYgaXNQb3dlck9mVHdvKHRoaXMuX2hlaWdodCkpKSB7XG5cdFx0XHR0aGlzLl9nZW5lcmF0ZU1pcG1hcCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1pbkZpbHRlciA9IFdlYmdsTnVtYmVyW3RoaXMuX3BhcmFtcy5taW5GaWx0ZXJdO1xuXHRcdGlmKG1pbkZpbHRlci5pbmRleE9mKCdNSVBNQVAnKSA9PSAtMSkge1xuXHRcdFx0dGhpcy5fZ2VuZXJhdGVNaXBtYXAgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRfY2hlY2tXcmFwcGluZygpIHtcblx0XHRpZighdGhpcy5fZ2VuZXJhdGVNaXBtYXApIHtcblx0XHRcdHRoaXMuX3BhcmFtcy53cmFwUyA9IEdMLkNMQU1QX1RPX0VER0U7XG5cdFx0XHR0aGlzLl9wYXJhbXMud3JhcFQgPSBHTC5DTEFNUF9UT19FREdFO1xuXHRcdH1cblx0fVxuXG5cdF9pc1NvdXJjZUh0bWxFbGVtZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3VyY2VUeXBlID09PSAnaW1hZ2UnIHx8IHRoaXMuX3NvdXJjZVR5cGUgPT09ICd2aWRlbycgfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gJ2NhbnZhcyc7XG5cdH1cblxuXG5cdGdldCBtaW5GaWx0ZXIoKSB7XHRyZXR1cm4gdGhpcy5fcGFyYW1zLm1pbkZpbHRlcjtcdH1cblxuXHRzZXQgbWluRmlsdGVyKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3BhcmFtcy5taW5GaWx0ZXIgPSBtVmFsdWU7XG5cdFx0dGhpcy5fY2hlY2tNaXBtYXAoKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9wYXJhbXMubWluRmlsdGVyKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXAoKTtcblx0fVxuXG5cdGdldCBtYWdGaWx0ZXIoKSB7XHRyZXR1cm4gdGhpcy5fcGFyYW1zLm1pbkZpbHRlcjtcdH1cblxuXHRzZXQgbWFnRmlsdGVyKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3BhcmFtcy5tYWdGaWx0ZXIgPSBtVmFsdWU7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fcGFyYW1zLm1hZ0ZpbHRlcik7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXG5cdGdldCB3cmFwUygpIHtcdHJldHVybiB0aGlzLl9wYXJhbXMud3JhcFM7XHR9XG5cblx0c2V0IHdyYXBTKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3BhcmFtcy53cmFwUyA9IG1WYWx1ZTtcblx0XHR0aGlzLl9jaGVja1dyYXBwaW5nKCk7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9wYXJhbXMud3JhcFMpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblxuXHRnZXQgd3JhcFQoKSB7XHRyZXR1cm4gdGhpcy5fcGFyYW1zLndyYXBUO1x0fVxuXG5cdHNldCB3cmFwVChtVmFsdWUpIHtcblx0XHR0aGlzLl9wYXJhbXMud3JhcFQgPSBtVmFsdWU7XG5cdFx0dGhpcy5fY2hlY2tXcmFwcGluZygpO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fcGFyYW1zLndyYXBUKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cdGdldCB0ZXhlbFR5cGUoKSB7XHRyZXR1cm4gdGhpcy5fdGV4ZWxUeXBlO1x0fVxuXG5cdGdldCB3aWR0aCgpIHtcdHJldHVybiB0aGlzLl93aWR0aDtcdH1cblxuXHRnZXQgaGVpZ2h0KCkge1x0cmV0dXJuIHRoaXMuX2hlaWdodDtcdH1cblxuXHRnZXQgdGV4dHVyZSgpIHtcdHJldHVybiB0aGlzLl90ZXh0dXJlO1x0fVxuXG5cdGdldCBpc1RleHR1cmVSZWFkeSgpIHtcdHJldHVybiB0aGlzLl9pc1RleHR1cmVSZWFkeTtcdH1cblxufVxuXG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byh4KSB7XHRcblx0cmV0dXJuICh4ICE9PSAwKSAmJiAoISh4ICYgKHggLSAxKSkpO1xufTtcblxuZnVuY3Rpb24gZ2V0U291cmNlVHlwZShtU291cmNlKSB7XG5cdC8vXHRwb3NzaWJsZSBzb3VyY2UgdHlwZSA6IEltYWdlIC8gVmlkZW8gLyBVbml0OEFycmF5IC8gRmxvYXQzMkFycmF5XG5cdC8vXHR0aGlzIGxpc3QgbXVzdCBiZSBmbGV4aWJsZVxuXG5cdGxldCB0eXBlID0gR0wuVU5TSUdORURfQllURTtcblxuXHRpZihtU291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHR0eXBlID0gR0wuVU5TSUdORURfQllURTtcblx0fSBlbHNlIGlmKG1Tb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdFx0dHlwZSA9IEdMLlVOU0lHTkVEX0JZVEU7XG5cdH0gZWxzZSBpZihtU291cmNlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG5cdFx0dHlwZSA9IEdMLkZMT0FUO1xuXHR9IGVsc2UgaWYobVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHR0eXBlID0gJ2ltYWdlJztcblx0fSBlbHNlIGlmKG1Tb3VyY2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuXHRcdHR5cGUgPSAnY2FudmFzJztcblx0fSBlbHNlIGlmKG1Tb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG5cdFx0dHlwZSA9ICd2aWRlbyc7XG5cdH1cblx0cmV0dXJuIHR5cGU7XG59XG5cbmxldCBfd2hpdGVUZXh0dXJlLCBfZ3JleVRleHR1cmUsIF9ibGFja1RleHR1cmU7XG5cbkdMVGV4dHVyZS53aGl0ZVRleHR1cmUgPSBmdW5jdGlvbiB3aGl0ZVRleHR1cmUoKSB7XG5cdGlmKF93aGl0ZVRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAyO1xuXHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSAnI2ZmZic7XG5cdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDIsIDIpO1xuXHRcdF93aGl0ZVRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGNhbnZhcyk7XG5cdH1cblx0XG5cdHJldHVybiBfd2hpdGVUZXh0dXJlO1xufTtcblxuR0xUZXh0dXJlLmdyZXlUZXh0dXJlID0gZnVuY3Rpb24gZ3JleVRleHR1cmUoKSB7XG5cdGlmKF9ncmV5VGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDI7XG5cdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9ICdyZ2IoMTI3LCAxMjcsIDEyNyknO1xuXHRcdGN0eC5maWxsUmVjdCgwLCAwLCAyLCAyKTtcblx0XHRfZ3JleVRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGNhbnZhcyk7XG5cdH1cblx0cmV0dXJuIF9ncmV5VGV4dHVyZTtcbn07XG5cbkdMVGV4dHVyZS5ibGFja1RleHR1cmUgPSBmdW5jdGlvbiBibGFja1RleHR1cmUoKSB7XG5cdGlmKF9ibGFja1RleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAyO1xuXHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSAncmdiKDAsIDAsIDApJztcblx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMiwgMik7XG5cdFx0X2JsYWNrVGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY2FudmFzKTtcblx0fVxuXHRyZXR1cm4gX2JsYWNrVGV4dHVyZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdMVGV4dHVyZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9HTFRleHR1cmUuanMiLCIvLyBzdG9sZW4gdGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2dsLWNvbnN0YW50cyB0aGFua3MgQG1hdHRkZXNsIF5eXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0MDogJ05PTkUnLFxuXHQxOiAnT05FJyxcblx0MjogJ0xJTkVfTE9PUCcsXG5cdDM6ICdMSU5FX1NUUklQJyxcblx0NDogJ1RSSUFOR0xFUycsXG5cdDU6ICdUUklBTkdMRV9TVFJJUCcsXG5cdDY6ICdUUklBTkdMRV9GQU4nLFxuXHQyNTY6ICdERVBUSF9CVUZGRVJfQklUJyxcblx0NTEyOiAnTkVWRVInLFxuXHQ1MTM6ICdMRVNTJyxcblx0NTE0OiAnRVFVQUwnLFxuXHQ1MTU6ICdMRVFVQUwnLFxuXHQ1MTY6ICdHUkVBVEVSJyxcblx0NTE3OiAnTk9URVFVQUwnLFxuXHQ1MTg6ICdHRVFVQUwnLFxuXHQ1MTk6ICdBTFdBWVMnLFxuXHQ3Njg6ICdTUkNfQ09MT1InLFxuXHQ3Njk6ICdPTkVfTUlOVVNfU1JDX0NPTE9SJyxcblx0NzcwOiAnU1JDX0FMUEhBJyxcblx0NzcxOiAnT05FX01JTlVTX1NSQ19BTFBIQScsXG5cdDc3MjogJ0RTVF9BTFBIQScsXG5cdDc3MzogJ09ORV9NSU5VU19EU1RfQUxQSEEnLFxuXHQ3NzQ6ICdEU1RfQ09MT1InLFxuXHQ3NzU6ICdPTkVfTUlOVVNfRFNUX0NPTE9SJyxcblx0Nzc2OiAnU1JDX0FMUEhBX1NBVFVSQVRFJyxcblx0MTAyNDogJ1NURU5DSUxfQlVGRkVSX0JJVCcsXG5cdDEwMjg6ICdGUk9OVCcsXG5cdDEwMjk6ICdCQUNLJyxcblx0MTAzMjogJ0ZST05UX0FORF9CQUNLJyxcblx0MTI4MDogJ0lOVkFMSURfRU5VTScsXG5cdDEyODE6ICdJTlZBTElEX1ZBTFVFJyxcblx0MTI4MjogJ0lOVkFMSURfT1BFUkFUSU9OJyxcblx0MTI4NTogJ09VVF9PRl9NRU1PUlknLFxuXHQxMjg2OiAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nLFxuXHQyMzA0OiAnQ1cnLFxuXHQyMzA1OiAnQ0NXJyxcblx0Mjg0OTogJ0xJTkVfV0lEVEgnLFxuXHQyODg0OiAnQ1VMTF9GQUNFJyxcblx0Mjg4NTogJ0NVTExfRkFDRV9NT0RFJyxcblx0Mjg4NjogJ0ZST05UX0ZBQ0UnLFxuXHQyOTI4OiAnREVQVEhfUkFOR0UnLFxuXHQyOTI5OiAnREVQVEhfVEVTVCcsXG5cdDI5MzA6ICdERVBUSF9XUklURU1BU0snLFxuXHQyOTMxOiAnREVQVEhfQ0xFQVJfVkFMVUUnLFxuXHQyOTMyOiAnREVQVEhfRlVOQycsXG5cdDI5NjA6ICdTVEVOQ0lMX1RFU1QnLFxuXHQyOTYxOiAnU1RFTkNJTF9DTEVBUl9WQUxVRScsXG5cdDI5NjI6ICdTVEVOQ0lMX0ZVTkMnLFxuXHQyOTYzOiAnU1RFTkNJTF9WQUxVRV9NQVNLJyxcblx0Mjk2NDogJ1NURU5DSUxfRkFJTCcsXG5cdDI5NjU6ICdTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTCcsXG5cdDI5NjY6ICdTVEVOQ0lMX1BBU1NfREVQVEhfUEFTUycsXG5cdDI5Njc6ICdTVEVOQ0lMX1JFRicsXG5cdDI5Njg6ICdTVEVOQ0lMX1dSSVRFTUFTSycsXG5cdDI5Nzg6ICdWSUVXUE9SVCcsXG5cdDMwMjQ6ICdESVRIRVInLFxuXHQzMDQyOiAnQkxFTkQnLFxuXHQzMDg4OiAnU0NJU1NPUl9CT1gnLFxuXHQzMDg5OiAnU0NJU1NPUl9URVNUJyxcblx0MzEwNjogJ0NPTE9SX0NMRUFSX1ZBTFVFJyxcblx0MzEwNzogJ0NPTE9SX1dSSVRFTUFTSycsXG5cdDMzMTc6ICdVTlBBQ0tfQUxJR05NRU5UJyxcblx0MzMzMzogJ1BBQ0tfQUxJR05NRU5UJyxcblx0MzM3OTogJ01BWF9URVhUVVJFX1NJWkUnLFxuXHQzMzg2OiAnTUFYX1ZJRVdQT1JUX0RJTVMnLFxuXHQzNDA4OiAnU1VCUElYRUxfQklUUycsXG5cdDM0MTA6ICdSRURfQklUUycsXG5cdDM0MTE6ICdHUkVFTl9CSVRTJyxcblx0MzQxMjogJ0JMVUVfQklUUycsXG5cdDM0MTM6ICdBTFBIQV9CSVRTJyxcblx0MzQxNDogJ0RFUFRIX0JJVFMnLFxuXHQzNDE1OiAnU1RFTkNJTF9CSVRTJyxcblx0MzU1MzogJ1RFWFRVUkVfMkQnLFxuXHQ0MzUyOiAnRE9OVF9DQVJFJyxcblx0NDM1MzogJ0ZBU1RFU1QnLFxuXHQ0MzU0OiAnTklDRVNUJyxcblx0NTEyMDogJ0JZVEUnLFxuXHQ1MTIxOiAnVU5TSUdORURfQllURScsXG5cdDUxMjI6ICdTSE9SVCcsXG5cdDUxMjM6ICdVTlNJR05FRF9TSE9SVCcsXG5cdDUxMjQ6ICdJTlQnLFxuXHQ1MTI1OiAnVU5TSUdORURfSU5UJyxcblx0NTEyNjogJ0ZMT0FUJyxcblx0NTM4NjogJ0lOVkVSVCcsXG5cdDU4OTA6ICdURVhUVVJFJyxcblx0NjQwMTogJ1NURU5DSUxfSU5ERVgnLFxuXHQ2NDAyOiAnREVQVEhfQ09NUE9ORU5UJyxcblx0NjQwMzogJ1JFRCcsXG5cdDY0MDY6ICdBTFBIQScsXG5cdDY0MDc6ICdSR0InLFxuXHQ2NDA4OiAnUkdCQScsXG5cdDY0MDk6ICdMVU1JTkFOQ0UnLFxuXHQ2NDEwOiAnTFVNSU5BTkNFX0FMUEhBJyxcblx0NzY4MDogJ0tFRVAnLFxuXHQ3NjgxOiAnUkVQTEFDRScsXG5cdDc2ODI6ICdJTkNSJyxcblx0NzY4MzogJ0RFQ1InLFxuXHQ3OTM2OiAnVkVORE9SJyxcblx0NzkzNzogJ1JFTkRFUkVSJyxcblx0NzkzODogJ1ZFUlNJT04nLFxuXHQ5NzI4OiAnTkVBUkVTVCcsXG5cdDk3Mjk6ICdMSU5FQVInLFxuXHQ5OTg0OiAnTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCcsXG5cdDk5ODU6ICdMSU5FQVJfTUlQTUFQX05FQVJFU1QnLFxuXHQ5OTg2OiAnTkVBUkVTVF9NSVBNQVBfTElORUFSJyxcblx0OTk4NzogJ0xJTkVBUl9NSVBNQVBfTElORUFSJyxcblx0MTAyNDA6ICdURVhUVVJFX01BR19GSUxURVInLFxuXHQxMDI0MTogJ1RFWFRVUkVfTUlOX0ZJTFRFUicsXG5cdDEwMjQyOiAnVEVYVFVSRV9XUkFQX1MnLFxuXHQxMDI0MzogJ1RFWFRVUkVfV1JBUF9UJyxcblx0MTA0OTc6ICdSRVBFQVQnLFxuXHQxMDc1MjogJ1BPTFlHT05fT0ZGU0VUX1VOSVRTJyxcblx0MTYzODQ6ICdDT0xPUl9CVUZGRVJfQklUJyxcblx0MzI3Njk6ICdDT05TVEFOVF9DT0xPUicsXG5cdDMyNzcwOiAnT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SJyxcblx0MzI3NzE6ICdDT05TVEFOVF9BTFBIQScsXG5cdDMyNzcyOiAnT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBJyxcblx0MzI3NzM6ICdCTEVORF9DT0xPUicsXG5cdDMyNzc0OiAnRlVOQ19BREQnLFxuXHQzMjc3NzogJ0JMRU5EX0VRVUFUSU9OX1JHQicsXG5cdDMyNzc4OiAnRlVOQ19TVUJUUkFDVCcsXG5cdDMyNzc5OiAnRlVOQ19SRVZFUlNFX1NVQlRSQUNUJyxcblx0MzI4MTk6ICdVTlNJR05FRF9TSE9SVF80XzRfNF80Jyxcblx0MzI4MjA6ICdVTlNJR05FRF9TSE9SVF81XzVfNV8xJyxcblx0MzI4MjM6ICdQT0xZR09OX09GRlNFVF9GSUxMJyxcblx0MzI4MjQ6ICdQT0xZR09OX09GRlNFVF9GQUNUT1InLFxuXHQzMjg1NDogJ1JHQkE0Jyxcblx0MzI4NTU6ICdSR0I1X0ExJyxcblx0MzI4NzM6ICdURVhUVVJFX0JJTkRJTkdfMkQnLFxuXHQzMjkyNjogJ1NBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRScsXG5cdDMyOTI4OiAnU0FNUExFX0NPVkVSQUdFJyxcblx0MzI5MzY6ICdTQU1QTEVfQlVGRkVSUycsXG5cdDMyOTM3OiAnU0FNUExFUycsXG5cdDMyOTM4OiAnU0FNUExFX0NPVkVSQUdFX1ZBTFVFJyxcblx0MzI5Mzk6ICdTQU1QTEVfQ09WRVJBR0VfSU5WRVJUJyxcblx0MzI5Njg6ICdCTEVORF9EU1RfUkdCJyxcblx0MzI5Njk6ICdCTEVORF9TUkNfUkdCJyxcblx0MzI5NzA6ICdCTEVORF9EU1RfQUxQSEEnLFxuXHQzMjk3MTogJ0JMRU5EX1NSQ19BTFBIQScsXG5cdDMzMDcxOiAnQ0xBTVBfVE9fRURHRScsXG5cdDMzMTcwOiAnR0VORVJBVEVfTUlQTUFQX0hJTlQnLFxuXHQzMzE4OTogJ0RFUFRIX0NPTVBPTkVOVDE2Jyxcblx0MzMzMDY6ICdERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQnLFxuXHQzMzMyMTogJ1I4Jyxcblx0MzM2MzU6ICdVTlNJR05FRF9TSE9SVF81XzZfNScsXG5cdDMzNjQ4OiAnTUlSUk9SRURfUkVQRUFUJyxcblx0MzM5MDE6ICdBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UnLFxuXHQzMzkwMjogJ0FMSUFTRURfTElORV9XSURUSF9SQU5HRScsXG5cdDMzOTg0OiAnVEVYVFVSRTAnLFxuXHQzMzk4NTogJ1RFWFRVUkUxJyxcblx0MzM5ODY6ICdURVhUVVJFMicsXG5cdDMzOTg3OiAnVEVYVFVSRTMnLFxuXHQzMzk4ODogJ1RFWFRVUkU0Jyxcblx0MzM5ODk6ICdURVhUVVJFNScsXG5cdDMzOTkwOiAnVEVYVFVSRTYnLFxuXHQzMzk5MTogJ1RFWFRVUkU3Jyxcblx0MzM5OTI6ICdURVhUVVJFOCcsXG5cdDMzOTkzOiAnVEVYVFVSRTknLFxuXHQzMzk5NDogJ1RFWFRVUkUxMCcsXG5cdDMzOTk1OiAnVEVYVFVSRTExJyxcblx0MzM5OTY6ICdURVhUVVJFMTInLFxuXHQzMzk5NzogJ1RFWFRVUkUxMycsXG5cdDMzOTk4OiAnVEVYVFVSRTE0Jyxcblx0MzM5OTk6ICdURVhUVVJFMTUnLFxuXHQzNDAwMDogJ1RFWFRVUkUxNicsXG5cdDM0MDAxOiAnVEVYVFVSRTE3Jyxcblx0MzQwMDI6ICdURVhUVVJFMTgnLFxuXHQzNDAwMzogJ1RFWFRVUkUxOScsXG5cdDM0MDA0OiAnVEVYVFVSRTIwJyxcblx0MzQwMDU6ICdURVhUVVJFMjEnLFxuXHQzNDAwNjogJ1RFWFRVUkUyMicsXG5cdDM0MDA3OiAnVEVYVFVSRTIzJyxcblx0MzQwMDg6ICdURVhUVVJFMjQnLFxuXHQzNDAwOTogJ1RFWFRVUkUyNScsXG5cdDM0MDEwOiAnVEVYVFVSRTI2Jyxcblx0MzQwMTE6ICdURVhUVVJFMjcnLFxuXHQzNDAxMjogJ1RFWFRVUkUyOCcsXG5cdDM0MDEzOiAnVEVYVFVSRTI5Jyxcblx0MzQwMTQ6ICdURVhUVVJFMzAnLFxuXHQzNDAxNTogJ1RFWFRVUkUzMScsXG5cdDM0MDE2OiAnQUNUSVZFX1RFWFRVUkUnLFxuXHQzNDAyNDogJ01BWF9SRU5ERVJCVUZGRVJfU0laRScsXG5cdDM0MDQxOiAnREVQVEhfU1RFTkNJTCcsXG5cdDM0MDU1OiAnSU5DUl9XUkFQJyxcblx0MzQwNTY6ICdERUNSX1dSQVAnLFxuXHQzNDA2NzogJ1RFWFRVUkVfQ1VCRV9NQVAnLFxuXHQzNDA2ODogJ1RFWFRVUkVfQklORElOR19DVUJFX01BUCcsXG5cdDM0MDY5OiAnVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJyxcblx0MzQwNzA6ICdURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gnLFxuXHQzNDA3MTogJ1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWScsXG5cdDM0MDcyOiAnVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZJyxcblx0MzQwNzM6ICdURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1onLFxuXHQzNDA3NDogJ1RFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWicsXG5cdDM0MDc2OiAnTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRScsXG5cdDM0MzM4OiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEJyxcblx0MzQzMzk6ICdWRVJURVhfQVRUUklCX0FSUkFZX1NJWkUnLFxuXHQzNDM0MDogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFJyxcblx0MzQzNDE6ICdWRVJURVhfQVRUUklCX0FSUkFZX1RZUEUnLFxuXHQzNDM0MjogJ0NVUlJFTlRfVkVSVEVYX0FUVFJJQicsXG5cdDM0MzczOiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSJyxcblx0MzQ0NjY6ICdOVU1fQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMnLFxuXHQzNDQ2NzogJ0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTJyxcblx0MzQ2NjA6ICdCVUZGRVJfU0laRScsXG5cdDM0NjYxOiAnQlVGRkVSX1VTQUdFJyxcblx0MzQ4MTY6ICdTVEVOQ0lMX0JBQ0tfRlVOQycsXG5cdDM0ODE3OiAnU1RFTkNJTF9CQUNLX0ZBSUwnLFxuXHQzNDgxODogJ1NURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUwnLFxuXHQzNDgxOTogJ1NURU5DSUxfQkFDS19QQVNTX0RFUFRIX1BBU1MnLFxuXHQzNDg3NzogJ0JMRU5EX0VRVUFUSU9OX0FMUEhBJyxcblx0MzQ5MjE6ICdNQVhfVkVSVEVYX0FUVFJJQlMnLFxuXHQzNDkyMjogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRCcsXG5cdDM0OTMwOiAnTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMnLFxuXHQzNDk2MjogJ0FSUkFZX0JVRkZFUicsXG5cdDM0OTYzOiAnRUxFTUVOVF9BUlJBWV9CVUZGRVInLFxuXHQzNDk2NDogJ0FSUkFZX0JVRkZFUl9CSU5ESU5HJyxcblx0MzQ5NjU6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HJyxcblx0MzQ5NzU6ICdWRVJURVhfQVRUUklCX0FSUkFZX0JVRkZFUl9CSU5ESU5HJyxcblx0MzUwNDA6ICdTVFJFQU1fRFJBVycsXG5cdDM1MDQ0OiAnU1RBVElDX0RSQVcnLFxuXHQzNTA0ODogJ0RZTkFNSUNfRFJBVycsXG5cdDM1NjMyOiAnRlJBR01FTlRfU0hBREVSJyxcblx0MzU2MzM6ICdWRVJURVhfU0hBREVSJyxcblx0MzU2NjA6ICdNQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMnLFxuXHQzNTY2MTogJ01BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTJyxcblx0MzU2NjM6ICdTSEFERVJfVFlQRScsXG5cdDM1NjY0OiAnRkxPQVRfVkVDMicsXG5cdDM1NjY1OiAnRkxPQVRfVkVDMycsXG5cdDM1NjY2OiAnRkxPQVRfVkVDNCcsXG5cdDM1NjY3OiAnSU5UX1ZFQzInLFxuXHQzNTY2ODogJ0lOVF9WRUMzJyxcblx0MzU2Njk6ICdJTlRfVkVDNCcsXG5cdDM1NjcwOiAnQk9PTCcsXG5cdDM1NjcxOiAnQk9PTF9WRUMyJyxcblx0MzU2NzI6ICdCT09MX1ZFQzMnLFxuXHQzNTY3MzogJ0JPT0xfVkVDNCcsXG5cdDM1Njc0OiAnRkxPQVRfTUFUMicsXG5cdDM1Njc1OiAnRkxPQVRfTUFUMycsXG5cdDM1Njc2OiAnRkxPQVRfTUFUNCcsXG5cdDM1Njc4OiAnU0FNUExFUl8yRCcsXG5cdDM1NjgwOiAnU0FNUExFUl9DVUJFJyxcblx0MzU3MTI6ICdERUxFVEVfU1RBVFVTJyxcblx0MzU3MTM6ICdDT01QSUxFX1NUQVRVUycsXG5cdDM1NzE0OiAnTElOS19TVEFUVVMnLFxuXHQzNTcxNTogJ1ZBTElEQVRFX1NUQVRVUycsXG5cdDM1NzE2OiAnSU5GT19MT0dfTEVOR1RIJyxcblx0MzU3MTc6ICdBVFRBQ0hFRF9TSEFERVJTJyxcblx0MzU3MTg6ICdBQ1RJVkVfVU5JRk9STVMnLFxuXHQzNTcxOTogJ0FDVElWRV9VTklGT1JNX01BWF9MRU5HVEgnLFxuXHQzNTcyMDogJ1NIQURFUl9TT1VSQ0VfTEVOR1RIJyxcblx0MzU3MjE6ICdBQ1RJVkVfQVRUUklCVVRFUycsXG5cdDM1NzIyOiAnQUNUSVZFX0FUVFJJQlVURV9NQVhfTEVOR1RIJyxcblx0MzU3MjQ6ICdTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04nLFxuXHQzNTcyNTogJ0NVUlJFTlRfUFJPR1JBTScsXG5cdDM2MDAzOiAnU1RFTkNJTF9CQUNLX1JFRicsXG5cdDM2MDA0OiAnU1RFTkNJTF9CQUNLX1ZBTFVFX01BU0snLFxuXHQzNjAwNTogJ1NURU5DSUxfQkFDS19XUklURU1BU0snLFxuXHQzNjAwNjogJ0ZSQU1FQlVGRkVSX0JJTkRJTkcnLFxuXHQzNjAwNzogJ1JFTkRFUkJVRkZFUl9CSU5ESU5HJyxcblx0MzYwNDg6ICdGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFJyxcblx0MzYwNDk6ICdGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9OQU1FJyxcblx0MzYwNTA6ICdGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfTEVWRUwnLFxuXHQzNjA1MTogJ0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9DVUJFX01BUF9GQUNFJyxcblx0MzYwNTM6ICdGUkFNRUJVRkZFUl9DT01QTEVURScsXG5cdDM2MDU0OiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UJyxcblx0MzYwNTU6ICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCcsXG5cdDM2MDU3OiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TJyxcblx0MzYwNjE6ICdGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRCcsXG5cdDM2MDY0OiAnQ09MT1JfQVRUQUNITUVOVDAnLFxuXHQzNjA5NjogJ0RFUFRIX0FUVEFDSE1FTlQnLFxuXHQzNjEyODogJ1NURU5DSUxfQVRUQUNITUVOVCcsXG5cdDM2MTYwOiAnRlJBTUVCVUZGRVInLFxuXHQzNjE2MTogJ1JFTkRFUkJVRkZFUicsXG5cdDM2MTYyOiAnUkVOREVSQlVGRkVSX1dJRFRIJyxcblx0MzYxNjM6ICdSRU5ERVJCVUZGRVJfSEVJR0hUJyxcblx0MzYxNjQ6ICdSRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUJyxcblx0MzYxNjg6ICdTVEVOQ0lMX0lOREVYOCcsXG5cdDM2MTc2OiAnUkVOREVSQlVGRkVSX1JFRF9TSVpFJyxcblx0MzYxNzc6ICdSRU5ERVJCVUZGRVJfR1JFRU5fU0laRScsXG5cdDM2MTc4OiAnUkVOREVSQlVGRkVSX0JMVUVfU0laRScsXG5cdDM2MTc5OiAnUkVOREVSQlVGRkVSX0FMUEhBX1NJWkUnLFxuXHQzNjE4MDogJ1JFTkRFUkJVRkZFUl9ERVBUSF9TSVpFJyxcblx0MzYxODE6ICdSRU5ERVJCVUZGRVJfU1RFTkNJTF9TSVpFJyxcblx0MzYxOTQ6ICdSR0I1NjUnLFxuXHQzNjMzNjogJ0xPV19GTE9BVCcsXG5cdDM2MzM3OiAnTUVESVVNX0ZMT0FUJyxcblx0MzYzMzg6ICdISUdIX0ZMT0FUJyxcblx0MzYzMzk6ICdMT1dfSU5UJyxcblx0MzYzNDA6ICdNRURJVU1fSU5UJyxcblx0MzYzNDE6ICdISUdIX0lOVCcsXG5cdDM2MzQ2OiAnU0hBREVSX0NPTVBJTEVSJyxcblx0MzYzNDc6ICdNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUycsXG5cdDM2MzQ4OiAnTUFYX1ZBUllJTkdfVkVDVE9SUycsXG5cdDM2MzQ5OiAnTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUycsXG5cdDM3NDQwOiAnVU5QQUNLX0ZMSVBfWV9XRUJHTCcsXG5cdDM3NDQxOiAnVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMJyxcblx0Mzc0NDI6ICdDT05URVhUX0xPU1RfV0VCR0wnLFxuXHQzNzQ0MzogJ1VOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wnLFxuXHQzNzQ0NDogJ0JST1dTRVJfREVGQVVMVF9XRUJHTCdcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvV2ViZ2xOdW1iZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gc2ltcGxlQ29sb3IuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0lNUExFX0NPTE9SXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzMgY29sb3I7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9zaW1wbGVDb2xvci5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFBhc3MuanNcblxuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBGcmFtZUJ1ZmZlciBmcm9tICcuLi9GcmFtZUJ1ZmZlcic7XG5pbXBvcnQgU2hhZGVyTGlicyBmcm9tICcuLi9zaGFkZXJzL1NoYWRlckxpYnMnO1xuXG5jbGFzcyBQYXNzIHtcblx0Y29uc3RydWN0b3IobVNvdXJjZSwgbVdpZHRoID0gMCwgbUhlaWdodCA9IDAsIG1QYXJhbXMgPSB7fSkge1xuXHRcdHRoaXMuc2hhZGVyID0gbmV3IEdMU2hhZGVyKFNoYWRlckxpYnMuYmlnVHJpYW5nbGVWZXJ0LCBtU291cmNlKTtcblxuXHRcdHRoaXMuX3dpZHRoID0gbVdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IG1IZWlnaHQ7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7fTtcblx0XHR0aGlzLl9oYXNPd25GYm8gPSB0aGlzLl93aWR0aCA+IDAgJiYgdGhpcy5fd2lkdGggPiAwO1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge307XG5cblx0XHRpZiAodGhpcy5faGFzT3duRmJvKSB7XG5cdFx0XHR0aGlzLl9mYm8gPSBuZXcgRnJhbWVCdWZmZXIodGhpcy5fd2lkdGgsIHRoaXMuaGVpZ2h0LCBtUGFybWFzKTtcblx0XHR9XG5cdH1cblxuXG5cdHVuaWZvcm0obU5hbWUsIG1WYWx1ZSkge1xuXHRcdHRoaXMuX3VuaWZvcm1zW21OYW1lXSA9IG1WYWx1ZTtcblx0fVxuXG5cblx0cmVuZGVyKHRleHR1cmUpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndGV4dHVyZScsICd1bmlmb3JtMWknLCAwKTtcblx0XHR0ZXh0dXJlLmJpbmQoMCk7XG5cblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKHRoaXMuX3VuaWZvcm1zKTtcblx0fVxuXG5cdGdldCB3aWR0aCgpIHtcdHJldHVybiB0aGlzLl93aWR0aDtcdH1cblx0Z2V0IGhlaWdodCgpIHtcdHJldHVybiB0aGlzLl9oZWlnaHQ7XHR9XG5cdGdldCBmYm8oKSB7XHRyZXR1cm4gdGhpcy5fZmJvO1x0fVxuXHRnZXQgaGFzRmJvKCkge1x0cmV0dXJuIHRoaXMuX2hhc093bkZibzsgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzcy5qcyIsIlxuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4vb2JqZWN0cy9PYmplY3QzRCc7XG5cbmNsYXNzIE1lc2ggZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoZ2VvbWV0cnksIG1hdGVyaWFsKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lc2g7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvTWVzaC5qcyIsIi8vIEdMQ3ViZVRleHR1cmUuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IHBhcnNlIGZyb20gJ3BhcnNlLWRkcyc7XG5sZXQgZ2w7XG5jb25zdCBERFNEX01JUE1BUENPVU5UID0gMHgyMDAwMDtcbmNvbnN0IE9GRl9NSVBNQVBDT1VOVCA9IDc7XG5jb25zdCBoZWFkZXJMZW5ndGhJbnQgPSAzMTtcblxuY2xhc3MgR0xDdWJlVGV4dHVyZSB7XG5cdGNvbnN0cnVjdG9yKG1Tb3VyY2UsIG1QYXJhbWV0ZXJzID0ge30sIGlzQ3ViZVRleHR1cmUgPSBmYWxzZSkge1xuXHRcdGdsID0gR0wuZ2w7XG5cblx0XHRpZihpc0N1YmVUZXh0dXJlKSB7XG5cdFx0XHR0aGlzLnRleHR1cmUgPSBtU291cmNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxldCBoYXNNaXBtYXBzID0gbVNvdXJjZS5sZW5ndGggPiA2O1xuXHRcdGlmKG1Tb3VyY2VbMF0ubWlwbWFwQ291bnQpIHtcblx0XHRcdGhhc01pcG1hcHMgPSBtU291cmNlWzBdLm1pcG1hcENvdW50ID4gMTtcblx0XHR9XG5cblx0XHR0aGlzLnRleHR1cmUgICA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1QYXJhbWV0ZXJzLm1hZ0ZpbHRlciB8fCBnbC5MSU5FQVI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtUGFyYW1ldGVycy5taW5GaWx0ZXIgfHwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cdFx0dGhpcy53cmFwUyAgICAgPSBtUGFyYW1ldGVycy53cmFwUyB8fCBnbC5DTEFNUF9UT19FREdFO1xuXHRcdHRoaXMud3JhcFQgICAgID0gbVBhcmFtZXRlcnMud3JhcFQgfHwgZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdGlmKCFoYXNNaXBtYXBzICYmIHRoaXMubWluRmlsdGVyID09IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSKSB7XG5cdFx0XHR0aGlzLm1pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHR9XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0aGlzLnRleHR1cmUpO1xuXHRcdGNvbnN0IHRhcmdldHMgPSBbXG5cdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCwgXG5cdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSwgXG5cdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWiBcblx0XHRdO1xuXG5cdFx0XG5cdFx0bGV0IG51bUxldmVscyA9IDE7XG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRudW1MZXZlbHMgPSBtU291cmNlLmxlbmd0aCAvIDY7XG5cdFx0dGhpcy5udW1MZXZlbHMgPSBudW1MZXZlbHM7XG5cblx0XHRpZiAoaGFzTWlwbWFwcykge1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCA2OyBqKyspIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1MZXZlbHM7IGkrKykge1xuXHRcdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0aW5kZXggPSBqICogbnVtTGV2ZWxzICsgaTtcblx0XHRcdFx0XHRpZihtU291cmNlW2luZGV4XS5zaGFwZSkge1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2pdLCBpLCBnbC5SR0JBLCBtU291cmNlW2luZGV4XS5zaGFwZVswXSwgbVNvdXJjZVtpbmRleF0uc2hhcGVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBtU291cmNlW2luZGV4XS5kYXRhKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2pdLCBpLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBtU291cmNlW2luZGV4XSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy53cmFwUyk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy53cmFwVCk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5taW5GaWx0ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDY7IGorKykge1xuXHRcdFx0XHRpbmRleCA9IGogKiBudW1MZXZlbHM7XG5cdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcblx0XHRcdFx0aWYobVNvdXJjZVtpbmRleF0uc2hhcGUpIHtcblx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldHNbal0sIDAsIGdsLlJHQkEsIG1Tb3VyY2VbaW5kZXhdLnNoYXBlWzBdLCBtU291cmNlW2luZGV4XS5zaGFwZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG1Tb3VyY2VbaW5kZXhdLmRhdGEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQodGFyZ2V0c1tqXSwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbVNvdXJjZVtpbmRleF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMubWluRmlsdGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV9DVUJFX01BUCk7XG5cdFx0fVxuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG5cdH1cblxuXHRcblxuXHQvL1x0UFVCTElDIE1FVEhPRFxuXG5cdGJpbmQoaW5kZXggPSAwKSB7XG5cdFx0aWYoIUdMLnNoYWRlcikgeyByZXR1cm47IH1cblxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpbmRleCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy50ZXh0dXJlKTtcblx0XHQvLyBnbC51bmlmb3JtMWkoR0wuc2hhZGVyLnVuaWZvcm1UZXh0dXJlc1tpbmRleF0sIGluZGV4KTtcblx0XHR0aGlzLl9iaW5kSW5kZXggPSBpbmRleDtcblx0fVxuXG5cdHVuYmluZCgpIHtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcdFxuXHR9XG59XG5cblxuR0xDdWJlVGV4dHVyZS5wYXJzZUREUyA9IGZ1bmN0aW9uIHBhcnNlRERTKG1BcnJheUJ1ZmZlcikge1xuXG5cdGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuXHRcdGlmIChtaW4gPiBtYXgpIHtcblx0XHRcdHJldHVybiBjbGFtcCh2YWx1ZSwgbWF4LCBtaW4pO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSA8IG1pbikgcmV0dXJuIG1pbjtcblx0XHRlbHNlIGlmICh2YWx1ZSA+IG1heCkgcmV0dXJuIG1heDtcblx0XHRlbHNlIHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8vXHRDSEVDS0lORyBNSVAgTUFQIExFVkVMU1xuXHRjb25zdCBkZHNJbmZvcyA9IHBhcnNlKG1BcnJheUJ1ZmZlcik7XG5cdGNvbnN0IHsgZmxhZ3MgfSA9IGRkc0luZm9zO1xuXHRjb25zdCBoZWFkZXIgPSBuZXcgSW50MzJBcnJheShtQXJyYXlCdWZmZXIsIDAsIGhlYWRlckxlbmd0aEludCk7XG5cdGxldCBtaXBtYXBDb3VudCA9IDE7XG5cdGlmIChmbGFncyAmIEREU0RfTUlQTUFQQ09VTlQpIHtcblx0XHRtaXBtYXBDb3VudCA9IE1hdGgubWF4KDEsIGhlYWRlcltPRkZfTUlQTUFQQ09VTlRdKTtcblx0fVxuXHRjb25zdCBzb3VyY2VzID0gZGRzSW5mb3MuaW1hZ2VzLm1hcCgoaW1nKSA9PiB7XG5cdFx0Y29uc3QgZmFjZURhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG1BcnJheUJ1ZmZlci5zbGljZShpbWcub2Zmc2V0LCBpbWcub2Zmc2V0ICsgaW1nLmxlbmd0aCkpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOiBmYWNlRGF0YSxcblx0XHRcdHNoYXBlOiBpbWcuc2hhcGUsXG5cdFx0XHRtaXBtYXBDb3VudCxcblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gbmV3IEdMQ3ViZVRleHR1cmUoc291cmNlcyk7XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEdMQ3ViZVRleHR1cmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR0xDdWJlVGV4dHVyZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiYXNpYy52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCQVNJQ19WRVJURVhcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9iYXNpYy52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFNoYWRlcnMuanNcblxuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcblxuY29uc3Qgc2hhZGVyQ2FjaGUgPSBbXTtcblxuY29uc3QgZGVmaW5lc1RvU3RyaW5nID0gZnVuY3Rpb24gKGRlZmluZXMpIHtcblx0bGV0IG91dFN0ciA9ICcnO1xuXHRmb3IgKGNvbnN0IGRlZiBpbiBkZWZpbmVzKSB7XG5cdFx0aWYoZGVmaW5lc1tkZWZdKSB7XG5cdFx0XHRvdXRTdHIgKz0gYCNkZWZpbmUgJHtkZWZ9ICR7ZGVmaW5lc1tkZWZdfVxcbmA7XHRcblx0XHR9XG5cdFx0XG5cdH1cblx0cmV0dXJuIG91dFN0cjtcbn07XG5cbmNvbnN0IGdldFVuaWZvcm1UeXBlID0gZnVuY3Rpb24gKG1WYWx1ZSkge1xuXHRpZihtVmFsdWUubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGB2ZWMke21WYWx1ZS5sZW5ndGh9YDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gJ2Zsb2F0Jztcblx0fVxufTtcblxuY29uc3QgYWRkVW5pZm9ybXMgPSBmdW5jdGlvbiAobVNoYWRlciwgbU9ialVuaWZvcm1zKSB7XG5cblx0bGV0IHN0clVuaWZvcm1zID0gJyc7XG5cdGZvcihjb25zdCB1bmlmb3JtTmFtZSBpbiBtT2JqVW5pZm9ybXMpIHtcblx0XHRjb25zdCB1bmlmb3JtVmFsdWUgPSBtT2JqVW5pZm9ybXNbdW5pZm9ybU5hbWVdO1xuXHRcdGNvbnN0IHVuaWZvcm1UeXBlID0gZ2V0VW5pZm9ybVR5cGUodW5pZm9ybVZhbHVlKTtcblxuXHRcdHN0clVuaWZvcm1zICs9IGB1bmlmb3JtICR7dW5pZm9ybVR5cGV9ICR7dW5pZm9ybU5hbWV9O1xcbmA7XG5cdH1cblxuXHRtU2hhZGVyID0gbVNoYWRlci5yZXBsYWNlKCd7e1VOSUZPUk1TfX0nLCBzdHJVbmlmb3Jtcyk7XG5cblx0cmV0dXJuIG1TaGFkZXI7XG59O1xuXG5cbmNvbnN0IGJpbmRVbmlmb3JtcyA9IGZ1bmN0aW9uIChtU2hhZGVyLCBtT2JqVW5pZm9ybXMpIHtcblxuXHRmb3IoY29uc3QgdW5pZm9ybU5hbWUgaW4gbU9ialVuaWZvcm1zKSB7XG5cdFx0Y29uc3QgdW5pZm9ybVZhbHVlID0gbU9ialVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcblx0XHRjb25zdCB1bmlmb3JtVHlwZSA9IGdldFVuaWZvcm1UeXBlKHVuaWZvcm1WYWx1ZSk7XG5cdFx0bVNoYWRlci51bmlmb3JtKHVuaWZvcm1OYW1lLCB1bmlmb3JtVHlwZSwgdW5pZm9ybVZhbHVlKTtcblx0fVxuXHRcbn07XG5cbmNvbnN0IGluamVjdERlZmluZXMgPSBmdW5jdGlvbiAobVNoYWRlciwgbURlZmluZXMpIHtcblxuXHRyZXR1cm4gYCR7ZGVmaW5lc1RvU3RyaW5nKG1EZWZpbmVzKX1cXG4ke21TaGFkZXJ9YDtcblxufTtcblxuY29uc3QgZ2V0ID0gKHZzLCBmcywgZGVmaW5lcyA9IHt9KSA9PiB7XG5cdGxldCBfc2hhZGVyO1xuXHRjb25zdCBfdnMgPSBpbmplY3REZWZpbmVzKHZzLCBkZWZpbmVzKTtcblx0Y29uc3QgX2ZzID0gaW5qZWN0RGVmaW5lcyhmcywgZGVmaW5lcyk7XG5cblx0c2hhZGVyQ2FjaGUuZm9yRWFjaChzaGFkZXIgPT4ge1xuXHRcdGlmKF92cyA9PT0gc2hhZGVyLnZzICYmIF9mcyA9PT0gc2hhZGVyLmZzKSB7XG5cdFx0XHRfc2hhZGVyID0gc2hhZGVyLmdsU2hhZGVyO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKCFfc2hhZGVyKSB7XG5cdFx0X3NoYWRlciA9IG5ldyBHTFNoYWRlcihfdnMsIF9mcyk7XG5cdFx0c2hhZGVyQ2FjaGUucHVzaCh7XG5cdFx0XHR2czpfdnMsXG5cdFx0XHRmczpfZnMsXG5cdFx0XHRnbFNoYWRlcjpfc2hhZGVyXG5cdFx0fSk7XG5cdH1cblxuXG5cdHJldHVybiBfc2hhZGVyO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGdldCxcblx0YWRkVW5pZm9ybXMsXG5cdGJpbmRVbmlmb3Jtcyxcblx0aW5qZWN0RGVmaW5lc1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL1NoYWRlcnMuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBGcmFtZUJ1ZmZlci5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuL0dMVGV4dHVyZSc7XG5pbXBvcnQgV2ViZ2xOdW1iZXIgZnJvbSAnLi91dGlscy9XZWJnbE51bWJlcic7XG5pbXBvcnQgb2JqZWN0QXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nO1xuXG5sZXQgZ2w7XG5sZXQgd2ViZ2xEZXB0aFRleHR1cmU7XG5sZXQgaGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCA9IGZhbHNlO1xubGV0IGV4dERyYXdCdWZmZXI7XG5cblxuY29uc3QgY2hlY2tNdWx0aVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblx0aWYoR0wud2ViZ2wyKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gZWxzZSB7XG5cdFx0ZXh0RHJhd0J1ZmZlciA9IEdMLmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyk7XG5cdFx0cmV0dXJuICEhZXh0RHJhd0J1ZmZlcjtcblx0fVxuXHRcblx0aGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCA9IHRydWU7XG59O1xuXG5jbGFzcyBGcmFtZUJ1ZmZlciB7XG5cblx0Y29uc3RydWN0b3IobVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1ldGVycyA9IHt9LCBtTnVtVGFyZ2V0cyA9IDEpIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHdlYmdsRGVwdGhUZXh0dXJlID0gR0wuY2hlY2tFeHRlbnNpb24oJ1dFQkdMX2RlcHRoX3RleHR1cmUnKTtcblxuXHRcdHRoaXMud2lkdGggICAgICAgICAgICA9IG1XaWR0aDtcblx0XHR0aGlzLmhlaWdodCAgICAgICAgICAgPSBtSGVpZ2h0O1xuXHRcdHRoaXMuX251bVRhcmdldHMgXHQgID0gbU51bVRhcmdldHM7XG5cdFx0dGhpcy5fbXVsdGlwbGVUYXJnZXRzID0gbU51bVRhcmdldHMgPiAxO1xuXHRcdHRoaXMuX3BhcmFtZXRlcnMgPSBtUGFyYW1ldGVycztcblxuXHRcdGlmKCFoYXNDaGVja2VkTXVsdGlSZW5kZXJTdXBwb3J0KSB7XG5cdFx0XHRjaGVja011bHRpUmVuZGVyKCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5fbXVsdGlwbGVUYXJnZXRzKSB7XG5cdFx0XHR0aGlzLl9jaGVja01heE51bVJlbmRlclRhcmdldCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy5faW5pdFRleHR1cmVzKCk7XG5cdFx0XG5cdFx0dGhpcy5mcmFtZUJ1ZmZlciAgICAgICAgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1x0XHRcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXG5cdFx0aWYoR0wud2ViZ2wyKSB7XG5cdFx0XHQvLyB0aGlzLnJlbmRlckJ1ZmZlckRlcHRoID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHQvLyBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0XHQvLyBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRcdC8vIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyRGVwdGgpO1xuXG5cdFx0XHRjb25zdCBidWZmZXJzID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVRhcmdldHM7IGkrKykge1xuXHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5EUkFXX0ZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVzW2ldLnRleHR1cmUsIDApO1xuXHRcdFx0XHRidWZmZXJzLnB1c2goZ2xbYENPTE9SX0FUVEFDSE1FTlQke2l9YF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRnbC5kcmF3QnVmZmVycyhidWZmZXJzKTtcblxuXHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRFJBV19GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbERlcHRoVGV4dHVyZS50ZXh0dXJlLCAwKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVRhcmdldHM7IGkrKykge1xuXHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlc1tpXS50ZXh0dXJlLCAwKTtcdFxuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLl9tdWx0aXBsZVRhcmdldHMpIHtcblx0XHRcdFx0Y29uc3QgZHJhd0J1ZmZlcnMgPSBbXTtcblx0XHRcdFx0Zm9yKGxldCBpPTA7IGk8dGhpcy5fbnVtVGFyZ2V0czsgaSsrKSB7XG5cdFx0XHRcdFx0ZHJhd0J1ZmZlcnMucHVzaChleHREcmF3QnVmZmVyW2BDT0xPUl9BVFRBQ0hNRU5UJHtpfV9XRUJHTGBdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV4dERyYXdCdWZmZXIuZHJhd0J1ZmZlcnNXRUJHTChkcmF3QnVmZmVycyk7XHRcblx0XHRcdH1cblxuXHRcdFx0aWYod2ViZ2xEZXB0aFRleHR1cmUpIHtcblx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMCk7XHRcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cblx0XHQvL1x0Q0hFQ0tJTkcgRkJPXG5cdFx0Y29uc3QgRkJPc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG5cdFx0aWYoRkJPc3RhdHVzICE9IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdHTF9GUkFNRUJVRkZFUl9DT01QTEVURSBmYWlsZWQsIENBTk5PVCB1c2UgRnJhbWVidWZmZXInLCBXZWJnbE51bWJlcltGQk9zdGF0dXNdKTtcblx0XHR9XG5cblx0XHQvL1x0VU5CSU5EXG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdFxuXHRcdC8vXHRDTEVBUiBGUkFNRUJVRkZFUiBcblxuXHRcdHRoaXMuY2xlYXIoKTtcblx0fVxuXG5cdF9jaGVja01heE51bVJlbmRlclRhcmdldCgpIHtcblx0XHRjb25zdCBtYXhOdW1EcmF3QnVmZmVycyA9IEdMLmdsLmdldFBhcmFtZXRlcihleHREcmF3QnVmZmVyLk1BWF9EUkFXX0JVRkZFUlNfV0VCR0wpO1xuXHRcdGlmKHRoaXMuX251bVRhcmdldHMgPiBtYXhOdW1EcmF3QnVmZmVycykge1xuXHRcdFx0Y29uc29sZS5lcnJvcignT3ZlciBtYXggbnVtYmVyIG9mIGRyYXcgYnVmZmVycyBzdXBwb3J0ZWQgOiAnLCBtYXhOdW1EcmF3QnVmZmVycyk7XG5cdFx0XHR0aGlzLl9udW1UYXJnZXRzID0gbWF4TnVtRHJhd0J1ZmZlcnM7XG5cdFx0fVxuXHR9XG5cblx0X2luaXRUZXh0dXJlcygpIHtcblx0XHR0aGlzLl90ZXh0dXJlcyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbnVtVGFyZ2V0czsgaSsrKSB7XG5cdFx0XHRjb25zdCBnbHQgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKCk7XG5cdFx0XHR0aGlzLl90ZXh0dXJlcy5wdXNoKGdsdCk7XG5cdFx0fVxuXG5cdFx0XG5cdFx0aWYoR0wud2ViZ2wyKSB7IFxuXHRcdFx0dGhpcy5nbERlcHRoVGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZ2wuREVQVEhfQ09NUE9ORU5UMTYsIGdsLlVOU0lHTkVEX1NIT1JULCBnbC5ERVBUSF9DT01QT05FTlQsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmdsRGVwdGhUZXh0dXJlID0gdGhpcy5fY3JlYXRlVGV4dHVyZShnbC5ERVBUSF9DT01QT05FTlQsIGdsLlVOU0lHTkVEX1NIT1JULCBnbC5ERVBUSF9DT01QT05FTlQsIHsgbWluRmlsdGVyOkdMLkxJTkVBUiB9KTtcblx0XHR9XG5cdH1cblxuXHRfY3JlYXRlVGV4dHVyZShtSW50ZXJuYWxmb3JtYXQsIG1UZXhlbFR5cGUsIG1Gb3JtYXQsIG1QYXJhbWV0ZXJzID0ge30pIHtcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gb2JqZWN0QXNzaWduKHt9LCB0aGlzLl9wYXJhbWV0ZXJzKTtcblx0XHRpZighbUZvcm1hdCkge1x0bUZvcm1hdCA9IG1JbnRlcm5hbGZvcm1hdDsgfVxuXHRcdFxuXHRcdHBhcmFtZXRlcnMuaW50ZXJuYWxGb3JtYXQgPSBtSW50ZXJuYWxmb3JtYXQgfHwgZ2wuUkdCQTtcblx0XHRwYXJhbWV0ZXJzLmZvcm1hdCA9IG1Gb3JtYXQ7XG5cdFx0cGFyYW1ldGVycy50eXBlID0gbVRleGVsVHlwZSB8fCBwYXJhbWV0ZXJzLnR5cGUgfHwgR0wuVU5TSUdORURfQllURTtcblx0XHRmb3IoY29uc3QgcyBpbiBtUGFyYW1ldGVycykge1xuXHRcdFx0cGFyYW1ldGVyc1tzXSA9IG1QYXJhbWV0ZXJzW3NdO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKG51bGwsIHBhcmFtZXRlcnMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRyZXR1cm4gdGV4dHVyZTtcblx0fVxuXG5cdC8vXHRQVUJMSUMgTUVUSE9EU1xuXG5cdGJpbmQobUF1dG9TZXRWaWV3cG9ydD10cnVlKSB7XG5cdFx0aWYobUF1dG9TZXRWaWV3cG9ydCkge1xuXHRcdFx0R0wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1x0XG5cdFx0fVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlcik7XG5cdH1cblxuXG5cdHVuYmluZChtQXV0b1NldFZpZXdwb3J0PXRydWUpIHtcblx0XHRpZihtQXV0b1NldFZpZXdwb3J0KSB7XG5cdFx0XHRHTC52aWV3cG9ydCgwLCAwLCBHTC53aWR0aCwgR0wuaGVpZ2h0KTtcdFxuXHRcdH1cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cdFx0dGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcblx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXAoKTtcblx0XHR9KTtcblx0fVxuXG5cblx0Y2xlYXIociA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDApIHtcblx0XHR0aGlzLmJpbmQoKTtcblx0XHRHTC5jbGVhcihyLCBnLCBiLCBhKTtcblx0XHR0aGlzLnVuYmluZCgpO1xuXHR9XHRcblxuXG5cdC8vXHRURVhUVVJFU1xuXG5cdGdldFRleHR1cmUobUluZGV4ID0gMCkge1xuXHRcdHJldHVybiB0aGlzLl90ZXh0dXJlc1ttSW5kZXhdO1xuXHR9XG5cblx0Z2V0RGVwdGhUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLmdsRGVwdGhUZXh0dXJlO1xuXHR9XG5cblx0Ly9cdFRPVUdIVFMgOiBTaG91bGQgSSByZW1vdmUgdGhlc2UgZnJvbSBmcmFtZSBidWZmZXIgPyBcblx0Ly9cdFNob3VsZG4ndCB0aGVzZSBiZSBzZXQgaW5kaXZpZHVhbGx5IHRvIGVhY2ggdGV4dHVyZSA/IFxuXHQvL1x0ZS5nLiBmYm8uZ2V0VGV4dHVyZSgwKS5taW5GaWx0ZXIgPSBHTC5ORUFSRVNUO1xuXHQvL1x0XHQgZmJvLmdldFRleHR1cmUoMSkubWluRmlsdGVyID0gR0wuTElORUFSOyAuLi4gZXRjID8gXG5cblx0Ly9cdE1JUE1BUCBGSUxURVJcblxuXHRnZXQgbWluRmlsdGVyKCkge1x0cmV0dXJuIHRoaXMuX3RleHR1cmVzWzBdLm1pbkZpbHRlcjtcdH1cblxuXHRzZXQgbWluRmlsdGVyKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IG1WYWx1ZTtcblx0XHR9KTtcblx0fVxuXG5cdGdldCBtYWdGaWx0ZXIoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ubWFnRmlsdGVyO1x0fVxuXG5cdHNldCBtYWdGaWx0ZXIobVZhbHVlKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblxuXHQvL1x0V1JBUFBJTkdcblxuXHRnZXQgd3JhcFMoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ud3JhcFM7XHR9XG5cblx0c2V0IHdyYXBTKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblxuXHRnZXQgd3JhcFQoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ud3JhcFQ7XHR9XG5cblx0c2V0IHdyYXBUKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly9cdFVUSUxTXG5cblx0c2hvd1BhcmFtZXRlcnMoKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXNbMF0uc2hvd1BhcmFtZXRlcnMoKTtcblx0fVxuXG5cdGdldCBudW1UYXJnZXRzKCkge1x0cmV0dXJuIHRoaXMuX251bVRhcmdldHM7XHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRnJhbWVCdWZmZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvRnJhbWVCdWZmZXIuanMiLCIvLyBFYXNlTnVtYmVyLmpzXG5cbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnc2NoZWR1bGluZyc7XG5cbmNsYXNzIEVhc2VOdW1iZXIge1xuXHRjb25zdHJ1Y3RvcihtVmFsdWUsIG1FYXNpbmcgPSAwLjEpIHtcblx0XHR0aGlzLmVhc2luZyAgICAgICA9IG1FYXNpbmc7XG5cdFx0dGhpcy5fdmFsdWUgICAgICAgPSBtVmFsdWU7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fZWZJbmRleCAgICAgPSBTY2hlZHVsZXIuYWRkRUYoKCk9PiB0aGlzLl91cGRhdGUoKSk7XG5cdH1cblxuXG5cdF91cGRhdGUoKSB7XG5cdFx0Y29uc3QgTUlOX0RJRkYgPSAwLjAwMDE7XG5cdFx0dGhpcy5fY2hlY2tMaW1pdCgpO1xuXHRcdHRoaXMuX3ZhbHVlICs9ICh0aGlzLl90YXJnZXRWYWx1ZSAtIHRoaXMuX3ZhbHVlKSAqIHRoaXMuZWFzaW5nO1x0XG5cdFx0aWYoTWF0aC5hYnModGhpcy5fdGFyZ2V0VmFsdWUgLSB0aGlzLl92YWx1ZSkgPCBNSU5fRElGRikge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB0aGlzLl90YXJnZXRWYWx1ZTtcblx0XHR9XG5cdH1cblxuXHRzZXRUbyhtVmFsdWUpIHtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX3ZhbHVlID0gbVZhbHVlO1xuXHR9XG5cblxuXHRhZGQobUFkZCkge1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlICs9IG1BZGQ7XG5cdH1cblxuXHRsaW1pdChtTWluLCBtTWF4KSB7XG5cdFx0aWYobU1pbiA+IG1NYXgpIHtcblx0XHRcdHRoaXMubGltaXQobU1heCwgbU1pbik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWluID0gbU1pbjtcblx0XHR0aGlzLl9tYXggPSBtTWF4O1xuXG5cdFx0dGhpcy5fY2hlY2tMaW1pdCgpO1xuXHR9XG5cblxuXHRfY2hlY2tMaW1pdCgpIHtcblx0XHRpZih0aGlzLl9taW4gIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90YXJnZXRWYWx1ZSA8IHRoaXMuX21pbikge1xuXHRcdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSB0aGlzLl9taW47XG5cdFx0fSBcblxuXHRcdGlmKHRoaXMuX21heCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3RhcmdldFZhbHVlID4gdGhpcy5fbWF4KSB7XG5cdFx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX21heDtcblx0XHR9IFxuXHR9XG5cblxuXHRkZXN0cm95KCkge1xuXHRcdFNjaGVkdWxlci5yZW1vdmVFRih0aGlzLl9lZkluZGV4KTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUlMgLyBTRVRURVJTXG5cblx0c2V0IHZhbHVlKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gbVZhbHVlO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fVxuXG5cdGdldCB0YXJnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGFyZ2V0VmFsdWU7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEVhc2VOdW1iZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvRWFzZU51bWJlci5qcyIsIi8vIFJheS5qc1xuXG5pbXBvcnQgeyBtYXQ0LCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuXG5jb25zdCBhID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IGIgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgYyA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCB0YXJnZXQgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgZWRnZTEgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgZWRnZTIgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3Qgbm9ybWFsID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IGRpZmYgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5jbGFzcyBSYXkge1xuXHRjb25zdHJ1Y3RvcihtT3JpZ2luLCBtRGlyZWN0aW9uKSB7XG5cdFx0dGhpcy5vcmlnaW4gPSB2ZWMzLmNsb25lKG1PcmlnaW4pO1xuXHRcdHRoaXMuZGlyZWN0aW9uID0gdmVjMy5jbG9uZShtRGlyZWN0aW9uKTtcblx0fVxuXG5cdGF0KHQpIHtcblx0XHR2ZWMzLmNvcHkodGFyZ2V0LCB0aGlzLmRpcmVjdGlvbik7XG5cdFx0dmVjMy5zY2FsZSh0YXJnZXQsIHRhcmdldCwgdCk7XG5cdFx0dmVjMy5hZGQodGFyZ2V0LCB0YXJnZXQsIHRoaXMub3JpZ2luKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXG5cdGxvb2tBdChtVGFyZ2V0KSB7XG5cdFx0dmVjMy5zdWIodGhpcy5kaXJlY3Rpb24sIG1UYXJnZXQsIHRoaXMub3JpZ2luKTtcblx0XHR2ZWMzLm5vcm1hbGl6ZSh0aGlzLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuXHR9XG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludChtUG9pbnQpIHtcblx0XHRjb25zdCByZXN1bHQgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHZlYzMuc3ViKG1Qb2ludCwgdGhpcy5vcmlnaW4pO1xuXHRcdGNvbnN0IGRpcmVjdGlvbkRpc3RhbmNlID0gdmVjMy5kb3QocmVzdWx0LCB0aGlzLmRpcmVjdGlvbik7XG5cblx0XHRpZiAoZGlyZWN0aW9uRGlzdGFuY2UgPCAwKSB7XG5cdFx0XHRyZXR1cm4gdmVjMy5jbG9uZSh0aGlzLm9yaWdpbik7XG5cdFx0fVxuXG5cdFx0dmVjMy5jb3B5KHJlc3VsdCwgdGhpcy5kaXJlY3Rpb24pO1xuXHRcdHZlYzMuc2NhbGUocmVzdWx0LCByZXN1bHQsIGRpcmVjdGlvbkRpc3RhbmNlKTtcblx0XHR2ZWMzLmFkZChyZXN1bHQsIHJlc3VsdCwgdGhpcy5vcmlnaW4pO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cblx0ZGlzdGFuY2VUb1BvaW50KG1Qb2ludCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxVG9Qb2ludChtUG9pbnQpKTtcblx0fVxuXG5cblx0ZGlzdGFuY2VTcVRvUG9pbnQobVBvaW50KSB7XG5cdFx0Y29uc3QgdjEgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5cdFx0dmVjMy5zdWIodjEsIG1Qb2ludCwgdGhpcy5vcmlnaW4pO1xuXHRcdGNvbnN0IGRpcmVjdGlvbkRpc3RhbmNlID0gdmVjMy5kb3QodjEsIHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdGlmIChkaXJlY3Rpb25EaXN0YW5jZSA8IDApIHtcblx0XHRcdHJldHVybiB2ZWMzLnNxdWFyZWREaXN0YW5jZSh0aGlzLm9yaWdpbiwgbVBvaW50KTtcblx0XHR9XG5cblx0XHR2ZWMzLmNvcHkodjEsIHRoaXMuZGlyZWN0aW9uKTtcblx0XHR2ZWMzLnNjYWxlKHYxLCB2MSwgZGlyZWN0aW9uRGlzdGFuY2UpO1xuXHRcdHZlYzMuYWRkKHYxLCB2MSwgdGhpcy5vcmlnaW4pO1xuXHRcdHJldHVybiB2ZWMzLnNxdWFyZWREaXN0YW5jZSh2MSwgbVBvaW50KTtcblx0fVxuXG5cblx0aW50ZXJzZWN0c1NwaGVyZShtQ2VudGVyLCBtUmFkaXVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KG1DZW50ZXIpIDw9IG1SYWRpdXM7XG5cdH1cblxuXG5cdGludGVyc2VjdFNwaGVyZShtQ2VudGVyLCBtUmFkaXVzKSB7XG5cdFx0Y29uc3QgdjEgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHZlYzMuc3ViKHYxLCBtQ2VudGVyLCB0aGlzLm9yaWdpbik7XG5cdFx0Y29uc3QgdGNhID0gdmVjMy5kb3QodjEsIHRoaXMuZGlyZWN0aW9uKTtcblx0XHRjb25zdCBkMiA9IHZlYzMuZG90KHYxLCB2MSkgLSB0Y2EgKiB0Y2E7XG5cdFx0Y29uc3QgcmFkaXVzMiA9IG1SYWRpdXMgKiBtUmFkaXVzO1xuXG5cdFx0aWYoZDIgPiByYWRpdXMyKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IHRoYyA9IE1hdGguc3FydChyYWRpdXMyIC0gZDIpO1xuXG5cdFx0Y29uc3QgdDAgPSB0Y2EgLSB0aGM7XG5cblx0XHRjb25zdCB0MSA9IHRjYSArIHRoYztcblxuXHRcdGlmKHQwIDwgMCAmJiB0MSA8IDApIHJldHVybiBudWxsO1xuXG5cdFx0aWYodDAgPCAwKSByZXR1cm4gdGhpcy5hdCh0MSk7XG5cblx0XHRyZXR1cm4gdGhpcy5hdCh0MCk7XG5cdH1cblxuXG5cdGRpc3RhbmNlVG9QbGFuZShtUGxhbmVDZW50ZXIsIG1Ob3JtYWwpIHtcblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHZlYzMuZG90KG1Ob3JtYWwsIHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdGlmKGRlbm9taW5hdG9yID09PSAwKSB7XG5cdFx0fVxuXHR9XG5cblxuXHRpbnRlcnNlY3RUcmlhbmdsZShtUEEsIG1QQiwgbVBDLCBiYWNrZmFjZUN1bGxpbmcgPSB0cnVlKSB7XG5cdFx0dmVjMy5jb3B5KGEsIG1QQSk7XG5cdFx0dmVjMy5jb3B5KGIsIG1QQik7XG5cdFx0dmVjMy5jb3B5KGMsIG1QQyk7XG5cblx0XHQvLyBjb25zdCBlZGdlMSA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Ly8gY29uc3QgZWRnZTIgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdC8vIGNvbnN0IG5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Ly8gY29uc3QgZGlmZiA9IHZlYzMuY3JlYXRlKCk7XG5cblx0XHR2ZWMzLnN1YihlZGdlMSwgYiwgYSk7XG5cdFx0dmVjMy5zdWIoZWRnZTIsIGMsIGEpO1xuXHRcdHZlYzMuY3Jvc3Mobm9ybWFsLCBlZGdlMSwgZWRnZTIpO1xuXG5cdFx0bGV0IERkTiA9IHZlYzMuZG90KHRoaXMuZGlyZWN0aW9uLCBub3JtYWwpO1xuXHRcdGxldCBzaWduO1xuXG5cdFx0aWYgKERkTiA+IDApIHtcblx0XHRcdGlmIChiYWNrZmFjZUN1bGxpbmcpIHtcdHJldHVybiBudWxsO1x0fVxuXHRcdFx0c2lnbiA9IDE7XG5cdFx0fSBlbHNlIGlmIChEZE4gPCAwKSB7XG5cdFx0XHRzaWduID0gLTE7XG5cdFx0XHREZE4gPSAtIERkTjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmVjMy5zdWIoZGlmZiwgdGhpcy5vcmlnaW4sIGEpO1xuXG5cdFx0dmVjMy5jcm9zcyhlZGdlMiwgZGlmZiwgZWRnZTIpO1xuXHRcdGNvbnN0IERkUXhFMiA9IHNpZ24gKiB2ZWMzLmRvdCh0aGlzLmRpcmVjdGlvbiwgZWRnZTIpO1xuXHRcdGlmIChEZFF4RTIgPCAwKSB7IFx0cmV0dXJuIG51bGw7IFx0fVxuXG5cdFx0dmVjMy5jcm9zcyhlZGdlMSwgZWRnZTEsIGRpZmYpO1xuXHRcdGNvbnN0IERkRTF4USA9IHNpZ24gKiB2ZWMzLmRvdCh0aGlzLmRpcmVjdGlvbiwgZWRnZTEpO1xuXHRcdGlmIChEZEUxeFEgPCAwKSB7XHRyZXR1cm4gbnVsbDtcdH1cblxuXHRcdGlmKERkUXhFMiArIERkRTF4USA+IERkTikge1x0cmV0dXJuIG51bGw7XHR9XG5cblx0XHRjb25zdCBRZG4gPSAtIHNpZ24gKiB2ZWMzLmRvdChkaWZmLCBub3JtYWwpO1xuXHRcdGlmKFFkbiA8IDApIHtcdHJldHVybiBudWxsO1x0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYXQoUWRuIC8gRGROKTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL21hdGgvUmF5LmpzIiwiLy8gU2hhZGVyTGJzLmpzXG5cbmltcG9ydCBzaW1wbGVDb2xvckZyYWcgZnJvbSAnLi4vZ2xzbC9zaW1wbGVDb2xvci5mcmFnJztcbmltcG9ydCBiaWdUcmlhbmdsZVZlcnQgZnJvbSAnLi4vZ2xzbC9iaWdUcmlhbmdsZS52ZXJ0JztcbmltcG9ydCBnZW5lcmFsVmVydCBmcm9tICcuLi9nbHNsL2dlbmVyYWwudmVydCc7XG5pbXBvcnQgY29weUZyYWcgZnJvbSAnLi4vZ2xzbC9jb3B5LmZyYWcnO1xuaW1wb3J0IGJhc2ljVmVydCBmcm9tICcuLi9nbHNsL2Jhc2ljLnZlcnQnO1xuaW1wb3J0IHNreWJveFZlcnQgZnJvbSAnLi4vZ2xzbC9za3lib3gudmVydCc7XG5pbXBvcnQgc2t5Ym94RnJhZyBmcm9tICcuLi9nbHNsL3NreWJveC5mcmFnJztcbmltcG9ydCBnbHRmVmVydCBmcm9tICcuLi9nbHNsL2dsdGYudmVydCc7XG5pbXBvcnQgZ2x0ZkZyYWcgZnJvbSAnLi4vZ2xzbC9nbHRmLmZyYWcnO1xuaW1wb3J0IGRlYnVnRnJhZyBmcm9tICcuLi9nbHNsL2RlYnVnLmZyYWcnO1xuXG5jb25zdCBTaGFkZXJMaWJzID0ge1xuXHRzaW1wbGVDb2xvckZyYWcsXG5cdGJpZ1RyaWFuZ2xlVmVydCxcblx0Z2VuZXJhbFZlcnQsXG5cdGNvcHlGcmFnLFxuXHRiYXNpY1ZlcnQsXG5cdHNreWJveFZlcnQsXG5cdHNreWJveEZyYWcsXG5cdGdsdGZWZXJ0LFxuXHRnbHRmRnJhZyxcblx0ZGVidWdGcmFnLFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTaGFkZXJMaWJzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvU2hhZGVyTGlicy5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiaWdUcmlhbmdsZS52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCSUdfVFJJQU5HTEVfVkVSVEVYXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVBvc2l0aW9uICogLjUgKyAuNTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYmlnVHJpYW5nbGUudmVydFxuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gY29weS5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBDT1BZX0ZSQUdNRU5UXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvY29weS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIENhbWVyYS5qc1xuXG5pbXBvcnQgeyBtYXQ0LCBtYXQzLCBxdWF0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY2xhc3MgQ2FtZXJhIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Ly9cdFZJRVcgTUFUUklYXG5cdFx0dGhpcy5fbWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuXHRcdC8vXHRGT1IgVFJBTlNGT1JNIEZST00gT1JJRU5UQVRJT05cblx0XHR0aGlzLl9xdWF0ID0gcXVhdC5jcmVhdGUoKTtcblx0XHR0aGlzLl9vcmllbnRhdGlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cblx0XHQvL1x0UFJPSkVDVElPTiBNQVRSSVhcblx0XHR0aGlzLl9wcm9qZWN0aW9uID0gbWF0NC5jcmVhdGUoKTtcblxuXHRcdC8vXHRQT1NJVElPTiBPRiBDQU1FUkFcblx0XHR0aGlzLnBvc2l0aW9uID0gdmVjMy5jcmVhdGUoKTtcblx0fVxuXG5cblx0bG9va0F0KGFFeWUsIGFDZW50ZXIsIGFVcCA9IFswLCAxLCAwXSkge1xuXHRcdHRoaXMuX2V5ZSA9IHZlYzMuY2xvbmUoYUV5ZSk7XG5cdFx0dGhpcy5fY2VudGVyID0gdmVjMy5jbG9uZShhQ2VudGVyKTtcblxuXHRcdHZlYzMuY29weSh0aGlzLnBvc2l0aW9uLCBhRXllKTtcblx0XHRtYXQ0LmlkZW50aXR5KHRoaXMuX21hdHJpeCk7XG5cdFx0bWF0NC5sb29rQXQodGhpcy5fbWF0cml4LCBhRXllLCBhQ2VudGVyLCBhVXApO1xuXHR9XG5cblxuXHRzZXRGcm9tT3JpZW50YXRpb24oeCwgeSwgeiwgdykge1xuXHRcdHF1YXQuc2V0KHRoaXMuX3F1YXQsIHgsIHksIHosIHcpO1xuXHRcdG1hdDQuZnJvbVF1YXQodGhpcy5fb3JpZW50YXRpb24sIHRoaXMuX3F1YXQpO1xuXHRcdG1hdDQudHJhbnNsYXRlKHRoaXMuX21hdHJpeCwgdGhpcy5fb3JpZW50YXRpb24sIHRoaXMucG9zaXRpb25PZmZzZXQpO1xuXHR9XG5cblxuXHRzZXRQcm9qZWN0aW9uKG1Qcm9qKSB7XG5cdFx0dGhpcy5fcHJvamVjdGlvbiA9IG1hdDQuY2xvbmUobVByb2opO1xuXHR9XG5cblxuXHRzZXRWaWV3KG1WaWV3KSB7XG5cdFx0dGhpcy5fbWF0cml4ID0gbWF0NC5jbG9uZShtVmlldyk7XG5cdH1cblx0XG5cblx0c2V0RnJvbVZpZXdQcm9qKG1WaWV3LCBtUHJvaikge1xuXHRcdHRoaXMuc2V0VmlldyhtVmlldyk7XG5cdFx0dGhpcy5zZXRQcm9qZWN0aW9uKG1Qcm9qKTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUlMgXG5cblx0Z2V0IG1hdHJpeCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9XG5cblx0Z2V0IHZpZXdNYXRyaXgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeDtcblx0fVxuXG5cblx0Z2V0IHByb2plY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Rpb247XG5cdH0gXG5cblx0Z2V0IHByb2plY3Rpb25NYXRyaXgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Rpb247XG5cdH0gXG5cblxuXHRnZXQgZXllKCkge1x0cmV0dXJuIHRoaXMuX2V5ZTtcdH1cblxuXHRnZXQgY2VudGVyKCkge1x0cmV0dXJuIHRoaXMuX2NlbnRlcjtcdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmE7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmEuanMiLCIvLyBDYW1lcmFQZXJzcGVjdGl2ZS5qc1xuXG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vQ2FtZXJhJztcbmltcG9ydCBSYXkgZnJvbSAnLi4vbWF0aC9SYXknO1xuaW1wb3J0IHsgbWF0NCwgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IG1JbnZlcnNlVmlld1Byb2ogPSBtYXQ0LmNyZWF0ZSgpO1xuY29uc3QgY2FtZXJhRGlyID0gdmVjMy5jcmVhdGUoKTtcblxuXG5jbGFzcyBDYW1lcmFQZXJzcGVjdGl2ZSBleHRlbmRzIENhbWVyYSB7XG5cblx0c2V0UGVyc3BlY3RpdmUobUZvdiwgbUFzcGVjdFJhdGlvLCBtTmVhciwgbUZhcikge1xuXHRcdFxuXHRcdHRoaXMuX2ZvdiAgICAgICAgID0gbUZvdjtcblx0XHR0aGlzLl9uZWFyICAgICAgICA9IG1OZWFyO1xuXHRcdHRoaXMuX2ZhciAgICAgICAgID0gbUZhcjtcblx0XHR0aGlzLl9hc3BlY3RSYXRpbyA9IG1Bc3BlY3RSYXRpbztcblx0XHRtYXQ0LnBlcnNwZWN0aXZlKHRoaXMuX3Byb2plY3Rpb24sIG1Gb3YsIG1Bc3BlY3RSYXRpbywgbU5lYXIsIG1GYXIpO1xuXG5cdFx0Ly8gdGhpcy5fZnJ1c3R1bVRvcCA9IHRoaXMuX25lYXIgKiBNYXRoLnRhbih0aGlzLl9mb3YgKiAwLjUpO1xuXHRcdC8vIHRoaXMuX2ZydXN0dW1CdXR0b20gPSAtdGhpcy5fZnJ1c3R1bVRvcDtcblx0XHQvLyB0aGlzLl9mcnVzdHVtUmlnaHQgPSB0aGlzLl9mcnVzdHVtVG9wICogdGhpcy5fYXNwZWN0UmF0aW87XG5cdFx0Ly8gdGhpcy5fZnJ1c3R1bUxlZnQgPSAtdGhpcy5fZnJ1c3R1bVJpZ2h0O1xuXHR9XG5cblxuXHRzZXRBc3BlY3RSYXRpbyhtQXNwZWN0UmF0aW8pIHtcblx0XHR0aGlzLl9hc3BlY3RSYXRpbyA9IG1Bc3BlY3RSYXRpbztcblx0XHRtYXQ0LnBlcnNwZWN0aXZlKHRoaXMucHJvamVjdGlvbiwgdGhpcy5fZm92LCBtQXNwZWN0UmF0aW8sIHRoaXMuX25lYXIsIHRoaXMuX2Zhcik7XG5cdH1cblxuXG5cdGdlbmVyYXRlUmF5KG1TY3JlZW5Qb3NpdGlvbiwgbVJheSkge1xuXHRcdGNvbnN0IHByb2ogPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG5cdFx0Y29uc3QgdmlldyA9IHRoaXMudmlld01hdHJpeDtcblxuXHRcdG1hdDQubXVsdGlwbHkobUludmVyc2VWaWV3UHJvaiwgcHJvaiwgdmlldyk7XG5cdFx0bWF0NC5pbnZlcnQobUludmVyc2VWaWV3UHJvaiwgbUludmVyc2VWaWV3UHJvaik7XG5cblx0XHR2ZWMzLnRyYW5zZm9ybU1hdDQoY2FtZXJhRGlyLCBtU2NyZWVuUG9zaXRpb24sIG1JbnZlcnNlVmlld1Byb2opO1xuXHRcdHZlYzMuc3ViKGNhbWVyYURpciwgY2FtZXJhRGlyLCB0aGlzLnBvc2l0aW9uKTtcblx0XHR2ZWMzLm5vcm1hbGl6ZShjYW1lcmFEaXIsIGNhbWVyYURpcik7XG5cblx0XHRpZiAoIW1SYXkpIHtcblx0XHRcdG1SYXkgPSBuZXcgUmF5KHRoaXMucG9zaXRpb24sIGNhbWVyYURpcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1SYXkub3JpZ2luID0gdGhpcy5wb3NpdGlvbjtcblx0XHRcdG1SYXkuZGlyZWN0aW9uID0gY2FtZXJhRGlyO1xuXHRcdH1cblxuXG5cdFx0cmV0dXJuIG1SYXk7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmFQZXJzcGVjdGl2ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYVBlcnNwZWN0aXZlLmpzIiwiLy8gQmluYXJ5TG9hZGVyLmpzXG5cbmNsYXNzIEJpbmFyeUxvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoaXNBcnJheUJ1ZmZlciA9IGZhbHNlKSB7XG5cdFx0dGhpcy5fcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0dGhpcy5fcmVxLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoZSk9PnRoaXMuX29uTG9hZGVkKGUpKTtcblx0XHR0aGlzLl9yZXEuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZSk9PnRoaXMuX29uUHJvZ3Jlc3MoZSkpO1xuXHRcdGlmKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMuX3JlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHRcdH1cblx0fVx0XG5cblxuXHRsb2FkKHVybCwgY2FsbGJhY2spIHtcblx0XHRjb25zb2xlLmxvZygnTG9hZGluZyA6ICcsIHVybCk7XG5cdFx0dGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHRoaXMuX3JlcS5vcGVuKCdHRVQnLCB1cmwpO1xuXHRcdHRoaXMuX3JlcS5zZW5kKCk7XG5cdH1cblxuXG5cdF9vbkxvYWRlZCgpIHtcblx0XHR0aGlzLl9jYWxsYmFjayh0aGlzLl9yZXEucmVzcG9uc2UpO1xuXHR9XG5cblx0X29uUHJvZ3Jlc3MoLyogZSovKSB7XG5cdFx0Ly8gY29uc29sZS5sb2coJ29uIFByb2dyZXNzOicsIChlLmxvYWRlZC9lLnRvdGFsKjEwMCkudG9GaXhlZCgyKSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmluYXJ5TG9hZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvQmluYXJ5TG9hZGVyLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGFsZnJpZC5qc1xuXG5pbXBvcnQgKiBhcyBHTE0gXHRcdFx0ZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBHTCBcdFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvR0xUb29sJztcbmltcG9ydCBHTFNoYWRlciBcdFx0XHRmcm9tICcuL2FsZnJpZC9HTFNoYWRlcic7XG5pbXBvcnQgR0xUZXh0dXJlIFx0XHRcdGZyb20gJy4vYWxmcmlkL0dMVGV4dHVyZSc7XG5pbXBvcnQgR0xDdWJlVGV4dHVyZSBcdFx0ZnJvbSAnLi9hbGZyaWQvR0xDdWJlVGV4dHVyZSc7XG5pbXBvcnQgTWVzaCBcdFx0XHRcdGZyb20gJy4vYWxmcmlkL01lc2gnO1xuaW1wb3J0IEdlb21ldHJ5IFx0XHRcdGZyb20gJy4vYWxmcmlkL0dlb21ldHJ5JztcbmltcG9ydCBNYXRlcmlhbCBcdFx0XHRmcm9tICcuL2FsZnJpZC9NYXRlcmlhbCc7XG5pbXBvcnQgR2VvbVx0XHRcdFx0XHRmcm9tICcuL2FsZnJpZC9HZW9tJztcbmltcG9ydCBCYXRjaFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvQmF0Y2gnO1xuaW1wb3J0IEZyYW1lQnVmZmVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvRnJhbWVCdWZmZXInO1xuaW1wb3J0IEN1YmVGcmFtZUJ1ZmZlclx0XHRmcm9tICcuL2FsZnJpZC9DdWJlRnJhbWVCdWZmZXInO1xuXG4vL1x0V0VCR0wgMlxuaW1wb3J0IE11bHRpc2FtcGxlRnJhbWVCdWZmZXIgIGZyb20gJy4vYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXInO1xuaW1wb3J0IFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IGZyb20gJy4vYWxmcmlkL1RyYW5zZm9ybUZlZWRiYWNrT2JqZWN0JztcblxuLy9cdFRPT0xTXG5pbXBvcnQgU2NoZWR1bGVyIFx0XHRcdGZyb20gJ3NjaGVkdWxpbmcnO1xuaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvRXZlbnREaXNwYXRjaGVyJztcbmltcG9ydCBFYXNlTnVtYmVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL0Vhc2VOdW1iZXInO1xuaW1wb3J0IFR3ZWVuTnVtYmVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL1R3ZWVuTnVtYmVyJztcbmltcG9ydCBPcmJpdGFsQ29udHJvbFx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9PcmJpdGFsQ29udHJvbCc7XG5pbXBvcnQgUXVhdFJvdGF0aW9uXHRcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uJztcbmltcG9ydCBUb3VjaERldGVjdG9yXHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3InO1xuaW1wb3J0IFdlYmdsTnVtYmVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvV2ViZ2xOdW1iZXInO1xuaW1wb3J0IFdlYmdsQ29uc3RcdFx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9XZWJnbENvbnN0JztcblxuLy9cdFNIQURFUlNcbmltcG9ydCBTaGFkZXJzXHRcdFx0XHRmcm9tICcuL2FsZnJpZC9zaGFkZXJzL1NoYWRlcnMnO1xuaW1wb3J0IFNoYWRlckxpYnNcdFx0XHRmcm9tICcuL2FsZnJpZC9zaGFkZXJzL1NoYWRlckxpYnMnO1xuXG4vL1x0Q0FNRVJBU1xuaW1wb3J0IENhbWVyYSBcdFx0XHRcdGZyb20gJy4vYWxmcmlkL2NhbWVyYXMvQ2FtZXJhJztcbmltcG9ydCBDYW1lcmFPcnRobyBcdFx0XHRmcm9tICcuL2FsZnJpZC9jYW1lcmFzL0NhbWVyYU9ydGhvJztcbmltcG9ydCBDYW1lcmFQZXJzcGVjdGl2ZVx0ZnJvbSAnLi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFQZXJzcGVjdGl2ZSc7XG5pbXBvcnQgQ2FtZXJhQ3ViZVx0XHRcdGZyb20gJy4vYWxmcmlkL2NhbWVyYXMvQ2FtZXJhQ3ViZSc7XG5cbi8vXHRNQVRIXG5pbXBvcnQgUmF5IFx0XHRcdFx0XHRmcm9tICcuL2FsZnJpZC9tYXRoL1JheSc7XG5cbi8vXHRPQkpFQ1RcbmltcG9ydCBPYmplY3QzRCBcdFx0XHRmcm9tICcuL2FsZnJpZC9vYmplY3RzL09iamVjdDNEJztcblxuLy9cdExPQURFUlNcbmltcG9ydCBCaW5hcnlMb2FkZXJcdFx0XHRmcm9tICcuL2FsZnJpZC9sb2FkZXJzL0JpbmFyeUxvYWRlcic7XG5pbXBvcnQgT2JqTG9hZGVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvbG9hZGVycy9PYmpMb2FkZXInO1xuaW1wb3J0IEhEUkxvYWRlclx0XHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvSERSTG9hZGVyJztcbmltcG9ydCBDb2xsYWRhUGFyc2VyXHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvQ29sbGFkYVBhcnNlcic7XG5pbXBvcnQgR0xURkxvYWRlclx0XHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvR2x0ZkxvYWRlcic7XG5pbXBvcnQgbG9hZEltYWdlc1x0XHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvbG9hZEltYWdlcyc7XG5cbi8vXHRQT1NUIEVGRkVDVFxuaW1wb3J0IEVmZmVjdENvbXBvc2VyIFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L0VmZmVjdENvbXBvc2VyJztcbmltcG9ydCBQYXNzIFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvcG9zdC9QYXNzJztcbmltcG9ydCBQYXNzTWFjcm8gXHRcdFx0ZnJvbSAnLi9hbGZyaWQvcG9zdC9QYXNzTWFjcm8nO1xuaW1wb3J0IFBhc3NCbHVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3Bvc3QvUGFzc0JsdXInO1xuaW1wb3J0IFBhc3NWQmx1ciBcdFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L1Bhc3NWQmx1cic7XG5pbXBvcnQgUGFzc0hCbHVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3Bvc3QvUGFzc0hCbHVyJztcbmltcG9ydCBQYXNzRnhhYSBcdFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L1Bhc3NGeGFhJztcblxuXG4vL1x0SEVMUEVSU1xuaW1wb3J0IEJhdGNoQ29weVx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hDb3B5JztcbmltcG9ydCBCYXRjaEF4aXNcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoQXhpcyc7XG5pbXBvcnQgQmF0Y2hCYWxsXHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaEJhbGwnO1xuaW1wb3J0IEJhdGNoRG90c1BsYW5lXHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hEb3RzUGxhbmUnO1xuaW1wb3J0IEJhdGNoTGluZSBcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZSc7XG5pbXBvcnQgQmF0Y2hTa3lib3hcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoU2t5Ym94JztcbmltcG9ydCBCYXRjaFNreVx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaFNreSc7XG5pbXBvcnQgQmF0Y2hGWEFBXHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaEZYQUEnO1xuaW1wb3J0IFNjZW5lXHRcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL1NjZW5lJztcbmltcG9ydCBWaWV3XHRcdFx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvVmlldyc7XG5pbXBvcnQgVmlldzNEXHRcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL1ZpZXczRCc7XG5cblxuXG5jb25zdCBWRVJTSU9OID0gJzAuMi4wJztcblxuY2xhc3MgQWxmcmlkIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5nbG0gICAgICAgICAgICAgICA9IEdMTTtcblx0XHR0aGlzLkdMICAgICAgICAgICAgICAgID0gR0w7XG5cdFx0dGhpcy5HTFRvb2wgICAgICAgICAgICA9IEdMO1xuXHRcdHRoaXMuR0xTaGFkZXIgICAgICAgICAgPSBHTFNoYWRlcjtcblx0XHR0aGlzLkdMVGV4dHVyZSAgICAgICAgID0gR0xUZXh0dXJlO1xuXHRcdHRoaXMuR0xDdWJlVGV4dHVyZSAgICAgPSBHTEN1YmVUZXh0dXJlO1xuXHRcdHRoaXMuTWVzaCAgICAgICAgICAgICAgPSBNZXNoO1xuXHRcdHRoaXMuR2VvbWV0cnkgICAgICAgICAgPSBHZW9tZXRyeTtcblx0XHR0aGlzLk1hdGVyaWFsICAgICAgICAgID0gTWF0ZXJpYWw7XG5cdFx0dGhpcy5HZW9tICAgICAgICAgICAgICA9IEdlb207XG5cdFx0dGhpcy5CYXRjaCAgICAgICAgICAgICA9IEJhdGNoO1xuXHRcdHRoaXMuRnJhbWVCdWZmZXIgICAgICAgPSBGcmFtZUJ1ZmZlcjtcblx0XHR0aGlzLkN1YmVGcmFtZUJ1ZmZlciAgID0gQ3ViZUZyYW1lQnVmZmVyO1xuXHRcdHRoaXMuU2NoZWR1bGVyICAgICAgICAgPSBTY2hlZHVsZXI7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXIgICA9IEV2ZW50RGlzcGF0Y2hlcjtcblx0XHR0aGlzLkVhc2VOdW1iZXIgICAgICAgID0gRWFzZU51bWJlcjtcblx0XHR0aGlzLlR3ZWVuTnVtYmVyICAgICAgID0gVHdlZW5OdW1iZXI7XG5cdFx0dGhpcy5DYW1lcmEgICAgICAgICAgICA9IENhbWVyYTtcblx0XHR0aGlzLkNhbWVyYU9ydGhvICAgICAgID0gQ2FtZXJhT3J0aG87XG5cdFx0dGhpcy5DYW1lcmFQZXJzcGVjdGl2ZSA9IENhbWVyYVBlcnNwZWN0aXZlO1xuXHRcdHRoaXMuUmF5IFx0XHRcdCAgID0gUmF5O1xuXHRcdHRoaXMuQ2FtZXJhQ3ViZSAgICAgICAgPSBDYW1lcmFDdWJlO1xuXHRcdHRoaXMuT3JiaXRhbENvbnRyb2wgICAgPSBPcmJpdGFsQ29udHJvbDtcblx0XHR0aGlzLlF1YXRSb3RhdGlvbiAgICAgID0gUXVhdFJvdGF0aW9uO1xuXHRcdHRoaXMuVG91Y2hEZXRlY3RvciAgICAgPSBUb3VjaERldGVjdG9yO1xuXHRcdHRoaXMuQmluYXJ5TG9hZGVyICAgICAgPSBCaW5hcnlMb2FkZXI7XG5cdFx0dGhpcy5PYmpMb2FkZXIgICAgICAgICA9IE9iakxvYWRlcjtcblx0XHR0aGlzLkNvbGxhZGFQYXJzZXIgICAgID0gQ29sbGFkYVBhcnNlcjtcblx0XHR0aGlzLkhEUkxvYWRlciAgICAgICAgID0gSERSTG9hZGVyO1xuXHRcdHRoaXMuR0xURkxvYWRlciAgICAgICAgPSBHTFRGTG9hZGVyO1xuXHRcdHRoaXMubG9hZEltYWdlc1x0XHQgICA9IGxvYWRJbWFnZXM7XG5cdFx0dGhpcy5CYXRjaENvcHkgICAgICAgICA9IEJhdGNoQ29weTtcblx0XHR0aGlzLkJhdGNoQXhpcyAgICAgICAgID0gQmF0Y2hBeGlzO1xuXHRcdHRoaXMuQmF0Y2hCYWxsICAgICAgICAgPSBCYXRjaEJhbGw7XG5cdFx0dGhpcy5CYXRjaEJhbGwgICAgICAgICA9IEJhdGNoQmFsbDtcblx0XHR0aGlzLkJhdGNoTGluZSAgICAgICAgID0gQmF0Y2hMaW5lO1xuXHRcdHRoaXMuQmF0Y2hTa3lib3ggICAgICAgPSBCYXRjaFNreWJveDtcblx0XHR0aGlzLkJhdGNoU2t5ICAgICAgICAgID0gQmF0Y2hTa3k7XG5cdFx0dGhpcy5CYXRjaEZYQUEgICAgICAgICA9IEJhdGNoRlhBQTtcblx0XHR0aGlzLkJhdGNoRG90c1BsYW5lICAgID0gQmF0Y2hEb3RzUGxhbmU7XG5cdFx0dGhpcy5TY2VuZSAgICAgICAgICAgICA9IFNjZW5lO1xuXHRcdHRoaXMuVmlldyAgICAgICAgICAgICAgPSBWaWV3O1xuXHRcdHRoaXMuVmlldzNEICAgICAgICAgICAgPSBWaWV3M0Q7XG5cdFx0dGhpcy5PYmplY3QzRCAgICAgICAgICA9IE9iamVjdDNEO1xuXHRcdHRoaXMuU2hhZGVycyAgICAgICAgICAgPSBTaGFkZXJzO1xuXHRcdHRoaXMuU2hhZGVyTGlicyAgICAgICAgPSBTaGFkZXJMaWJzO1xuXHRcdHRoaXMuV2ViZ2xOdW1iZXIgICAgICAgPSBXZWJnbE51bWJlcjtcblx0XHRcblx0XHR0aGlzLkVmZmVjdENvbXBvc2VyICAgID0gRWZmZWN0Q29tcG9zZXI7XG5cdFx0dGhpcy5QYXNzICAgICAgICBcdCAgID0gUGFzcztcblx0XHR0aGlzLlBhc3NNYWNybyAgICAgICAgID0gUGFzc01hY3JvO1xuXHRcdHRoaXMuUGFzc0JsdXIgICAgICAgICAgPSBQYXNzQmx1cjtcblx0XHR0aGlzLlBhc3NWQmx1ciAgICAgICAgID0gUGFzc1ZCbHVyO1xuXHRcdHRoaXMuUGFzc0hCbHVyICAgICAgICAgPSBQYXNzSEJsdXI7XG5cdFx0dGhpcy5QYXNzRnhhYSAgICAgICAgICA9IFBhc3NGeGFhO1xuXG5cdFx0dGhpcy5NdWx0aXNhbXBsZUZyYW1lQnVmZmVyICAgPSBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyO1xuXHRcdHRoaXMuVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QgID0gVHJhbnNmb3JtRmVlZGJhY2tPYmplY3Q7XG5cblxuXHRcdC8vXHROT1QgU1VQRVIgU1VSRSBJJ1ZFIERPTkUgVEhJUyBJUyBBIEdPT0QgV0FZXG5cblx0XHRmb3IoY29uc3QgcyBpbiBHTE0pIHtcblx0XHRcdGlmKEdMTVtzXSkge1xuXHRcdFx0XHR3aW5kb3dbc10gPSBHTE1bc107XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bG9nKCkge1xuXHRcdGlmKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSkge1xuXHRcdFx0Y29uc29sZS5sb2coYCVjbGliIGFsZnJpZCA6IFZFUlNJT04gJHtWRVJTSU9OfWAsICdiYWNrZ3JvdW5kOiAjMTkzNDQxOyBjb2xvcjogI0ZDRkZGNScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZygnbGliIGFsZnJpZCA6IFZFUlNJT04gJywgVkVSU0lPTik7XG5cdFx0fVxuXHRcdGNvbnNvbGUubG9nKCclY0NsYXNzZXMgOiAnLCAnY29sb3I6ICMxOTM0NDEnKTtcblxuXHRcdGZvcihjb25zdCBzIGluIHRoaXMpIHtcblx0XHRcdGlmKHRoaXNbc10pIHtcblx0XHRcdFx0Y29uc29sZS5sb2coYCVjIC0gJHtzfWAsICdjb2xvcjogIzNFNjA2RicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5jb25zdCBhbCA9IG5ldyBBbGZyaWQoKTtcblxuZXhwb3J0IGRlZmF1bHQgYWw7XG5leHBvcnQge1xuXHRHTCxcblx0R0xTaGFkZXIsXG5cdEdMVGV4dHVyZSxcblx0R0xDdWJlVGV4dHVyZSxcblx0TWVzaCxcblx0R2VvbWV0cnksXG5cdE1hdGVyaWFsLFxuXHRHZW9tLFxuXHRCYXRjaCxcblx0RnJhbWVCdWZmZXIsXG5cdEN1YmVGcmFtZUJ1ZmZlcixcblx0TXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcixcblx0VHJhbnNmb3JtRmVlZGJhY2tPYmplY3QsXG5cdFNjaGVkdWxlcixcblx0RXZlbnREaXNwYXRjaGVyLFxuXHRFYXNlTnVtYmVyLFxuXHRUd2Vlbk51bWJlcixcblx0T3JiaXRhbENvbnRyb2wsXG5cdFdlYmdsTnVtYmVyLFxuXHRRdWF0Um90YXRpb24sXG5cdFRvdWNoRGV0ZWN0b3IsXG5cdENhbWVyYSxcblx0Q2FtZXJhT3J0aG8sXG5cdENhbWVyYVBlcnNwZWN0aXZlLFxuXHRDYW1lcmFDdWJlLFxuXHRSYXksXG5cdE9iamVjdDNELFxuXHRCaW5hcnlMb2FkZXIsXG5cdE9iakxvYWRlcixcblx0SERSTG9hZGVyLFxuXHRHTFRGTG9hZGVyLFxuXHRsb2FkSW1hZ2VzLFxuXHRDb2xsYWRhUGFyc2VyLFxuXHRFZmZlY3RDb21wb3Nlcixcblx0UGFzcyxcblx0UGFzc01hY3JvLFxuXHRQYXNzQmx1cixcblx0UGFzc1ZCbHVyLFxuXHRQYXNzSEJsdXIsXG5cdFBhc3NGeGFhLFxuXHRCYXRjaENvcHksXG5cdEJhdGNoQXhpcyxcblx0QmF0Y2hCYWxsLFxuXHRCYXRjaERvdHNQbGFuZSxcblx0QmF0Y2hMaW5lLFxuXHRCYXRjaFNreWJveCxcblx0QmF0Y2hTa3ksXG5cdEJhdGNoRlhBQSxcblx0U2NlbmUsXG5cdFZpZXcsXG5cdFZpZXczRCxcblx0U2hhZGVycyxcblx0U2hhZGVyTGlic1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC5qcyIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDN4MyBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0M1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXG4gKlxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzRdO1xuICBvdXRbNF0gPSBhWzVdO1xuICBvdXRbNV0gPSBhWzZdO1xuICBvdXRbNl0gPSBhWzhdO1xuICBvdXRbN10gPSBhWzldO1xuICBvdXRbOF0gPSBhWzEwXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0xMDtcbiAgb3V0WzRdID0gbTExO1xuICBvdXRbNV0gPSBtMTI7XG4gIG91dFs2XSA9IG0yMDtcbiAgb3V0WzddID0gbTIxO1xuICBvdXRbOF0gPSBtMjI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICBsZXQgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTEyID0gYVs1XTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYTAxO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYTAyO1xuICAgIG91dFs3XSA9IGExMjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhWzFdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhWzJdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdO1xuICBsZXQgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XTtcbiAgbGV0IGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgbGV0IGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcbiAgbGV0IGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XG4gIGxldCBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICBsZXQgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9IGIwMSAqIGRldDtcbiAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgb3V0WzNdID0gYjExICogZGV0O1xuICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl07XG4gIGxldCBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdO1xuICBsZXQgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICBvdXRbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcbiAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gIG91dFsyXSA9IChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICBvdXRbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcbiAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gIG91dFs1XSA9IChhMDIgKiBhMTAgLSBhMDAgKiBhMTIpO1xuICBvdXRbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcbiAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gIG91dFs4XSA9IChhMDAgKiBhMTEgLSBhMDEgKiBhMTApO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXTtcbiAgbGV0IGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV07XG4gIGxldCBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXTtcbiAgbGV0IGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV07XG4gIGxldCBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gIGxldCBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdO1xuICBsZXQgYjEwID0gYlszXSwgYjExID0gYls0XSwgYjEyID0gYls1XTtcbiAgbGV0IGIyMCA9IGJbNl0sIGIyMSA9IGJbN10sIGIyMiA9IGJbOF07XG5cbiAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcblxuICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuXG4gIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuICAgIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICBvdXRbMF0gPSBhMDA7XG4gIG91dFsxXSA9IGEwMTtcbiAgb3V0WzJdID0gYTAyO1xuXG4gIG91dFszXSA9IGExMDtcbiAgb3V0WzRdID0gYTExO1xuICBvdXRbNV0gPSBhMTI7XG5cbiAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIG91dFswXSA9IGMgKiBhMDAgKyBzICogYTEwO1xuICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICBvdXRbNl0gPSBhMjA7XG4gIG91dFs3XSA9IGEyMTtcbiAgb3V0WzhdID0gYTIyO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICBsZXQgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gIG91dFswXSA9IHggKiBhWzBdO1xuICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgb3V0WzJdID0geCAqIGFbMl07XG5cbiAgb3V0WzNdID0geSAqIGFbM107XG4gIG91dFs0XSA9IHkgKiBhWzRdO1xuICBvdXRbNV0gPSB5ICogYVs1XTtcblxuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IHZbMF07XG4gIG91dFs3XSA9IHZbMV07XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG5cbiAgb3V0WzNdID0gLXM7XG4gIG91dFs0XSA9IGM7XG4gIG91dFs1XSA9IDA7XG5cbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG5cbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gdlsxXTtcbiAgb3V0WzVdID0gMDtcblxuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQyZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gMDtcblxuICBvdXRbM10gPSBhWzJdO1xuICBvdXRbNF0gPSBhWzNdO1xuICBvdXRbNV0gPSAwO1xuXG4gIG91dFs2XSA9IGFbNF07XG4gIG91dFs3XSA9IGFbNV07XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIGxldCB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXTtcbiAgbGV0IHgyID0geCArIHg7XG4gIGxldCB5MiA9IHkgKyB5O1xuICBsZXQgejIgPSB6ICsgejtcblxuICBsZXQgeHggPSB4ICogeDI7XG4gIGxldCB5eCA9IHkgKiB4MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgenggPSB6ICogeDI7XG4gIGxldCB6eSA9IHogKiB5MjtcbiAgbGV0IHp6ID0geiAqIHoyO1xuICBsZXQgd3ggPSB3ICogeDI7XG4gIGxldCB3eSA9IHcgKiB5MjtcbiAgbGV0IHd6ID0gdyAqIHoyO1xuXG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbM10gPSB5eCAtIHd6O1xuICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFs1XSA9IHp5ICsgd3g7XG4gIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxGcm9tTWF0NChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgbGV0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgbGV0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgbGV0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgbGV0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgbGV0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgbGV0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgbGV0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgbGV0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgbGV0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgbGV0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgbGV0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgbGV0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIGxldCBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbMl0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcblxuICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuXG4gIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSAyRCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgeW91ciBnbCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBnbCBjb250ZXh0XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0aW9uKG91dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIG91dFswXSA9IDIgLyB3aWR0aDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAtMiAvIGhlaWdodDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IC0xO1xuICAgIG91dFs3XSA9IDE7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArXG4gICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICtcbiAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSkpXG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cblxuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgb3V0WzZdID0gYVs2XSArIChiWzZdICogc2NhbGUpO1xuICBvdXRbN10gPSBhWzddICsgKGJbN10gKiBzY2FsZSk7XG4gIG91dFs4XSA9IGFbOF0gKyAoYls4XSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJlxuICAgICAgICAgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiZcbiAgICAgICAgIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLCBhNiA9IGFbNl0sIGE3ID0gYVs3XSwgYTggPSBhWzhdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XSwgYjYgPSBiWzZdLCBiNyA9IGJbN10sIGI4ID0gYls4XTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDMuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjM1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICBsZXQgeCA9IGJbMF0gLSBhWzBdO1xuICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICBsZXQgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgbGV0IHggPSBiWzBdIC0gYVswXTtcbiAgbGV0IHkgPSBiWzFdIC0gYVsxXTtcbiAgbGV0IHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCBsZW4gPSB4KnggKyB5KnkgKyB6Kno7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl07XG4gIGxldCBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICBsZXQgYXggPSBhWzBdO1xuICBsZXQgYXkgPSBhWzFdO1xuICBsZXQgYXogPSBhWzJdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICBsZXQgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIGxldCBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICBsZXQgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICBsZXQgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIGxldCBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG5cbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgbGV0IGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgbGV0IGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICBsZXQgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIGxldCBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgbGV0IGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgbGV0IGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgbGV0IGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgbGV0IHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIGxldCB6ID0gKGdsTWF0cml4LlJBTkRPTSgpICogMi4wKSAtIDEuMDtcbiAgbGV0IHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlO1xuXG4gIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgb3V0WzJdID0geiAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICBsZXQgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgdyA9IHcgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICBsZXQgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdO1xuXG4gIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gIGxldCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgbGV0IGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICBsZXQgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gIGxldCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpe1xuICBsZXQgcCA9IFtdLCByPVtdO1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07XG5cbiAgLy9wZXJmb3JtIHJvdGF0aW9uXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSpNYXRoLmNvcyhjKSAtIHBbMl0qTWF0aC5zaW4oYyk7XG4gIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCBjKXtcbiAgbGV0IHAgPSBbXSwgcj1bXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIHJbMV0gPSBwWzFdO1xuICByWzJdID0gcFsyXSpNYXRoLmNvcyhjKSAtIHBbMF0qTWF0aC5zaW4oYyk7XG5cbiAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYyl7XG4gIGxldCBwID0gW10sIHI9W107XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuICAvL3BlcmZvcm0gcm90YXRpb25cbiAgclswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuICByWzFdID0gcFswXSpNYXRoLnNpbihjKSArIHBbMV0qTWF0aC5jb3MoYyk7XG4gIHJbMl0gPSBwWzJdO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICBsZXQgdGVtcEEgPSBmcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pO1xuICBsZXQgdGVtcEIgPSBmcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuXG4gIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpO1xuICBub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcblxuICBsZXQgY29zaW5lID0gZG90KHRlbXBBLCB0ZW1wQik7XG5cbiAgaWYoY29zaW5lID4gMS4wKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSBpZihjb3NpbmUgPCAtMS4wKSB7XG4gICAgcmV0dXJuIE1hdGguUEk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXN0ID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gIGxldCB2ZWMgPSBjcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgbGV0IGksIGw7XG4gICAgaWYoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMztcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjNFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxuICpcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6LCB3KSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjNCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHosIHcpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguZmxvb3IoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICBvdXRbM10gPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLnJvdW5kKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIGxldCB4ID0gYlswXSAtIGFbMF07XG4gIGxldCB5ID0gYlsxXSAtIGFbMV07XG4gIGxldCB6ID0gYlsyXSAtIGFbMl07XG4gIGxldCB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICBsZXQgeCA9IGJbMF0gLSBhWzBdO1xuICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICBsZXQgeiA9IGJbMl0gLSBhWzJdO1xuICBsZXQgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICBsZXQgdyA9IGFbM107XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCB3ID0gYVszXTtcbiAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn1cblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSAtYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCB3ID0gYVszXTtcbiAgbGV0IGxlbiA9IHgqeCArIHkqeSArIHoqeiArIHcqdztcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgb3V0WzBdID0geCAqIGxlbjtcbiAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgIG91dFsyXSA9IHogKiBsZW47XG4gICAgb3V0WzNdID0gdyAqIGxlbjtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIGxldCBheCA9IGFbMF07XG4gIGxldCBheSA9IGFbMV07XG4gIGxldCBheiA9IGFbMl07XG4gIGxldCBhdyA9IGFbM107XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCB2ZWN0b3JTY2FsZSkge1xuICB2ZWN0b3JTY2FsZSA9IHZlY3RvclNjYWxlIHx8IDEuMDtcblxuICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgb3V0WzBdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIG91dFsxXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICBvdXRbMl0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgb3V0WzNdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gIHNjYWxlKG91dCwgb3V0LCB2ZWN0b3JTY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICBsZXQgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gIGxldCBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM107XG5cbiAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgbGV0IGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICBsZXQgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gIGxldCBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgbGV0IGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXN0ID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gIGxldCB2ZWMgPSBjcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgbGV0IGksIGw7XG4gICAgaWYoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gNDtcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWM0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFdlYmdsQ29uc3QuanNcblxuLy8gc3RvbGVuIHRoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9nbC1jb25zdGFudHMgdGhhbmtzIEBtYXR0ZGVzbCBeXlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0QUNUSVZFX0FUVFJJQlVURVM6IDM1NzIxLFxuXHRBQ1RJVkVfQVRUUklCVVRFX01BWF9MRU5HVEg6IDM1NzIyLFxuXHRBQ1RJVkVfVEVYVFVSRTogMzQwMTYsXG5cdEFDVElWRV9VTklGT1JNUzogMzU3MTgsXG5cdEFDVElWRV9VTklGT1JNX01BWF9MRU5HVEg6IDM1NzE5LFxuXHRBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0U6IDMzOTAyLFxuXHRBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0U6IDMzOTAxLFxuXHRBTFBIQTogNjQwNixcblx0QUxQSEFfQklUUzogMzQxMyxcblx0QUxXQVlTOiA1MTksXG5cdEFSUkFZX0JVRkZFUjogMzQ5NjIsXG5cdEFSUkFZX0JVRkZFUl9CSU5ESU5HOiAzNDk2NCxcblx0QVRUQUNIRURfU0hBREVSUzogMzU3MTcsXG5cdEJBQ0s6IDEwMjksXG5cdEJMRU5EOiAzMDQyLFxuXHRCTEVORF9DT0xPUjogMzI3NzMsXG5cdEJMRU5EX0RTVF9BTFBIQTogMzI5NzAsXG5cdEJMRU5EX0RTVF9SR0I6IDMyOTY4LFxuXHRCTEVORF9FUVVBVElPTjogMzI3NzcsXG5cdEJMRU5EX0VRVUFUSU9OX0FMUEhBOiAzNDg3Nyxcblx0QkxFTkRfRVFVQVRJT05fUkdCOiAzMjc3Nyxcblx0QkxFTkRfU1JDX0FMUEhBOiAzMjk3MSxcblx0QkxFTkRfU1JDX1JHQjogMzI5NjksXG5cdEJMVUVfQklUUzogMzQxMixcblx0Qk9PTDogMzU2NzAsXG5cdEJPT0xfVkVDMjogMzU2NzEsXG5cdEJPT0xfVkVDMzogMzU2NzIsXG5cdEJPT0xfVkVDNDogMzU2NzMsXG5cdEJST1dTRVJfREVGQVVMVF9XRUJHTDogMzc0NDQsXG5cdEJVRkZFUl9TSVpFOiAzNDY2MCxcblx0QlVGRkVSX1VTQUdFOiAzNDY2MSxcblx0QllURTogNTEyMCxcblx0Q0NXOiAyMzA1LFxuXHRDTEFNUF9UT19FREdFOiAzMzA3MSxcblx0Q09MT1JfQVRUQUNITUVOVDA6IDM2MDY0LFxuXHRDT0xPUl9CVUZGRVJfQklUOiAxNjM4NCxcblx0Q09MT1JfQ0xFQVJfVkFMVUU6IDMxMDYsXG5cdENPTE9SX1dSSVRFTUFTSzogMzEwNyxcblx0Q09NUElMRV9TVEFUVVM6IDM1NzEzLFxuXHRDT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUzogMzQ0NjcsXG5cdENPTlNUQU5UX0FMUEhBOiAzMjc3MSxcblx0Q09OU1RBTlRfQ09MT1I6IDMyNzY5LFxuXHRDT05URVhUX0xPU1RfV0VCR0w6IDM3NDQyLFxuXHRDVUxMX0ZBQ0U6IDI4ODQsXG5cdENVTExfRkFDRV9NT0RFOiAyODg1LFxuXHRDVVJSRU5UX1BST0dSQU06IDM1NzI1LFxuXHRDVVJSRU5UX1ZFUlRFWF9BVFRSSUI6IDM0MzQyLFxuXHRDVzogMjMwNCxcblx0REVDUjogNzY4Myxcblx0REVDUl9XUkFQOiAzNDA1Nixcblx0REVMRVRFX1NUQVRVUzogMzU3MTIsXG5cdERFUFRIX0FUVEFDSE1FTlQ6IDM2MDk2LFxuXHRERVBUSF9CSVRTOiAzNDE0LFxuXHRERVBUSF9CVUZGRVJfQklUOiAyNTYsXG5cdERFUFRIX0NMRUFSX1ZBTFVFOiAyOTMxLFxuXHRERVBUSF9DT01QT05FTlQ6IDY0MDIsXG5cdFJFRDogNjQwMyxcblx0REVQVEhfQ09NUE9ORU5UMTY6IDMzMTg5LFxuXHRERVBUSF9GVU5DOiAyOTMyLFxuXHRERVBUSF9SQU5HRTogMjkyOCxcblx0REVQVEhfU1RFTkNJTDogMzQwNDEsXG5cdERFUFRIX1NURU5DSUxfQVRUQUNITUVOVDogMzMzMDYsXG5cdERFUFRIX1RFU1Q6IDI5MjksXG5cdERFUFRIX1dSSVRFTUFTSzogMjkzMCxcblx0RElUSEVSOiAzMDI0LFxuXHRET05UX0NBUkU6IDQzNTIsXG5cdERTVF9BTFBIQTogNzcyLFxuXHREU1RfQ09MT1I6IDc3NCxcblx0RFlOQU1JQ19EUkFXOiAzNTA0OCxcblx0RUxFTUVOVF9BUlJBWV9CVUZGRVI6IDM0OTYzLFxuXHRFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HOiAzNDk2NSxcblx0RVFVQUw6IDUxNCxcblx0RkFTVEVTVDogNDM1Myxcblx0RkxPQVQ6IDUxMjYsXG5cdEZMT0FUX01BVDI6IDM1Njc0LFxuXHRGTE9BVF9NQVQzOiAzNTY3NSxcblx0RkxPQVRfTUFUNDogMzU2NzYsXG5cdEZMT0FUX1ZFQzI6IDM1NjY0LFxuXHRGTE9BVF9WRUMzOiAzNTY2NSxcblx0RkxPQVRfVkVDNDogMzU2NjYsXG5cdEZSQUdNRU5UX1NIQURFUjogMzU2MzIsXG5cdEZSQU1FQlVGRkVSOiAzNjE2MCxcblx0RlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRTogMzYwNDksXG5cdEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEU6IDM2MDQ4LFxuXHRGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfQ1VCRV9NQVBfRkFDRTogMzYwNTEsXG5cdEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTDogMzYwNTAsXG5cdEZSQU1FQlVGRkVSX0JJTkRJTkc6IDM2MDA2LFxuXHRGUkFNRUJVRkZFUl9DT01QTEVURTogMzYwNTMsXG5cdEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDogMzYwNTQsXG5cdEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzogMzYwNTcsXG5cdEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOiAzNjA1NSxcblx0RlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6IDM2MDYxLFxuXHRGUk9OVDogMTAyOCxcblx0RlJPTlRfQU5EX0JBQ0s6IDEwMzIsXG5cdEZST05UX0ZBQ0U6IDI4ODYsXG5cdEZVTkNfQUREOiAzMjc3NCxcblx0RlVOQ19SRVZFUlNFX1NVQlRSQUNUOiAzMjc3OSxcblx0RlVOQ19TVUJUUkFDVDogMzI3NzgsXG5cdEdFTkVSQVRFX01JUE1BUF9ISU5UOiAzMzE3MCxcblx0R0VRVUFMOiA1MTgsXG5cdEdSRUFURVI6IDUxNixcblx0R1JFRU5fQklUUzogMzQxMSxcblx0SElHSF9GTE9BVDogMzYzMzgsXG5cdEhJR0hfSU5UOiAzNjM0MSxcblx0SU5DUjogNzY4Mixcblx0SU5DUl9XUkFQOiAzNDA1NSxcblx0SU5GT19MT0dfTEVOR1RIOiAzNTcxNixcblx0SU5UOiA1MTI0LFxuXHRJTlRfVkVDMjogMzU2NjcsXG5cdElOVF9WRUMzOiAzNTY2OCxcblx0SU5UX1ZFQzQ6IDM1NjY5LFxuXHRJTlZBTElEX0VOVU06IDEyODAsXG5cdElOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOiAxMjg2LFxuXHRJTlZBTElEX09QRVJBVElPTjogMTI4Mixcblx0SU5WQUxJRF9WQUxVRTogMTI4MSxcblx0SU5WRVJUOiA1Mzg2LFxuXHRLRUVQOiA3NjgwLFxuXHRMRVFVQUw6IDUxNSxcblx0TEVTUzogNTEzLFxuXHRMSU5FQVI6IDk3MjksXG5cdExJTkVBUl9NSVBNQVBfTElORUFSOiA5OTg3LFxuXHRMSU5FQVJfTUlQTUFQX05FQVJFU1Q6IDk5ODUsXG5cdExJTkVTOiAxLFxuXHRMSU5FX0xPT1A6IDIsXG5cdExJTkVfU1RSSVA6IDMsXG5cdExJTkVfV0lEVEg6IDI4NDksXG5cdExJTktfU1RBVFVTOiAzNTcxNCxcblx0TE9XX0ZMT0FUOiAzNjMzNixcblx0TE9XX0lOVDogMzYzMzksXG5cdExVTUlOQU5DRTogNjQwOSxcblx0TFVNSU5BTkNFX0FMUEhBOiA2NDEwLFxuXHRNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUzogMzU2NjEsXG5cdE1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkU6IDM0MDc2LFxuXHRNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTOiAzNjM0OSxcblx0TUFYX1JFTkRFUkJVRkZFUl9TSVpFOiAzNDAyNCxcblx0TUFYX1RFWFRVUkVfSU1BR0VfVU5JVFM6IDM0OTMwLFxuXHRNQVhfVEVYVFVSRV9TSVpFOiAzMzc5LFxuXHRNQVhfVkFSWUlOR19WRUNUT1JTOiAzNjM0OCxcblx0TUFYX1ZFUlRFWF9BVFRSSUJTOiAzNDkyMSxcblx0TUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTOiAzNTY2MCxcblx0TUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlM6IDM2MzQ3LFxuXHRNQVhfVklFV1BPUlRfRElNUzogMzM4Nixcblx0TUVESVVNX0ZMT0FUOiAzNjMzNyxcblx0TUVESVVNX0lOVDogMzYzNDAsXG5cdE1JUlJPUkVEX1JFUEVBVDogMzM2NDgsXG5cdE5FQVJFU1Q6IDk3MjgsXG5cdE5FQVJFU1RfTUlQTUFQX0xJTkVBUjogOTk4Nixcblx0TkVBUkVTVF9NSVBNQVBfTkVBUkVTVDogOTk4NCxcblx0TkVWRVI6IDUxMixcblx0TklDRVNUOiA0MzU0LFxuXHROT05FOiAwLFxuXHROT1RFUVVBTDogNTE3LFxuXHROT19FUlJPUjogMCxcblx0TlVNX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTOiAzNDQ2Nixcblx0T05FOiAxLFxuXHRPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEE6IDMyNzcyLFxuXHRPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1I6IDMyNzcwLFxuXHRPTkVfTUlOVVNfRFNUX0FMUEhBOiA3NzMsXG5cdE9ORV9NSU5VU19EU1RfQ09MT1I6IDc3NSxcblx0T05FX01JTlVTX1NSQ19BTFBIQTogNzcxLFxuXHRPTkVfTUlOVVNfU1JDX0NPTE9SOiA3NjksXG5cdE9VVF9PRl9NRU1PUlk6IDEyODUsXG5cdFBBQ0tfQUxJR05NRU5UOiAzMzMzLFxuXHRQT0lOVFM6IDAsXG5cdFBPTFlHT05fT0ZGU0VUX0ZBQ1RPUjogMzI4MjQsXG5cdFBPTFlHT05fT0ZGU0VUX0ZJTEw6IDMyODIzLFxuXHRQT0xZR09OX09GRlNFVF9VTklUUzogMTA3NTIsXG5cdFJFRF9CSVRTOiAzNDEwLFxuXHRSRU5ERVJCVUZGRVI6IDM2MTYxLFxuXHRSRU5ERVJCVUZGRVJfQUxQSEFfU0laRTogMzYxNzksXG5cdFJFTkRFUkJVRkZFUl9CSU5ESU5HOiAzNjAwNyxcblx0UkVOREVSQlVGRkVSX0JMVUVfU0laRTogMzYxNzgsXG5cdFJFTkRFUkJVRkZFUl9ERVBUSF9TSVpFOiAzNjE4MCxcblx0UkVOREVSQlVGRkVSX0dSRUVOX1NJWkU6IDM2MTc3LFxuXHRSRU5ERVJCVUZGRVJfSEVJR0hUOiAzNjE2Myxcblx0UkVOREVSQlVGRkVSX0lOVEVSTkFMX0ZPUk1BVDogMzYxNjQsXG5cdFJFTkRFUkJVRkZFUl9SRURfU0laRTogMzYxNzYsXG5cdFJFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkU6IDM2MTgxLFxuXHRSRU5ERVJCVUZGRVJfV0lEVEg6IDM2MTYyLFxuXHRSRU5ERVJFUjogNzkzNyxcblx0UkVQRUFUOiAxMDQ5Nyxcblx0UkVQTEFDRTogNzY4MSxcblx0UkdCOiA2NDA3LFxuXHRSR0I1X0ExOiAzMjg1NSxcblx0UkdCNTY1OiAzNjE5NCxcblx0UkdCQTogNjQwOCxcblx0UkdCQTQ6IDMyODU0LFxuXHRTQU1QTEVSXzJEOiAzNTY3OCxcblx0U0FNUExFUl9DVUJFOiAzNTY4MCxcblx0U0FNUExFUzogMzI5MzcsXG5cdFNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRTogMzI5MjYsXG5cdFNBTVBMRV9CVUZGRVJTOiAzMjkzNixcblx0U0FNUExFX0NPVkVSQUdFOiAzMjkyOCxcblx0U0FNUExFX0NPVkVSQUdFX0lOVkVSVDogMzI5MzksXG5cdFNBTVBMRV9DT1ZFUkFHRV9WQUxVRTogMzI5MzgsXG5cdFNDSVNTT1JfQk9YOiAzMDg4LFxuXHRTQ0lTU09SX1RFU1Q6IDMwODksXG5cdFNIQURFUl9DT01QSUxFUjogMzYzNDYsXG5cdFNIQURFUl9TT1VSQ0VfTEVOR1RIOiAzNTcyMCxcblx0U0hBREVSX1RZUEU6IDM1NjYzLFxuXHRTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT046IDM1NzI0LFxuXHRTSE9SVDogNTEyMixcblx0U1JDX0FMUEhBOiA3NzAsXG5cdFNSQ19BTFBIQV9TQVRVUkFURTogNzc2LFxuXHRTUkNfQ09MT1I6IDc2OCxcblx0U1RBVElDX0RSQVc6IDM1MDQ0LFxuXHRTVEVOQ0lMX0FUVEFDSE1FTlQ6IDM2MTI4LFxuXHRTVEVOQ0lMX0JBQ0tfRkFJTDogMzQ4MTcsXG5cdFNURU5DSUxfQkFDS19GVU5DOiAzNDgxNixcblx0U1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfRkFJTDogMzQ4MTgsXG5cdFNURU5DSUxfQkFDS19QQVNTX0RFUFRIX1BBU1M6IDM0ODE5LFxuXHRTVEVOQ0lMX0JBQ0tfUkVGOiAzNjAwMyxcblx0U1RFTkNJTF9CQUNLX1ZBTFVFX01BU0s6IDM2MDA0LFxuXHRTVEVOQ0lMX0JBQ0tfV1JJVEVNQVNLOiAzNjAwNSxcblx0U1RFTkNJTF9CSVRTOiAzNDE1LFxuXHRTVEVOQ0lMX0JVRkZFUl9CSVQ6IDEwMjQsXG5cdFNURU5DSUxfQ0xFQVJfVkFMVUU6IDI5NjEsXG5cdFNURU5DSUxfRkFJTDogMjk2NCxcblx0U1RFTkNJTF9GVU5DOiAyOTYyLFxuXHRTVEVOQ0lMX0lOREVYOiA2NDAxLFxuXHRTVEVOQ0lMX0lOREVYODogMzYxNjgsXG5cdFNURU5DSUxfUEFTU19ERVBUSF9GQUlMOiAyOTY1LFxuXHRTVEVOQ0lMX1BBU1NfREVQVEhfUEFTUzogMjk2Nixcblx0U1RFTkNJTF9SRUY6IDI5NjcsXG5cdFNURU5DSUxfVEVTVDogMjk2MCxcblx0U1RFTkNJTF9WQUxVRV9NQVNLOiAyOTYzLFxuXHRTVEVOQ0lMX1dSSVRFTUFTSzogMjk2OCxcblx0U1RSRUFNX0RSQVc6IDM1MDQwLFxuXHRTVUJQSVhFTF9CSVRTOiAzNDA4LFxuXHRURVhUVVJFOiA1ODkwLFxuXHRURVhUVVJFMDogMzM5ODQsXG5cdFRFWFRVUkUxOiAzMzk4NSxcblx0VEVYVFVSRTI6IDMzOTg2LFxuXHRURVhUVVJFMzogMzM5ODcsXG5cdFRFWFRVUkU0OiAzMzk4OCxcblx0VEVYVFVSRTU6IDMzOTg5LFxuXHRURVhUVVJFNjogMzM5OTAsXG5cdFRFWFRVUkU3OiAzMzk5MSxcblx0VEVYVFVSRTg6IDMzOTkyLFxuXHRURVhUVVJFOTogMzM5OTMsXG5cdFRFWFRVUkUxMDogMzM5OTQsXG5cdFRFWFRVUkUxMTogMzM5OTUsXG5cdFRFWFRVUkUxMjogMzM5OTYsXG5cdFRFWFRVUkUxMzogMzM5OTcsXG5cdFRFWFRVUkUxNDogMzM5OTgsXG5cdFRFWFRVUkUxNTogMzM5OTksXG5cdFRFWFRVUkUxNjogMzQwMDAsXG5cdFRFWFRVUkUxNzogMzQwMDEsXG5cdFRFWFRVUkUxODogMzQwMDIsXG5cdFRFWFRVUkUxOTogMzQwMDMsXG5cdFRFWFRVUkUyMDogMzQwMDQsXG5cdFRFWFRVUkUyMTogMzQwMDUsXG5cdFRFWFRVUkUyMjogMzQwMDYsXG5cdFRFWFRVUkUyMzogMzQwMDcsXG5cdFRFWFRVUkUyNDogMzQwMDgsXG5cdFRFWFRVUkUyNTogMzQwMDksXG5cdFRFWFRVUkUyNjogMzQwMTAsXG5cdFRFWFRVUkUyNzogMzQwMTEsXG5cdFRFWFRVUkUyODogMzQwMTIsXG5cdFRFWFRVUkUyOTogMzQwMTMsXG5cdFRFWFRVUkUzMDogMzQwMTQsXG5cdFRFWFRVUkUzMTogMzQwMTUsXG5cdFRFWFRVUkVfMkQ6IDM1NTMsXG5cdFRFWFRVUkVfQklORElOR18yRDogMzI4NzMsXG5cdFRFWFRVUkVfQklORElOR19DVUJFX01BUDogMzQwNjgsXG5cdFRFWFRVUkVfQ1VCRV9NQVA6IDM0MDY3LFxuXHRURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1g6IDM0MDcwLFxuXHRURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1k6IDM0MDcyLFxuXHRURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1o6IDM0MDc0LFxuXHRURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1g6IDM0MDY5LFxuXHRURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1k6IDM0MDcxLFxuXHRURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1o6IDM0MDczLFxuXHRURVhUVVJFX01BR19GSUxURVI6IDEwMjQwLFxuXHRURVhUVVJFX01JTl9GSUxURVI6IDEwMjQxLFxuXHRURVhUVVJFX1dSQVBfUzogMTAyNDIsXG5cdFRFWFRVUkVfV1JBUF9UOiAxMDI0Myxcblx0VFJJQU5HTEVTOiA0LFxuXHRUUklBTkdMRV9GQU46IDYsXG5cdFRSSUFOR0xFX1NUUklQOiA1LFxuXHRVTlBBQ0tfQUxJR05NRU5UOiAzMzE3LFxuXHRVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMOiAzNzQ0Myxcblx0VU5QQUNLX0ZMSVBfWV9XRUJHTDogMzc0NDAsXG5cdFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTDogMzc0NDEsXG5cdFVOU0lHTkVEX0JZVEU6IDUxMjEsXG5cdFVOU0lHTkVEX0lOVDogNTEyNSxcblx0VU5TSUdORURfU0hPUlQ6IDUxMjMsXG5cdFVOU0lHTkVEX1NIT1JUXzRfNF80XzQ6IDMyODE5LFxuXHRVTlNJR05FRF9TSE9SVF81XzVfNV8xOiAzMjgyMCxcblx0VU5TSUdORURfU0hPUlRfNV82XzU6IDMzNjM1LFxuXHRWQUxJREFURV9TVEFUVVM6IDM1NzE1LFxuXHRWRU5ET1I6IDc5MzYsXG5cdFZFUlNJT046IDc5MzgsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfQlVGRkVSX0JJTkRJTkc6IDM0OTc1LFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX0VOQUJMRUQ6IDM0MzM4LFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRUQ6IDM0OTIyLFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX1BPSU5URVI6IDM0MzczLFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX1NJWkU6IDM0MzM5LFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX1NUUklERTogMzQzNDAsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRTogMzQzNDEsXG5cdFZFUlRFWF9TSEFERVI6IDM1NjMzLFxuXHRWSUVXUE9SVDogMjk3OCxcblx0WkVSTzogMCxcblx0Ujg6IDMzMzIxLFxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9XZWJnbENvbnN0LmpzIiwiLy8gZ2V0QXR0cmliTG9jLmpzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChnbCwgc2hhZGVyUHJvZ3JhbSwgbmFtZSkge1xuXHRpZihzaGFkZXJQcm9ncmFtLmNhY2hlQXR0cmliTG9jID09PSB1bmRlZmluZWQpIHtcdHNoYWRlclByb2dyYW0uY2FjaGVBdHRyaWJMb2MgPSB7fTtcdH1cblx0aWYoc2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvY1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0c2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvY1tuYW1lXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHNoYWRlclByb2dyYW0sIG5hbWUpO1xuXHR9XG5cblx0cmV0dXJuIHNoYWRlclByb2dyYW0uY2FjaGVBdHRyaWJMb2NbbmFtZV07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldEF0dHJpYkxvYy5qcyIsIi8vIE1hdGVyaWFsLmpzXG5cbmltcG9ydCBTaGFkZXJzIGZyb20gJy4vc2hhZGVycy9TaGFkZXJzJztcbmltcG9ydCBvYmplY3RBc3NpZ24gZnJvbSAnb2JqZWN0LWFzc2lnbic7XG5cbmNsYXNzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3Rvcih2cywgZnMsIHVuaWZvcm1zPXt9LCBkZWZpbmVzPXt9KSB7XG5cdFx0dGhpcy5fc2hhZGVyID0gU2hhZGVycy5nZXQodnMsIGZzLCBkZWZpbmVzKTtcblx0XHR0aGlzLnVuaWZvcm1zID0gb2JqZWN0QXNzaWduKHt9LCB1bmlmb3Jtcyk7XG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cdFx0dGhpcy5fc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLl9zaGFkZXIudW5pZm9ybSh0aGlzLnVuaWZvcm1zKTtcblx0fVxuXG5cblx0Z2V0IHNoYWRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2hhZGVyO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hdGVyaWFsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL01hdGVyaWFsLmpzIiwiLy8gRXZlbnREaXNwYXRjaGVyLmpzXG5cbmxldCBzdXBwb3J0c0N1c3RvbUV2ZW50cyA9IHRydWU7XG50cnkge1xuXHRsZXQgbmV3VGVzdEN1c3RvbUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG5cdG5ld1Rlc3RDdXN0b21FdmVudCA9IG51bGw7XG59IGNhdGNoKGUpIHtcblx0c3VwcG9ydHNDdXN0b21FdmVudHMgPSBmYWxzZTtcbn1cblxuY2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuXHR9XG5cblxuXHRhZGRFdmVudExpc3RlbmVyKGFFdmVudFR5cGUsIGFGdW5jdGlvbikge1xuXG5cdFx0aWYodGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IG51bGwgfHwgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHR9XG5cblx0XHRpZighdGhpcy5fZXZlbnRMaXN0ZW5lcnNbYUV2ZW50VHlwZV0pIHtcblx0XHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdID0gW107XG5cdFx0fVxuXHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdLnB1c2goYUZ1bmN0aW9uKTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0b24oYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKSB7XHRyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKGFFdmVudFR5cGUsIGFGdW5jdGlvbik7XHR9XG5cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pIHtcblx0XHRpZih0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gbnVsbCB8fCB0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuXHRcdH1cblx0XHRjb25zdCBjdXJyZW50QXJyYXkgPSB0aGlzLl9ldmVudExpc3RlbmVyc1thRXZlbnRUeXBlXTtcblx0XHRcblx0XHRpZiAodHlwZW9mKGN1cnJlbnRBcnJheSkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0bGV0IGN1cnJlbnRBcnJheUxlbmd0aCA9IGN1cnJlbnRBcnJheS5sZW5ndGg7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcnJheUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZihjdXJyZW50QXJyYXlbaV0gPT09IGFGdW5jdGlvbikge1xuXHRcdFx0XHRjdXJyZW50QXJyYXkuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRpLS07XG5cdFx0XHRcdGN1cnJlbnRBcnJheUxlbmd0aC0tO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdG9mZihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pIHtcdHJldHVybiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKTtcdH1cblxuXHRkaXNwYXRjaEV2ZW50KGFFdmVudCkge1xuXHRcdGlmKHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSBudWxsIHx8IHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge307XG5cdFx0fVxuXHRcdGNvbnN0IGV2ZW50VHlwZSA9IGFFdmVudC50eXBlO1xuXHRcdFxuXHRcdHRyeSB7XG5cdFx0XHRpZihhRXZlbnQudGFyZ2V0ID09PSBudWxsKSB7XG5cdFx0XHRcdGFFdmVudC50YXJnZXQgPSB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0YUV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXHRcdH0gY2F0Y2godGhlRXJyb3IpIHtcblx0XHRcdGNvbnN0IG5ld0V2ZW50ID0geyB0eXBlOiBldmVudFR5cGUsIGRldGFpbDogYUV2ZW50LmRldGFpbCwgZGlzcGF0Y2hlcjogdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnN0IGN1cnJlbnRFdmVudExpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50VHlwZV07XG5cdFx0aWYoY3VycmVudEV2ZW50TGlzdGVuZXJzICE9PSBudWxsICYmIGN1cnJlbnRFdmVudExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBjdXJyZW50QXJyYXkgPSB0aGlzLl9jb3B5QXJyYXkoY3VycmVudEV2ZW50TGlzdGVuZXJzKTtcblx0XHRcdGNvbnN0IGN1cnJlbnRBcnJheUxlbmd0aCA9IGN1cnJlbnRBcnJheS5sZW5ndGg7XG5cdFx0XHRmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudEFycmF5TGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY3VycmVudEZ1bmN0aW9uID0gY3VycmVudEFycmF5W2ldO1xuXHRcdFx0XHRjdXJyZW50RnVuY3Rpb24uY2FsbCh0aGlzLCBhRXZlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGRpc3BhdGNoQ3VzdG9tRXZlbnQoYUV2ZW50VHlwZSwgYURldGFpbCkge1xuXHRcdGxldCBuZXdFdmVudDtcblx0XHRpZiAoc3VwcG9ydHNDdXN0b21FdmVudHMpIHtcblx0XHRcdG5ld0V2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG5cdFx0XHRuZXdFdmVudC5kaXNwYXRjaGVyID0gdGhpcztcblx0XHRcdG5ld0V2ZW50LmluaXRDdXN0b21FdmVudChhRXZlbnRUeXBlLCBmYWxzZSwgZmFsc2UsIGFEZXRhaWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdFdmVudCA9IHsgdHlwZTogYUV2ZW50VHlwZSwgZGV0YWlsOiBhRGV0YWlsLCBkaXNwYXRjaGVyOiB0aGlzIH07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9XG5cblx0dHJpZ2dlcihhRXZlbnRUeXBlLCBhRGV0YWlsKSB7XHRyZXR1cm4gdGhpcy5kaXNwYXRjaEN1c3RvbUV2ZW50KGFFdmVudFR5cGUsIGFEZXRhaWwpO1x0fVxuXG5cdF9kZXN0cm95KCkge1xuXHRcdGlmKHRoaXMuX2V2ZW50TGlzdGVuZXJzICE9PSBudWxsKSB7XG5cdFx0XHRmb3IoY29uc3Qgb2JqZWN0TmFtZSBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuXHRcdFx0XHRpZih0aGlzLl9ldmVudExpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShvYmplY3ROYW1lKSkge1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRBcnJheSA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW29iamVjdE5hbWVdO1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRBcnJheUxlbmd0aCA9IGN1cnJlbnRBcnJheS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcnJheUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50QXJyYXlbaV0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbb2JqZWN0TmFtZV07XHRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdF9jb3B5QXJyYXkoYUFycmF5KSB7XG5cdFx0Y29uc3QgY3VycmVudEFycmF5ID0gbmV3IEFycmF5KGFBcnJheS5sZW5ndGgpO1xuXHRcdGNvbnN0IGN1cnJlbnRBcnJheUxlbmd0aCA9IGN1cnJlbnRBcnJheS5sZW5ndGg7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcnJheUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjdXJyZW50QXJyYXlbaV0gPSBhQXJyYXlbaV07XG5cdFx0fVxuXHRcdHJldHVybiBjdXJyZW50QXJyYXk7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBFdmVudERpc3BhdGNoZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvRXZlbnREaXNwYXRjaGVyLmpzIiwiLy8gT3JiaXRhbENvbnRyb2wuanNcbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEVhc2VOdW1iZXIgZnJvbSAnLi9FYXNlTnVtYmVyJztcbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAgJ3NjaGVkdWxpbmcnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IGdldE1vdXNlID0gZnVuY3Rpb24gKG1FdmVudCwgbVRhcmdldCkge1xuXG5cdGNvbnN0IG8gPSBtVGFyZ2V0IHx8IHt9O1xuXHRpZihtRXZlbnQudG91Y2hlcykge1xuXHRcdG8ueCA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdG8ueSA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXHR9IGVsc2Uge1xuXHRcdG8ueCA9IG1FdmVudC5jbGllbnRYO1xuXHRcdG8ueSA9IG1FdmVudC5jbGllbnRZO1xuXHR9XG5cblx0cmV0dXJuIG87XG59O1xuXG5jbGFzcyBPcmJpdGFsQ29udHJvbCB7XG5cblx0Y29uc3RydWN0b3IobVRhcmdldCwgbUxpc3RlbmVyVGFyZ2V0ID0gd2luZG93LCBtUmFkaXVzID0gNTAwKSB7XG5cdFx0dGhpcy5fdGFyZ2V0ICAgICAgICAgPSBtVGFyZ2V0O1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0ID0gbUxpc3RlbmVyVGFyZ2V0O1xuXHRcdHRoaXMuX21vdXNlICAgICAgICAgID0ge307XG5cdFx0dGhpcy5fcHJlTW91c2UgICAgICAgPSB7fTtcblx0XHR0aGlzLmNlbnRlciAgICAgICAgICA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGhpcy5fdXAgICAgICAgICAgICAgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCk7XG5cdFx0dGhpcy5yYWRpdXMgICAgICAgICAgPSBuZXcgRWFzZU51bWJlcihtUmFkaXVzKTtcblx0XHR0aGlzLnBvc2l0aW9uICAgICAgICA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCB0aGlzLnJhZGl1cy52YWx1ZSk7XG5cdFx0dGhpcy5wb3NpdGlvbk9mZnNldCAgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3J4ICAgICAgICAgICAgID0gbmV3IEVhc2VOdW1iZXIoMCk7XG5cdFx0dGhpcy5fcngubGltaXQoLU1hdGguUEkgLyAyLCBNYXRoLlBJIC8gMik7XG5cdFx0dGhpcy5fcnkgICAgICAgICAgICAgPSBuZXcgRWFzZU51bWJlcigwKTtcblx0XHR0aGlzLl9wcmVSWCAgICAgICAgICA9IDA7XG5cdFx0dGhpcy5fcHJlUlkgICAgICAgICAgPSAwO1xuXHRcdFxuXHRcdHRoaXMuX2lzTG9ja1pvb20gICAgID0gZmFsc2U7XG5cdFx0dGhpcy5faXNMb2NrUm90YXRpb24gPSBmYWxzZTtcblx0XHR0aGlzLl9pc0ludmVydCAgICAgICA9IGZhbHNlO1xuXHRcdHRoaXMuc2Vuc2l0aXZpdHlcdCA9IDEuMDtcblxuXG5cdFx0dGhpcy5fd2hlZWxCaW5kID0gKGUpID0+IHRoaXMuX29uV2hlZWwoZSk7XG5cdFx0dGhpcy5fZG93bkJpbmQgPSAoZSkgPT4gdGhpcy5fb25Eb3duKGUpO1xuXHRcdHRoaXMuX21vdmVCaW5kID0gKGUpID0+IHRoaXMuX29uTW92ZShlKTtcblx0XHR0aGlzLl91cEJpbmQgPSAoKSA9PiB0aGlzLl9vblVwKCk7XG5cdFxuXHRcdHRoaXMuY29ubmVjdCgpO1x0XHRcblx0XHRTY2hlZHVsZXIuYWRkRUYoKCkgPT4gdGhpcy5fbG9vcCgpKTtcblx0fVxuXG5cdGNvbm5lY3QoKSB7XG5cdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fd2hlZWxCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMuX3doZWVsQmluZCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9kb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2Rvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fbW92ZUJpbmQpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3VwQmluZCk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl91cEJpbmQpO1xuXHR9XG5cblx0ZGlzY29ubmVjdCgpIHtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fd2hlZWxCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMuX3doZWVsQmluZCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9kb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2Rvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fbW92ZUJpbmQpO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3VwQmluZCk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl91cEJpbmQpO1xuXHR9XG5cblxuXHQvL1x0UFVCTElDIE1FVEhPRFNcblxuXHRsb2NrKG1WYWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0xvY2tab29tID0gbVZhbHVlO1xuXHRcdHRoaXMuX2lzTG9ja1JvdGF0aW9uID0gbVZhbHVlO1xuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7XG5cdH1cblxuXHRsb2NrWm9vbShtVmFsdWUgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNMb2NrWm9vbSA9IG1WYWx1ZTtcblx0fVxuXG5cblx0bG9ja1JvdGF0aW9uKG1WYWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0xvY2tSb3RhdGlvbiA9IG1WYWx1ZTtcblx0fVxuXG5cblx0aW52ZXJzZUNvbnRyb2woaXNJbnZlcnQgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNJbnZlcnQgPSBpc0ludmVydDtcblx0fVxuXG5cblx0Ly9cdEVWRU5UIEhBTkRMRVJFU1xuXHRfb25Eb3duKG1FdmVudCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja1JvdGF0aW9uKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gdHJ1ZTtcblx0XHRnZXRNb3VzZShtRXZlbnQsIHRoaXMuX21vdXNlKTtcblx0XHRnZXRNb3VzZShtRXZlbnQsIHRoaXMuX3ByZU1vdXNlKTtcblx0XHR0aGlzLl9wcmVSWCA9IHRoaXMuX3J4LnRhcmdldFZhbHVlO1xuXHRcdHRoaXMuX3ByZVJZID0gdGhpcy5fcnkudGFyZ2V0VmFsdWU7XG5cdH1cblxuXG5cdF9vbk1vdmUobUV2ZW50KSB7XG5cdFx0aWYodGhpcy5faXNMb2NrUm90YXRpb24pIHsgcmV0dXJuOyB9XG5cdFx0Z2V0TW91c2UobUV2ZW50LCB0aGlzLl9tb3VzZSk7XG5cdFx0aWYobUV2ZW50LnRvdWNoZXMpIHsgbUV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH1cblxuXHRcdGlmKHRoaXMuX2lzTW91c2VEb3duKSB7XG5cdFx0XHRsZXQgZGlmZlggPSAtKHRoaXMuX21vdXNlLnggLSB0aGlzLl9wcmVNb3VzZS54KTtcblx0XHRcdGlmKHRoaXMuX2lzSW52ZXJ0KSB7IGRpZmZYICo9IC0xOyB9XG5cdFx0XHR0aGlzLl9yeS52YWx1ZSA9IHRoaXMuX3ByZVJZIC0gZGlmZlggKiAwLjAxICogdGhpcy5zZW5zaXRpdml0eTtcblxuXHRcdFx0bGV0IGRpZmZZID0gLSh0aGlzLl9tb3VzZS55IC0gdGhpcy5fcHJlTW91c2UueSk7XG5cdFx0XHRpZih0aGlzLl9pc0ludmVydCkgeyBkaWZmWSAqPSAtMTsgfVxuXHRcdFx0dGhpcy5fcngudmFsdWUgPSB0aGlzLl9wcmVSWCAtIGRpZmZZICogMC4wMSAqIHRoaXMuc2Vuc2l0aXZpdHk7XG5cdFx0fVxuXHR9XG5cblxuXHRfb25VcCgpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tSb3RhdGlvbikgeyByZXR1cm47IH1cblx0XHR0aGlzLl9pc01vdXNlRG93biA9IGZhbHNlO1xuXHR9XG5cblxuXHRfb25XaGVlbChtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tab29tKSB7XHRyZXR1cm47XHR9XG5cdFx0Y29uc3QgdyA9IG1FdmVudC53aGVlbERlbHRhO1xuXHRcdGNvbnN0IGQgPSBtRXZlbnQuZGV0YWlsO1xuXHRcdGxldCB2YWx1ZSA9IDA7XG5cdFx0aWYgKGQpIHtcblx0XHRcdGlmICh3KSB7XG5cdFx0XHRcdHZhbHVlID0gdyAvIGQgLyA0MCAqIGQgPiAwID8gMSA6IC0xOyAvLyBPcGVyYVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSAtZCAvIDM7ICAgICAgICAgICAgICAvLyBGaXJlZm94OyAgICAgICAgIFRPRE86IGRvIG5vdCAvMyBmb3IgT1MgWFxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHcgLyAxMjA7IFxuXHRcdH1cblxuXHRcdHRoaXMucmFkaXVzLmFkZCgtdmFsdWUgKiAyKTtcblx0fVxuXG5cblx0Ly9cdFBSSVZBVEUgTUVUSE9EU1xuXG5cdF9sb29wKCkge1xuXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuXHRcdGlmKHRoaXMuX3RhcmdldCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlQ2FtZXJhKCk7XG5cdFx0fVxuXHR9XG5cblxuXHRfdXBkYXRlUG9zaXRpb24oKSB7XG5cdFx0dGhpcy5wb3NpdGlvblsxXSA9IE1hdGguc2luKHRoaXMuX3J4LnZhbHVlKSAqIHRoaXMucmFkaXVzLnZhbHVlO1xuXHRcdGNvbnN0IHRyID0gTWF0aC5jb3ModGhpcy5fcngudmFsdWUpICogdGhpcy5yYWRpdXMudmFsdWU7XG5cdFx0dGhpcy5wb3NpdGlvblswXSA9IE1hdGguY29zKHRoaXMuX3J5LnZhbHVlICsgTWF0aC5QSSAqIDAuNSkgKiB0cjtcblx0XHR0aGlzLnBvc2l0aW9uWzJdID0gTWF0aC5zaW4odGhpcy5fcnkudmFsdWUgKyBNYXRoLlBJICogMC41KSAqIHRyO1xuXHRcdHZlYzMuYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb25PZmZzZXQpO1xuXHR9XG5cblxuXHRfdXBkYXRlQ2FtZXJhKCkge1xuXHRcdHRoaXMuX3RhcmdldC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGhpcy5jZW50ZXIsIHRoaXMuX3VwKTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUiAvIFNFVFRFUlxuXG5cblx0Z2V0IHJ4KCkge1xuXHRcdHJldHVybiB0aGlzLl9yeDtcblx0fVxuXG5cblx0Z2V0IHJ5KCkge1xuXHRcdHJldHVybiB0aGlzLl9yeTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE9yYml0YWxDb250cm9sO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL09yYml0YWxDb250cm9sLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGdlbmVyYWxXaXRoTm9ybWFsLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEdFTkVSQUxfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVOb3JtYWxNYXRyaXg7XFxuXFxudW5pZm9ybSB2ZWMzIHBvc2l0aW9uO1xcbnVuaWZvcm0gdmVjMyBzY2FsZTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdHZlYzMgcG9zICAgICAgPSBhVmVydGV4UG9zaXRpb24gKiBzY2FsZTtcXG5cXHRwb3MgICAgICAgICAgICs9IHBvc2l0aW9uO1xcblxcdGdsX1Bvc2l0aW9uICAgPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChwb3MsIDEuMCk7XFxuXFx0XFxuXFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0dk5vcm1hbCAgICAgICA9IG5vcm1hbGl6ZSh1Tm9ybWFsTWF0cml4ICogYU5vcm1hbCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2dlbmVyYWwudmVydFxuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0tZQk9YX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2VmVydGV4O1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0bWF0NCBtYXRWaWV3ID0gdVZpZXdNYXRyaXg7XFxuXFx0bWF0Vmlld1szXVswXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzFdID0gMC4wO1xcblxcdG1hdFZpZXdbM11bMl0gPSAwLjA7XFxuXFx0XFxuXFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIG1hdFZpZXcgKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG5cXHR2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG5cXHRcXG5cXHR2VmVydGV4ID0gYVZlcnRleFBvc2l0aW9uO1xcblxcdHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9za3lib3gudmVydFxuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0tZQk9YX0ZSQUdNRU5UXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG51bmlmb3JtIHNhbXBsZXJDdWJlIHRleHR1cmU7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZWZXJ0ZXg7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUodGV4dHVyZSwgdlZlcnRleCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL3NreWJveC5mcmFnXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIENhbWVyYU9ydGhvLmpzXG5cbmltcG9ydCBDYW1lcmEgZnJvbSAnLi9DYW1lcmEnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNsYXNzIENhbWVyYU9ydGhvIGV4dGVuZHMgQ2FtZXJhIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGNvbnN0IGV5ZSAgICA9IHZlYzMuY2xvbmUoWzAsIDAsIDE1XSk7XG5cdFx0Y29uc3QgY2VudGVyID0gdmVjMy5jcmVhdGUoKTtcblx0XHRjb25zdCB1cCAgICAgPSB2ZWMzLmNsb25lKFswLCAtMSwgMF0pO1xuXHRcdHRoaXMubG9va0F0KGV5ZSwgY2VudGVyLCB1cCk7XG5cdFx0dGhpcy5vcnRobygxLCAtMSwgMSwgLTEpO1xuXHR9XG5cblxuXHRzZXRCb3VuZGFyeShsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXI9MC4xLCBmYXI9MTAwKSB7XG5cdFx0dGhpcy5vcnRobyhsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcik7XG5cdH1cblxuXG5cdG9ydGhvKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhcj0wLjEsIGZhcj0xMDApIHtcblx0XHR0aGlzLmxlZnQgICA9IGxlZnQ7XG5cdFx0dGhpcy5yaWdodCAgPSByaWdodDtcblx0XHR0aGlzLnRvcCAgICA9IHRvcDtcblx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblx0XHRtYXQ0Lm9ydGhvKHRoaXMuX3Byb2plY3Rpb24sIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyKTtcblx0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FtZXJhT3J0aG87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFPcnRoby5qcyIsIi8vIGxvYWRJbWFnZXMuanNcblxuaW1wb3J0IFByb21pc2UgZnJvbSAncHJvbWlzZS1wb2x5ZmlsbCc7XG5cbmNvbnN0IGdldCA9ICh1cmwpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cdGltZy5vbmxvYWQgPSBmdW5jdGlvbiBvbkxvYWQoKSB7XG5cdFx0cmVzb2x2ZSh0aGlzKTtcblx0fTtcblxuXHRpbWcub25lcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoKSB7XG5cdFx0cmVqZWN0KGBJbWFnZSBub3QgZm91bmQgOiAke3VybH1gKTtcblx0fTtcblxuXHRpbWcuc3JjID0gdXJsO1xufSk7XG5cblxuY29uc3QgbG9hZEltYWdlcyA9IChwYXRocykgPT4gUHJvbWlzZS5hbGwoXG5cdHBhdGhzLm1hcChnZXQpXG4pO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGxvYWRJbWFnZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9sb2FkSW1hZ2VzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG52YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLy8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5mdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5fc3RhdGUgPSAwO1xuICB0aGlzLl9oYW5kbGVkID0gZmFsc2U7XG4gIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9kZWZlcnJlZHMgPSBbXTtcblxuICBkb1Jlc29sdmUoZm4sIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgd2hpbGUgKHNlbGYuX3N0YXRlID09PSAzKSB7XG4gICAgc2VsZiA9IHNlbGYuX3ZhbHVlO1xuICB9XG4gIGlmIChzZWxmLl9zdGF0ZSA9PT0gMCkge1xuICAgIHNlbGYuX2RlZmVycmVkcy5wdXNoKGRlZmVycmVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VsZi5faGFuZGxlZCA9IHRydWU7XG4gIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYiA9IHNlbGYuX3N0YXRlID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgKHNlbGYuX3N0YXRlID09PSAxID8gcmVzb2x2ZSA6IHJlamVjdCkoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICByZXQgPSBjYihzZWxmLl92YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gIHRyeSB7XG4gICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgIGlmIChcbiAgICAgIG5ld1ZhbHVlICYmXG4gICAgICAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW47XG4gICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHNlbGYuX3N0YXRlID0gMztcbiAgICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRvUmVzb2x2ZShiaW5kKHRoZW4sIG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5fc3RhdGUgPSAxO1xuICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgZmluYWxlKHNlbGYpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHNlbGYsIGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICBzZWxmLl9zdGF0ZSA9IDI7XG4gIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gIGZpbmFsZShzZWxmKTtcbn1cblxuZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3N0YXRlID09PSAyICYmIHNlbGYuX2RlZmVycmVkcy5sZW5ndGggPT09IDApIHtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICAgIGlmICghc2VsZi5faGFuZGxlZCkge1xuICAgICAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbihzZWxmLl92YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaGFuZGxlKHNlbGYsIHNlbGYuX2RlZmVycmVkc1tpXSk7XG4gIH1cbiAgc2VsZi5fZGVmZXJyZWRzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSkge1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgc2VsZikge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIGZuKFxuICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICB9XG4gICAgKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlamVjdChzZWxmLCBleCk7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIHByb20gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgcmV0dXJuIHByb207XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIWFyciB8fCB0eXBlb2YgYXJyLmxlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlLmFsbCBhY2NlcHRzIGFuIGFycmF5Jyk7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZWplY3QoZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuUHJvbWlzZS5faW1tZWRpYXRlRm4gPVxuICAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGZ1bmN0aW9uKGZuKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0pIHx8XG4gIGZ1bmN0aW9uKGZuKSB7XG4gICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICB9O1xuXG5Qcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF91bmhhbmRsZWRSZWplY3Rpb25GbihlcnIpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgY29uc29sZS53YXJuKCdQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb21pc2UtcG9seWZpbGwvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFBhc3NNYWNyby5qc1xuXG5jbGFzcyBQYXNzTWFjcm8ge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9wYXNzZXMgPSBbXTtcblx0fVxuXG5cdGFkZFBhc3MocGFzcykge1xuXHRcdHRoaXMuX3Bhc3Nlcy5wdXNoKHBhc3MpO1xuXHR9XG5cblx0Z2V0IHBhc3NlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFzc2VzO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NNYWNybztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NNYWNyby5qcyIsIi8vIFBhc3NWQmx1ci5qc1xuXG5pbXBvcnQgUGFzc0JsdXJCYXNlIGZyb20gJy4vUGFzc0JsdXJCYXNlJztcblxuY2xhc3MgUGFzc1ZCbHVyIGV4dGVuZHMgUGFzc0JsdXJCYXNlIHtcblx0Y29uc3RydWN0b3IobVF1YWxpdHkgPSA5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpIHtcblx0XHRzdXBlcihtUXVhbGl0eSwgWzAsIDFdLCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NWQmx1cjtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzVkJsdXIuanMiLCIvLyBQYXNzQmx1ckJhc2UuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgUGFzcyBmcm9tICcuL1Bhc3MnO1xuXG5jb25zdCBmc0JsdXI1ID0gcmVxdWlyZSgnLi4vZ2xzbC9ibHVyNS5mcmFnJyk7XG5jb25zdCBmc0JsdXI5ID0gcmVxdWlyZSgnLi4vZ2xzbC9ibHVyOS5mcmFnJyk7XG5jb25zdCBmc0JsdXIxMyA9IHJlcXVpcmUoJy4uL2dsc2wvYmx1cjEzLmZyYWcnKTtcblxuY2xhc3MgUGFzc0JsdXJCYXNlIGV4dGVuZHMgUGFzcyB7XG5cdGNvbnN0cnVjdG9yKG1RdWFsaXR5ID0gOSwgbURpcmVjdGlvbiwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zID0ge30pIHtcblx0XHRsZXQgZnM7XG5cdFx0c3dpdGNoKG1RdWFsaXR5KSB7XG5cdFx0Y2FzZSA1OlxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRmcyA9IGZzQmx1cjU7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDkgOiBcblx0XHRcdGZzID0gZnNCbHVyOTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMTMgOiBcblx0XHRcdGZzID0gZnNCbHVyMTM7XG5cdFx0XHRicmVhaztcblxuXHRcdH1cblx0XHRzdXBlcihmcywgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKTtcblx0XHR0aGlzLnVuaWZvcm0oJ3VEaXJlY3Rpb24nLCBtRGlyZWN0aW9uKTtcblx0XHR0aGlzLnVuaWZvcm0oJ3VSZXNvbHV0aW9uJywgW0dMLndpZHRoLCBHTC5oZWlnaHRdKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzQmx1ckJhc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NCbHVyQmFzZS5qcyIsIi8vIFBhc3NIQmx1ci5qc1xuXG5pbXBvcnQgUGFzc0JsdXJCYXNlIGZyb20gJy4vUGFzc0JsdXJCYXNlJztcblxuY2xhc3MgUGFzc0hCbHVyIGV4dGVuZHMgUGFzc0JsdXJCYXNlIHtcblx0Y29uc3RydWN0b3IobVF1YWxpdHkgPSA5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpIHtcblx0XHRzdXBlcihtUXVhbGl0eSwgWzEsIDBdLCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NIQmx1cjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc0hCbHVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGZ4YWEuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgRlhBQVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xcblxcblxcbmZsb2F0IEZYQUFfU1VCUElYX1NISUZUID0gMS4wLzQuMDtcXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAgICgxLjAvIDEyOC4wKVxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTVVMICAgKDEuMCAvIDguMClcXG4jZGVmaW5lIEZYQUFfU1BBTl9NQVggICAgIDguMFxcblxcblxcbnZlYzQgYXBwbHlGWEFBKHNhbXBsZXIyRCB0ZXgpIHtcXG4gICAgdmVjNCBjb2xvcjtcXG4gICAgdmVjMiBmcmFnQ29vcmQgPSBnbF9GcmFnQ29vcmQueHk7XFxuICAgIHZlYzMgcmdiTlcgPSB0ZXh0dXJlMkQodGV4LCAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAtMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoMS4wLCAtMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYlNFID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoMS4wLCAxLjApKSAqIHVSZXNvbHV0aW9uKS54eXo7XFxuICAgIHZlYzMgcmdiTSAgPSB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyBsdW1hID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcXG4gICAgZmxvYXQgbHVtYU5XID0gZG90KHJnYk5XLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNFID0gZG90KHJnYlNFLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU0gID0gZG90KHJnYk0sICBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcXG4gICAgZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcXG5cXG4gICAgdmVjMiBkaXI7XFxuICAgIGRpci54ID0gLSgobHVtYU5XICsgbHVtYU5FKSAtIChsdW1hU1cgKyBsdW1hU0UpKTtcXG4gICAgZGlyLnkgPSAgKChsdW1hTlcgKyBsdW1hU1cpIC0gKGx1bWFORSArIGx1bWFTRSkpO1xcblxcbiAgICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwpLCBGWEFBX1JFRFVDRV9NSU4pO1xcblxcbiAgICBmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAobWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcXG4gICAgZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksXFxuICAgICAgICAgICAgICBtYXgodmVjMigtRlhBQV9TUEFOX01BWCwgLUZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgZGlyICogcmNwRGlyTWluKSkgKiB1UmVzb2x1dGlvbjtcXG5cXG4gICAgdmVjMyByZ2JBID0gMC41ICogKFxcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogdVJlc29sdXRpb24gKyBkaXIgKiAoMS4wIC8gMy4wIC0gMC41KSkueHl6ICtcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XFxuICAgIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKFxcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogdVJlc29sdXRpb24gKyBkaXIgKiAtMC41KS54eXogK1xcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogdVJlc29sdXRpb24gKyBkaXIgKiAwLjUpLnh5eik7XFxuXFxuICAgIGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcbiAgICBpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXFxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQSwgMS4wKTtcXG4gICAgZWxzZVxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkIsIDEuMCk7XFxuICAgIHJldHVybiBjb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gXFx0dmVjNCBjb2xvciA9IGFwcGx5RlhBQSh0ZXh0dXJlKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2Z4YWEuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJodG1sLCBib2R5IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwb3NpdGlvbjogc3RhdGljO1xcbiAgLyogUGVybWFsaW5rIC0gdXNlIHRvIGVkaXQgYW5kIHNoYXJlIHRoaXMgZ3JhZGllbnQ6IGh0dHA6Ly9jb2xvcnppbGxhLmNvbS9ncmFkaWVudC1lZGl0b3IvIzZkNmQ2ZCswLDAwMDAwMCsxMDAgKi9cXG4gIGJhY2tncm91bmQ6ICMzMzMzMzM7XFxuICAvKiBPbGQgYnJvd3NlcnMgKi9cXG4gIGJhY2tncm91bmQ6IC1tb3otcmFkaWFsLWdyYWRpZW50KGNlbnRlciwgZWxsaXBzZSBjb3ZlciwgIzMzMzMzMyAwJSwgIzAwMDAwMCAxMDAlKTtcXG4gIC8qIEZGMy42LTE1ICovXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LXJhZGlhbC1ncmFkaWVudChjZW50ZXIsIGVsbGlwc2UgY292ZXIsICMzMzMzMzMgMCUsICMwMDAwMDAgMTAwJSk7XFxuICAvKiBDaHJvbWUxMC0yNSxTYWZhcmk1LjEtNiAqL1xcbiAgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KGVsbGlwc2UgYXQgY2VudGVyLCAjMzMzMzMzIDAlLCAjMDAwMDAwIDEwMCUpO1xcbiAgLyogVzNDLCBJRTEwKywgRkYxNissIENocm9tZTI2KywgT3BlcmExMissIFNhZmFyaTcrICovIH1cXG5cXG5odG1sIHtcXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogbm9uZTtcXG4gIC1tb3otdGV4dC1zaXplLWFkanVzdDogbm9uZTtcXG4gIHRleHQtc2l6ZS1hZGp1c3Q6IG5vbmU7IH1cXG5cXG5oMSwgaDIsIGgzLCBoNCwgdGV4dCwgcCB7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC1tb3otb3N4LXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICBmb250LWZhbWlseTogJ09wZW4gU2FucycsIHNhbnMtc2VyaWY7IH1cXG5cXG4uTWFpbi1DYW52YXMge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB0b3A6IDBweDtcXG4gIGxlZnQ6IDBweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgb3BhY2l0eTogMTtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgLjVzIGVhc2Utb3V0IC4yNXM7IH1cXG4gIC5pc0xvYWRpbmcgLk1haW4tQ2FudmFzIHtcXG4gICAgb3BhY2l0eTogMDsgfVxcblxcbi5NZXNzYWdlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgdG9wOiBjYWxjKDUwJSAtIDUwcHgpO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgbGV0dGVyLXNwYWNpbmc6IDExcHg7XFxuICBjb2xvcjogd2hpdGU7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAuNXMgZWFzZS1vdXQsIGxldHRlci1zcGFjaW5nIC41cyBlYXNlLW91dDsgfVxcbiAgLmlzTG9hZGluZyAuTWVzc2FnZSB7XFxuICAgIGxldHRlci1zcGFjaW5nOiAxMHB4O1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuXFxuLkxvYWRpbmctQmFyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IDk5ODtcXG4gIHdpZHRoOiAwJTtcXG4gIGhlaWdodDogMXB4O1xcbiAgdG9wOiA1MCU7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSk7XFxuICBvcGFjaXR5OiAwO1xcbiAgdHJhbnNpdGlvbjogd2lkdGggLjVzIGVhc2Utb3V0LCBvcGFjaXR5IC41cyBlYXNlLW91dDsgfVxcbiAgLmlzTG9hZGluZyAuTG9hZGluZy1CYXIge1xcbiAgICBvcGFjaXR5OiAxOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj91cmw9ZmFsc2UhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL3NyYy9zY3NzL2dsb2JhbC5zY3NzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIlxuXG4vKipcbiAqIDJ4MiBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0MlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDIgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dCBBIG5ldyAyeDIgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGVcbiAgLy8gc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIGxldCBhMSA9IGFbMV07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhMTtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYVsxXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIGxldCBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRldCA9IDEuMCAvIGRldDtcblxuICBvdXRbMF0gPSAgYTMgKiBkZXQ7XG4gIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgb3V0WzJdID0gLWEyICogZGV0O1xuICBvdXRbM10gPSAgYTAgKiBkZXQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIGxldCBhMCA9IGFbMF07XG4gIG91dFswXSA9ICBhWzNdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9ICBhMDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXG59XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBMRFUoTCwgRCwgVSwgYSkge1xuICBMWzJdID0gYVsyXS9hWzBdO1xuICBVWzBdID0gYVswXTtcbiAgVVsxXSA9IGFbMV07XG4gIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV07XG4gIHJldHVybiBbTCwgRCwgVV07XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogMngzIE1hdHJpeFxuICogQG1vZHVsZSBtYXQyZFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQyZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IGMgQ29tcG9uZW50IEMgKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gdHkgQ29tcG9uZW50IFRZIChpbmRleCA1KVxuICogQHJldHVybnMge21hdDJkfSBBIG5ldyBtYXQyZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICBvdXRbMl0gPSBjO1xuICBvdXRbM10gPSBkO1xuICBvdXRbNF0gPSB0eDtcbiAgb3V0WzVdID0gdHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MmQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgb3V0WzJdID0gYztcbiAgb3V0WzNdID0gZDtcbiAgb3V0WzRdID0gdHg7XG4gIG91dFs1XSA9IHR5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgbGV0IGFhID0gYVswXSwgYWIgPSBhWzFdLCBhYyA9IGFbMl0sIGFkID0gYVszXTtcbiAgbGV0IGF0eCA9IGFbNF0sIGF0eSA9IGFbNV07XG5cbiAgbGV0IGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICBpZighZGV0KXtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgb3V0WzJdID0gLWFjICogZGV0O1xuICBvdXRbM10gPSBhYSAqIGRldDtcbiAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsxXSAqIGFbMl07XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTAgKiB2MDtcbiAgb3V0WzFdID0gYTEgKiB2MDtcbiAgb3V0WzJdID0gYTIgKiB2MTtcbiAgb3V0WzNdID0gYTMgKiB2MTtcbiAgb3V0WzRdID0gYTQ7XG4gIG91dFs1XSA9IGE1O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgbGV0IHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDtcbiAgb3V0WzFdID0gYTE7XG4gIG91dFsyXSA9IGEyO1xuICBvdXRbM10gPSBhMztcbiAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiB2MCArIGEzICogdjEgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB2WzBdO1xuICBvdXRbNV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArXG4gICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIDEpKVxufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MmQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gIG91dFs0XSA9IGFbNF0gKyAoYls0XSAqIHNjYWxlKTtcbiAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDJkLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDR4NCBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0NFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBBIG5ldyBtYXQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0NCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG5cblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICBsZXQgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXTtcbiAgICBsZXQgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgICBsZXQgYTIzID0gYVsxMV07XG5cbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXTtcbiAgbGV0IGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gIGxldCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIGxldCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIGxldCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIGxldCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIGxldCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIGxldCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIGxldCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIGxldCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIGxldCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIGxldCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIGxldCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIGxldCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICBsZXQgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgbGV0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgbGV0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgbGV0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgbGV0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgbGV0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgbGV0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgbGV0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgbGV0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgbGV0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgbGV0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgbGV0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgbGV0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gIGxldCBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgbGV0IHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG4gIGxldCBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIGxldCBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIGxldCBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgaWYgKGEgPT09IG91dCkge1xuICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICB9IGVsc2Uge1xuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgbm90IHVzaW5nIHZlY3Rvcml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIGxldCB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdO1xuICBsZXQgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIGxldCBzLCBjLCB0O1xuICBsZXQgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICBsZXQgYTEwLCBhMTEsIGExMiwgYTEzO1xuICBsZXQgYTIwLCBhMjEsIGEyMiwgYTIzO1xuICBsZXQgYjAwLCBiMDEsIGIwMjtcbiAgbGV0IGIxMCwgYjExLCBiMTI7XG4gIGxldCBiMjAsIGIyMSwgYjIyO1xuXG4gIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG5cbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG5cbiAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgbGV0IGExMCA9IGFbNF07XG4gIGxldCBhMTEgPSBhWzVdO1xuICBsZXQgYTEyID0gYVs2XTtcbiAgbGV0IGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdO1xuICBsZXQgYTIxID0gYVs5XTtcbiAgbGV0IGEyMiA9IGFbMTBdO1xuICBsZXQgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzBdICA9IGFbMF07XG4gICAgb3V0WzFdICA9IGFbMV07XG4gICAgb3V0WzJdICA9IGFbMl07XG4gICAgb3V0WzNdICA9IGFbM107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBsZXQgYTAwID0gYVswXTtcbiAgbGV0IGEwMSA9IGFbMV07XG4gIGxldCBhMDIgPSBhWzJdO1xuICBsZXQgYTAzID0gYVszXTtcbiAgbGV0IGEyMCA9IGFbOF07XG4gIGxldCBhMjEgPSBhWzldO1xuICBsZXQgYTIyID0gYVsxMF07XG4gIGxldCBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gID0gYVs0XTtcbiAgICBvdXRbNV0gID0gYVs1XTtcbiAgICBvdXRbNl0gID0gYVs2XTtcbiAgICBvdXRbN10gID0gYVs3XTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG4gIGxldCBhMDAgPSBhWzBdO1xuICBsZXQgYTAxID0gYVsxXTtcbiAgbGV0IGEwMiA9IGFbMl07XG4gIGxldCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XTtcbiAgbGV0IGExMSA9IGFbNV07XG4gIGxldCBhMTIgPSBhWzZdO1xuICBsZXQgYTEzID0gYVs3XTtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzhdICA9IGFbOF07XG4gICAgb3V0WzldICA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIGxldCB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdO1xuICBsZXQgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIGxldCBzLCBjLCB0O1xuXG4gIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG5cbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG5cbiAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSAgPSAxO1xuICBvdXRbMV0gID0gMDtcbiAgb3V0WzJdICA9IDA7XG4gIG91dFszXSAgPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAtcztcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSAgPSBjO1xuICBvdXRbMV0gID0gMDtcbiAgb3V0WzJdICA9IC1zO1xuICBvdXRbM10gID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gcztcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVpSb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSAgPSBjO1xuICBvdXRbMV0gID0gcztcbiAgb3V0WzJdICA9IDA7XG4gIG91dFszXSAgPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeHkgPSB4ICogeTI7XG4gIGxldCB4eiA9IHggKiB6MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgeXogPSB5ICogejI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcblxuICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICBvdXRbMV0gPSB4eSArIHd6O1xuICBvdXRbMl0gPSB4eiAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4eSAtIHd6O1xuICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICBvdXRbNl0gPSB5eiArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4eiArIHd5O1xuICBvdXRbOV0gPSB5eiAtIHd4O1xuICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgbWF0KSB7XG4gIG91dFswXSA9IG1hdFsxMl07XG4gIG91dFsxXSA9IG1hdFsxM107XG4gIG91dFsyXSA9IG1hdFsxNF07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlXG4gKiAgd2l0aCBhIG5vcm1hbGl6ZWQgUXVhdGVybmlvbiBwYXJhbXRlciwgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnRcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxpbmcob3V0LCBtYXQpIHtcbiAgbGV0IG0xMSA9IG1hdFswXTtcbiAgbGV0IG0xMiA9IG1hdFsxXTtcbiAgbGV0IG0xMyA9IG1hdFsyXTtcbiAgbGV0IG0yMSA9IG1hdFs0XTtcbiAgbGV0IG0yMiA9IG1hdFs1XTtcbiAgbGV0IG0yMyA9IG1hdFs2XTtcbiAgbGV0IG0zMSA9IG1hdFs4XTtcbiAgbGV0IG0zMiA9IG1hdFs5XTtcbiAgbGV0IG0zMyA9IG1hdFsxMF07XG5cbiAgb3V0WzBdID0gTWF0aC5zcXJ0KG0xMSAqIG0xMSArIG0xMiAqIG0xMiArIG0xMyAqIG0xMyk7XG4gIG91dFsxXSA9IE1hdGguc3FydChtMjEgKiBtMjEgKyBtMjIgKiBtMjIgKyBtMjMgKiBtMjMpO1xuICBvdXRbMl0gPSBNYXRoLnNxcnQobTMxICogbTMxICsgbTMyICogbTMyICsgbTMzICogbTMzKTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0ge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0aW9uKG91dCwgbWF0KSB7XG4gIC8vIEFsZ29yaXRobSB0YWtlbiBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG4gIGxldCB0cmFjZSA9IG1hdFswXSArIG1hdFs1XSArIG1hdFsxMF07XG4gIGxldCBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMV0gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7XG4gICAgb3V0WzJdID0gKG1hdFsxXSAtIG1hdFs0XSkgLyBTO1xuICB9IGVsc2UgaWYgKChtYXRbMF0gPiBtYXRbNV0pJihtYXRbMF0gPiBtYXRbMTBdKSkge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzBdIC0gbWF0WzVdIC0gbWF0WzEwXSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAobWF0WzFdICsgbWF0WzRdKSAvIFM7XG4gICAgb3V0WzJdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTO1xuICB9IGVsc2UgaWYgKG1hdFs1XSA+IG1hdFsxMF0pIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFs1XSAtIG1hdFswXSAtIG1hdFsxMF0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFsxXSArIG1hdFs0XSkgLyBTO1xuICAgIG91dFsxXSA9IDAuMjUgKiBTO1xuICAgIG91dFsyXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUztcbiAgfSBlbHNlIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFsxMF0gLSBtYXRbMF0gLSBtYXRbNV0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzFdIC0gbWF0WzRdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTO1xuICAgIG91dFsxXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeHkgPSB4ICogeTI7XG4gIGxldCB4eiA9IHggKiB6MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgeXogPSB5ICogejI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcbiAgbGV0IHN4ID0gc1swXTtcbiAgbGV0IHN5ID0gc1sxXTtcbiAgbGV0IHN6ID0gc1syXTtcblxuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4ob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeHkgPSB4ICogeTI7XG4gIGxldCB4eiA9IHggKiB6MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgeXogPSB5ICogejI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcblxuICBsZXQgc3ggPSBzWzBdO1xuICBsZXQgc3kgPSBzWzFdO1xuICBsZXQgc3ogPSBzWzJdO1xuXG4gIGxldCBveCA9IG9bMF07XG4gIGxldCBveSA9IG9bMV07XG4gIGxldCBveiA9IG9bMl07XG5cbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dFswXSAqIG94ICsgb3V0WzRdICogb3kgKyBvdXRbOF0gKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0WzFdICogb3ggKyBvdXRbNV0gKiBveSArIG91dFs5XSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXRbMl0gKiBveCArIG91dFs2XSAqIG95ICsgb3V0WzEwXSAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIGxldCB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXTtcbiAgbGV0IHgyID0geCArIHg7XG4gIGxldCB5MiA9IHkgKyB5O1xuICBsZXQgejIgPSB6ICsgejtcblxuICBsZXQgeHggPSB4ICogeDI7XG4gIGxldCB5eCA9IHkgKiB4MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgenggPSB6ICogeDI7XG4gIGxldCB6eSA9IHogKiB5MjtcbiAgbGV0IHp6ID0geiAqIHoyO1xuICBsZXQgd3ggPSB3ICogeDI7XG4gIGxldCB3eSA9IHcgKiB5MjtcbiAgbGV0IHd6ID0gdyAqIHoyO1xuXG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuXG4gIG91dFs0XSA9IHl4IC0gd3o7XG4gIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbNl0gPSB6eSArIHd4O1xuICBvdXRbN10gPSAwO1xuXG4gIG91dFs4XSA9IHp4ICsgd3k7XG4gIG91dFs5XSA9IHp5IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgb3V0WzExXSA9IDA7XG5cbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZydXN0dW0ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICBsZXQgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XG4gIGxldCB0YiA9IDEgLyAodG9wIC0gYm90dG9tKTtcbiAgbGV0IG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAobmVhciAqIDIpICogdGI7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XG4gIG91dFsxNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIGxldCBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpO1xuICBsZXQgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtPYmplY3R9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgbGV0IHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSS8xODAuMCk7XG4gIGxldCB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKTtcbiAgbGV0IHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKCh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41KTtcbiAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzExXSA9IC0xLjA7XG4gIG91dFsxMl0gPSAwLjA7XG4gIG91dFsxM10gPSAwLjA7XG4gIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gIG91dFsxNV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgbGV0IGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICBsZXQgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIGxldCBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9va0F0KG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gIGxldCB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW47XG4gIGxldCBleWV4ID0gZXllWzBdO1xuICBsZXQgZXlleSA9IGV5ZVsxXTtcbiAgbGV0IGV5ZXogPSBleWVbMl07XG4gIGxldCB1cHggPSB1cFswXTtcbiAgbGV0IHVweSA9IHVwWzFdO1xuICBsZXQgdXB6ID0gdXBbMl07XG4gIGxldCBjZW50ZXJ4ID0gY2VudGVyWzBdO1xuICBsZXQgY2VudGVyeSA9IGNlbnRlclsxXTtcbiAgbGV0IGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbWF0NC5pZGVudGl0eShvdXQpO1xuICB9XG5cbiAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gIHowICo9IGxlbjtcbiAgejEgKj0gbGVuO1xuICB6MiAqPSBsZW47XG5cbiAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gIGlmICghbGVuKSB7XG4gICAgeTAgPSAwO1xuICAgIHkxID0gMDtcbiAgICB5MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB5MCAqPSBsZW47XG4gICAgeTEgKj0gbGVuO1xuICAgIHkyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB5MDtcbiAgb3V0WzJdID0gejA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHgxO1xuICBvdXRbNV0gPSB5MTtcbiAgb3V0WzZdID0gejE7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHgyO1xuICBvdXRbOV0gPSB5MjtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgbGV0IGV5ZXggPSBleWVbMF0sXG4gICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICB1cHogPSB1cFsyXTtcblxuICBsZXQgejAgPSBleWV4IC0gdGFyZ2V0WzBdLFxuICAgICAgejEgPSBleWV5IC0gdGFyZ2V0WzFdLFxuICAgICAgejIgPSBleWV6IC0gdGFyZ2V0WzJdO1xuXG4gIGxldCBsZW4gPSB6MCp6MCArIHoxKnoxICsgejIqejI7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuICB9XG5cbiAgbGV0IHgwID0gdXB5ICogejIgLSB1cHogKiB6MSxcbiAgICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MixcbiAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgK1xuICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICBvdXRbNV0gPSBhWzVdICsgKGJbNV0gKiBzY2FsZSk7XG4gIG91dFs2XSA9IGFbNl0gKyAoYls2XSAqIHNjYWxlKTtcbiAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICBvdXRbOF0gPSBhWzhdICsgKGJbOF0gKiBzY2FsZSk7XG4gIG91dFs5XSA9IGFbOV0gKyAoYls5XSAqIHNjYWxlKTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgKGJbMTBdICogc2NhbGUpO1xuICBvdXRbMTFdID0gYVsxMV0gKyAoYlsxMV0gKiBzY2FsZSk7XG4gIG91dFsxMl0gPSBhWzEyXSArIChiWzEyXSAqIHNjYWxlKTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgKGJbMTNdICogc2NhbGUpO1xuICBvdXRbMTRdID0gYVsxNF0gKyAoYlsxNF0gKiBzY2FsZSk7XG4gIG91dFsxNV0gPSBhWzE1XSArIChiWzE1XSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmXG4gICAgICAgICBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmXG4gICAgICAgICBhWzhdID09PSBiWzhdICYmIGFbOV0gPT09IGJbOV0gJiYgYVsxMF0gPT09IGJbMTBdICYmIGFbMTFdID09PSBiWzExXSAmJlxuICAgICAgICAgYVsxMl0gPT09IGJbMTJdICYmIGFbMTNdID09PSBiWzEzXSAmJiBhWzE0XSA9PT0gYlsxNF0gJiYgYVsxNV0gPT09IGJbMTVdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCAgPSBhWzBdLCAgYTEgID0gYVsxXSwgIGEyICA9IGFbMl0sICBhMyAgPSBhWzNdO1xuICBsZXQgYTQgID0gYVs0XSwgIGE1ICA9IGFbNV0sICBhNiAgPSBhWzZdLCAgYTcgID0gYVs3XTtcbiAgbGV0IGE4ICA9IGFbOF0sICBhOSAgPSBhWzldLCAgYTEwID0gYVsxMF0sIGExMSA9IGFbMTFdO1xuICBsZXQgYTEyID0gYVsxMl0sIGExMyA9IGFbMTNdLCBhMTQgPSBhWzE0XSwgYTE1ID0gYVsxNV07XG5cbiAgbGV0IGIwICA9IGJbMF0sICBiMSAgPSBiWzFdLCAgYjIgID0gYlsyXSwgIGIzICA9IGJbM107XG4gIGxldCBiNCAgPSBiWzRdLCAgYjUgID0gYls1XSwgIGI2ICA9IGJbNl0sICBiNyAgPSBiWzddO1xuICBsZXQgYjggID0gYls4XSwgIGI5ICA9IGJbOV0sICBiMTAgPSBiWzEwXSwgYjExID0gYlsxMV07XG4gIGxldCBiMTIgPSBiWzEyXSwgYjEzID0gYlsxM10sIGIxNCA9IGJbMTRdLCBiMTUgPSBiWzE1XTtcblxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOSksIE1hdGguYWJzKGI5KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTApLCBNYXRoLmFicyhiMTApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMSksIE1hdGguYWJzKGIxMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEyKSwgTWF0aC5hYnMoYjEyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTMpLCBNYXRoLmFicyhiMTMpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNCksIE1hdGguYWJzKGIxNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE1KSwgTWF0aC5hYnMoYjE1KSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDQuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCJcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vbWF0M1wiXG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gXCIuL3ZlYzNcIlxuaW1wb3J0ICogYXMgdmVjNCBmcm9tIFwiLi92ZWM0XCJcblxuLyoqXG4gKiBRdWF0ZXJuaW9uXG4gKiBAbW9kdWxlIHF1YXRcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcbiAqIHRoZW4gcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2V0QXhpc0FuZ2xlKG91dCwgYXhpcywgcmFkKSB7XG4gIHJhZCA9IHJhZCAqIDAuNTtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHJvdGF0aW9uIGF4aXMgYW5kIGFuZ2xlIGZvciBhIGdpdmVuXG4gKiAgcXVhdGVybmlvbi4gSWYgYSBxdWF0ZXJuaW9uIGlzIGNyZWF0ZWQgd2l0aFxuICogIHNldEF4aXNBbmdsZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWVcbiAqICB2YWx1ZXMgYXMgcHJvdmlkaWVkIGluIHRoZSBvcmlnaW5hbCBwYXJhbWV0ZXIgbGlzdFxuICogIE9SIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqIEV4YW1wbGU6IFRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieSBheGlzIFswLCAwLCAxXSBhbmRcbiAqICBhbmdsZSAtOTAgaXMgdGhlIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5XG4gKiAgWzAsIDAsIDFdIGFuZCAyNzAuIFRoaXMgbWV0aG9kIGZhdm9ycyB0aGUgbGF0dGVyLlxuICogQHBhcmFtICB7dmVjM30gb3V0X2F4aXMgIFZlY3RvciByZWNlaXZpbmcgdGhlIGF4aXMgb2Ygcm90YXRpb25cbiAqIEBwYXJhbSAge3F1YXR9IHEgICAgIFF1YXRlcm5pb24gdG8gYmUgZGVjb21wb3NlZFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSByb3RhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpc0FuZ2xlKG91dF9heGlzLCBxKSB7XG4gIGxldCByYWQgPSBNYXRoLmFjb3MocVszXSkgKiAyLjA7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkIC8gMi4wKTtcbiAgaWYgKHMgIT0gMC4wKSB7XG4gICAgb3V0X2F4aXNbMF0gPSBxWzBdIC8gcztcbiAgICBvdXRfYXhpc1sxXSA9IHFbMV0gLyBzO1xuICAgIG91dF9heGlzWzJdID0gcVsyXSAvIHM7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgcyBpcyB6ZXJvLCByZXR1cm4gYW55IGF4aXMgKG5vIHJvdGF0aW9uIC0gYXhpcyBkb2VzIG5vdCBtYXR0ZXIpXG4gICAgb3V0X2F4aXNbMF0gPSAxO1xuICAgIG91dF9heGlzWzFdID0gMDtcbiAgICBvdXRfYXhpc1syXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHJhZDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM107XG4gIGxldCBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG5cbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXTtcbiAgbGV0IGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcblxuICBsZXQgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdO1xuICBsZXQgYnkgPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuXG4gIGxldCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM107XG4gIGxldCBieiA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVXKG91dCwgYSkge1xuICBsZXQgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcblxuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgLy8gYmVuY2htYXJrczpcbiAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXTtcbiAgbGV0IGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICBsZXQgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgLy8gY2FsYyBjb3NpbmVcbiAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcbiAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICBieCA9IC0gYng7XG4gICAgYnkgPSAtIGJ5O1xuICAgIGJ6ID0gLSBiejtcbiAgICBidyA9IC0gYnc7XG4gIH1cbiAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICBpZiAoICgxLjAgLSBjb3NvbSkgPiAwLjAwMDAwMSApIHtcbiAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICBvbWVnYSAgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgIHNpbm9tICA9IE1hdGguc2luKG9tZWdhKTtcbiAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gIH0gZWxzZSB7XG4gICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZVxuICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cbiAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgIHNjYWxlMSA9IHQ7XG4gIH1cbiAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMztcbiAgbGV0IGludkRvdCA9IGRvdCA/IDEuMC9kb3QgOiAwO1xuXG4gIC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgb3V0WzBdID0gLWEwKmludkRvdDtcbiAgb3V0WzFdID0gLWExKmludkRvdDtcbiAgb3V0WzJdID0gLWEyKmludkRvdDtcbiAgb3V0WzNdID0gYTMqaW52RG90O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25qdWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHttYXQzfSBtIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0MyhvdXQsIG0pIHtcbiAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gIGxldCBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gIGxldCBmUm9vdDtcblxuICBpZiAoIGZUcmFjZSA+IDAuMCApIHtcbiAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgZlJvb3QgPSBNYXRoLnNxcnQoZlRyYWNlICsgMS4wKTsgIC8vIDJ3XG4gICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUvZlJvb3Q7ICAvLyAxLyg0dylcbiAgICBvdXRbMF0gPSAobVs1XS1tWzddKSpmUm9vdDtcbiAgICBvdXRbMV0gPSAobVs2XS1tWzJdKSpmUm9vdDtcbiAgICBvdXRbMl0gPSAobVsxXS1tWzNdKSpmUm9vdDtcbiAgfSBlbHNlIHtcbiAgICAvLyB8d3wgPD0gMS8yXG4gICAgbGV0IGkgPSAwO1xuICAgIGlmICggbVs0XSA+IG1bMF0gKVxuICAgICAgaSA9IDE7XG4gICAgaWYgKCBtWzhdID4gbVtpKjMraV0gKVxuICAgICAgaSA9IDI7XG4gICAgbGV0IGogPSAoaSsxKSUzO1xuICAgIGxldCBrID0gKGkrMiklMztcblxuICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSozK2ldLW1baiozK2pdLW1bayozK2tdICsgMS4wKTtcbiAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgIG91dFszXSA9IChtW2oqMytrXSAtIG1bayozK2pdKSAqIGZSb290O1xuICAgIG91dFtqXSA9IChtW2oqMytpXSArIG1baSozK2pdKSAqIGZSb290O1xuICAgIG91dFtrXSA9IChtW2sqMytpXSArIG1baSozK2tdKSAqIGZSb290O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiBldWxlciBhbmdsZSB4LCB5LCB6LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt4fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFggYXhpcyBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHt5fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFkgYXhpcyBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHt6fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFogYXhpcyBpbiBkZWdyZWVzLlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXVsZXIob3V0LCB4LCB5LCB6KSB7XG4gICAgbGV0IGhhbGZUb1JhZCA9IDAuNSAqIE1hdGguUEkgLyAxODAuMDtcbiAgICB4ICo9IGhhbGZUb1JhZDtcbiAgICB5ICo9IGhhbGZUb1JhZDtcbiAgICB6ICo9IGhhbGZUb1JhZDtcblxuICAgIGxldCBzeCA9IE1hdGguc2luKHgpO1xuICAgIGxldCBjeCA9IE1hdGguY29zKHgpO1xuICAgIGxldCBzeSA9IE1hdGguc2luKHkpO1xuICAgIGxldCBjeSA9IE1hdGguY29zKHkpO1xuICAgIGxldCBzeiA9IE1hdGguc2luKHopO1xuICAgIGxldCBjeiA9IE1hdGguY29zKHopO1xuXG4gICAgb3V0WzBdID0gc3ggKiBjeSAqIGN6IC0gY3ggKiBzeSAqIHN6O1xuICAgIG91dFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgICBvdXRbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gICAgb3V0WzNdID0gY3ggKiBjeSAqIGN6ICsgc3ggKiBzeSAqIHN6O1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZSA9IHZlYzQuY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY29weSA9IHZlYzQuY29weTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNldCA9IHZlYzQuc2V0O1xuXG4vKipcbiAqIEFkZHMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRvdCA9IHZlYzQuZG90O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbGVuID0gbGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBleGFjdEVxdWFscyA9IHZlYzQuZXhhY3RFcXVhbHM7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtxdWF0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbHMgPSB2ZWM0LmVxdWFscztcblxuLyoqXG4gKiBTZXRzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cbiAqXG4gKiBCb3RoIHZlY3RvcnMgYXJlIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGNvbnN0IHJvdGF0aW9uVG8gPSAoZnVuY3Rpb24oKSB7XG4gIGxldCB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgbGV0IHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XG4gIGxldCB5VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApO1xuXG4gIHJldHVybiBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBsZXQgZG90ID0gdmVjMy5kb3QoYSwgYik7XG4gICAgaWYgKGRvdCA8IC0wLjk5OTk5OSkge1xuICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xuICAgICAgaWYgKHZlYzMubGVuKHRtcHZlYzMpIDwgMC4wMDAwMDEpXG4gICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeVVuaXRWZWMzLCBhKTtcbiAgICAgIHZlYzMubm9ybWFsaXplKHRtcHZlYzMsIHRtcHZlYzMpO1xuICAgICAgc2V0QXhpc0FuZ2xlKG91dCwgdG1wdmVjMywgTWF0aC5QSSk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSBpZiAoZG90ID4gMC45OTk5OTkpIHtcbiAgICAgIG91dFswXSA9IDA7XG4gICAgICBvdXRbMV0gPSAwO1xuICAgICAgb3V0WzJdID0gMDtcbiAgICAgIG91dFszXSA9IDE7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIGEsIGIpO1xuICAgICAgb3V0WzBdID0gdG1wdmVjM1swXTtcbiAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XG4gICAgICBvdXRbMl0gPSB0bXB2ZWMzWzJdO1xuICAgICAgb3V0WzNdID0gMSArIGRvdDtcbiAgICAgIHJldHVybiBub3JtYWxpemUob3V0LCBvdXQpO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgY29uc3Qgc3FsZXJwID0gKGZ1bmN0aW9uICgpIHtcbiAgbGV0IHRlbXAxID0gY3JlYXRlKCk7XG4gIGxldCB0ZW1wMiA9IGNyZWF0ZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgc2xlcnAodGVtcDEsIGEsIGQsIHQpO1xuICAgIHNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBzbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcblxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCkpO1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBeGVzID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgIG1hdHJbM10gPSByaWdodFsxXTtcbiAgICBtYXRyWzZdID0gcmlnaHRbMl07XG5cbiAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgbWF0cls0XSA9IHVwWzFdO1xuICAgIG1hdHJbN10gPSB1cFsyXTtcblxuICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgbWF0cls4XSA9IC12aWV3WzJdO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIGZyb21NYXQzKG91dCwgbWF0cikpO1xuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3F1YXQuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjMlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSkge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZCAob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGggKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV07XG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGxlbiA9IGxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGl2ID0gZGl2aWRlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGlzdCA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gIGxldCB2ZWMgPSBjcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgbGV0IGksIGw7XG4gICAgaWYoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMjtcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMi5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBWZXJ0ZXhBcnJheU9iamVjdC5qc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbmRBcHBseUV4dGVuc2lvbihnbCwgbmFtZSkge1xuXHRjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24obmFtZSk7XG5cdGlmICghZXh0KSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGNvbnN0IHN1ZmZpeCA9IG5hbWUuc3BsaXQoJ18nKVswXTtcblx0Y29uc3Qgc3VmZml4UkUgPSBuZXcgUmVnRXhwKGAke3N1ZmZpeH0kYCk7XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gZXh0KSB7XG5cdFx0Y29uc3QgdmFsID0gZXh0W2tleV07XG5cdFx0aWYgKHR5cGVvZih2YWwpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjb25zdCB1bnN1ZmZpeGVkS2V5ID0ga2V5LnJlcGxhY2Uoc3VmZml4UkUsICcnKTtcblx0XHRcdGlmIChrZXkuc3Vic3RyaW5nKSB7XG5cdFx0XHRcdGdsW3Vuc3VmZml4ZWRLZXldID0gZXh0W2tleV0uYmluZChleHQpO1x0XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdSZXBsYWNpbmcgOicsIGtleSwgJz0+JywgdW5zdWZmaXhlZEtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0QW5kQXBwbHlFeHRlbnNpb24uanMiLCIvLyBleHBvc2VBdHRyaWJ1dGVzLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IFdlYmdsQ29uc3QgZnJvbSAnLi9XZWJnbENvbnN0JztcblxuY29uc3QgZXhwb3NlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gR0wuVkVSVEVYX1NIQURFUiAgICAgICAgID0gR0wuZ2wuVkVSVEVYX1NIQURFUjtcblx0Ly8gR0wuRlJBR01FTlRfU0hBREVSICAgICAgID0gR0wuZ2wuRlJBR01FTlRfU0hBREVSO1xuXHQvLyBHTC5DT01QSUxFX1NUQVRVUyAgICAgICAgPSBHTC5nbC5DT01QSUxFX1NUQVRVUztcblx0Ly8gR0wuREVQVEhfVEVTVCAgICAgICAgICAgID0gR0wuZ2wuREVQVEhfVEVTVDtcblx0Ly8gR0wuQ1VMTF9GQUNFICAgICAgICAgICAgID0gR0wuZ2wuQ1VMTF9GQUNFO1xuXHQvLyBHTC5CTEVORCAgICAgICAgICAgICAgICAgPSBHTC5nbC5CTEVORDtcblx0Ly8gR0wuUE9JTlRTICAgICAgICAgICAgICAgID0gR0wuZ2wuUE9JTlRTO1xuXHQvLyBHTC5MSU5FUyAgICAgICAgICAgICAgICAgPSBHTC5nbC5MSU5FUztcblx0Ly8gR0wuVFJJQU5HTEVTICAgICAgICAgICAgID0gR0wuZ2wuVFJJQU5HTEVTO1xuXHRcblx0Ly8gR0wuTElORUFSICAgICAgICAgICAgICAgIFx0PSBHTC5nbC5MSU5FQVI7XG5cdC8vIEdMLk5FQVJFU1QgICAgICAgICAgICAgICBcdD0gR0wuZ2wuTkVBUkVTVDtcblx0Ly8gR0wuTElORUFSX01JUE1BUF9ORUFSRVNUIFx0PSBHTC5nbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XG5cdC8vIEdMLk5FQVJFU1RfTUlQTUFQX0xJTkVBUiBcdD0gR0wuZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXHQvLyBHTC5MSU5FQVJfTUlQTUFQX0xJTkVBUiBcdD0gR0wuZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cdC8vIEdMLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QgXHQ9IEdMLmdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XG5cdC8vIEdMLk1JUlJPUkVEX1JFUEVBVCAgICAgICBcdD0gR0wuZ2wuTUlSUk9SRURfUkVQRUFUO1xuXHQvLyBHTC5DTEFNUF9UT19FREdFICAgICAgICAgXHQ9IEdMLmdsLkNMQU1QX1RPX0VER0U7XG5cdC8vIEdMLlNDSVNTT1JfVEVTVFx0XHQgICBcdCBcdD0gR0wuZ2wuU0NJU1NPUl9URVNUO1xuXHQvLyBHTC5VTlNJR05FRF9CWVRFXHRcdCBcdD0gR0wuZ2wuVU5TSUdORURfQllURTtcblx0Zm9yIChjb25zdCBzIGluIFdlYmdsQ29uc3QpIHtcblx0XHRpZighR0xbc10pIHtcblx0XHRcdEdMW3NdID0gV2ViZ2xDb25zdFtzXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2coJ2FscmVhZHkgZXhpc3QgOiAnLCBzKTtcblx0XHR9XG5cdFx0XG5cdH1cbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgZXhwb3NlQXR0cmlidXRlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9leHBvc2VBdHRyaWJ1dGVzLmpzIiwiLy8gZ2V0RmxvYXQuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5cbmxldCBoYXNDaGVja2VkID0gZmFsc2U7XG5sZXQgX2Zsb2F0O1xuXG5cbmZ1bmN0aW9uIGNoZWNrRmxvYXQoKSB7XG5cdGlmKEdMLndlYmdsMikge1xuXHRcdHJldHVybiBHTC5nbC5GTE9BVDtcblx0fSBlbHNlIHtcblx0XHRjb25zdCBleHRGbG9hdCA9IEdMLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcblx0XHRpZihleHRGbG9hdCkge1xuXHRcdFx0cmV0dXJuIEdMLmdsLkZMT0FUO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1VTSU5HIEZMT0FUIEJVVCBPRVNfdGV4dHVyZV9mbG9hdCBOT1QgU1VQUE9SVEVEJyk7XG5cdFx0XHRyZXR1cm4gR0wuZ2wuVU5TSUdORURfQllURTtcblx0XHR9XG5cdH1cblxuXHRoYXNDaGVja2VkID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcblx0aWYoIWhhc0NoZWNrZWQpIHtcblx0XHRfZmxvYXQgPSBjaGVja0Zsb2F0KCk7XG5cdH1cblxuXG5cdHJldHVybiBfZmxvYXQ7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0RmxvYXQuanMiLCIvLyBnZXRIYWxmRmxvYXQuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5cbmxldCBoYXNDaGVja2VkID0gZmFsc2U7XG5sZXQgaGFsZkZsb2F0O1xuXG5mdW5jdGlvbiBjaGVja0hhbGZGbG9hdCgpIHtcblx0aWYoR0wud2ViZ2wyKSB7XG5cdFx0cmV0dXJuIEdMLmdsLkhBTEZfRkxPQVQ7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgZXh0SGFsZkZsb2F0ID0gR0wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG5cdFx0aWYoZXh0SGFsZkZsb2F0KSB7XG5cdFx0XHRyZXR1cm4gZXh0SGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1VTSU5HIEhBTEYgRkxPQVQgQlVUIE9FU190ZXh0dXJlX2hhbGZfZmxvYXQgTk9UIFNVUFBPUlRFRCcpO1xuXHRcdFx0cmV0dXJuIEdMLmdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0fVxuXHR9XG5cblx0aGFzQ2hlY2tlZCA9IHRydWU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG5cdGlmKCFoYXNDaGVja2VkKSB7XG5cdFx0aGFsZkZsb2F0ID0gY2hlY2tIYWxmRmxvYXQoKTtcblx0fVxuXG5cdHJldHVybiBoYWxmRmxvYXQ7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0SGFsZkZsb2F0LmpzIiwiLy8gRXh0ZW5zaW9uc0xpc3QuanNcblxuZXhwb3J0IGRlZmF1bHQgW1xuXHQnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcsIFxuXHQnRVhUX3NSR0InLCBcblx0J0VYVF9mcmFnX2RlcHRoJywgXG5cdCdPRVNfdGV4dHVyZV9mbG9hdCcsIFxuXHQnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcsIFxuXHQnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJywgXG5cdCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicsIFxuXHQnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJywgXG5cdCdXRUJHTF9kZXB0aF90ZXh0dXJlJywgXG5cdCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnLCBcblx0J09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JywgXG5cdCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgXG5cdCdXRUJHTF9kcmF3X2J1ZmZlcnMnXG5dO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0V4dGVuc2lvbnNMaXN0LmpzIiwiLy8gZ2V0VGV4dHVyZVBhcmFtZXRlcnMuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byh4KSB7XHRcblx0cmV0dXJuICh4ICE9PSAwKSAmJiAoISh4ICYgKHggLSAxKSkpO1xufTtcblxuY29uc3QgZ2V0VGV4dHVyZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobVBhcmFtcywgbVNvdXJjZSwgbVdpZHRoLCBtSGVpZ2h0KSB7XG5cdGlmKCFtUGFyYW1zLm1pbkZpbHRlcikge1xuXHRcdGxldCBtaW5GaWx0ZXIgPSBHTC5MSU5FQVI7XG5cdFx0aWYobVdpZHRoICYmIG1XaWR0aCkge1xuXHRcdFx0aWYoaXNQb3dlck9mVHdvKG1XaWR0aCkgJiYgaXNQb3dlck9mVHdvKG1IZWlnaHQpKSB7XG5cdFx0XHRcdG1pbkZpbHRlciA9IEdMLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtUGFyYW1zLm1pbkZpbHRlciA9IG1pbkZpbHRlcjtcblx0fSBcblxuXG5cdG1QYXJhbXMubWlwbWFwID0gbVBhcmFtcy5taXBtYXAgfHwgdHJ1ZTtcblx0bVBhcmFtcy5tYWdGaWx0ZXIgPSBtUGFyYW1zLm1hZ0ZpbHRlciB8fCBHTC5MSU5FQVI7XG5cdG1QYXJhbXMud3JhcFMgPSBtUGFyYW1zLndyYXBTIHx8IEdMLkNMQU1QX1RPX0VER0U7XG5cdG1QYXJhbXMud3JhcFQgPSBtUGFyYW1zLndyYXBUIHx8IEdMLkNMQU1QX1RPX0VER0U7XG5cdG1QYXJhbXMuaW50ZXJuYWxGb3JtYXQgPSBtUGFyYW1zLmludGVybmFsRm9ybWF0IHx8IEdMLlJHQkE7XG5cdG1QYXJhbXMuZm9ybWF0ID0gbVBhcmFtcy5mb3JtYXQgfHwgR0wuUkdCQTtcblx0bVBhcmFtcy5wcmVtdWx0aXBseUFscGhhID0gbVBhcmFtcy5wcmVtdWx0aXBseUFscGhhIHx8IGZhbHNlO1xuXHRtUGFyYW1zLmxldmVsID0gbVBhcmFtcy5sZXZlbCB8fCAwO1xuXHRtUGFyYW1zLmFuaXNvdHJvcHkgPSBtUGFyYW1zLmFuaXNvdHJvcHkgfHwgMDtcblxuXHRyZXR1cm4gbVBhcmFtcztcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VGV4dHVyZVBhcmFtZXRlcnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0VGV4dHVyZVBhcmFtZXRlcnMuanMiLCIvLyBBbGwgdmFsdWVzIGFuZCBzdHJ1Y3R1cmVzIHJlZmVyZW5jZWQgZnJvbTpcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9iYjk0Mzk5MS5hc3B4L1xuLy9cbi8vIERYMTAgQ3ViZW1hcCBzdXBwb3J0IGJhc2VkIG9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFyaW9tYW5lc2t1L2NtZnQvaXNzdWVzLzcjaXNzdWVjb21tZW50LTY5NTE2ODQ0XG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9iYjk0Mzk4Myh2PXZzLjg1KS5hc3B4XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGxheWNhbnZhcy9lbmdpbmUvYmxvYi9tYXN0ZXIvc3JjL3Jlc291cmNlcy9yZXNvdXJjZXNfdGV4dHVyZS5qc1xuXG52YXIgRERTX01BR0lDID0gMHgyMDUzNDQ0NFxudmFyIEREU0RfTUlQTUFQQ09VTlQgPSAweDIwMDAwXG52YXIgRERQRl9GT1VSQ0MgPSAweDRcblxudmFyIEZPVVJDQ19EWFQxID0gZm91ckNDVG9JbnQzMignRFhUMScpXG52YXIgRk9VUkNDX0RYVDMgPSBmb3VyQ0NUb0ludDMyKCdEWFQzJylcbnZhciBGT1VSQ0NfRFhUNSA9IGZvdXJDQ1RvSW50MzIoJ0RYVDUnKVxudmFyIEZPVVJDQ19EWDEwID0gZm91ckNDVG9JbnQzMignRFgxMCcpXG52YXIgRk9VUkNDX0ZQMzJGID0gMTE2IC8vIERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVFxuXG52YXIgRERTQ0FQUzJfQ1VCRU1BUCA9IDB4MjAwXG52YXIgRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OX1RFWFRVUkUyRCA9IDNcbnZhciBEWEdJX0ZPUk1BVF9SMzJHMzJCMzJBMzJfRkxPQVQgPSAyXG5cbi8vIFRoZSBoZWFkZXIgbGVuZ3RoIGluIDMyIGJpdCBpbnRzXG52YXIgaGVhZGVyTGVuZ3RoSW50ID0gMzFcblxuLy8gT2Zmc2V0cyBpbnRvIHRoZSBoZWFkZXIgYXJyYXlcbnZhciBvZmZfbWFnaWMgPSAwXG52YXIgb2ZmX3NpemUgPSAxXG52YXIgb2ZmX2ZsYWdzID0gMlxudmFyIG9mZl9oZWlnaHQgPSAzXG52YXIgb2ZmX3dpZHRoID0gNFxudmFyIG9mZl9taXBtYXBDb3VudCA9IDdcbnZhciBvZmZfcGZGbGFncyA9IDIwXG52YXIgb2ZmX3BmRm91ckNDID0gMjFcbnZhciBvZmZfY2FwczIgPSAyOFxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlSGVhZGVyc1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKGFycmF5QnVmZmVyKSB7XG4gIHZhciBoZWFkZXIgPSBuZXcgSW50MzJBcnJheShhcnJheUJ1ZmZlciwgMCwgaGVhZGVyTGVuZ3RoSW50KVxuXG4gIGlmIChoZWFkZXJbb2ZmX21hZ2ljXSAhPT0gRERTX01BR0lDKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hZ2ljIG51bWJlciBpbiBERFMgaGVhZGVyJylcbiAgfVxuXG4gIGlmICghaGVhZGVyW29mZl9wZkZsYWdzXSAmIEREUEZfRk9VUkNDKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBmb3JtYXQsIG11c3QgY29udGFpbiBhIEZvdXJDQyBjb2RlJylcbiAgfVxuXG4gIHZhciBibG9ja0J5dGVzXG4gIHZhciBmb3JtYXRcbiAgdmFyIGZvdXJDQyA9IGhlYWRlcltvZmZfcGZGb3VyQ0NdXG4gIHN3aXRjaCAoZm91ckNDKSB7XG4gICAgY2FzZSBGT1VSQ0NfRFhUMTpcbiAgICAgIGJsb2NrQnl0ZXMgPSA4XG4gICAgICBmb3JtYXQgPSAnZHh0MSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBGT1VSQ0NfRFhUMzpcbiAgICAgIGJsb2NrQnl0ZXMgPSAxNlxuICAgICAgZm9ybWF0ID0gJ2R4dDMnXG4gICAgICBicmVha1xuICAgIGNhc2UgRk9VUkNDX0RYVDU6XG4gICAgICBibG9ja0J5dGVzID0gMTZcbiAgICAgIGZvcm1hdCA9ICdkeHQ1J1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEZPVVJDQ19GUDMyRjpcbiAgICAgIGZvcm1hdCA9ICdyZ2JhMzJmJ1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEZPVVJDQ19EWDEwOlxuICAgICAgdmFyIGR4MTBIZWFkZXIgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoMTI4LCAxMjggKyAyMCkpXG4gICAgICBmb3JtYXQgPSBkeDEwSGVhZGVyWzBdXG4gICAgICB2YXIgcmVzb3VyY2VEaW1lbnNpb24gPSBkeDEwSGVhZGVyWzFdXG4gICAgICB2YXIgbWlzY0ZsYWcgPSBkeDEwSGVhZGVyWzJdXG4gICAgICB2YXIgYXJyYXlTaXplID0gZHgxMEhlYWRlclszXVxuICAgICAgdmFyIG1pc2NGbGFnczIgPSBkeDEwSGVhZGVyWzRdXG5cbiAgICAgIGlmIChyZXNvdXJjZURpbWVuc2lvbiA9PT0gRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OX1RFWFRVUkUyRCAmJiBmb3JtYXQgPT09IERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVCkge1xuICAgICAgICBmb3JtYXQgPSAncmdiYTMyZidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgRFgxMCB0ZXh0dXJlIGZvcm1hdCAnICsgZm9ybWF0KVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBGb3VyQ0MgY29kZTogJyArIGludDMyVG9Gb3VyQ0MoZm91ckNDKSlcbiAgfVxuXG4gIHZhciBmbGFncyA9IGhlYWRlcltvZmZfZmxhZ3NdXG4gIHZhciBtaXBtYXBDb3VudCA9IDFcblxuICBpZiAoZmxhZ3MgJiBERFNEX01JUE1BUENPVU5UKSB7XG4gICAgbWlwbWFwQ291bnQgPSBNYXRoLm1heCgxLCBoZWFkZXJbb2ZmX21pcG1hcENvdW50XSlcbiAgfVxuXG4gIHZhciBjdWJlbWFwID0gZmFsc2VcbiAgdmFyIGNhcHMyID0gaGVhZGVyW29mZl9jYXBzMl1cbiAgaWYgKGNhcHMyICYgRERTQ0FQUzJfQ1VCRU1BUCkge1xuICAgIGN1YmVtYXAgPSB0cnVlXG4gIH1cblxuICB2YXIgd2lkdGggPSBoZWFkZXJbb2ZmX3dpZHRoXVxuICB2YXIgaGVpZ2h0ID0gaGVhZGVyW29mZl9oZWlnaHRdXG4gIHZhciBkYXRhT2Zmc2V0ID0gaGVhZGVyW29mZl9zaXplXSArIDRcbiAgdmFyIHRleFdpZHRoID0gd2lkdGhcbiAgdmFyIHRleEhlaWdodCA9IGhlaWdodFxuICB2YXIgaW1hZ2VzID0gW11cbiAgdmFyIGRhdGFMZW5ndGhcblxuICBpZiAoZm91ckNDID09PSBGT1VSQ0NfRFgxMCkge1xuICAgIGRhdGFPZmZzZXQgKz0gMjBcbiAgfVxuXG4gIGlmIChjdWJlbWFwKSB7XG4gICAgZm9yICh2YXIgZiA9IDA7IGYgPCA2OyBmKyspIHtcbiAgICAgIGlmIChmb3JtYXQgIT09ICdyZ2JhMzJmJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgUkdCQTMyZiBjdWJlbWFwcyBhcmUgc3VwcG9ydGVkJylcbiAgICAgIH1cbiAgICAgIHZhciBicHAgPSA0ICogMzIgLyA4XG5cbiAgICAgIHdpZHRoID0gdGV4V2lkdGhcbiAgICAgIGhlaWdodCA9IHRleEhlaWdodFxuXG4gICAgICAvLyBjdWJlbWFwIHNob3VsZCBoYXZlIGFsbCBtaXBtYXAgbGV2ZWxzIGRlZmluZWRcbiAgICAgIC8vIE1hdGgubG9nMih3aWR0aCkgKyAxXG4gICAgICB2YXIgcmVxdWlyZWRNaXBMZXZlbHMgPSBNYXRoLmxvZyh3aWR0aCkgLyBNYXRoLmxvZygyKSArIDFcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXF1aXJlZE1pcExldmVsczsgaSsrKSB7XG4gICAgICAgIGRhdGFMZW5ndGggPSB3aWR0aCAqIGhlaWdodCAqIGJwcFxuICAgICAgICBpbWFnZXMucHVzaCh7XG4gICAgICAgICAgb2Zmc2V0OiBkYXRhT2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aDogZGF0YUxlbmd0aCxcbiAgICAgICAgICBzaGFwZTogWyB3aWR0aCwgaGVpZ2h0IF1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gUmV1c2UgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyBsZXZlbCBpZiB3ZSBhcmUgYmV5b25kIG1pcG1hcENvdW50XG4gICAgICAgIC8vIFRoaXMgaXMgaGFjayBmb3IgQ01GVCBub3QgcHVibGlzaGluZyBmdWxsIG1pcG1hcCBjaGFpbiBodHRwczovL2dpdGh1Yi5jb20vZGFyaW9tYW5lc2t1L2NtZnQvaXNzdWVzLzEwXG4gICAgICAgIGlmIChpIDwgbWlwbWFwQ291bnQpIHtcbiAgICAgICAgICBkYXRhT2Zmc2V0ICs9IGRhdGFMZW5ndGhcbiAgICAgICAgfVxuICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKVxuICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAvIDIpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlwbWFwQ291bnQ7IGkrKykge1xuICAgICAgZGF0YUxlbmd0aCA9IE1hdGgubWF4KDQsIHdpZHRoKSAvIDQgKiBNYXRoLm1heCg0LCBoZWlnaHQpIC8gNCAqIGJsb2NrQnl0ZXNcblxuICAgICAgaW1hZ2VzLnB1c2goe1xuICAgICAgICBvZmZzZXQ6IGRhdGFPZmZzZXQsXG4gICAgICAgIGxlbmd0aDogZGF0YUxlbmd0aCxcbiAgICAgICAgc2hhcGU6IFsgd2lkdGgsIGhlaWdodCBdXG4gICAgICB9KVxuICAgICAgZGF0YU9mZnNldCArPSBkYXRhTGVuZ3RoXG4gICAgICB3aWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKVxuICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgLyAyKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2hhcGU6IFsgdGV4V2lkdGgsIHRleEhlaWdodCBdLFxuICAgIGltYWdlczogaW1hZ2VzLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZsYWdzOiBmbGFncyxcbiAgICBjdWJlbWFwOiBjdWJlbWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gZm91ckNDVG9JbnQzMiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCkgK1xuICAgICh2YWx1ZS5jaGFyQ29kZUF0KDEpIDw8IDgpICtcbiAgICAodmFsdWUuY2hhckNvZGVBdCgyKSA8PCAxNikgK1xuICAgICh2YWx1ZS5jaGFyQ29kZUF0KDMpIDw8IDI0KVxufVxuXG5mdW5jdGlvbiBpbnQzMlRvRm91ckNDICh2YWx1ZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICB2YWx1ZSAmIDB4ZmYsXG4gICAgKHZhbHVlID4+IDgpICYgMHhmZixcbiAgICAodmFsdWUgPj4gMTYpICYgMHhmZixcbiAgICAodmFsdWUgPj4gMjQpICYgMHhmZlxuICApXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wYXJzZS1kZHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHJpbmdzKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5ncyA9PT0gJ3N0cmluZycpIHN0cmluZ3MgPSBbc3RyaW5nc11cbiAgdmFyIGV4cHJzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSlcbiAgdmFyIHBhcnRzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aC0xOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0sIGV4cHJzW2ldIHx8ICcnKVxuICB9XG4gIHBhcnRzLnB1c2goc3RyaW5nc1tpXSlcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJhc2ljLmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJBU0lDX0ZSQUdNRU5UXFxuXFxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxuLy8gdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZUZXh0dXJlQ29vcmQsIHNpbih0aW1lKSAqIC41ICsgLjUsIDEuMCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2Jhc2ljLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQ3ViZUZyYW1lQnVmZmVyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCBHTEN1YmVUZXh0dXJlIGZyb20gJy4vR0xDdWJlVGV4dHVyZSc7XG5cbmxldCBnbDtcblxuXG5jbGFzcyBDdWJlRnJhbWVCdWZmZXIge1xuXG5cdGNvbnN0cnVjdG9yKHNpemUsIG1QYXJhbWV0ZXJzID0ge30pIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHRoaXMuX3NpemUgPSBzaXplO1xuXHRcdHRoaXMubWFnRmlsdGVyID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciB8fCBnbC5MSU5FQVI7XG5cdFx0dGhpcy53cmFwUyAgICAgPSBtUGFyYW1ldGVycy53cmFwUyB8fCBnbC5DTEFNUF9UT19FREdFO1xuXHRcdHRoaXMud3JhcFQgICAgID0gbVBhcmFtZXRlcnMud3JhcFQgfHwgZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy50ZXh0dXJlICAgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0dGhpcy5nbFRleHR1cmUgPSBuZXcgR0xDdWJlVGV4dHVyZSh0aGlzLnRleHR1cmUsIHt9LCB0cnVlKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5taW5GaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMud3JhcFQpO1xuXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IFtcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWiwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aIFxuXHRcdF07XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2ldLCAwLCBnbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5fZnJhbWVCdWZmZXJzID0gW107XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuXHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0YXJnZXRzW2ldLCB0aGlzLnRleHR1cmUsIDApO1xuXG5cdFx0XHRjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcblx0XHRcdGlmIChzdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGAnZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cygpIHJldHVybmVkICcke3N0YXR1c31gKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZnJhbWVCdWZmZXJzLnB1c2goZnJhbWVCdWZmZXIpO1xuXHRcdH1cblxuXHRcdC8vIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuXHR9XG5cblxuXHRiaW5kKG1UYXJnZXRJbmRleCkge1xuXG5cdFx0Ly8gaWYoTWF0aC5yYW5kb20oKSA+IC45OSkgY29uc29sZS5sb2coJ2JpbmQgOicsIG1UYXJnZXRJbmRleCwgdGhpcy5fZnJhbWVCdWZmZXJzW21UYXJnZXRJbmRleF0pO1xuXHRcdEdMLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmZmVyc1ttVGFyZ2V0SW5kZXhdKTtcblx0fVxuXG5cdHVuYmluZCgpIHtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdEdMLnZpZXdwb3J0KDAsIDAsIEdMLndpZHRoLCBHTC5oZWlnaHQpO1xuXHR9XG5cblx0Ly9cdFRFWFRVUkVTXG5cblx0Z2V0VGV4dHVyZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5nbFRleHR1cmU7XG5cdH1cblxuXHQvL1x0R0VUVEVSUyBBTkQgU0VUVEVSU1xuXG5cdGdldCB3aWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZTtcblx0fVxuXG5cdGdldCBoZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemU7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDdWJlRnJhbWVCdWZmZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyLmpzIiwiLy8gTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlci5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuL0dMVGV4dHVyZSc7XG5cbmxldCBnbDtcblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpIHtcdFxuXHRyZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSk7XG59O1xuXG5jbGFzcyBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyIHtcblx0Y29uc3RydWN0b3IobVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0Z2wgPSBHTC5nbDtcblxuXHRcdHRoaXMud2lkdGggICAgICAgICAgICA9IG1XaWR0aDtcblx0XHR0aGlzLmhlaWdodCAgICAgICAgICAgPSBtSGVpZ2h0O1xuXG5cdFx0dGhpcy5tYWdGaWx0ZXIgID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIFx0fHwgZ2wuTElORUFSO1xuXHRcdHRoaXMubWluRmlsdGVyICA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciBcdHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLndyYXBTICAgICAgPSBtUGFyYW1ldGVycy53cmFwUyBcdFx0fHwgZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHR0aGlzLndyYXBUICAgICAgPSBtUGFyYW1ldGVycy53cmFwVCBcdFx0fHwgZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHR0aGlzLnVzZURlcHRoICAgPSBtUGFyYW1ldGVycy51c2VEZXB0aCBcdFx0fHwgdHJ1ZTtcblx0XHR0aGlzLnVzZVN0ZW5jaWwgPSBtUGFyYW1ldGVycy51c2VTdGVuY2lsIFx0fHwgZmFsc2U7XG5cdFx0dGhpcy50ZXhlbFR5cGUgXHQ9IG1QYXJhbWV0ZXJzLnR5cGU7XG5cdFx0dGhpcy5fbnVtU2FtcGxlID0gbVBhcmFtZXRlcnMubnVtU2FtcGxlIFx0fHwgODtcblxuXHRcdGlmKCFpc1Bvd2VyT2ZUd28odGhpcy53aWR0aCkgfHwgIWlzUG93ZXJPZlR3byh0aGlzLmhlaWdodCkpIHtcblx0XHRcdHRoaXMud3JhcFMgPSB0aGlzLndyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdFx0aWYodGhpcy5taW5GaWx0ZXIgPT09IGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCkge1xuXHRcdFx0XHR0aGlzLm1pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHRcdH1cblx0XHR9IFxuXG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblx0X2luaXQoKSB7XG5cdFx0bGV0IHRleGVsVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRoaXMudGV4ZWxUeXBlKSB7XG5cdFx0XHR0ZXhlbFR5cGUgPSB0aGlzLnRleGVsVHlwZTtcblx0XHR9XG5cblx0XHR0aGlzLnRleGVsVHlwZSA9IHRleGVsVHlwZTtcblxuXHRcdHRoaXMuZnJhbWVCdWZmZXIgICAgICAgID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcdFxuXHRcdHRoaXMuZnJhbWVCdWZmZXJDb2xvciAgID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcdFxuXHRcdHRoaXMucmVuZGVyQnVmZmVyQ29sb3IgID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0dGhpcy5yZW5kZXJCdWZmZXJEZXB0aCAgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHR0aGlzLmdsVGV4dHVyZSBcdFx0XHQ9IHRoaXMuX2NyZWF0ZVRleHR1cmUoKTtcblx0XHR0aGlzLmdsRGVwdGhUZXh0dXJlIFx0PSB0aGlzLl9jcmVhdGVUZXh0dXJlKGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBnbC5VTlNJR05FRF9TSE9SVCwgZ2wuREVQVEhfQ09NUE9ORU5ULCB0cnVlKTtcblxuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlckNvbG9yKTtcblx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9udW1TYW1wbGUsIGdsLlJHQkE4LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fbnVtU2FtcGxlLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJDb2xvcik7XG5cdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlckNvbG9yKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xUZXh0dXJlLnRleHR1cmUsIDApO1xuXHRcdC8vIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5URVhUVVJFXzJELCB0aGlzLmdsRGVwdGhUZXh0dXJlLnRleHR1cmUsIDApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXJEZXB0aCk7XG5cdFx0Ly8gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMCk7XG5cdFx0Ly8gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0fVxuXG5cdF9jcmVhdGVUZXh0dXJlKG1JbnRlcm5hbGZvcm1hdCwgbVRleGVsVHlwZSwgbUZvcm1hdCwgZm9yY2VOZWFyZXN0ID0gZmFsc2UpIHtcblx0XHRpZihtSW50ZXJuYWxmb3JtYXQgPT09IHVuZGVmaW5lZCkge1x0bUludGVybmFsZm9ybWF0ID0gZ2wuUkdCQTtcdH1cblx0XHRpZihtVGV4ZWxUeXBlID09PSB1bmRlZmluZWQpIHtcdG1UZXhlbFR5cGUgPSB0aGlzLnRleGVsVHlwZTtcdH1cblx0XHRpZighbUZvcm1hdCkge1x0bUZvcm1hdCA9IG1JbnRlcm5hbGZvcm1hdDsgfVxuXG5cdFx0Y29uc3QgdCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRjb25zdCBnbHQgPSBuZXcgR0xUZXh0dXJlKHQsIHRydWUpO1xuXHRcdGNvbnN0IG1hZ0ZpbHRlciA9IGZvcmNlTmVhcmVzdCA/IEdMLk5FQVJFU1QgOiB0aGlzLm1hZ0ZpbHRlcjtcblx0XHRjb25zdCBtaW5GaWx0ZXIgPSBmb3JjZU5lYXJlc3QgPyBHTC5ORUFSRVNUIDogdGhpcy5taW5GaWx0ZXI7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0KTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgbWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbWluRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLndyYXBTKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIG1JbnRlcm5hbGZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIG1Gb3JtYXQsIG1UZXhlbFR5cGUsIG51bGwpO1x0XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cblx0XHRyZXR1cm4gZ2x0O1xuXHR9XG5cblxuXHRiaW5kKG1BdXRvU2V0Vmlld3BvcnQ9dHJ1ZSkge1xuXHRcdGlmKG1BdXRvU2V0Vmlld3BvcnQpIHtcblx0XHRcdEdMLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcdFxuXHRcdH1cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHR9XG5cblxuXHR1bmJpbmQobUF1dG9TZXRWaWV3cG9ydD10cnVlKSB7XG5cdFx0aWYobUF1dG9TZXRWaWV3cG9ydCkge1xuXHRcdFx0R0wudmlld3BvcnQoMCwgMCwgR0wud2lkdGgsIEdMLmhlaWdodCk7XHRcblx0XHR9XG5cblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG5cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyQ29sb3IpO1xuXHRcdGdsLmNsZWFyQnVmZmVyZnYoZ2wuQ09MT1IsIDAsIFswLjAsIDAuMCwgMC4wLCAwLjBdKTtcblx0XHRnbC5ibGl0RnJhbWVidWZmZXIoXG5cdFx0XHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHRcdGdsLkNPTE9SX0JVRkZFUl9CSVQsIEdMLk5FQVJFU1Rcblx0XHQpO1xuXHRcdC8vIGdsLmJsaXRGcmFtZWJ1ZmZlcihcblx0XHQvLyBcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0Ly8gXHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdC8vIFx0Z2wuQ09MT1JfQlVGRkVSX0JJVHxnbC5ERVBUSF9TVEVOQ0lMLCBHTC5ORUFSRVNUXG5cdFx0Ly8gKTtcblxuXHRcdC8vIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlckRlcHRoKTtcblx0XHQvLyBnbC5jbGVhckJ1ZmZlcmZpKGdsLkRFUFRIX1NURU5DSUwsIDAsIDEuMCwgMCk7XG5cdFx0Ly8gZ2wuYmxpdEZyYW1lYnVmZmVyKFxuXHRcdC8vIFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHQvLyBcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0Ly8gXHRnbC5ERVBUSF9CVUZGRVJfQklULCBnbC5ORUFSRVNUXG5cdFx0Ly8gKTtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdH1cblxuXG5cdGdldFRleHR1cmUobUluZGV4ID0gMCkge1xuXHRcdHJldHVybiB0aGlzLmdsVGV4dHVyZTtcblx0fVxuXG5cblx0Z2V0RGVwdGhUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLmdsRGVwdGhUZXh0dXJlO1xuXHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXIuanMiLCIvLyBUcmFuc2Zvcm1GZWVkYmFja09iamVjdC5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4vR0xTaGFkZXInO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4vR2VvbWV0cnknO1xuXG5sZXQgZ2w7XG5cbmNsYXNzIFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IHtcblxuXG5cdGNvbnN0cnVjdG9yKHN0clZlcnRleFNoYWRlciwgc3RyRnJhZ21lbnRTaGFkZXIpIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHRoaXMuX3ZzID0gc3RyVmVydGV4U2hhZGVyO1xuXHRcdHRoaXMuX2ZzID0gc3RyRnJhZ21lbnRTaGFkZXI7XG5cdFx0XG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLl9nZW9DdXJyZW50ID0gbmV3IEdlb21ldHJ5KCk7XG5cdFx0dGhpcy5fZ2VvVGFyZ2V0ID0gbmV3IEdlb21ldHJ5KCk7XG5cdFx0dGhpcy5fbnVtUG9pbnRzID0gLTE7XG5cblx0XHR0aGlzLl92YXJ5aW5ncyA9IFtdO1xuXHRcdHRoaXMudHJhbnNmb3JtRmVlZGJhY2sgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xuXHR9XG5cblxuXHRidWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbVZhcnlpbmdOYW1lKSB7XG5cdFx0Y29uc3QgaXNUcmFuc2Zvcm1GZWVkYmFjayA9ICEhbVZhcnlpbmdOYW1lO1xuXHRcdGNvbnNvbGUubG9nKCdpcyBUcmFuc2Zvcm0gZmVlZGJhY2sgPycsIG1OYW1lLCBpc1RyYW5zZm9ybUZlZWRiYWNrKTtcblx0XHR0aGlzLl9nZW9DdXJyZW50LmJ1ZmZlckRhdGEobURhdGEsIG1OYW1lLCBudWxsLCBnbC5TVFJFQU1fQ09QWSwgZmFsc2UpO1xuXHRcdHRoaXMuX2dlb1RhcmdldC5idWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbnVsbCwgZ2wuU1RSRUFNX0NPUFksIGZhbHNlKTtcblxuXHRcdGlmKGlzVHJhbnNmb3JtRmVlZGJhY2spIHtcblx0XHRcdHRoaXMuX3ZhcnlpbmdzLnB1c2gobVZhcnlpbmdOYW1lKTtcblxuXHRcdFx0aWYodGhpcy5fbnVtUG9pbnRzIDwgMCkge1xuXHRcdFx0XHR0aGlzLl9udW1Qb2ludHMgPSBtRGF0YS5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YnVmZmVySW5kZXgobUFycmF5SW5kaWNlcykge1xuXHRcdHRoaXMuX2dlb0N1cnJlbnQuYnVmZmVySW5kZXgobUFycmF5SW5kaWNlcyk7XG5cdFx0dGhpcy5fZ2VvVGFyZ2V0LmJ1ZmZlckluZGV4KG1BcnJheUluZGljZXMpO1xuXHR9XG5cblxuXHR1bmlmb3JtKG1OYW1lLCBtVHlwZSwgbVZhbHVlKSB7XG5cdFx0aWYodGhpcy5zaGFkZXIpIHtcblx0XHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0obU5hbWUsIG1UeXBlLCBtVmFsdWUpO1x0XG5cdFx0fVxuXHRcdFxuXHR9XG5cblx0Z2VuZXJhdGUoKSB7XG5cdFx0dGhpcy5zaGFkZXIgPSBuZXcgR0xTaGFkZXIodGhpcy5fdnMsIHRoaXMuX2ZzLCB0aGlzLl92YXJ5aW5ncyk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0aWYoIXRoaXMuc2hhZGVyKSB7XHR0aGlzLmdlbmVyYXRlKCk7XHR9XG5cblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0R0wuZHJhd1RyYW5zZm9ybUZlZWRiYWNrKHRoaXMpO1xuXG5cdFx0dGhpcy5fc3dhcCgpO1xuXHR9XG5cblx0X3N3YXAoKSB7XG5cdFx0Y29uc3QgdG1wICAgICAgICAgID0gdGhpcy5fZ2VvQ3VycmVudDtcblx0XHR0aGlzLl9nZW9DdXJyZW50ID0gdGhpcy5fZ2VvVGFyZ2V0O1xuXHRcdHRoaXMuX2dlb1RhcmdldCAgPSB0bXA7XG5cdH1cblxuXHRnZXQgbnVtUG9pbnRzKCkge1x0cmV0dXJuIHRoaXMuX251bVBvaW50cztcdH1cblx0Z2V0IGdlb0N1cnJlbnQoKSB7XHRyZXR1cm4gdGhpcy5fZ2VvQ3VycmVudDtcdH1cblx0Z2V0IGdlb1RhcmdldCgpIHtcdHJldHVybiB0aGlzLl9nZW9UYXJnZXQ7XHR9XG5cdGdldCBnZW9Tb3VyY2UoKSB7XHRyZXR1cm4gdGhpcy5fZ2VvQ3VycmVudDtcdH1cblx0Z2V0IGdlb0Rlc3RpbmF0aW9uKCkge1x0cmV0dXJuIHRoaXMuX2dlb1RhcmdldDtcdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBUcmFuc2Zvcm1GZWVkYmFja09iamVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9UcmFuc2Zvcm1GZWVkYmFja09iamVjdC5qcyIsIi8vIFR3ZWVuTnVtYmVyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcblxuY29uc3QgRWFzaW5nID0ge1xuXHRMaW5lYXI6IHtcblx0XHROb25lKGspIHtcblx0XHRcdHJldHVybiBrO1xuXHRcdH1cblx0fSxcblx0UXVhZHJhdGljOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIGsgKiBrO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiBrICogKDIgLSBrKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0gMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcblx0XHR9XG5cdH0sXG5cdEN1YmljOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIGsgKiBrICogaztcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gLS1rICogayAqIGsgKyAxO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG5cdFx0fVxuXHR9LFxuXHRRdWFydGljOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIGsgKiBrICogayAqIGs7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIDEgLSAoLS1rICogayAqIGsgKiBrKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLSAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcblx0XHR9XG5cdH0sXG5cdFF1aW50aWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrICogayArIDIpO1xuXHRcdH1cblx0fSxcblx0U2ludXNvaWRhbDoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG5cdFx0fVxuXHR9LFxuXHRFeHBvbmVudGlhbDoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLSAxMCAqIGspO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoLSBNYXRoLnBvdygyLCAtIDEwICogKGsgLSAxKSkgKyAyKTtcblx0XHR9XG5cdH0sXG5cdENpcmN1bGFyOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gLSAwLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG5cdFx0fVxuXHR9LFxuXHRFbGFzdGljOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0bGV0IHM7XG5cdFx0XHRsZXQgYSA9IDAuMTtcblx0XHRcdGNvbnN0IHAgPSAwLjQ7XG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhIHx8IGEgPCAxKSB7XG5cdFx0XHRcdGEgPSAxO1xuXHRcdFx0XHRzID0gcCAvIDQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0gKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdGxldCBzO1xuXHRcdFx0bGV0IGEgPSAwLjE7XG5cdFx0XHRjb25zdCBwID0gMC40O1xuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdGlmICghYSB8fCBhIDwgMSkge1xuXHRcdFx0XHRhID0gMTtcblx0XHRcdFx0cyA9IHAgLyA0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0gMTAgKiBrKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGxldCBzO1xuXHRcdFx0bGV0IGEgPSAwLjE7XG5cdFx0XHRjb25zdCBwID0gMC40O1xuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdGlmICghYSB8fCBhIDwgMSkge1xuXHRcdFx0XHRhID0gMTtcblx0XHRcdFx0cyA9IHAgLyA0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcblx0XHRcdH1cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIC0gMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcblx0XHR9XG5cdH0sXG5cdEJhY2s6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRjb25zdCBzID0gMS43MDE1ODtcblx0XHRcdHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdGNvbnN0IHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRjb25zdCBzID0gMS43MDE1OCAqIDEuNTI1O1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuXHRcdH1cblx0fSxcblx0Qm91bmNlOiB7XG5cdFx0aW4oaykge1xuXHRcdFx0cmV0dXJuIDEgLSBFYXNpbmcuQm91bmNlLm91dCgxIC0gayk7XG5cdFx0fSxcblx0XHRvdXQoaykge1xuXHRcdFx0aWYgKGsgPCAoMSAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiBrICogaztcblx0XHRcdH0gZWxzZSBpZiAoayA8ICgyIC8gMi43NSkpIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChrIC09ICgxLjUgLyAyLjc1KSkgKiBrICsgMC43NTtcblx0XHRcdH0gZWxzZSBpZiAoayA8ICgyLjUgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuMjUgLyAyLjc1KSkgKiBrICsgMC45Mzc1O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjYyNSAvIDIuNzUpKSAqIGsgKyAwLjk4NDM3NTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGluT3V0KGspIHtcblx0XHRcdGlmIChrIDwgMC41KSB7XG5cdFx0XHRcdHJldHVybiBFYXNpbmcuQm91bmNlLmluKGsgKiAyKSAqIDAuNTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBFYXNpbmcuQm91bmNlLm91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuXHRcdH1cblx0fVxufTtcblxuZnVuY3Rpb24gZ2V0RnVuYyhtRWFzaW5nKSB7XG5cdHN3aXRjaCAobUVhc2luZykge1xuXHRkZWZhdWx0OlxuXHRjYXNlICdsaW5lYXInIDpcblx0XHRyZXR1cm4gRWFzaW5nLkxpbmVhci5Ob25lO1xuXHRjYXNlICdleHBJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuRXhwb25lbnRpYWwuSW47XG5cdGNhc2UgJ2V4cE91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuRXhwb25lbnRpYWwuT3V0O1xuXHRjYXNlICdleHBJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuRXhwb25lbnRpYWwuSW5PdXQ7XG5cblx0Y2FzZSAnY3ViaWNJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuQ3ViaWMuSW47XG5cdGNhc2UgJ2N1YmljT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DdWJpYy5PdXQ7XG5cdGNhc2UgJ2N1YmljSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkN1YmljLkluT3V0O1xuXG5cdGNhc2UgJ3F1YXJ0aWNJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVhcnRpYy5Jbjtcblx0Y2FzZSAncXVhcnRpY091dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVhcnRpYy5PdXQ7XG5cdGNhc2UgJ3F1YXJ0aWNJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVhcnRpYy5Jbk91dDtcblxuXHRjYXNlICdxdWludGljSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLlF1aW50aWMuSW47XG5cdGNhc2UgJ3F1aW50aWNPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlF1aW50aWMuT3V0O1xuXHRjYXNlICdxdWludGljSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlF1aW50aWMuSW5PdXQ7XG5cblx0Y2FzZSAnc2ludXNvaWRhbEluJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5TaW51c29pZGFsLkluO1xuXHRjYXNlICdzaW51c29pZGFsT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5TaW51c29pZGFsLk91dDtcblx0Y2FzZSAnc2ludXNvaWRhbEluT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5TaW51c29pZGFsLkluT3V0O1xuXG5cdGNhc2UgJ2NpcmN1bGFySW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkNpcmN1bGFyLkluO1xuXHRjYXNlICdjaXJjdWxhck91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQ2lyY3VsYXIuT3V0O1xuXHRjYXNlICdjaXJjdWxhckluT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DaXJjdWxhci5Jbk91dDtcblxuXHRjYXNlICdlbGFzdGljSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkVsYXN0aWMuSW47XG5cdGNhc2UgJ2VsYXN0aWNPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkVsYXN0aWMuT3V0O1xuXHRjYXNlICdlbGFzdGljSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkVsYXN0aWMuSW5PdXQ7XG5cblx0Y2FzZSAnYmFja0luJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5CYWNrLkluO1xuXHRjYXNlICdiYWNrT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5CYWNrLk91dDtcblx0Y2FzZSAnYmFja0luT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5CYWNrLkluT3V0O1xuXG5cdGNhc2UgJ2JvdW5jZUluJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5Cb3VuY2UuaW47XG5cdGNhc2UgJ2JvdW5jZU91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQm91bmNlLm91dDtcblx0Y2FzZSAnYm91bmNlSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJvdW5jZS5pbk91dDtcblx0fVxufVxuXG5jbGFzcyBUd2Vlbk51bWJlciB7XG5cdGNvbnN0cnVjdG9yKG1WYWx1ZSwgbUVhc2luZyA9ICdleHBPdXQnLCBtU3BlZWQgPSAwLjAxKSB7XG5cdFx0dGhpcy5fdmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fc3RhcnRWYWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9jb3VudGVyID0gMTtcblx0XHR0aGlzLnNwZWVkID0gbVNwZWVkO1xuXHRcdHRoaXMuZWFzaW5nID0gbUVhc2luZztcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2VmSW5kZXggICAgID0gU2NoZWR1bGVyLmFkZEVGKCgpPT4gdGhpcy5fdXBkYXRlKCkpO1xuXHR9XG5cblxuXHRfdXBkYXRlKCkge1xuXHRcdGxldCBuZXdDb3VudGVyID0gdGhpcy5fY291bnRlciArIHRoaXMuc3BlZWQ7XG5cdFx0aWYobmV3Q291bnRlciA+IDEpIHsgbmV3Q291bnRlciA9IDE7IH1cblx0XHRpZih0aGlzLl9jb3VudGVyID09PSBuZXdDb3VudGVyKSB7XG5cdFx0XHR0aGlzLl9uZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fY291bnRlciA9IG5ld0NvdW50ZXI7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdH1cblxuXG5cdGxpbWl0KG1NaW4sIG1NYXgpIHtcblx0XHRpZihtTWluID4gbU1heCkge1xuXHRcdFx0dGhpcy5saW1pdChtTWF4LCBtTWluKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9taW4gPSBtTWluO1xuXHRcdHRoaXMuX21heCA9IG1NYXg7XG5cblx0XHR0aGlzLl9jaGVja0xpbWl0KCk7XG5cdH1cblxuXHRzZXRUbyhtVmFsdWUpIHtcblx0XHR0aGlzLl92YWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9jb3VudGVyID0gMTtcblx0fVxuXG5cblx0X2NoZWNrTGltaXQoKSB7XG5cdFx0aWYodGhpcy5fbWluICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdGFyZ2V0VmFsdWUgPCB0aGlzLl9taW4pIHtcblx0XHRcdHRoaXMuX3RhcmdldFZhbHVlID0gdGhpcy5fbWluO1xuXHRcdH0gXG5cblx0XHRpZih0aGlzLl9tYXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90YXJnZXRWYWx1ZSA+IHRoaXMuX21heCkge1xuXHRcdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSB0aGlzLl9tYXg7XG5cdFx0fSBcblx0fVxuXG5cblx0ZGVzdHJveSgpIHtcblx0XHRTY2hlZHVsZXIucmVtb3ZlRUYodGhpcy5fZWZJbmRleCk7XG5cdH1cblxuXHQvL1x0R0VUVEVSUyAvIFNFVFRFUlNcblxuXHRzZXQgdmFsdWUobVZhbHVlKSB7XG5cdFx0dGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX2NoZWNrTGltaXQoKTtcblx0XHR0aGlzLl9jb3VudGVyID0gMDtcblx0fVxuXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRpZih0aGlzLl9uZWVkVXBkYXRlKSB7XG5cdFx0XHRjb25zdCBmID0gZ2V0RnVuYyh0aGlzLmVhc2luZyk7XG5cdFx0XHRjb25zdCBwID0gZih0aGlzLl9jb3VudGVyKTtcblx0XHRcdHRoaXMuX3ZhbHVlID0gdGhpcy5fc3RhcnRWYWx1ZSArIHAgKiAodGhpcy5fdGFyZ2V0VmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKTtcblx0XHRcdHRoaXMuX25lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9XG5cblx0Z2V0IHRhcmdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl90YXJnZXRWYWx1ZTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFR3ZWVuTnVtYmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1R3ZWVuTnVtYmVyLmpzIiwiLy8gUXVhdFJvdGF0aW9uLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGdsbSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IEVhc2VOdW1iZXIgZnJvbSAnLi9FYXNlTnVtYmVyJztcbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnc2NoZWR1bGluZyc7XG5cbmNvbnN0IGdldE1vdXNlID0gZnVuY3Rpb24gKG1FdmVudCwgbVRhcmdldCkge1xuXG5cdGNvbnN0IG8gPSBtVGFyZ2V0IHx8IHt9O1xuXHRpZihtRXZlbnQudG91Y2hlcykge1xuXHRcdG8ueCA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdG8ueSA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXHR9IGVsc2Uge1xuXHRcdG8ueCA9IG1FdmVudC5jbGllbnRYO1xuXHRcdG8ueSA9IG1FdmVudC5jbGllbnRZO1xuXHR9XG5cblx0cmV0dXJuIG87XG59O1xuXG5jbGFzcyBRdWF0Um90YXRpb24ge1xuXHRjb25zdHJ1Y3RvcihtVGFyZ2V0LCBtTGlzdGVuZXJUYXJnZXQgPSB3aW5kb3csIG1FYXNpbmcgPSAwLjEpIHtcblxuXHRcdHRoaXMuX3RhcmdldCAgICAgICAgID0gbVRhcmdldDtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldCA9IG1MaXN0ZW5lclRhcmdldDtcblx0XHRcblx0XHR0aGlzLm1hdHJpeCAgICAgICAgICA9IGdsbS5tYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMubSAgICAgICAgICAgICAgID0gZ2xtLm1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fdlpheGlzICAgICAgICAgPSBnbG0udmVjMy5jbG9uZShbMCwgMCwgMF0pO1xuXHRcdHRoaXMuX3pBeGlzICAgICAgICAgID0gZ2xtLnZlYzMuY2xvbmUoWzAsIDAsIDFdKTtcblx0XHR0aGlzLnByZU1vdXNlICAgICAgICA9IHsgeDowLCB5OjAgfTtcblx0XHR0aGlzLm1vdXNlICAgICAgICAgICA9IHsgeDowLCB5OjAgfTtcblx0XHR0aGlzLl9pc01vdXNlRG93biAgICA9IGZhbHNlO1xuXHRcdHRoaXMuX3JvdGF0aW9uICAgICAgID0gZ2xtLnF1YXQuY3JlYXRlKCk7XG5cdFx0dGhpcy50ZW1wUm90YXRpb24gICAgPSBnbG0ucXVhdC5jcmVhdGUoKTtcblx0XHR0aGlzLl9yb3RhdGVaTWFyZ2luICA9IDA7XG5cdFx0dGhpcy5fb2Zmc2V0ICAgICAgICAgPSAwLjAwNDtcblx0XHR0aGlzLl9zbGVycCAgICAgICAgICA9IC0xO1xuXHRcdHRoaXMuX2lzTG9ja2VkICAgICAgID0gZmFsc2U7XG5cdFx0XG5cdFx0dGhpcy5fZGlmZlggICAgICAgICAgPSBuZXcgRWFzZU51bWJlcigwLCBtRWFzaW5nKTtcblx0XHR0aGlzLl9kaWZmWSAgICAgICAgICA9IG5ldyBFYXNlTnVtYmVyKDAsIG1FYXNpbmcpO1xuXG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHRoaXMuX29uRG93bihlKSk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIChlKSA9PiB0aGlzLl9vbkRvd24oZSkpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB0aGlzLl9vbk1vdmUoZSkpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIChlKSA9PiB0aGlzLl9vbk1vdmUoZSkpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpID0+IHRoaXMuX29uVXAoKSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB0aGlzLl9vblVwKCkpO1xuXG5cdFx0U2NoZWR1bGVyLmFkZEVGKCgpID0+IHRoaXMuX2xvb3AoKSk7XG5cdH1cblxuXHQvLyBcdFBVQkxJQyBNRVRIT0RTXG5cblx0aW52ZXJzZUNvbnRyb2woaXNJbnZlcnQgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNJbnZlcnQgPSBpc0ludmVydDtcblx0fVxuXG5cdGxvY2sobVZhbHVlID0gdHJ1ZSkge1xuXHRcdHRoaXMuX2lzTG9ja2VkID0gbVZhbHVlO1xuXHR9XHRcblxuXHRzZXRDYW1lcmFQb3MobVF1YXQsIHNwZWVkID0gMC4xKSB7XG5cdFx0dGhpcy5lYXNpbmcgPSBzcGVlZDtcblx0XHRpZih0aGlzLl9zbGVycCA+IDApIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0Y29uc3QgdGVtcFJvdGF0aW9uICA9IGdsbS5xdWF0LmNsb25lKHRoaXMuX3JvdGF0aW9uKTtcblx0XHR0aGlzLl91cGRhdGVSb3RhdGlvbih0ZW1wUm90YXRpb24pO1xuXHRcdHRoaXMuX3JvdGF0aW9uICAgID0gZ2xtLnF1YXQuY2xvbmUodGVtcFJvdGF0aW9uKTtcblx0XHR0aGlzLl9jdXJyRGlmZlggICA9IHRoaXMuZGlmZlggPSAwO1xuXHRcdHRoaXMuX2N1cnJEaWZmWSAgID0gdGhpcy5kaWZmWSA9IDA7XG5cdFx0XG5cdFx0dGhpcy5faXNNb3VzZURvd24gPSBmYWxzZTtcblx0XHR0aGlzLl9pc1JvdGF0ZVogICA9IDA7XG5cdFx0XG5cdFx0dGhpcy5fdGFyZ2V0UXVhdCAgPSBnbG0ucXVhdC5jbG9uZShtUXVhdCk7XG5cdFx0dGhpcy5fc2xlcnAgICAgICAgPSAxO1xuXHR9XG5cblx0cmVzZXRRdWF0KCkge1xuXHRcdHRoaXMuX3JvdGF0aW9uICAgID0gZ2xtLnF1YXQuY2xvbmUoWzAsIDAsIDEsIDBdKTtcblx0XHR0aGlzLnRlbXBSb3RhdGlvbiA9IGdsbS5xdWF0LmNsb25lKFswLCAwLCAwLCAwXSk7XG5cdFx0dGhpcy5fdGFyZ2V0UXVhdCAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5fc2xlcnAgICAgICAgPSAtMTtcblx0fVxuXG5cdC8vXHRFVkVOVCBIQU5ETEVSXG5cblx0X29uRG93bihtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tlZCkgeyByZXR1cm47IH1cblxuXHRcdGNvbnN0IG1vdXNlID0gZ2V0TW91c2UobUV2ZW50KTtcblx0XHRjb25zdCB0ZW1wUm90YXRpb24gPSBnbG0ucXVhdC5jbG9uZSh0aGlzLl9yb3RhdGlvbik7XG5cdFx0dGhpcy5fdXBkYXRlUm90YXRpb24odGVtcFJvdGF0aW9uKTtcblx0XHR0aGlzLl9yb3RhdGlvbiA9IHRlbXBSb3RhdGlvbjtcblxuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gdHJ1ZTtcblx0XHR0aGlzLl9pc1JvdGF0ZVogPSAwO1xuXHRcdHRoaXMucHJlTW91c2UgPSB7IHg6bW91c2UueCwgeTptb3VzZS55IH07XG5cblx0XHRpZihtb3VzZS55IDwgdGhpcy5fcm90YXRlWk1hcmdpbiB8fCBtb3VzZS55ID4gKHdpbmRvdy5pbm5lckhlaWdodCAtIHRoaXMuX3JvdGF0ZVpNYXJnaW4pKSB7XHRcblx0XHRcdHRoaXMuX2lzUm90YXRlWiA9IDE7XHRcblx0XHR9IGVsc2UgaWYobW91c2UueCA8IHRoaXMuX3JvdGF0ZVpNYXJnaW4gfHwgbW91c2UueCA+ICh3aW5kb3cuaW5uZXJXaWR0aCAtIHRoaXMuX3JvdGF0ZVpNYXJnaW4pKSB7XHRcblx0XHRcdHRoaXMuX2lzUm90YXRlWiA9IDI7XHRcblx0XHR9XG5cblx0XHR0aGlzLl9kaWZmWC5zZXRUbygwKTtcblx0XHR0aGlzLl9kaWZmWS5zZXRUbygwKTtcblx0fVxuXG5cblx0X29uTW92ZShtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tlZCkgeyByZXR1cm47IH1cblx0XHRnZXRNb3VzZShtRXZlbnQsIHRoaXMubW91c2UpO1xuXHR9XG5cblxuXHRfb25VcCgpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tlZCkgeyByZXR1cm47IH1cblx0XHR0aGlzLl9pc01vdXNlRG93biA9IGZhbHNlO1xuXHR9XG5cblxuXHQvL1x0UFJJVkFURSBNRVRIT0RTXG5cblx0X3VwZGF0ZVJvdGF0aW9uKG1UZW1wUm90YXRpb24pIHtcblx0XHRpZih0aGlzLl9pc01vdXNlRG93biAmJiAhdGhpcy5faXNMb2NrZWQpIHtcblx0XHRcdHRoaXMuX2RpZmZYLnZhbHVlID0gLSh0aGlzLm1vdXNlLnggLSB0aGlzLnByZU1vdXNlLngpO1xuXHRcdFx0dGhpcy5fZGlmZlkudmFsdWUgPSAgKHRoaXMubW91c2UueSAtIHRoaXMucHJlTW91c2UueSk7XG5cblx0XHRcdGlmKHRoaXMuX2lzSW52ZXJ0KSB7XG5cdFx0XHRcdHRoaXMuX2RpZmZYLnZhbHVlID0gLXRoaXMuX2RpZmZYLnRhcmdldFZhbHVlO1xuXHRcdFx0XHR0aGlzLl9kaWZmWS52YWx1ZSA9IC10aGlzLl9kaWZmWS50YXJnZXRWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0bGV0IGFuZ2xlLCBfcXVhdDtcblxuXHRcdGlmKHRoaXMuX2lzUm90YXRlWiA+IDApIHtcblx0XHRcdGlmKHRoaXMuX2lzUm90YXRlWiA9PT0gMSkge1xuXHRcdFx0XHRhbmdsZSA9IC10aGlzLl9kaWZmWC52YWx1ZSAqIHRoaXMuX29mZnNldDsgXG5cdFx0XHRcdGFuZ2xlICo9ICh0aGlzLnByZU1vdXNlLnkgPCB0aGlzLl9yb3RhdGVaTWFyZ2luKSA/IC0xIDogMTtcblx0XHRcdFx0X3F1YXQgPSBnbG0ucXVhdC5jbG9uZShbMCwgMCwgTWF0aC5zaW4oYW5nbGUpLCBNYXRoLmNvcyhhbmdsZSldKTtcblx0XHRcdFx0Z2xtLnF1YXQubXVsdGlwbHkoX3F1YXQsIG1UZW1wUm90YXRpb24sIF9xdWF0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuZ2xlID0gLXRoaXMuX2RpZmZZLnZhbHVlICogdGhpcy5fb2Zmc2V0OyBcblx0XHRcdFx0YW5nbGUgKj0gKHRoaXMucHJlTW91c2UueCA8IHRoaXMuX3JvdGF0ZVpNYXJnaW4pID8gMSA6IC0xO1xuXHRcdFx0XHRfcXVhdCA9IGdsbS5xdWF0LmNsb25lKFswLCAwLCBNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKV0pO1xuXHRcdFx0XHRnbG0ucXVhdC5tdWx0aXBseShfcXVhdCwgbVRlbXBSb3RhdGlvbiwgX3F1YXQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCB2ID0gZ2xtLnZlYzMuY2xvbmUoW3RoaXMuX2RpZmZYLnZhbHVlLCB0aGlzLl9kaWZmWS52YWx1ZSwgMF0pO1xuXHRcdFx0Y29uc3QgYXhpcyA9IGdsbS52ZWMzLmNyZWF0ZSgpO1xuXHRcdFx0Z2xtLnZlYzMuY3Jvc3MoYXhpcywgdiwgdGhpcy5fekF4aXMpO1xuXHRcdFx0Z2xtLnZlYzMubm9ybWFsaXplKGF4aXMsIGF4aXMpO1xuXHRcdFx0YW5nbGUgPSBnbG0udmVjMy5sZW5ndGgodikgKiB0aGlzLl9vZmZzZXQ7XG5cdFx0XHRfcXVhdCA9IGdsbS5xdWF0LmNsb25lKFtNYXRoLnNpbihhbmdsZSkgKiBheGlzWzBdLCBNYXRoLnNpbihhbmdsZSkgKiBheGlzWzFdLCBNYXRoLnNpbihhbmdsZSkgKiBheGlzWzJdLCBNYXRoLmNvcyhhbmdsZSldKTtcblx0XHRcdGdsbS5xdWF0Lm11bHRpcGx5KG1UZW1wUm90YXRpb24sIF9xdWF0LCBtVGVtcFJvdGF0aW9uKTtcblx0XHR9XG5cdH1cblxuXHRfbG9vcCgpIHtcblx0XHRnbG0ubWF0NC5pZGVudGl0eSh0aGlzLm0pO1xuXG5cdFx0aWYodGhpcy5fdGFyZ2V0UXVhdCA9PT0gdW5kZWZpbmVkKSB7IFxuXHRcdFx0Z2xtLnF1YXQuc2V0KHRoaXMudGVtcFJvdGF0aW9uLCB0aGlzLl9yb3RhdGlvblswXSwgdGhpcy5fcm90YXRpb25bMV0sIHRoaXMuX3JvdGF0aW9uWzJdLCB0aGlzLl9yb3RhdGlvblszXSk7XG5cdFx0XHR0aGlzLl91cGRhdGVSb3RhdGlvbih0aGlzLnRlbXBSb3RhdGlvbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NsZXJwICs9ICgwIC0gdGhpcy5fc2xlcnApICogMC4xO1xuXG5cdFx0XHRpZih0aGlzLl9zbGVycCA8IDAuMDAwNSkge1xuXHRcdFx0XHRnbG0ucXVhdC5jb3B5KHRoaXMuX3JvdGF0aW9uLCB0aGlzLl90YXJnZXRRdWF0KTtcblx0XHRcdFx0Z2xtLnF1YXQuY29weSh0aGlzLnRlbXBSb3RhdGlvbiwgdGhpcy5fdGFyZ2V0UXVhdCk7XG5cdFx0XHRcdHRoaXMuX3RhcmdldFF1YXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHRoaXMuX2RpZmZYLnNldFRvKDApO1xuXHRcdFx0XHR0aGlzLl9kaWZmWS5zZXRUbygwKTtcblx0XHRcdFx0dGhpcy5fc2xlcnAgPSAtMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsbS5xdWF0LnNldCh0aGlzLnRlbXBSb3RhdGlvbiwgMCwgMCwgMCwgMCk7XG5cdFx0XHRcdGdsbS5xdWF0LnNsZXJwKHRoaXMudGVtcFJvdGF0aW9uLCB0aGlzLl90YXJnZXRRdWF0LCB0aGlzLl9yb3RhdGlvbiwgdGhpcy5fc2xlcnApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdsbS52ZWMzLnRyYW5zZm9ybVF1YXQodGhpcy5fdlpheGlzLCB0aGlzLl92WmF4aXMsIHRoaXMudGVtcFJvdGF0aW9uKTtcblxuXHRcdGdsbS5tYXQ0LmZyb21RdWF0KHRoaXMubWF0cml4LCB0aGlzLnRlbXBSb3RhdGlvbik7XG5cdH1cblxuXG5cdC8vXHRHRVRURVIgQU5EIFNFVFRFUlxuXG5cdHNldCBlYXNpbmcobVZhbHVlKSB7XG5cdFx0dGhpcy5fZGlmZlguZWFzaW5nID0gbVZhbHVlO1xuXHRcdHRoaXMuX2RpZmZZLmVhc2luZyA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCBlYXNpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RpZmZYLmVhc2luZztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBRdWF0Um90YXRpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uLmpzIiwiLy8gVG91Y2hEZXRlY3Rvci5qc1xuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgRXZlbnREaXNwYXRjaGVyIGZyb20gJy4vRXZlbnREaXNwYXRjaGVyJztcbmltcG9ydCBSYXkgZnJvbSAnLi4vbWF0aC9SYXknO1xuaW1wb3J0IGdldE1vdXNlIGZyb20gJy4vZ2V0TW91c2UnO1xuXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG5cdGNvbnN0IGR4ID0gYS54IC0gYi54O1xuXHRjb25zdCBkeSA9IGEueSAtIGIueTtcblx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmNsYXNzIFRvdWNoRGV0ZWN0b3IgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXHRjb25zdHJ1Y3RvcihtR2VvbWV0cnksIG1DYW1lcmEsIG1Ta2lwTW92ZUNoZWNrPWZhbHNlLCBtTGlzdGVuZXJUYXJnZXQ9d2luZG93KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX2dlb21ldHJ5ID0gbUdlb21ldHJ5O1xuXHRcdHRoaXMuX2dlb21ldHJ5LmdlbmVyYXRlRmFjZXMoKTtcblx0XHR0aGlzLl9jYW1lcmEgPSBtQ2FtZXJhO1xuXHRcdHRoaXMuZmFjZVZlcnRpY2VzID0gbUdlb21ldHJ5LmZhY2VzLm1hcCgoZmFjZSk9PihmYWNlLnZlcnRpY2VzKSk7XG5cdFx0dGhpcy5jbGlja1RvbGVyYW5jZSA9IDg7XG5cblx0XHR0aGlzLl9yYXkgPSBuZXcgUmF5KFswLCAwLCAwXSwgWzAsIDAsIC0xXSk7XG5cdFx0dGhpcy5faGl0ID0gdmVjMy5mcm9tVmFsdWVzKC05OTksIC05OTksIC05OTkpO1xuXHRcdHRoaXMuX2xhc3RQb3M7XG5cdFx0dGhpcy5fZmlyc3RQb3M7XG5cdFx0dGhpcy5tdHhNb2RlbCA9IG1hdDQuY3JlYXRlKCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldCA9IG1MaXN0ZW5lclRhcmdldDtcblx0XHR0aGlzLl9za2lwcGluZ01vdmUgPSBtU2tpcE1vdmVDaGVjaztcblxuXHRcdHRoaXMuX29uTW92ZUJpbmQgPSAoZSkgPT4gdGhpcy5fb25Nb3ZlKGUpO1xuXHRcdHRoaXMuX29uRG93bkJpbmQgPSAoZSkgPT4gdGhpcy5fb25Eb3duKGUpO1xuXHRcdHRoaXMuX29uVXBCaW5kID0gKCkgPT4gdGhpcy5fb25VcCgpO1xuXG5cdFx0dGhpcy5jb25uZWN0KCk7XG5cdH1cblxuXHRjb25uZWN0KCkge1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bkJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZUJpbmQpO1x0XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVXBCaW5kKTtcblx0fVxuXG5cdGRpc2Nvbm5lY3QoKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVXBCaW5kKTtcblx0fVxuXG5cblx0X2NoZWNrSGl0KG1UeXBlPSdvbkhpdCcpIHtcblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG5cdFx0aWYoIWNhbWVyYSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXG5cdFx0Y29uc3QgbXggPSAodGhpcy5fbGFzdFBvcy54IC8gR0wud2lkdGgpICogMi4wIC0gMS4wO1xuXHRcdGNvbnN0IG15ID0gLSAodGhpcy5fbGFzdFBvcy55IC8gR0wuaGVpZ2h0KSAqIDIuMCArIDEuMDtcblxuXHRcdGNhbWVyYS5nZW5lcmF0ZVJheShbbXgsIG15LCAwXSwgdGhpcy5fcmF5KTtcblxuXHRcdGxldCBoaXQ7XG5cdFx0Y29uc3QgdjAgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IHYxID0gdmVjMy5jcmVhdGUoKTtcblx0XHRjb25zdCB2MiA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0bGV0IGRpc3QgPSAwO1xuXG5cdFx0Y29uc3QgZ2V0VmVjdG9yID0gKHYsIHRhcmdldCkgPT4ge1xuXHRcdFx0dmVjMy50cmFuc2Zvcm1NYXQ0KHRhcmdldCwgdiwgdGhpcy5tdHhNb2RlbCk7XG5cdFx0fTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZhY2VWZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSB0aGlzLmZhY2VWZXJ0aWNlc1tpXTtcblx0XHRcdGdldFZlY3Rvcih2ZXJ0aWNlc1swXSwgdjApOyBcblx0XHRcdGdldFZlY3Rvcih2ZXJ0aWNlc1sxXSwgdjEpOyBcblx0XHRcdGdldFZlY3Rvcih2ZXJ0aWNlc1syXSwgdjIpOyBcblx0XHRcdGNvbnN0IHQgPSB0aGlzLl9yYXkuaW50ZXJzZWN0VHJpYW5nbGUodjAsIHYxLCB2Mik7XG5cblx0XHRcdGlmKHQpIHtcblx0XHRcdFx0aWYoaGl0KSB7XG5cdFx0XHRcdFx0Y29uc3QgZGlzdFRvQ2FtID0gdmVjMy5kaXN0KHQsIGNhbWVyYS5wb3NpdGlvbik7XG5cdFx0XHRcdFx0aWYoZGlzdFRvQ2FtIDwgZGlzdCkge1xuXHRcdFx0XHRcdFx0aGl0ID0gdmVjMy5jbG9uZSh0KTtcblx0XHRcdFx0XHRcdGRpc3QgPSBkaXN0VG9DYW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhpdCA9IHZlYzMuY2xvbmUodCk7XG5cdFx0XHRcdFx0ZGlzdCA9IHZlYzMuZGlzdChoaXQsIGNhbWVyYS5wb3NpdGlvbik7XG5cdFx0XHRcdH1cdFxuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0aWYoaGl0KSB7XG5cdFx0XHR0aGlzLl9oaXQgPSB2ZWMzLmNsb25lKGhpdCk7XG5cdFx0XHR0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQobVR5cGUsIHsgaGl0IH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQoJ29uVXAnKTtcblx0XHR9XG5cdH1cblxuXG5cdF9vbkRvd24oZSkge1xuXHRcdHRoaXMuX2ZpcnN0UG9zID0gZ2V0TW91c2UoZSk7XG5cdFx0dGhpcy5fbGFzdFBvcyA9IGdldE1vdXNlKGUpO1xuXHRcdHRoaXMuX2NoZWNrSGl0KCdvbkRvd24nKTtcblx0fVxuXG5cdF9vbk1vdmUoZSkge1xuXHRcdHRoaXMuX2xhc3RQb3MgPSBnZXRNb3VzZShlKTtcblx0XHRpZighdGhpcy5fc2tpcHBpbmdNb3ZlKSB7XG5cdFx0XHR0aGlzLl9jaGVja0hpdCgpO1xuXHRcdH1cblx0fVxuXG5cdF9vblVwKCkge1xuXHRcdGNvbnN0IGRpc3QgPSBkaXN0YW5jZSh0aGlzLl9maXJzdFBvcywgdGhpcy5fbGFzdFBvcyk7XG5cdFx0aWYoZGlzdCA8IHRoaXMuY2xpY2tUb2xlcmFuY2UpIHtcblx0XHRcdHRoaXMuX2NoZWNrSGl0KCk7XHRcblx0XHR9XG5cdFx0XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBUb3VjaERldGVjdG9yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3IuanMiLCIvLyBnZXRNb3VzZS5qc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZSkge1xuXHRsZXQgeCwgeTtcblxuXHRpZihlLnRvdWNoZXMpIHtcblx0XHR4ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG5cdH0gZWxzZSB7XG5cdFx0eCA9IGUuY2xpZW50WDtcblx0XHR5ID0gZS5jbGllbnRZO1xuXHR9XG5cblxuXHRyZXR1cm4ge1xuXHRcdHgsIHlcblx0fTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRNb3VzZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIFNIQURFUl9OQU1FIGdsdGZfdmVydFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5cXG4jaWZkZWYgSEFTX1VWXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX05PUk1BTFNcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdU5vcm1hbE1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdU1vZGVsVmlld01hdHJpeEludmVyc2U7XFxuXFxuXFxudmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG4jaWZkZWYgSEFTX05PUk1BTFNcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdHZlYzQgcG9zaXRpb24gPSB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG5cXHR2UG9zaXRpb24gICAgID0gcG9zaXRpb24ueHl6IC8gcG9zaXRpb24udztcXG5cXHRcXG5cXHQjaWZkZWYgSEFTX1VWXFxuXFx0dlRleHR1cmVDb29yZCA9IHZlYzIoYVRleHR1cmVDb29yZC54LCAxLjAgLSBhVGV4dHVyZUNvb3JkLnkpO1xcblxcdCNlbHNlXFxuXFx0dlRleHR1cmVDb29yZCA9IHZlYzIoMC4sMC4pO1xcblxcdCNlbmRpZlxcblxcblxcdCNpZmRlZiBIQVNfTk9STUFMU1xcblxcdHZOb3JtYWwgICAgICAgPSBub3JtYWxpemUodmVjMyh1TW9kZWxNYXRyaXggKiB2ZWM0KGFOb3JtYWwsIDAuMCkpKTtcXG5cXHQjZW5kaWZcXG5cXHRcXG5cXHRnbF9Qb3NpdGlvbiAgID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHBvc2l0aW9uO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9nbHRmLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgU0hBREVSX05BTUUgZ2x0Zl9mcmFnXFxuXFxuI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kOiBlbmFibGVcXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIFxcdHVCUkRGTWFwO1xcbnVuaWZvcm0gc2FtcGxlckN1YmUgdVJhZGlhbmNlTWFwO1xcbnVuaWZvcm0gc2FtcGxlckN1YmUgdUlycmFkaWFuY2VNYXA7XFxuXFxuI2lmZGVmIEhBU19CQVNFQ09MT1JNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1Q29sb3JNYXA7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19NRVRBTFJPVUdITkVTU01BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVNZXRhbGxpY1JvdWdobmVzc01hcDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX09DQ0xVU0lPTk1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVBb01hcDtcXG51bmlmb3JtIGZsb2F0IHVPY2NsdXNpb25TdHJlbmd0aDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX05PUk1BTE1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVOb3JtYWxNYXA7XFxudW5pZm9ybSBmbG9hdCB1Tm9ybWFsU2NhbGU7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19FTUlTU0lWRU1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVFbWlzc2l2ZU1hcDtcXG51bmlmb3JtIHZlYzMgdUVtaXNzaXZlRmFjdG9yO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gdmVjMyB1TGlnaHREaXJlY3Rpb247XFxudW5pZm9ybSB2ZWMzIHVMaWdodENvbG9yO1xcbnVuaWZvcm0gdmVjMyB1Q2FtZXJhUG9zO1xcblxcbnVuaWZvcm0gdmVjNCB1U2NhbGVEaWZmQmFzZU1SO1xcbnVuaWZvcm0gdmVjNCB1U2NhbGVGR0RTcGVjO1xcbnVuaWZvcm0gdmVjNCB1U2NhbGVJQkxBbWJpZW50O1xcblxcbnVuaWZvcm0gdmVjMyB1QmFzZUNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdVJvdWdobmVzcztcXG51bmlmb3JtIGZsb2F0IHVNZXRhbGxpYztcXG51bmlmb3JtIGZsb2F0IHVHYW1tYTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xcblxcbiNpZmRlZiBIQVNfTk9STUFMU1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcblxcblxcbi8vXFx0RnJvbSBHTFRGIFdlYkdMIFBCUiA6XFxuLy9cXHRodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYtV2ViR0wtUEJSXFxuXFxuLy8gRW5jYXBzdWxhdGUgdGhlIHZhcmlvdXMgaW5wdXRzIHVzZWQgYnkgdGhlIHZhcmlvdXMgZnVuY3Rpb25zIGluIHRoZSBzaGFkaW5nIGVxdWF0aW9uXFxuLy8gV2Ugc3RvcmUgdmFsdWVzIGluIHRoaXMgc3RydWN0IHRvIHNpbXBsaWZ5IHRoZSBpbnRlZ3JhdGlvbiBvZiBhbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbnNcXG4vLyBvZiB0aGUgc2hhZGluZyB0ZXJtcywgb3V0bGluZWQgaW4gdGhlIFJlYWRtZS5NRCBBcHBlbmRpeC5cXG5zdHJ1Y3QgUEJSSW5mb1xcbntcXG5cXHRmbG9hdCBOZG90TDsgICAgICAgICAgICAgICAgICAvLyBjb3MgYW5nbGUgYmV0d2VlbiBub3JtYWwgYW5kIGxpZ2h0IGRpcmVjdGlvblxcblxcdGZsb2F0IE5kb3RWOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIG5vcm1hbCBhbmQgdmlldyBkaXJlY3Rpb25cXG5cXHRmbG9hdCBOZG90SDsgICAgICAgICAgICAgICAgICAvLyBjb3MgYW5nbGUgYmV0d2VlbiBub3JtYWwgYW5kIGhhbGYgdmVjdG9yXFxuXFx0ZmxvYXQgTGRvdEg7ICAgICAgICAgICAgICAgICAgLy8gY29zIGFuZ2xlIGJldHdlZW4gbGlnaHQgZGlyZWN0aW9uIGFuZCBoYWxmIHZlY3RvclxcblxcdGZsb2F0IFZkb3RIOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIHZpZXcgZGlyZWN0aW9uIGFuZCBoYWxmIHZlY3RvclxcblxcdGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3M7ICAgIC8vIHJvdWdobmVzcyB2YWx1ZSwgYXMgYXV0aG9yZWQgYnkgdGhlIG1vZGVsIGNyZWF0b3IgKGlucHV0IHRvIHNoYWRlcilcXG5cXHRmbG9hdCBtZXRhbG5lc3M7ICAgICAgICAgICAgICAvLyBtZXRhbGxpYyB2YWx1ZSBhdCB0aGUgc3VyZmFjZVxcblxcdHZlYzMgcmVmbGVjdGFuY2UwOyAgICAgICAgICAgIC8vIGZ1bGwgcmVmbGVjdGFuY2UgY29sb3IgKG5vcm1hbCBpbmNpZGVuY2UgYW5nbGUpXFxuXFx0dmVjMyByZWZsZWN0YW5jZTkwOyAgICAgICAgICAgLy8gcmVmbGVjdGFuY2UgY29sb3IgYXQgZ3JhemluZyBhbmdsZVxcblxcdGZsb2F0IGFscGhhUm91Z2huZXNzOyAgICAgICAgIC8vIHJvdWdobmVzcyBtYXBwZWQgdG8gYSBtb3JlIGxpbmVhciBjaGFuZ2UgaW4gdGhlIHJvdWdobmVzcyAocHJvcG9zZWQgYnkgWzJdKVxcblxcdHZlYzMgZGlmZnVzZUNvbG9yOyAgICAgICAgICAgIC8vIGNvbG9yIGNvbnRyaWJ1dGlvbiBmcm9tIGRpZmZ1c2UgbGlnaHRpbmdcXG5cXHR2ZWMzIHNwZWN1bGFyQ29sb3I7ICAgICAgICAgICAvLyBjb2xvciBjb250cmlidXRpb24gZnJvbSBzcGVjdWxhciBsaWdodGluZ1xcbn07XFxuXFxuXFxuY29uc3QgZmxvYXQgTV9QSSA9IDMuMTQxNTkyNjUzNTg5NzkzO1xcbmNvbnN0IGZsb2F0IGNfTWluUm91Z2huZXNzID0gMC4wNDtcXG5cXG5cXG52ZWM0IFNSR0J0b0xJTkVBUih2ZWM0IHNyZ2JJbilcXG57XFxuXFx0I2lmZGVmIE1BTlVBTF9TUkdCXFxuXFx0I2lmZGVmIFNSR0JfRkFTVF9BUFBST1hJTUFUSU9OXFxuXFx0dmVjMyBsaW5PdXQgPSBwb3coc3JnYkluLnh5eix2ZWMzKDIuMikpO1xcblxcdCNlbHNlIC8vU1JHQl9GQVNUX0FQUFJPWElNQVRJT05cXG5cXHR2ZWMzIGJMZXNzID0gc3RlcCh2ZWMzKDAuMDQwNDUpLHNyZ2JJbi54eXopO1xcblxcdHZlYzMgbGluT3V0ID0gbWl4KCBzcmdiSW4ueHl6L3ZlYzMoMTIuOTIpLCBwb3coKHNyZ2JJbi54eXordmVjMygwLjA1NSkpL3ZlYzMoMS4wNTUpLHZlYzMoMi40KSksIGJMZXNzICk7XFxuXFx0I2VuZGlmIC8vU1JHQl9GQVNUX0FQUFJPWElNQVRJT05cXG5cXHRyZXR1cm4gdmVjNChsaW5PdXQsc3JnYkluLncpOztcXG5cXHQjZWxzZSAvL01BTlVBTF9TUkdCXFxuXFx0cmV0dXJuIHNyZ2JJbjtcXG5cXHQjZW5kaWYgLy9NQU5VQUxfU1JHQlxcbn1cXG5cXG5cXG52ZWMzIGdldE5vcm1hbCgpIHtcXG5cXHR2ZWMzIHBvc19keCA9IGRGZHgodlBvc2l0aW9uKTtcXG5cXHR2ZWMzIHBvc19keSA9IGRGZHkodlBvc2l0aW9uKTtcXG5cXHR2ZWMzIHRleF9keCA9IGRGZHgodmVjMyh2VGV4dHVyZUNvb3JkLCAwLjApKTtcXG5cXHR2ZWMzIHRleF9keSA9IGRGZHkodmVjMyh2VGV4dHVyZUNvb3JkLCAwLjApKTtcXG5cXHR2ZWMzIHQgPSAodGV4X2R5LnQgKiBwb3NfZHggLSB0ZXhfZHgudCAqIHBvc19keSkgLyAodGV4X2R4LnMgKiB0ZXhfZHkudCAtIHRleF9keS5zICogdGV4X2R4LnQpO1xcblxcblxcdFxcbiNpZmRlZiBIQVNfTk9STUFMU1xcblxcdHZlYzMgbmcgPSBub3JtYWxpemUodk5vcm1hbCk7XFxuI2Vsc2VcXG5cXHR2ZWMzIG5nID0gY3Jvc3MocG9zX2R4LCBwb3NfZHkpO1xcbiNlbmRpZlxcblxcblxcdHQgPSBub3JtYWxpemUodCAtIG5nICogZG90KG5nLCB0KSk7XFxuXFx0dmVjMyBiID0gbm9ybWFsaXplKGNyb3NzKG5nLCB0KSk7XFxuXFx0bWF0MyB0Ym4gPSBtYXQzKHQsIGIsIG5nKTtcXG5cXG4jaWZkZWYgSEFTX05PUk1BTE1BUFxcblxcdHZlYzMgbiA9IHRleHR1cmUyRCh1Tm9ybWFsTWFwLCB2VGV4dHVyZUNvb3JkKS5yZ2I7XFxuXFx0biA9IG5vcm1hbGl6ZSh0Ym4gKiAoKDIuMCAqIG4gLSAxLjApICogdmVjMyh1Tm9ybWFsU2NhbGUsIHVOb3JtYWxTY2FsZSwgMS4wKSkpO1xcbiNlbHNlXFxuXFx0Ly8gVGhlIHRibiBtYXRyaXggaXMgbGluZWFybHkgaW50ZXJwb2xhdGVkLCBzbyB3ZSBuZWVkIHRvIHJlLW5vcm1hbGl6ZVxcblxcdHZlYzMgbiA9IG5vcm1hbGl6ZSh0Ym5bMl0ueHl6KTtcXG4jZW5kaWZcXG5cXG5cXHRyZXR1cm4gbjtcXG59XFxuXFxuXFxudmVjMyBnZXRJQkxDb250cmlidXRpb24oUEJSSW5mbyBwYnJJbnB1dHMsIHZlYzMgbiwgdmVjMyByZWZsZWN0aW9uKVxcbntcXG5cXHRmbG9hdCBtaXBDb3VudCA9IDcuMDsgLy8gcmVzb2x1dGlvbiBvZiA1MTJ4NTEyXFxuXFx0ZmxvYXQgbG9kID0gKHBicklucHV0cy5wZXJjZXB0dWFsUm91Z2huZXNzICogbWlwQ291bnQpO1xcblxcdC8vIHJldHJpZXZlIGEgc2NhbGUgYW5kIGJpYXMgdG8gRjAuIFNlZSBbMV0sIEZpZ3VyZSAzXFxuXFx0dmVjMyBicmRmID0gU1JHQnRvTElORUFSKHRleHR1cmUyRCh1QlJERk1hcCwgdmVjMihwYnJJbnB1dHMuTmRvdFYsIDEuMCAtIHBicklucHV0cy5wZXJjZXB0dWFsUm91Z2huZXNzKSkpLnJnYjtcXG5cXHR2ZWMzIGRpZmZ1c2VMaWdodCA9IFNSR0J0b0xJTkVBUih0ZXh0dXJlQ3ViZSh1SXJyYWRpYW5jZU1hcCwgbikpLnJnYjtcXG5cXG5cXHR2ZWMzIHNwZWN1bGFyTGlnaHQgPSBTUkdCdG9MSU5FQVIodGV4dHVyZUN1YmVMb2RFWFQodVJhZGlhbmNlTWFwLCByZWZsZWN0aW9uLCBsb2QpKS5yZ2I7XFxuXFxuXFx0dmVjMyBkaWZmdXNlID0gZGlmZnVzZUxpZ2h0ICogcGJySW5wdXRzLmRpZmZ1c2VDb2xvcjtcXG5cXHR2ZWMzIHNwZWN1bGFyID0gc3BlY3VsYXJMaWdodCAqIChwYnJJbnB1dHMuc3BlY3VsYXJDb2xvciAqIGJyZGYueCArIGJyZGYueSk7XFxuXFxuXFx0Ly8gRm9yIHByZXNlbnRhdGlvbiwgdGhpcyBhbGxvd3MgdXMgdG8gZGlzYWJsZSBJQkwgdGVybXNcXG5cXHRkaWZmdXNlICo9IHVTY2FsZUlCTEFtYmllbnQueDtcXG5cXHRzcGVjdWxhciAqPSB1U2NhbGVJQkxBbWJpZW50Lnk7XFxuXFxuXFx0cmV0dXJuIGRpZmZ1c2UgKyBzcGVjdWxhcjtcXG59XFxuXFxuXFxudmVjMyBkaWZmdXNlKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRyZXR1cm4gcGJySW5wdXRzLmRpZmZ1c2VDb2xvciAvIE1fUEk7XFxufVxcblxcblxcbnZlYzMgc3BlY3VsYXJSZWZsZWN0aW9uKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRyZXR1cm4gcGJySW5wdXRzLnJlZmxlY3RhbmNlMCArIChwYnJJbnB1dHMucmVmbGVjdGFuY2U5MCAtIHBicklucHV0cy5yZWZsZWN0YW5jZTApICogcG93KGNsYW1wKDEuMCAtIHBicklucHV0cy5WZG90SCwgMC4wLCAxLjApLCA1LjApO1xcbn1cXG5cXG5mbG9hdCBnZW9tZXRyaWNPY2NsdXNpb24oUEJSSW5mbyBwYnJJbnB1dHMpXFxue1xcblxcdGZsb2F0IE5kb3RMID0gcGJySW5wdXRzLk5kb3RMO1xcblxcdGZsb2F0IE5kb3RWID0gcGJySW5wdXRzLk5kb3RWO1xcblxcdGZsb2F0IHIgPSBwYnJJbnB1dHMuYWxwaGFSb3VnaG5lc3M7XFxuXFxuXFx0ZmxvYXQgYXR0ZW51YXRpb25MID0gMi4wICogTmRvdEwgLyAoTmRvdEwgKyBzcXJ0KHIgKiByICsgKDEuMCAtIHIgKiByKSAqIChOZG90TCAqIE5kb3RMKSkpO1xcblxcdGZsb2F0IGF0dGVudWF0aW9uViA9IDIuMCAqIE5kb3RWIC8gKE5kb3RWICsgc3FydChyICogciArICgxLjAgLSByICogcikgKiAoTmRvdFYgKiBOZG90VikpKTtcXG5cXHRyZXR1cm4gYXR0ZW51YXRpb25MICogYXR0ZW51YXRpb25WO1xcbn1cXG5cXG5cXG5mbG9hdCBtaWNyb2ZhY2V0RGlzdHJpYnV0aW9uKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRmbG9hdCByb3VnaG5lc3NTcSA9IHBicklucHV0cy5hbHBoYVJvdWdobmVzcyAqIHBicklucHV0cy5hbHBoYVJvdWdobmVzcztcXG5cXHRmbG9hdCBmID0gKHBicklucHV0cy5OZG90SCAqIHJvdWdobmVzc1NxIC0gcGJySW5wdXRzLk5kb3RIKSAqIHBicklucHV0cy5OZG90SCArIDEuMDtcXG5cXHRyZXR1cm4gcm91Z2huZXNzU3EgLyAoTV9QSSAqIGYgKiBmKTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcblxcdGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3MgICA9IHVSb3VnaG5lc3M7XFxuXFx0ZmxvYXQgbWV0YWxsaWMgICAgICAgICAgICAgID0gdU1ldGFsbGljO1xcbiNpZmRlZiBIQVNfTUVUQUxST1VHSE5FU1NNQVBcXG5cXHQvLyBSb3VnaG5lc3MgaXMgc3RvcmVkIGluIHRoZSAnZycgY2hhbm5lbCwgbWV0YWxsaWMgaXMgc3RvcmVkIGluIHRoZSAnYicgY2hhbm5lbC5cXG5cXHQvLyBUaGlzIGxheW91dCBpbnRlbnRpb25hbGx5IHJlc2VydmVzIHRoZSAncicgY2hhbm5lbCBmb3IgKG9wdGlvbmFsKSBvY2NsdXNpb24gbWFwIGRhdGFcXG5cXHR2ZWM0IG1yU2FtcGxlID0gdGV4dHVyZTJEKHVNZXRhbGxpY1JvdWdobmVzc01hcCwgdlRleHR1cmVDb29yZCk7XFxuXFx0cGVyY2VwdHVhbFJvdWdobmVzcyA9IG1yU2FtcGxlLmcgKiBwZXJjZXB0dWFsUm91Z2huZXNzO1xcblxcdG1ldGFsbGljID0gbXJTYW1wbGUuYiAqIG1ldGFsbGljO1xcbiNlbmRpZlxcdFxcblxcdHBlcmNlcHR1YWxSb3VnaG5lc3MgICAgICAgICA9IGNsYW1wKHBlcmNlcHR1YWxSb3VnaG5lc3MsIGNfTWluUm91Z2huZXNzLCAxLjApO1xcblxcdG1ldGFsbGljICAgICAgICAgICAgICAgICAgICA9IGNsYW1wKG1ldGFsbGljLCAwLjAsIDEuMCk7XFxuXFx0ZmxvYXQgYWxwaGFSb3VnaG5lc3MgICAgICAgID0gcGVyY2VwdHVhbFJvdWdobmVzcyAqIHBlcmNlcHR1YWxSb3VnaG5lc3M7XFxuXFxuI2lmZGVmIEhBU19CQVNFQ09MT1JNQVBcXHRcXG5cXHR2ZWM0IGJhc2VDb2xvciA9IFNSR0J0b0xJTkVBUih0ZXh0dXJlMkQodUNvbG9yTWFwLCB2VGV4dHVyZUNvb3JkKSk7XFxuI2Vsc2VcXG5cXHR2ZWM0IGJhc2VDb2xvciAgICAgICAgICAgICAgPSB2ZWM0KHVCYXNlQ29sb3IsIDEuMCk7XFxuI2VuZGlmXFx0XFxuXFx0XFxuXFx0dmVjMyBmMCAgICAgICAgICAgICAgICAgICAgID0gdmVjMygwLjA0KTtcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvciAgICAgICAgICAgPSBiYXNlQ29sb3IucmdiICogKHZlYzMoMS4wKSAtIGYwKTtcXG5cXHRkaWZmdXNlQ29sb3IgICAgICAgICAgICAgICAgKj0gMS4wIC0gbWV0YWxsaWM7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yICAgICAgICAgID0gbWl4KGYwLCBiYXNlQ29sb3IucmdiLCBtZXRhbGxpYyk7XFxuXFx0XFxuXFx0Ly8gQ29tcHV0ZSByZWZsZWN0YW5jZS5cXG5cXHRmbG9hdCByZWZsZWN0YW5jZSAgICAgICAgICAgPSBtYXgobWF4KHNwZWN1bGFyQ29sb3Iuciwgc3BlY3VsYXJDb2xvci5nKSwgc3BlY3VsYXJDb2xvci5iKTtcXG5cXHRcXG5cXHQvLyBGb3IgdHlwaWNhbCBpbmNpZGVudCByZWZsZWN0YW5jZSByYW5nZSAoYmV0d2VlbiA0JSB0byAxMDAlKSBzZXQgdGhlIGdyYXppbmcgcmVmbGVjdGFuY2UgdG8gMTAwJSBmb3IgdHlwaWNhbCBmcmVzbmVsIGVmZmVjdC5cXG5cXHQvLyBGb3IgdmVyeSBsb3cgcmVmbGVjdGFuY2UgcmFuZ2Ugb24gaGlnaGx5IGRpZmZ1c2Ugb2JqZWN0cyAoYmVsb3cgNCUpLCBpbmNyZW1lbnRhbGx5IHJlZHVjZSBncmF6aW5nIHJlZmxlY2FuY2UgdG8gMCUuXFxuXFx0ZmxvYXQgcmVmbGVjdGFuY2U5MCAgICAgICAgID0gY2xhbXAocmVmbGVjdGFuY2UgKiAyNS4wLCAwLjAsIDEuMCk7XFxuXFx0dmVjMyBzcGVjdWxhckVudmlyb25tZW50UjAgID0gc3BlY3VsYXJDb2xvci5yZ2I7XFxuXFx0dmVjMyBzcGVjdWxhckVudmlyb25tZW50UjkwID0gdmVjMygxLjAsIDEuMCwgMS4wKSAqIHJlZmxlY3RhbmNlOTA7XFxuXFx0XFxuXFx0dmVjMyBuICAgICAgICAgICAgICAgICAgICAgID0gZ2V0Tm9ybWFsKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWwgYXQgc3VyZmFjZSBwb2ludFxcblxcdHZlYzMgdiAgICAgICAgICAgICAgICAgICAgICA9IG5vcm1hbGl6ZSh1Q2FtZXJhUG9zIC0gdlBvc2l0aW9uKTsgICAgICAgIC8vIFZlY3RvciBmcm9tIHN1cmZhY2UgcG9pbnQgdG8gY2FtZXJhXFxuXFx0dmVjMyBsICAgICAgICAgICAgICAgICAgICAgID0gbm9ybWFsaXplKHVMaWdodERpcmVjdGlvbik7ICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIHN1cmZhY2UgcG9pbnQgdG8gbGlnaHRcXG5cXHR2ZWMzIGggICAgICAgICAgICAgICAgICAgICAgPSBub3JtYWxpemUobCt2KTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbGYgdmVjdG9yIGJldHdlZW4gYm90aCBsIGFuZCB2XFxuXFx0dmVjMyByZWZsZWN0aW9uICAgICAgICAgICAgID0gLW5vcm1hbGl6ZShyZWZsZWN0KHYsIG4pKTtcXG5cXHRcXG5cXHRmbG9hdCBOZG90TCAgICAgICAgICAgICAgICAgPSBjbGFtcChkb3QobiwgbCksIDAuMDAxLCAxLjApO1xcblxcdGZsb2F0IE5kb3RWICAgICAgICAgICAgICAgICA9IGFicyhkb3QobiwgdikpICsgMC4wMDE7XFxuXFx0ZmxvYXQgTmRvdEggICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KG4sIGgpLCAwLjAsIDEuMCk7XFxuXFx0ZmxvYXQgTGRvdEggICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KGwsIGgpLCAwLjAsIDEuMCk7XFxuXFx0ZmxvYXQgVmRvdEggICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KHYsIGgpLCAwLjAsIDEuMCk7XFxuXFxuXFx0UEJSSW5mbyBwYnJJbnB1dHMgPSBQQlJJbmZvKFxcblxcdFxcdE5kb3RMLFxcblxcdFxcdE5kb3RWLFxcblxcdFxcdE5kb3RILFxcblxcdFxcdExkb3RILFxcblxcdFxcdFZkb3RILFxcblxcdFxcdHBlcmNlcHR1YWxSb3VnaG5lc3MsXFxuXFx0XFx0bWV0YWxsaWMsXFxuXFx0XFx0c3BlY3VsYXJFbnZpcm9ubWVudFIwLFxcblxcdFxcdHNwZWN1bGFyRW52aXJvbm1lbnRSOTAsXFxuXFx0XFx0YWxwaGFSb3VnaG5lc3MsXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLFxcblxcdFxcdHNwZWN1bGFyQ29sb3JcXG5cXHQpO1xcblxcblxcdC8vIENhbGN1bGF0ZSB0aGUgc2hhZGluZyB0ZXJtcyBmb3IgdGhlIG1pY3JvZmFjZXQgc3BlY3VsYXIgc2hhZGluZyBtb2RlbFxcblxcdHZlYzMgRiAgICAgICAgICAgICAgPSBzcGVjdWxhclJlZmxlY3Rpb24ocGJySW5wdXRzKTtcXG5cXHRmbG9hdCBHICAgICAgICAgICAgID0gZ2VvbWV0cmljT2NjbHVzaW9uKHBicklucHV0cyk7XFxuXFx0ZmxvYXQgRCAgICAgICAgICAgICA9IG1pY3JvZmFjZXREaXN0cmlidXRpb24ocGJySW5wdXRzKTtcXG5cXHRcXG5cXHQvLyBDYWxjdWxhdGlvbiBvZiBhbmFseXRpY2FsIGxpZ2h0aW5nIGNvbnRyaWJ1dGlvblxcblxcdHZlYzMgZGlmZnVzZUNvbnRyaWIgPSAoMS4wIC0gRikgKiBkaWZmdXNlKHBicklucHV0cyk7XFxuXFx0dmVjMyBzcGVjQ29udHJpYiAgICA9IEYgKiBHICogRCAvICg0LjAgKiBOZG90TCAqIE5kb3RWKTtcXG5cXHQvLyBPYnRhaW4gZmluYWwgaW50ZW5zaXR5IGFzIHJlZmxlY3RhbmNlIChCUkRGKSBzY2FsZWQgYnkgdGhlIGVuZXJneSBvZiB0aGUgbGlnaHQgKGNvc2luZSBsYXcpXFxuXFx0dmVjMyBjb2xvciAgICAgICAgICA9IE5kb3RMICogdUxpZ2h0Q29sb3IgKiAoZGlmZnVzZUNvbnRyaWIgKyBzcGVjQ29udHJpYik7XFxuXFx0XFxuI2lmZGVmIFVTRV9JQkxcXG5cXHRjb2xvciArPSBnZXRJQkxDb250cmlidXRpb24ocGJySW5wdXRzLCBuLCByZWZsZWN0aW9uKTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX09DQ0xVU0lPTk1BUFxcdFxcblxcdGZsb2F0IGFvICAgICAgICAgICAgPSB0ZXh0dXJlMkQodUFvTWFwLCB2VGV4dHVyZUNvb3JkKS5yO1xcblxcdGNvbG9yICAgICAgICAgICAgICAgPSBtaXgoY29sb3IsIGNvbG9yICogYW8sIHVPY2NsdXNpb25TdHJlbmd0aCk7XFxuI2VuZGlmXFx0XFxuXFxuI2lmZGVmIEhBU19FTUlTU0lWRU1BUFxcblxcdHZlYzMgZW1pc3NpdmUgPSBTUkdCdG9MSU5FQVIodGV4dHVyZTJEKHVFbWlzc2l2ZU1hcCwgdlRleHR1cmVDb29yZCkpLnJnYiAqIHVFbWlzc2l2ZUZhY3RvcjtcXG5cXHRjb2xvciArPSBlbWlzc2l2ZTtcXG4jZW5kaWZcXG5cXHRcXG5cXHQvLyBUaGlzIHNlY3Rpb24gdXNlcyBtaXggdG8gb3ZlcnJpZGUgZmluYWwgY29sb3IgZm9yIHJlZmVyZW5jZSBhcHAgdmlzdWFsaXphdGlvblxcblxcdC8vIG9mIHZhcmlvdXMgcGFyYW1ldGVycyBpbiB0aGUgbGlnaHRpbmcgZXF1YXRpb24uXFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgRiwgdVNjYWxlRkdEU3BlYy54KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKEcpLCB1U2NhbGVGR0RTcGVjLnkpO1xcblxcdGNvbG9yICAgICAgICAgICAgICAgPSBtaXgoY29sb3IsIHZlYzMoRCksIHVTY2FsZUZHRFNwZWMueik7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgc3BlY0NvbnRyaWIsIHVTY2FsZUZHRFNwZWMudyk7XFxuXFx0XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgZGlmZnVzZUNvbnRyaWIsIHVTY2FsZURpZmZCYXNlTVIueCk7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgYmFzZUNvbG9yLnJnYiwgdVNjYWxlRGlmZkJhc2VNUi55KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKG1ldGFsbGljKSwgdVNjYWxlRGlmZkJhc2VNUi56KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKHBlcmNlcHR1YWxSb3VnaG5lc3MpLCB1U2NhbGVEaWZmQmFzZU1SLncpO1xcblxcdFxcblxcdC8vIG91dHB1dCB0aGUgZnJhZ21lbnQgY29sb3JcXG5cXHRnbF9GcmFnQ29sb3IgICAgICAgID0gdmVjNChwb3coY29sb3IsdmVjMygxLjAvdUdhbW1hKSksIGJhc2VDb2xvci5hKTtcXG5cXHQvLyBnbF9GcmFnQ29sb3IgICAgICAgID0gdmVjNCh2ZWMzKG1ldGFsbGljKSwgMS4wKTtcXG5cXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvZ2x0Zi5mcmFnXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBkZWJ1Zy5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBkZWJ1Z19mcmFnXFxuI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kOiBlbmFibGVcXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMyB1RW1pc3NpdmVGYWN0b3I7XFxuXFxuI2lmZGVmIEhBU19CQVNFQ09MT1JNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1Q29sb3JNYXA7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19OT1JNQUxNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1Tm9ybWFsTWFwO1xcbnVuaWZvcm0gZmxvYXQgdU5vcm1hbFNjYWxlO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfT0NDTFVTSU9OTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdUFvTWFwO1xcbnVuaWZvcm0gZmxvYXQgdU9jY2x1c2lvblN0cmVuZ3RoO1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb247XFxuXFxudmVjMyBnZXROb3JtYWwoKSB7XFxuXFx0dmVjMyBwb3NfZHggPSBkRmR4KHZQb3NpdGlvbik7XFxuXFx0dmVjMyBwb3NfZHkgPSBkRmR5KHZQb3NpdGlvbik7XFxuXFx0dmVjMyB0ZXhfZHggPSBkRmR4KHZlYzModlRleHR1cmVDb29yZCwgMC4wKSk7XFxuXFx0dmVjMyB0ZXhfZHkgPSBkRmR5KHZlYzModlRleHR1cmVDb29yZCwgMC4wKSk7XFxuXFx0dmVjMyB0ID0gKHRleF9keS50ICogcG9zX2R4IC0gdGV4X2R4LnQgKiBwb3NfZHkpIC8gKHRleF9keC5zICogdGV4X2R5LnQgLSB0ZXhfZHkucyAqIHRleF9keC50KTtcXG5cXG5cXHR2ZWMzIG5nID0gbm9ybWFsaXplKHZOb3JtYWwpO1xcblxcblxcdHQgPSBub3JtYWxpemUodCAtIG5nICogZG90KG5nLCB0KSk7XFxuXFx0dmVjMyBiID0gbm9ybWFsaXplKGNyb3NzKG5nLCB0KSk7XFxuXFx0bWF0MyB0Ym4gPSBtYXQzKHQsIGIsIG5nKTtcXG5cXG4jaWZkZWYgSEFTX05PUk1BTE1BUFxcblxcdHZlYzMgbiA9IHRleHR1cmUyRCh1Tm9ybWFsTWFwLCB2VGV4dHVyZUNvb3JkKS5yZ2I7XFxuXFx0biA9IG5vcm1hbGl6ZSh0Ym4gKiAoKDIuMCAqIG4gLSAxLjApICogdmVjMyh1Tm9ybWFsU2NhbGUsIHVOb3JtYWxTY2FsZSwgMS4wKSkpO1xcbiNlbHNlXFxuXFx0Ly8gVGhlIHRibiBtYXRyaXggaXMgbGluZWFybHkgaW50ZXJwb2xhdGVkLCBzbyB3ZSBuZWVkIHRvIHJlLW5vcm1hbGl6ZVxcblxcdHZlYzMgbiA9IG5vcm1hbGl6ZSh0Ym5bMl0ueHl6KTtcXG4jZW5kaWZcXG5cXG5cXHRyZXR1cm4gbjtcXG59XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgLy8gZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Tm9ybWFsICogLjUgKyAuNSwgMS4wKTtcXG5cXG4gICAgdmVjMyBjb2xvciA9IGdldE5vcm1hbCgpICogLjUgKyAuNTtcXG5cXG4jaWZkZWYgSEFTX0JBU0VDT0xPUk1BUFxcblxcdGNvbG9yID0gdGV4dHVyZTJEKHVDb2xvck1hcCwgdlRleHR1cmVDb29yZCkucmdiO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfT0NDTFVTSU9OTUFQXFx0XFxuXFx0ZmxvYXQgYW8gICAgICAgICAgICA9IHRleHR1cmUyRCh1QW9NYXAsIHZUZXh0dXJlQ29vcmQpLnI7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgY29sb3IgKiBhbywgdU9jY2x1c2lvblN0cmVuZ3RoKTtcXG4jZW5kaWZcXHRcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvZGVidWcuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBDYW1lcmFDdWJlLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IENhbWVyYVBlcnNwZWN0aXZlIGZyb20gJy4vQ2FtZXJhUGVyc3BlY3RpdmUnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IENBTUVSQV9TRVRUSU5HUyA9IFtcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDEsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgLTEsIDApXSxcdFx0XG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygtMSwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAtMSwgMCldLFxuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgIDEsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgIDEpXSxcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIC0xLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIDAsIC0xKV0sXG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAwLCAgMSksIHZlYzMuZnJvbVZhbHVlcygwLCAtMSwgMCldLFxuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgLTEpLCB2ZWMzLmZyb21WYWx1ZXMoMCwgLTEsIDApXVxuXTtcblxuY2xhc3MgQ2FtZXJhQ3ViZSBleHRlbmRzIENhbWVyYVBlcnNwZWN0aXZlIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zZXRQZXJzcGVjdGl2ZShNYXRoLlBJIC8gMiwgMSwgMC4xLCAxMDAwKTtcblx0fVxuXG5cblx0ZmFjZShtSW5kZXgpIHtcblx0XHRjb25zdCBvID0gQ0FNRVJBX1NFVFRJTkdTW21JbmRleF07XG5cdFx0dGhpcy5sb29rQXQob1swXSwgb1sxXSwgb1syXSk7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmFDdWJlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2NhbWVyYXMvQ2FtZXJhQ3ViZS5qcyIsIi8vIE9iakxvYWRlci5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBCaW5hcnlMb2FkZXIgZnJvbSAnLi9CaW5hcnlMb2FkZXInO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4uL0dlb21ldHJ5JztcblxuY2xhc3MgT2JqTG9hZGVyIGV4dGVuZHMgQmluYXJ5TG9hZGVyIHtcblxuXHRsb2FkKHVybCwgY2FsbGJhY2ssIGRyYXdUeXBlID0gNCkge1xuXHRcdHRoaXMuX2RyYXdUeXBlID0gZHJhd1R5cGU7XG5cdFx0c3VwZXIubG9hZCh1cmwsIGNhbGxiYWNrKTtcblx0fVxuXG5cdF9vbkxvYWRlZCgpIHtcblx0XHR0aGlzLnBhcnNlT2JqKHRoaXMuX3JlcS5yZXNwb25zZSk7XG5cdH1cblxuXHRwYXJzZU9iaihvYmpTdHIpIHtcblx0XHRjb25zdCBsaW5lcyA9IG9ialN0ci5zcGxpdCgnXFxuJyk7XG5cblx0XHRjb25zdCBwb3NpdGlvbnMgICAgPSBbXTtcblx0XHRjb25zdCBjb29yZHMgICAgICAgPSBbXTtcblx0XHRjb25zdCBmaW5hbE5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyAgICAgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzICAgICAgPSBbXTtcblx0XHRjb25zdCB1dnMgICAgICAgICAgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzICAgICAgPSBbXTtcblx0XHRsZXQgY291bnQgICAgICAgID0gMDtcblx0XHRsZXQgcmVzdWx0O1xuXG5cdFx0Ly8gdiBmbG9hdCBmbG9hdCBmbG9hdFxuXHRcdGNvbnN0IHZlcnRleFBhdHRlcm4gPSAvdiggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS87XG5cblx0XHQvLyB2biBmbG9hdCBmbG9hdCBmbG9hdFxuXHRcdGNvbnN0IG5vcm1hbFBhdHRlcm4gPSAvdm4oICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykvO1xuXG5cdFx0Ly8gdnQgZmxvYXQgZmxvYXRcblx0XHRjb25zdCB1dlBhdHRlcm4gPSAvdnQoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspLztcblxuXHRcdC8vIGYgdmVydGV4IHZlcnRleCB2ZXJ0ZXggLi4uXG5cdFx0Y29uc3QgZmFjZVBhdHRlcm4xID0gL2YoICstP1xcZCspKCArLT9cXGQrKSggKy0/XFxkKykoICstP1xcZCspPy87XG5cblx0XHQvLyBmIHZlcnRleC91diB2ZXJ0ZXgvdXYgdmVydGV4L3V2IC4uLlxuXHRcdGNvbnN0IGZhY2VQYXR0ZXJuMiA9IC9mKCArKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKSk/LztcblxuXHRcdC8vIGYgdmVydGV4L3V2L25vcm1hbCB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWwgLi4uXG5cdFx0Y29uc3QgZmFjZVBhdHRlcm4zID0gL2YoICsoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpPy87XG5cblx0XHQvLyBmIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIC4uLiBcblx0XHRjb25zdCBmYWNlUGF0dGVybjQgPSAvZiggKygtP1xcZCspXFwvXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC9cXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcL1xcLygtP1xcZCspKSggKygtP1xcZCspXFwvXFwvKC0/XFxkKykpPy87XG5cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVmVydGV4SW5kZXgodmFsdWUpIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gcGFyc2VJbnQodmFsdWUpO1xuXHRcdFx0cmV0dXJuIChpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyB2ZXJ0aWNlcy5sZW5ndGggLyAzKSAqIDM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb3JtYWxJbmRleCh2YWx1ZSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gKGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIG5vcm1hbHMubGVuZ3RoIC8gMykgKiAzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVVZJbmRleCh2YWx1ZSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gKGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIHV2cy5sZW5ndGggLyAyKSAqIDI7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoYSwgYiwgYykge1xuXHRcdFx0cG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2FdLCB2ZXJ0aWNlc1thICsgMV0sIHZlcnRpY2VzW2EgKyAyXV0pO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2JdLCB2ZXJ0aWNlc1tiICsgMV0sIHZlcnRpY2VzW2IgKyAyXV0pO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2NdLCB2ZXJ0aWNlc1tjICsgMV0sIHZlcnRpY2VzW2MgKyAyXV0pO1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goY291bnQgKiAzICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goY291bnQgKiAzICsgMSk7XG5cdFx0XHRpbmRpY2VzLnB1c2goY291bnQgKiAzICsgMik7XG5cblx0XHRcdGNvdW50ICsrO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gYWRkVVYoYSwgYiwgYykge1xuXHRcdFx0Y29vcmRzLnB1c2goW3V2c1thXSwgdXZzW2EgKyAxXV0pO1xuXHRcdFx0Y29vcmRzLnB1c2goW3V2c1tiXSwgdXZzW2IgKyAxXV0pO1xuXHRcdFx0Y29vcmRzLnB1c2goW3V2c1tjXSwgdXZzW2MgKyAxXV0pO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gYWRkTm9ybWFsKGEsIGIsIGMpIHtcblx0XHRcdGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2FdLCBub3JtYWxzW2EgKyAxXSwgbm9ybWFsc1thICsgMl1dKTtcblx0XHRcdGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2JdLCBub3JtYWxzW2IgKyAxXSwgbm9ybWFsc1tiICsgMl1dKTtcblx0XHRcdGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2NdLCBub3JtYWxzW2MgKyAxXSwgbm9ybWFsc1tjICsgMl1dKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRGYWNlKGEsIGIsIGMsIGQsICB1YSwgdWIsIHVjLCB1ZCwgIG5hLCBuYiwgbmMsIG5kKSB7XG5cdFx0XHRsZXQgaWEgPSBwYXJzZVZlcnRleEluZGV4KGEpO1xuXHRcdFx0bGV0IGliID0gcGFyc2VWZXJ0ZXhJbmRleChiKTtcblx0XHRcdGxldCBpYyA9IHBhcnNlVmVydGV4SW5kZXgoYyk7XG5cdFx0XHRsZXQgaWQ7XG5cblx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoaWEsIGliLCBpYyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWQgPSBwYXJzZVZlcnRleEluZGV4KGQpO1xuXG5cdFx0XHRcdGFkZFZlcnRleChpYSwgaWIsIGlkKTtcblx0XHRcdFx0YWRkVmVydGV4KGliLCBpYywgaWQpO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKHVhICE9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRpYSA9IHBhcnNlVVZJbmRleCh1YSk7XG5cdFx0XHRcdGliID0gcGFyc2VVVkluZGV4KHViKTtcblx0XHRcdFx0aWMgPSBwYXJzZVVWSW5kZXgodWMpO1xuXG5cdFx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRcdGFkZFVWKGlhLCBpYiwgaWMpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZCA9IHBhcnNlVVZJbmRleCh1ZCk7XG5cblx0XHRcdFx0XHRhZGRVVihpYSwgaWIsIGlkKTtcblx0XHRcdFx0XHRhZGRVVihpYiwgaWMsIGlkKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5hICE9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRpYSA9IHBhcnNlTm9ybWFsSW5kZXgobmEpO1xuXHRcdFx0XHRpYiA9IHBhcnNlTm9ybWFsSW5kZXgobmIpO1xuXHRcdFx0XHRpYyA9IHBhcnNlTm9ybWFsSW5kZXgobmMpO1xuXG5cdFx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRcdGFkZE5vcm1hbChpYSwgaWIsIGljKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWQgPSBwYXJzZU5vcm1hbEluZGV4KG5kKTtcblxuXHRcdFx0XHRcdGFkZE5vcm1hbChpYSwgaWIsIGlkKTtcblx0XHRcdFx0XHRhZGROb3JtYWwoaWIsIGljLCBpZCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKykge1xuXHRcdFx0bGV0IGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuXHRcdFx0aWYgKGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUuY2hhckF0KDApID09PSAnIycpIHtcblxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gdmVydGV4UGF0dGVybi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMV0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzJdKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFszXSlcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gbm9ybWFsUGF0dGVybi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsxXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMl0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzNdKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKChyZXN1bHQgPSB1dlBhdHRlcm4uZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcblxuXHRcdFx0XHR1dnMucHVzaChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsxXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMl0pXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuMS5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzFdLCByZXN1bHRbMl0sIHJlc3VsdFszXSwgcmVzdWx0WzRdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuMi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzJdLCByZXN1bHRbNV0sIHJlc3VsdFs4XSwgcmVzdWx0WzExXSxcblx0XHRcdFx0XHRyZXN1bHRbM10sIHJlc3VsdFs2XSwgcmVzdWx0WzldLCByZXN1bHRbMTJdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuMy5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRhZGRGYWNlKFxuXHRcdFx0XHRcdHJlc3VsdFsyXSwgcmVzdWx0WzZdLCByZXN1bHRbMTBdLCByZXN1bHRbMTRdLFxuXHRcdFx0XHRcdHJlc3VsdFszXSwgcmVzdWx0WzddLCByZXN1bHRbMTFdLCByZXN1bHRbMTVdLFxuXHRcdFx0XHRcdHJlc3VsdFs0XSwgcmVzdWx0WzhdLCByZXN1bHRbMTJdLCByZXN1bHRbMTZdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuNC5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRhZGRGYWNlKFxuXHRcdFx0XHRcdHJlc3VsdFsyXSwgcmVzdWx0WzVdLCByZXN1bHRbOF0sIHJlc3VsdFsxMV0sXG5cdFx0XHRcdFx0dW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHJlc3VsdFszXSwgcmVzdWx0WzZdLCByZXN1bHRbOV0sIHJlc3VsdFsxMl1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fZ2VuZXJhdGVHZW9tZXRyeSh7XHRcblx0XHRcdHBvc2l0aW9ucyxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdG5vcm1hbHM6ZmluYWxOb3JtYWxzLFxuXHRcdFx0aW5kaWNlc1xuXHRcdH0pO1xuXHRcdFxuXHR9XG5cblx0X2dlbmVyYXRlR2VvbWV0cnkobykge1xuXHRcdGNvbnN0IG1heE51bVZlcnRpY2VzID0gNjU1MzU7XG5cdFx0Y29uc3QgaGFzTm9ybWFscyA9IG8ubm9ybWFscy5sZW5ndGggPiAwO1xuXHRcdGNvbnN0IGhhc1VWcyA9IG8uY29vcmRzLmxlbmd0aCA+IDA7XG5cdFx0bGV0IGdlb21ldHJ5O1xuXG5cdFx0aWYoby5wb3NpdGlvbnMubGVuZ3RoID4gbWF4TnVtVmVydGljZXMpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJpZXMgPSBbXTtcblx0XHRcdGxldCBsYXN0SW5kZXggPSAwO1xuXG5cdFx0XHRjb25zdCBvQ29weSAgICAgICA9IHt9O1xuXHRcdFx0b0NvcHkucG9zaXRpb25zID0gby5wb3NpdGlvbnMuY29uY2F0KCk7XG5cdFx0XHRvQ29weS5jb29yZHMgICAgPSBvLmNvb3Jkcy5jb25jYXQoKTtcblx0XHRcdG9Db3B5LmluZGljZXMgICA9IG8uaW5kaWNlcy5jb25jYXQoKTtcblx0XHRcdG9Db3B5Lm5vcm1hbHMgICA9IG8ubm9ybWFscy5jb25jYXQoKTtcblxuXHRcdFx0d2hpbGUoby5pbmRpY2VzLmxlbmd0aCA+IDApIHtcblxuXHRcdFx0XHRjb25zdCBzbGljZU51bSAgPSBNYXRoLm1pbihtYXhOdW1WZXJ0aWNlcywgby5wb3NpdGlvbnMubGVuZ3RoKTtcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyAgID0gby5pbmRpY2VzLnNwbGljZSgwLCBzbGljZU51bSk7XG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdFx0XHRjb25zdCBjb29yZHMgICAgPSBbXTtcblx0XHRcdFx0Y29uc3Qgbm9ybWFscyAgID0gW107XG5cdFx0XHRcdGxldCBpbmRleCwgdG1wSW5kZXggPSAwO1xuXG5cdFx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYoaW5kaWNlc1tpXSA+IHRtcEluZGV4KSB7XG5cdFx0XHRcdFx0XHR0bXBJbmRleCA9IGluZGljZXNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzW2ldO1xuXG5cdFx0XHRcdFx0cG9zaXRpb25zLnB1c2gob0NvcHkucG9zaXRpb25zW2luZGV4XSk7XG5cdFx0XHRcdFx0aWYoaGFzVVZzKSB7XG5cdFx0XHRcdFx0XHRjb29yZHMucHVzaChvQ29weS5jb29yZHNbaW5kZXhdKTtcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihoYXNOb3JtYWxzKSB7XG5cdFx0XHRcdFx0XHRub3JtYWxzLnB1c2gob0NvcHkubm9ybWFsc1tpbmRleF0pO1x0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGluZGljZXNbaV0gLT0gbGFzdEluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGFzdEluZGV4ID0gdG1wSW5kZXggKyAxO1xuXG5cdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KHRoaXMuX2RyYXdUeXBlKTtcblx0XHRcdFx0Z2VvbWV0cnkuYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdFx0XHRcdGlmKGhhc1VWcykge1xuXHRcdFx0XHRcdGdlb21ldHJ5LmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XHRcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Z2VvbWV0cnkuYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdFx0XHRcdGlmKGhhc05vcm1hbHMpIHtcblx0XHRcdFx0XHRnZW9tZXRyeS5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyaWVzLnB1c2goZ2VvbWV0cnkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhnZW9tZXRyaWVzLCBvQ29weSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyaWVzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSh0aGlzLl9kcmF3VHlwZSk7XG5cdFx0XHRnZW9tZXRyeS5idWZmZXJWZXJ0ZXgoby5wb3NpdGlvbnMpO1xuXHRcdFx0aWYoaGFzVVZzKSB7XG5cdFx0XHRcdGdlb21ldHJ5LmJ1ZmZlclRleENvb3JkKG8uY29vcmRzKTtcdFxuXHRcdFx0fVxuXHRcdFx0Z2VvbWV0cnkuYnVmZmVySW5kZXgoby5pbmRpY2VzKTtcblx0XHRcdGlmKGhhc05vcm1hbHMpIHtcblx0XHRcdFx0Z2VvbWV0cnkuYnVmZmVyTm9ybWFsKG8ubm9ybWFscyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuX2NhbGxiYWNrKSB7XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKGdlb21ldHJ5LCBvKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufVxuXG5cbk9iakxvYWRlci5wYXJzZSA9IGZ1bmN0aW9uIChvYmpTdHIpIHtcblx0Y29uc3QgbG9hZGVyID0gbmV3IE9iakxvYWRlcigpO1xuXHRyZXR1cm4gbG9hZGVyLnBhcnNlT2JqKG9ialN0cik7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBPYmpMb2FkZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9PYmpMb2FkZXIuanMiLCIvLyBIRFJMb2FkZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQmluYXJ5TG9hZGVyIGZyb20gJy4vQmluYXJ5TG9hZGVyJztcbmltcG9ydCBoZHJQYXJzZXIgZnJvbSAnLi4vdXRpbHMvSERSUGFyc2VyJztcblxuY2xhc3MgSERSTG9hZGVyIGV4dGVuZHMgQmluYXJ5TG9hZGVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIodHJ1ZSk7XG5cdH1cblxuXHRwYXJzZShtQXJyYXlCdWZmZXIpIHtcblx0XHRyZXR1cm4gaGRyUGFyc2VyKG1BcnJheUJ1ZmZlcik7XG5cdH1cblxuXHRfb25Mb2FkZWQoKSB7XG5cdFx0Y29uc3QgbyA9IHRoaXMucGFyc2UodGhpcy5fcmVxLnJlc3BvbnNlKTtcblx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0dGhpcy5fY2FsbGJhY2sobyk7XG5cdFx0fVxuXHR9XG5cbn1cblxuXG5IRFJMb2FkZXIucGFyc2UgPSBmdW5jdGlvbiAobUFycmF5QnVmZmVyKSB7XG5cdHJldHVybiBoZHJQYXJzZXIobUFycmF5QnVmZmVyKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhEUkxvYWRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0hEUkxvYWRlci5qcyIsIi8vIEhEUlBhcnNlci5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIENvZGUgcG9ydGVkIGJ5IE1hcmNpbiBJZ25hYyAoMjAxNClcbi8vIEJhc2VkIG9uIEphdmEgaW1wbGVtZW50YXRpb24gZnJvbVxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vci9jeXMxMjM0NS1yZXNlYXJjaC9zb3VyY2UvYnJvd3NlL2hkci9pbWFnZV9wcm9jZXNzb3IvUkdCRS5qYXZhP3I9N2Q4NGU5ZmQ4NjZiMjQwNzlkYmU2MWZhMGE5NjZjZTgzNjVmNTcyNlxuY29uc3QgcmFkaWFuY2VQYXR0ZXJuID0gJyNcXFxcP1JBRElBTkNFJztcbmNvbnN0IGNvbW1lbnRQYXR0ZXJuID0gJyMuKic7XG4vLyBsZXQgZ2FtbWFQYXR0ZXJuID0gJ0dBTU1BPSc7XG5jb25zdCBleHBvc3VyZVBhdHRlcm4gPSAnRVhQT1NVUkU9XFxcXHMqKFswLTldKlsuXVswLTldKiknO1xuY29uc3QgZm9ybWF0UGF0dGVybiA9ICdGT1JNQVQ9MzItYml0X3JsZV9yZ2JlJztcbmNvbnN0IHdpZHRoSGVpZ2h0UGF0dGVybiA9ICctWSAoWzAtOV0rKSBcXFxcK1ggKFswLTldKyknO1xuXG4vLyBodHRwOi8vY3JvcXVldHdlYWsuYmxvZ3Nwb3QuY28udWsvMjAxNC8wOC9kZWNvbnN0cnVjdGluZy1mbG9hdHMtZnJleHAtYW5kLWxkZXhwLmh0bWxcbi8vIGZ1bmN0aW9uIGxkZXhwKG1hbnRpc3NhLCBleHBvbmVudCkge1xuLy8gICAgIHJldHVybiBleHBvbmVudCA+IDEwMjMgPyBtYW50aXNzYSAqIE1hdGgucG93KDIsIDEwMjMpICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDIzKSA6IGV4cG9uZW50IDwgLTEwNzQgPyBtYW50aXNzYSAqIE1hdGgucG93KDIsIC0xMDc0KSAqIE1hdGgucG93KDIsIGV4cG9uZW50ICsgMTA3NCkgOiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbi8vIH1cblxuZnVuY3Rpb24gcmVhZFBpeGVsc1Jhd1JMRShidWZmZXIsIGRhdGEsIG9mZnNldCwgZmlsZU9mZnNldCwgc2NhbmxpbmVXaWR0aCwgbnVtU2NhbmxpbmVzKSB7XG5cdGNvbnN0IHJnYmUgPSBuZXcgQXJyYXkoNCk7XG5cdGxldCBzY2FubGluZUJ1ZmZlciA9IG51bGw7XG5cdGxldCBwdHI7XG5cdGxldCBwdHJFbmQ7XG5cdGxldCBjb3VudDtcblx0Y29uc3QgYnVmID0gbmV3IEFycmF5KDIpO1xuXHRjb25zdCBidWZmZXJMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuXG5cdGZ1bmN0aW9uIHJlYWRCdWYoYnVmKSB7XG5cdFx0bGV0IGJ5dGVzUmVhZCA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0YnVmW2J5dGVzUmVhZCsrXSA9IGJ1ZmZlcltmaWxlT2Zmc2V0XTtcblx0XHR9IHdoaWxlKCsrZmlsZU9mZnNldCA8IGJ1ZmZlckxlbmd0aCAmJiBieXRlc1JlYWQgPCBidWYubGVuZ3RoKTtcblx0XHRyZXR1cm4gYnl0ZXNSZWFkO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVhZEJ1Zk9mZnNldChidWYsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdFx0bGV0IGJ5dGVzUmVhZCA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0YnVmW29mZnNldCArIGJ5dGVzUmVhZCsrXSA9IGJ1ZmZlcltmaWxlT2Zmc2V0XTtcblx0XHR9IHdoaWxlKCsrZmlsZU9mZnNldCA8IGJ1ZmZlckxlbmd0aCAmJiBieXRlc1JlYWQgPCBsZW5ndGgpO1xuXHRcdHJldHVybiBieXRlc1JlYWQ7XG5cdH1cblxuXHRmdW5jdGlvbiByZWFkUGl4ZWxzUmF3KGJ1ZmZlciwgZGF0YSwgb2Zmc2V0LCBudW1waXhlbHMpIHtcblx0XHRjb25zdCBudW1FeHBlY3RlZCA9IDQgKiBudW1waXhlbHM7XG5cdFx0Y29uc3QgbnVtUmVhZCA9IHJlYWRCdWZPZmZzZXQoZGF0YSwgb2Zmc2V0LCBudW1FeHBlY3RlZCk7XG5cdFx0aWYgKG51bVJlYWQgPCBudW1FeHBlY3RlZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFcnJvciByZWFkaW5nIHJhdyBwaXhlbHM6IGdvdCAke251bVJlYWR9IGJ5dGVzLCBleHBlY3RlZCAke251bUV4cGVjdGVkfWApO1xuXHRcdH1cblx0fVxuXG5cdHdoaWxlIChudW1TY2FubGluZXMgPiAwKSB7XG5cdFx0aWYgKHJlYWRCdWYocmdiZSkgPCByZ2JlLmxlbmd0aCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFcnJvciByZWFkaW5nIGJ5dGVzOiBleHBlY3RlZCAke3JnYmUubGVuZ3RofWApO1xuXHRcdH1cblxuXHRcdGlmICgocmdiZVswXSAhPT0gMikgfHwgKHJnYmVbMV0gIT09IDIpIHx8ICgocmdiZVsyXSAmIDB4ODApICE9PSAwKSkge1xuXHRcdFx0Ly8gdGhpcyBmaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWRcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVswXTtcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVsxXTtcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVsyXTtcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVszXTtcblx0XHRcdHJlYWRQaXhlbHNSYXcoYnVmZmVyLCBkYXRhLCBvZmZzZXQsIHNjYW5saW5lV2lkdGggKiBudW1TY2FubGluZXMgLSAxKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoKCgocmdiZVsyXSAmIDB4RkYpIDw8IDgpIHwgKHJnYmVbM10gJiAweEZGKSkgIT09IHNjYW5saW5lV2lkdGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgV3Jvbmcgc2NhbmxpbmUgd2lkdGggJHsoKChyZ2JlWzJdICYgMHhGRikgPDwgOCkgfCAocmdiZVszXSAmIDB4RkYpKX0sIGV4cGVjdGVkICR7c2NhbmxpbmVXaWR0aH1gKTtcblx0XHR9XG5cblx0XHRpZiAoc2NhbmxpbmVCdWZmZXIgPT09IG51bGwpIHtcblx0XHRcdHNjYW5saW5lQnVmZmVyID0gbmV3IEFycmF5KDQgKiBzY2FubGluZVdpZHRoKTtcblx0XHR9XG5cblx0XHRwdHIgPSAwO1xuXHRcdC8qIHJlYWQgZWFjaCBvZiB0aGUgZm91ciBjaGFubmVscyBmb3IgdGhlIHNjYW5saW5lIGludG8gdGhlIGJ1ZmZlciAqL1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRwdHJFbmQgPSAoaSArIDEpICogc2NhbmxpbmVXaWR0aDtcblx0XHRcdHdoaWxlKHB0ciA8IHB0ckVuZCkge1xuXHRcdFx0XHRpZiAocmVhZEJ1ZihidWYpIDwgYnVmLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgcmVhZGluZyAyLWJ5dGUgYnVmZmVyJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKChidWZbMF0gJiAweEZGKSA+IDEyOCkge1xuXHRcdFx0XHRcdC8qIGEgcnVuIG9mIHRoZSBzYW1lIHZhbHVlICovXG5cdFx0XHRcdFx0Y291bnQgPSAoYnVmWzBdICYgMHhGRikgLSAxMjg7XG5cdFx0XHRcdFx0aWYgKChjb3VudCA9PT0gMCkgfHwgKGNvdW50ID4gcHRyRW5kIC0gcHRyKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYWQgc2NhbmxpbmUgZGF0YScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZShjb3VudC0tID4gMCkge1xuXHRcdFx0XHRcdFx0c2NhbmxpbmVCdWZmZXJbcHRyKytdID0gYnVmWzFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBhIG5vbi1ydW4gKi9cblx0XHRcdFx0XHRjb3VudCA9IGJ1ZlswXSAmIDB4RkY7XG5cdFx0XHRcdFx0aWYgKChjb3VudCA9PT0gMCkgfHwgKGNvdW50ID4gcHRyRW5kIC0gcHRyKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYWQgc2NhbmxpbmUgZGF0YScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzY2FubGluZUJ1ZmZlcltwdHIrK10gPSBidWZbMV07XG5cdFx0XHRcdFx0aWYgKC0tY291bnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRpZiAocmVhZEJ1Zk9mZnNldChzY2FubGluZUJ1ZmZlciwgcHRyLCBjb3VudCkgPCBjb3VudCkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHJlYWRpbmcgbm9uLXJ1biBkYXRhJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwdHIgKz0gY291bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyogY29weSBieXRlIGRhdGEgdG8gb3V0cHV0ICovXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHNjYW5saW5lV2lkdGg7IGkrKykge1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAwXSA9IHNjYW5saW5lQnVmZmVyW2ldO1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAxXSA9IHNjYW5saW5lQnVmZmVyW2kgKyBzY2FubGluZVdpZHRoXTtcblx0XHRcdGRhdGFbb2Zmc2V0ICsgMl0gPSBzY2FubGluZUJ1ZmZlcltpICsgMiAqIHNjYW5saW5lV2lkdGhdO1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAzXSA9IHNjYW5saW5lQnVmZmVyW2kgKyAzICogc2NhbmxpbmVXaWR0aF07XG5cdFx0XHRvZmZzZXQgKz0gNDtcblx0XHR9XG5cblx0XHRudW1TY2FubGluZXMtLTtcblx0fVxuXG59XG5cbi8vIFJldHVybnMgZGF0YSBhcyBmbG9hdHMgYW5kIGZsaXBwZWQgYWxvbmcgWSBieSBkZWZhdWx0XG5mdW5jdGlvbiBwYXJzZUhkcihidWZmZXIpIHtcblx0aWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0YnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblx0fVxuXG5cdGxldCBmaWxlT2Zmc2V0ID0gMDtcblx0Y29uc3QgYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcblxuXHRjb25zdCBORVdfTElORSA9IDEwO1xuXG5cdGZ1bmN0aW9uIHJlYWRMaW5lKCkge1xuXHRcdGxldCBidWYgPSAnJztcblx0XHRkbyB7XG5cdFx0XHRjb25zdCBiID0gYnVmZmVyW2ZpbGVPZmZzZXRdO1xuXHRcdFx0aWYgKGIgPT09IE5FV19MSU5FKSB7XG5cdFx0XHRcdCsrZmlsZU9mZnNldDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcblx0XHR9IHdoaWxlKCsrZmlsZU9mZnNldCA8IGJ1ZmZlckxlbmd0aCk7XG5cdFx0cmV0dXJuIGJ1Zjtcblx0fVxuXG5cdGxldCB3aWR0aCA9IDA7XG5cdGxldCBoZWlnaHQgPSAwO1xuXHRsZXQgZXhwb3N1cmUgPSAxO1xuXHRjb25zdCBnYW1tYSA9IDE7XG5cdGxldCBybGUgPSBmYWxzZTtcblxuXHRmb3IobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuXHRcdGNvbnN0IGxpbmUgPSByZWFkTGluZSgpO1xuXHRcdGxldCBtYXRjaDtcblx0XHRpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKHJhZGlhbmNlUGF0dGVybikpIHtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaChmb3JtYXRQYXR0ZXJuKSkge1xuXHRcdFx0cmxlID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaChleHBvc3VyZVBhdHRlcm4pKSB7XG5cdFx0XHRleHBvc3VyZSA9IE51bWJlcihtYXRjaFsxXSk7XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goY29tbWVudFBhdHRlcm4pKSB7XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IGxpbmUubWF0Y2god2lkdGhIZWlnaHRQYXR0ZXJuKSkge1xuXHRcdFx0aGVpZ2h0ID0gTnVtYmVyKG1hdGNoWzFdKTtcblx0XHRcdHdpZHRoID0gTnVtYmVyKG1hdGNoWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdGlmICghcmxlKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdGaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWQhJyk7XG5cdH1cblxuXHRjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcblx0Y29uc3Qgc2NhbmxpbmVXaWR0aCA9IHdpZHRoO1xuXHRjb25zdCBudW1TY2FubGluZXMgPSBoZWlnaHQ7XG5cblx0cmVhZFBpeGVsc1Jhd1JMRShidWZmZXIsIGRhdGEsIDAsIGZpbGVPZmZzZXQsIHNjYW5saW5lV2lkdGgsIG51bVNjYW5saW5lcyk7XG5cblx0Ly8gVE9ETzogU2hvdWxkIGJlIEZsb2F0MTZcblx0Y29uc3QgZmxvYXREYXRhID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuXHRmb3IobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGRhdGEubGVuZ3RoOyBvZmZzZXQgKz0gNCkge1xuXHRcdGxldCByID0gZGF0YVtvZmZzZXQgKyAwXSAvIDI1NTtcblx0XHRsZXQgZyA9IGRhdGFbb2Zmc2V0ICsgMV0gLyAyNTU7XG5cdFx0bGV0IGIgPSBkYXRhW29mZnNldCArIDJdIC8gMjU1O1xuXHRcdGNvbnN0IGUgPSBkYXRhW29mZnNldCArIDNdO1xuXHRcdGNvbnN0IGYgPSBNYXRoLnBvdygyLjAsIGUgLSAxMjguMCk7XG5cblx0XHRyICo9IGY7XG5cdFx0ZyAqPSBmO1xuXHRcdGIgKj0gZjtcblxuXHRcdGNvbnN0IGZsb2F0T2Zmc2V0ID0gb2Zmc2V0O1xuXG5cdFx0ZmxvYXREYXRhW2Zsb2F0T2Zmc2V0ICsgMF0gPSByO1xuXHRcdGZsb2F0RGF0YVtmbG9hdE9mZnNldCArIDFdID0gZztcblx0XHRmbG9hdERhdGFbZmxvYXRPZmZzZXQgKyAyXSA9IGI7XG5cdFx0ZmxvYXREYXRhW2Zsb2F0T2Zmc2V0ICsgM10gPSAxLjA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNoYXBlOiBbd2lkdGgsIGhlaWdodF0sXG5cdFx0ZXhwb3N1cmUsXG5cdFx0Z2FtbWEsXG5cdFx0ZGF0YTogZmxvYXREYXRhXG5cdH07XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2VIZHI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvSERSUGFyc2VyLmpzIiwiLy8gQ29sbGFkYVBhcnNlci5qc1xuXG5pbXBvcnQgcGFyc2VyIGZyb20gJ2NvbGxhZGEtcGFyc2VyJztcbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuLi9HZW9tZXRyeSc7XG5cblxuY29uc3QgZ2VuZXJhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uIChtZXNoZXMpIHtcblx0Y29uc3QgY2FjaGVzID0ge307XG5cblx0bWVzaGVzLmZvckVhY2goKG1lc2gpPT4ge1xuXHRcdGNvbnN0IHsgdmVydGljZXMsIG5vcm1hbHMsIGNvb3JkcywgdHJpYW5nbGVzLCBuYW1lIH0gPSBtZXNoLm1lc2g7XG5cdFx0aWYoIWNhY2hlc1tuYW1lXSkge1xuXHRcdFx0Y29uc3QgZ2xHZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpXG5cdFx0XHRcdC5idWZmZXJGbGF0dGVuRGF0YSh2ZXJ0aWNlcywgJ2FWZXJ0ZXhQb3NpdGlvbicsIDMpXG5cdFx0XHRcdC5idWZmZXJGbGF0dGVuRGF0YShjb29yZHMsICdhVGV4dHVyZUNvb3JkJywgMilcblx0XHRcdFx0LmJ1ZmZlckZsYXR0ZW5EYXRhKG5vcm1hbHMsICdhTm9ybWFsJywgMylcblx0XHRcdFx0LmJ1ZmZlckluZGV4KHRyaWFuZ2xlcyk7XG5cblx0XHRcdGNhY2hlc1tuYW1lXSA9IGdsR2VvbWV0cnk7XG5cdFx0fVxuXG5cdFx0bWVzaC5nbEdlb21ldHJ5ID0gY2FjaGVzW25hbWVdO1xuXHR9KTtcbn07XG5cbmNvbnN0IHBhcnNlID0gZnVuY3Rpb24gKG1EYXRhKSB7XG5cdGNvbnN0IG1lc2hlcyA9IHBhcnNlci5wYXJzZShtRGF0YSk7XG5cdGdlbmVyYXRlR2VvbWV0cnkobWVzaGVzKTtcblxuXHRyZXR1cm4gbWVzaGVzO1xufTtcblxuY29uc3QgbG9hZCA9IGZ1bmN0aW9uIChtUGF0aCwgbUNhbGxiYWNrKSB7XG5cdHBhcnNlci5sb2FkKG1QYXRoLCAobWVzaGVzKT0+IHtcblx0XHRnZW5lcmF0ZUdlb21ldHJ5KG1lc2hlcyk7XG5cdFx0bUNhbGxiYWNrKG1lc2hlcyk7XG5cdH0pO1xufTtcblxuY29uc3QgQ29sbGFkYVBhcnNlciA9IHtcblx0cGFyc2UsXG5cdGxvYWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQ29sbGFkYVBhcnNlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0NvbGxhZGFQYXJzZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQ29sbGFkYSA9IHJlcXVpcmUoJy4vQ29sbGFkYScpO1xuXG52YXIgX0NvbGxhZGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sbGFkYSk7XG5cbnZhciBfZ2xNYXRyaXggPSByZXF1aXJlKCdnbC1tYXRyaXgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gQ29sbGFkYVBhcnNlci5qc1xuXG52YXIgcGFyc2VEYXRhID0gZnVuY3Rpb24gcGFyc2VEYXRhKG1EYXRhKSB7XG5cdHZhciBtYXRlcmlhbHMgPSBtRGF0YS5tYXRlcmlhbHMsXG5cdCAgICBtZXNoZXMgPSBtRGF0YS5tZXNoZXM7XG5cblxuXHR2YXIgZmluYWxNZXNoZXMgPSBbXTtcblx0dmFyIG1lc2hPYmpzID0gW107XG5cdHZhciBhbGxNZXNoZXMgPSBbXTtcblxuXHQvL1x0Z2V0dGluZyBhbGwgbWVzaGVzJyBidWZmZXJzXG5cdGZvciAodmFyIHMgaW4gbWVzaGVzKSB7XG5cdFx0dmFyIG9NZXNoID0gbWVzaGVzW3NdO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IG9NZXNoLnZlcnRpY2VzLFxuXHRcdCAgICBub3JtYWxzID0gb01lc2gubm9ybWFscyxcblx0XHQgICAgY29vcmRzID0gb01lc2guY29vcmRzLFxuXHRcdCAgICB0cmlhbmdsZXMgPSBvTWVzaC50cmlhbmdsZXM7XG5cblx0XHR2YXIgYnVmZmVycyA9IHtcblx0XHRcdHZlcnRpY2VzOiB2ZXJ0aWNlcywgbm9ybWFsczogbm9ybWFscywgY29vcmRzOiBjb29yZHMsIHRyaWFuZ2xlczogdHJpYW5nbGVzXG5cdFx0fTtcblx0XHRhbGxNZXNoZXMucHVzaCh7XG5cdFx0XHRpZDogcyxcblx0XHRcdGJ1ZmZlcnM6IGJ1ZmZlcnNcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldE1hdGVyaWFsKGlkKSB7XG5cdFx0dmFyIG1hdCA9IHZvaWQgMDtcblx0XHRmb3IgKHZhciBfcyBpbiBtYXRlcmlhbHMpIHtcblx0XHRcdGlmIChfcyA9PT0gaWQpIHtcblx0XHRcdFx0bWF0ID0gbWF0ZXJpYWxzW19zXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgb01hdGVyaWFsID0ge307XG5cdFx0aWYgKG1hdC5kaWZmdXNlKSB7XG5cdFx0XHRvTWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gbWF0LmRpZmZ1c2U7XG5cdFx0fVxuXG5cdFx0b01hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IG1hdC5kaWZmdXNlIHx8IFswLCAwLCAwXTtcblx0XHRvTWF0ZXJpYWwuc2hpbmluZXNzID0gbWF0LnNoaW5pbmVzcyB8fCAwO1xuXHRcdGlmIChtYXQudGV4dHVyZXMpIHtcblx0XHRcdGlmIChtYXQudGV4dHVyZXMuZGlmZnVzZSkge1xuXHRcdFx0XHRvTWF0ZXJpYWwuZGlmZnVzZU1hcElEID0gbWF0LnRleHR1cmVzLmRpZmZ1c2UubWFwX2lkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0LnRleHR1cmVzLm5vcm1hbCkge1xuXHRcdFx0XHRvTWF0ZXJpYWwubm9ybWFsTWFwSUQgPSBtYXQudGV4dHVyZXMubm9ybWFsLm1hcF9pZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb01hdGVyaWFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gd2Fsayhub2RlLCBtdHhQYXJlbnQpIHtcblx0XHR2YXIgbSA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdGlmIChub2RlLm1vZGVsKSB7XG5cdFx0XHRfZ2xNYXRyaXgubWF0NC5tdWx0aXBseShtLCBtdHhQYXJlbnQsIG5vZGUubW9kZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfZ2xNYXRyaXgubWF0NC5jb3B5KG0sIG10eFBhcmVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0XHR3YWxrKGNoaWxkLCBtKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChub2RlLm1lc2gpIHtcblx0XHRcdHZhciBfb01lc2ggPSB7fTtcblx0XHRcdF9vTWVzaC5tb2RlbE1hdHJpeCA9IG07XG5cdFx0XHRfb01lc2gubWVzaCA9IG1lc2hlc1tub2RlLm1lc2hdO1xuXHRcdFx0X29NZXNoLmlkID0gbm9kZS5pZDtcblx0XHRcdF9vTWVzaC5uYW1lID0gbm9kZS5uYW1lO1xuXHRcdFx0X29NZXNoLm1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwobm9kZS5tYXRlcmlhbCk7XG5cdFx0XHRtZXNoT2Jqcy5wdXNoKF9vTWVzaCk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG10eCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHR3YWxrKG1EYXRhLnJvb3QsIG10eCk7XG5cblx0cmV0dXJuIG1lc2hPYmpzO1xufTtcblxudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UobUZpbGUpIHtcblx0dmFyIG8gPSBfQ29sbGFkYTIuZGVmYXVsdC5wYXJzZShtRmlsZSk7XG5cdHJldHVybiBwYXJzZURhdGEobyk7XG59O1xuXG52YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQobVBhdGgsIG1DYWxsQmFjaykge1xuXHRfQ29sbGFkYTIuZGVmYXVsdC5sb2FkKG1QYXRoLCBmdW5jdGlvbiAobURhdGEpIHtcblx0XHRtQ2FsbEJhY2socGFyc2VEYXRhKG1EYXRhKSk7XG5cdH0pO1xufTtcblxudmFyIENvbGxhZGFQYXJzZXIgPSB7XG5cdGxvYWQ6IGxvYWQsXG5cdHBhcnNlOiBwYXJzZVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29sbGFkYVBhcnNlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sbGFkYVBhcnNlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb2xsYWRhLXBhcnNlci9saWIvQ29sbGFkYVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nbE1hdHJpeCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIik7XG5cbnZhciBpc1dvcmtlciA9IGdsb2JhbC5kb2N1bWVudCA9PT0gdW5kZWZpbmVkOyAvLyBDb2xsYWRhLmpzXG5cbnZhciBERUcyUkFEID0gTWF0aC5QSSAqIDIgLyAzNjA7XG5cbi8vZ2xvYmFsIHRlbXBvcmFsIHZhcmlhYmxlc1xudmFyIHRlbXBfbWF0NCA9IG51bGw7XG52YXIgdGVtcF92ZWMyID0gbnVsbDtcbnZhciB0ZW1wX3ZlYzMgPSBudWxsO1xudmFyIHRlbXBfdmVjNCA9IG51bGw7XG52YXIgdGVtcF9xdWF0ID0gbnVsbDtcblxuZnVuY3Rpb24gcmVxdWVzdCh1cmwsIGNhbGxiYWNrKSB7XG5cdHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0cmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlO1xuXHRcdGlmICh0aGlzLnN0YXR1cyAhPSAyMDApIHJldHVybjtcblx0XHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHRoaXMucmVzcG9uc2UpO1xuXHR9O1xuXHRyZXEub3BlbihcImdldFwiLCB1cmwsIHRydWUpO1xuXHRyZXEuc2VuZCgpO1xufVxuXG52YXIgQ29sbGFkYSA9IHtcblxuXHRsaWJzUGF0aDogXCIuL1wiLFxuXHR3b3JrZXJQYXRoOiBcIi4vXCIsXG5cdG5vX2ZsaXA6IHRydWUsXG5cdHVzZV90cmFuc2ZlcmFibGVzOiB0cnVlLCAvL2ZvciB3b3JrZXJzXG5cdG9uZXJyb3I6IG51bGwsXG5cdHZlcmJvc2U6IGZhbHNlLFxuXHRjb25maWc6IHsgZm9yY2VQYXJzZXI6IGZhbHNlIH0sXG5cblx0aW5pdDogZnVuY3Rpb24gaW5pdChjb25maWcpIHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0Zm9yICh2YXIgaSBpbiBjb25maWcpIHtcblx0XHRcdHRoaXNbaV0gPSBjb25maWdbaV07XG5cdFx0fXRoaXMuY29uZmlnID0gY29uZmlnO1xuXG5cdFx0aWYgKGlzV29ya2VyKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpbXBvcnRTY3JpcHRzKHRoaXMubGlic1BhdGggKyBcImdsLW1hdHJpeC1taW4uanNcIiwgdGhpcy5saWJzUGF0aCArIFwidGlueXhtbC5qc1wiKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRDb2xsYWRhLnRocm93RXhjZXB0aW9uKENvbGxhZGEuTElCTUlTU0lOR19FUlJPUik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9pbml0IGdsTWF0cml4XG5cdFx0dGVtcF9tYXQ0ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dGVtcF92ZWMyID0gdmVjMy5jcmVhdGUoKTtcblx0XHR0ZW1wX3ZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRlbXBfdmVjNCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGVtcF9xdWF0ID0gX2dsTWF0cml4LnF1YXQuY3JlYXRlKCk7XG5cblx0XHRpZiAoaXNXb3JrZXIpIGNvbnNvbGUubG9nKFwiQ29sbGFkYSB3b3JrZXIgcmVhZHlcIik7XG5cdH0sXG5cblx0bG9hZDogZnVuY3Rpb24gbG9hZCh1cmwsIGNhbGxiYWNrKSB7XG5cdFx0cmVxdWVzdCh1cmwsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRpZiAoIWRhdGEpIGNhbGxiYWNrKG51bGwpO2Vsc2UgY2FsbGJhY2soQ29sbGFkYS5wYXJzZShkYXRhKSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X3htbHJvb3Q6IG51bGwsXG5cdF9ub2Rlc19ieV9pZDogbnVsbCxcblx0X3RyYW5zZmVyYWJsZXM6IG51bGwsXG5cdF9jb250cm9sbGVyc19mb3VuZDogbnVsbCxcblx0X2dlb21ldHJpZXNfZm91bmQ6IG51bGwsXG5cblx0c2FmZVN0cmluZzogZnVuY3Rpb24gc2FmZVN0cmluZyhzdHIpIHtcblx0XHRpZiAoIXN0cikgcmV0dXJuIFwiXCI7XG5cblx0XHRpZiAodGhpcy5jb252ZXJ0SUQpIHJldHVybiB0aGlzLmNvbnZlcnRJRChzdHIpO1xuXG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8gL2csIFwiX1wiKTtcblx0fSxcblxuXHRMSUJNSVNTSU5HX0VSUk9SOiBcIkxpYnJhcmllcyBsb2FkaW5nIGVycm9yLCB3aGVuIHVzaW5nIHdvcmtlcnMgcmVtZW1iZXIgdG8gcGFzcyB0aGUgVVJMIHRvIHRoZSB0aW55eG1sLmpzIGluIHRoZSBvcHRpb25zLmxpYnNQYXRoXCIsXG5cdE5PWE1MUEFSU0VSX0VSUk9SOiBcIlRpbnlYTUwgbm90IGZvdW5kLCB3aGVuIHVzaW5nIHdvcmtlcnMgcmVtZW1iZXIgdG8gcGFzcyB0aGUgVVJMIHRvIHRoZSB0aW55eG1sLmpzIGluIHRoZSBvcHRpb25zLmxpYnNQYXRoIChXb3JrZXJzIGRvIG5vdCBhbGxvdyB0byBhY2Nlc3MgdGhlIG5hdGl2ZSBYTUwgRE9NUGFyc2VyKVwiLFxuXHR0aHJvd0V4Y2VwdGlvbjogZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24obXNnKSB7XG5cdFx0aWYgKGlzV29ya2VyKSBzZWxmLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiBcImV4Y2VwdGlvblwiLCBtc2c6IG1zZyB9KTtlbHNlIGlmIChDb2xsYWRhLm9uZXJyb3IpIENvbGxhZGEub25lcnJvcihtc2cpO1xuXHRcdHRocm93IG1zZztcblx0fSxcblxuXHRnZXRGaWxlbmFtZTogZnVuY3Rpb24gZ2V0RmlsZW5hbWUoZmlsZW5hbWUpIHtcblx0XHR2YXIgcG9zID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCJcXFxcXCIpO1xuXHRcdGlmIChwb3MgIT0gLTEpIGZpbGVuYW1lID0gZmlsZW5hbWUuc3Vic3RyKHBvcyArIDEpO1xuXHRcdC8vc3RyaXAgdW5peCBzbGFzaGVzXG5cdFx0cG9zID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCIvXCIpO1xuXHRcdGlmIChwb3MgIT0gLTEpIGZpbGVuYW1lID0gZmlsZW5hbWUuc3Vic3RyKHBvcyArIDEpO1xuXHRcdHJldHVybiBmaWxlbmFtZTtcblx0fSxcblxuXHRsYXN0X25hbWU6IDAsXG5cblx0Z2VuZXJhdGVOYW1lOiBmdW5jdGlvbiBnZW5lcmF0ZU5hbWUodikge1xuXHRcdHYgPSB2IHx8IFwibmFtZV9cIjtcblx0XHR2YXIgbmFtZSA9IHYgKyB0aGlzLmxhc3RfbmFtZTtcblx0XHR0aGlzLmxhc3RfbmFtZSsrO1xuXHRcdHJldHVybiBuYW1lO1xuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiBwYXJzZShkYXRhLCBvcHRpb25zLCBmaWxlbmFtZSkge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGZpbGVuYW1lID0gZmlsZW5hbWUgfHwgXCJfZGFlX1wiICsgRGF0ZS5ub3coKSArIFwiLmRhZVwiO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyhcIlBhcnNpbmcgY29sbGFkYVwiKTtcblx0XHR2YXIgZmxpcCA9IGZhbHNlO1xuXG5cdFx0dmFyIHhtbHBhcnNlciA9IG51bGw7XG5cdFx0dmFyIHJvb3QgPSBudWxsO1xuXHRcdHRoaXMuX3RyYW5zZmVyYWJsZXMgPSBbXTtcblxuXHRcdGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUubG9nKFwiIC0gWE1MIHBhcnNpbmcuLi5cIik7XG5cblx0XHRpZiAoZ2xvYmFsW1wiRE9NUGFyc2VyXCJdICYmICF0aGlzLmNvbmZpZy5mb3JjZVBhcnNlcikge1xuXHRcdFx0eG1scGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0cm9vdCA9IHhtbHBhcnNlci5wYXJzZUZyb21TdHJpbmcoZGF0YSwgXCJ0ZXh0L3htbFwiKTtcblx0XHRcdGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUubG9nKFwiIC0gWE1MIHBhcnNlZFwiKTtcblx0XHR9IGVsc2UgLy9VU0lORyBKUyBYTUwgUEFSU0VSIElNUExFTUVOVEFUSU9OIChtdWNoIHNsb3dlcilcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFnbG9iYWxbXCJET01JbXBsZW1lbnRhdGlvblwiXSkgcmV0dXJuIENvbGxhZGEudGhyb3dFeGNlcHRpb24oQ29sbGFkYS5OT1hNTFBBUlNFUl9FUlJPUik7XG5cdFx0XHRcdC8vdXNlIHRpbnl4bWxwYXJzZXJcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR4bWxwYXJzZXIgPSBuZXcgRE9NSW1wbGVtZW50YXRpb24oKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIENvbGxhZGEudGhyb3dFeGNlcHRpb24oQ29sbGFkYS5OT1hNTFBBUlNFUl9FUlJPUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyb290ID0geG1scGFyc2VyLmxvYWRYTUwoZGF0YSk7XG5cdFx0XHRcdGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUubG9nKFwiIC0gWE1MIHBhcnNlZFwiKTtcblxuXHRcdFx0XHQvL2ZvciBldmVyeSBub2RlLi4uXG5cdFx0XHRcdHZhciBieV9pZHMgPSByb290Ll9ub2Rlc19ieV9pZCA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJvb3QuYWxsLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRcdHZhciBub2RlID0gcm9vdC5hbGxbaV07XG5cdFx0XHRcdFx0YnlfaWRzW25vZGUuaWRdID0gbm9kZTtcblx0XHRcdFx0XHRpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJzaWRcIikpIGJ5X2lkc1tub2RlLmdldEF0dHJpYnV0ZShcInNpZFwiKV0gPSBub2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF0aGlzLmV4dHJhX2Z1bmN0aW9ucykge1xuXHRcdFx0XHRcdHRoaXMuZXh0cmFfZnVuY3Rpb25zID0gdHJ1ZTtcblx0XHRcdFx0XHQvL3RoZXNlIG1ldGhvZHMgYXJlIG1pc3Npbmcgc28gaGVyZSBpcyBhIGxvdXN5IGltcGxlbWVudGF0aW9uXG5cdFx0XHRcdFx0RE9NRG9jdW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBET01FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGFncyA9IHNlbGVjdG9yLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50X2VsZW1lbnQgPSB0aGlzO1xuXG5cdFx0XHRcdFx0XHR3aGlsZSAodGFncy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0YWdzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdHZhciB0b2tlbnMgPSBjdXJyZW50LnNwbGl0KFwiI1wiKTtcblx0XHRcdFx0XHRcdFx0dmFyIHRhZ25hbWUgPSB0b2tlbnNbMF07XG5cdFx0XHRcdFx0XHRcdHZhciBpZCA9IHRva2Vuc1sxXTtcblx0XHRcdFx0XHRcdFx0dmFyIGVsZW1lbnRzID0gdGFnbmFtZSA/IGN1cnJlbnRfZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWduYW1lKSA6IGN1cnJlbnRfZWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdFx0XHRcdFx0XHRpZiAoIWlkKSAvL25vIGlkIGZpbHRlclxuXHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0YWdzLmxlbmd0aCA9PSAwKSByZXR1cm4gZWxlbWVudHMuaXRlbSgwKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfZWxlbWVudCA9IGVsZW1lbnRzLml0ZW0oMCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly9oYXMgaWQ/IGNoZWNrIGZvciBhbGwgdG8gc2VlIGlmIG9uZSBtYXRjaGVzIHRoZSBpZFxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnRzLml0ZW0oaSkuZ2V0QXR0cmlidXRlKFwiaWRcIikgPT0gaWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0YWdzLmxlbmd0aCA9PSAwKSByZXR1cm4gZWxlbWVudHMuaXRlbShpKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfZWxlbWVudCA9IGVsZW1lbnRzLml0ZW0oaSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRET01Eb2N1bWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IERPTUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0XHRcdFx0XHRcdHZhciB0YWdzID0gc2VsZWN0b3Iuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0aWYgKHRhZ3MubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKTtcblxuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRfZWxlbWVudCA9IHRoaXM7XG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdFx0XHRcdGlubmVyKHRoaXMsIHRhZ3MpO1xuXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiBpbm5lcihyb290LCB0YWdzKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdGFncykgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50ID0gdGFncy5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0XHR2YXIgZWxlbWVudHMgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKGN1cnJlbnQpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFncy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGVsZW1lbnRzLml0ZW0oaSkpO1xuXHRcdFx0XHRcdFx0XHRcdH1yZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXIoZWxlbWVudHMuaXRlbShpKSwgdGFncy5jb25jYXQoKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGxpc3QgPSBuZXcgRE9NTm9kZUxpc3QodGhpcy5kb2N1bWVudEVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0bGlzdC5fbm9kZXMgPSByZXN1bHQ7XG5cdFx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoRE9NRWxlbWVudC5wcm90b3R5cGUsIFwidGV4dENvbnRlbnRcIiwge1xuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBub2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZXMuaXRlbSgwKS50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHNldDogZnVuY3Rpb24gc2V0KCkge31cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdHRoaXMuX3htbHJvb3QgPSByb290O1xuXHRcdHZhciB4bWxjb2xsYWRhID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwiQ09MTEFEQVwiKTtcblx0XHRpZiAoeG1sY29sbGFkYSkge1xuXHRcdFx0dGhpcy5fY3VycmVudF9EQUVfdmVyc2lvbiA9IHhtbGNvbGxhZGEuZ2V0QXR0cmlidXRlKFwidmVyc2lvblwiKTtcblx0XHRcdGNvbnNvbGUubG9nKFwiREFFIFZlcnNpb246XCIgKyB0aGlzLl9jdXJyZW50X0RBRV92ZXJzaW9uKTtcblx0XHR9XG5cblx0XHQvL3ZhciB4bWx2aXN1YWxfc2NlbmUgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCJ2aXN1YWxfc2NlbmVcIik7XG5cdFx0dmFyIHhtbHZpc3VhbF9zY2VuZSA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ2aXN1YWxfc2NlbmVcIikuaXRlbSgwKTtcblx0XHRpZiAoIXhtbHZpc3VhbF9zY2VuZSkgdGhyb3cgXCJ2aXN1YWxfc2NlbmUgWE1MIG5vZGUgbm90IGZvdW5kIGluIERBRVwiO1xuXG5cdFx0Ly9oYWNrIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggYm9uZXMgd2l0aCBzcGFjZXMgaW4gbmFtZXNcblx0XHR0aGlzLl9ub2Rlc19ieV9pZCA9IHt9OyAvL2NsZWFyXG5cdFx0dGhpcy5fY29udHJvbGxlcnNfZm91bmQgPSB7fTsgLy93ZSBuZWVkIHRvIGNoZWNrIHdoYXQgY29udHJvbGxlcnMgaGFkIGJlZW4gZm91bmQsIGluIGNhc2Ugd2UgbWlzcyBvbmUgYXQgdGhlIGVuZFxuXHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmQgPSB7fTtcblxuXHRcdC8vQ3JlYXRlIGEgc2NlbmUgdHJlZVxuXHRcdHZhciBzY2VuZSA9IHtcblx0XHRcdG9iamVjdF90eXBlOiBcIlNjZW5lVHJlZVwiLFxuXHRcdFx0bGlnaHQ6IG51bGwsXG5cdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0bWVzaGVzOiB7fSxcblx0XHRcdHJlc291cmNlczoge30sIC8vdXNlZCB0byBzdG9yZSBhbmltYXRpb24gdHJhY2tzXG5cdFx0XHRyb290OiB7IGNoaWxkcmVuOiBbXSB9LFxuXHRcdFx0ZXh0ZXJuYWxfZmlsZXM6IHt9IC8vc3RvcmUgaW5mbyBhYm91dCBleHRlcm5hbCBmaWxlcyBtZW50aW9uZWQgaW4gdGhpcyBcblx0XHR9O1xuXG5cdFx0Ly9zY2VuZSBtZXRhZGF0YSAobGlrZSBhdXRob3IsIHRvb2wsIHVwIHZlY3RvciwgZGF0ZXMsIGV0Yylcblx0XHR2YXIgeG1sYXNzZXQgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYXNzZXRcIilbMF07XG5cdFx0aWYgKHhtbGFzc2V0KSBzY2VuZS5tZXRhZGF0YSA9IHRoaXMucmVhZEFzc2V0KHhtbGFzc2V0KTtcblxuXHRcdC8vcGFyc2Ugbm9kZXMgdHJlZSB0byBleHRyYWN0IG5hbWVzIGFuZCBpZXJhcmNoeSBvbmx5XG5cdFx0dmFyIHhtbG5vZGVzID0geG1sdmlzdWFsX3NjZW5lLmNoaWxkTm9kZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHhtbG5vZGVzLml0ZW0oaSkubG9jYWxOYW1lICE9IFwibm9kZVwiKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLnJlYWROb2RlVHJlZSh4bWxub2Rlcy5pdGVtKGkpLCBzY2VuZSwgMCwgZmxpcCk7XG5cdFx0XHRpZiAobm9kZSkgc2NlbmUucm9vdC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuXHRcdH1cblxuXHRcdC8vcGFyc2Ugbm9kZXMgY29udGVudCAodHdvIHN0ZXBzIHNvIHdlIGhhdmUgZmlyc3QgYWxsIHRoZSBzY2VuZSB0cmVlIGluZm8pXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHhtbG5vZGVzLml0ZW0oaSkubG9jYWxOYW1lICE9IFwibm9kZVwiKSBjb250aW51ZTtcblx0XHRcdHRoaXMucmVhZE5vZGVJbmZvKHhtbG5vZGVzLml0ZW0oaSksIHNjZW5lLCAwLCBmbGlwKTtcblx0XHR9XG5cblx0XHQvL3JlYWQgcmVtYWluaW5nIGNvbnRyb2xsZXJzIChpbiBzb21lIGNhc2VzIHNvbWUgY29udHJvbGxlcnMgYXJlIG5vdCBsaW5rZWQgZnJvbSB0aGUgbm9kZXMgb3IgdGhlIGdlb21ldHJpZXMpXG5cdFx0dGhpcy5yZWFkTGlicmFyeUNvbnRyb2xsZXJzKHNjZW5lKTtcblxuXHRcdC8vcmVhZCBhbmltYXRpb25zXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLnJlYWRBbmltYXRpb25zKHJvb3QsIHNjZW5lKTtcblx0XHRpZiAoYW5pbWF0aW9ucykge1xuXHRcdFx0dmFyIGFuaW1hdGlvbnNfbmFtZSA9IFwiI2FuaW1hdGlvbnNfXCIgKyBmaWxlbmFtZS5zdWJzdHIoMCwgZmlsZW5hbWUuaW5kZXhPZihcIi5cIikpO1xuXHRcdFx0c2NlbmUucmVzb3VyY2VzW2FuaW1hdGlvbnNfbmFtZV0gPSBhbmltYXRpb25zO1xuXHRcdFx0c2NlbmUucm9vdC5hbmltYXRpb25zID0gYW5pbWF0aW9uc19uYW1lO1xuXHRcdH1cblxuXHRcdC8vcmVhZCBleHRlcm5hbCBmaWxlcyAoaW1hZ2VzKVxuXHRcdHNjZW5lLmltYWdlcyA9IHRoaXMucmVhZEltYWdlcyhyb290KTtcblxuXHRcdC8vY2xlYXIgbWVtb3J5XG5cdFx0dGhpcy5fbm9kZXNfYnlfaWQgPSB7fTtcblx0XHR0aGlzLl9jb250cm9sbGVyc19mb3VuZCA9IHt9O1xuXHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmQgPSB7fTtcblx0XHR0aGlzLl94bWxyb290ID0gbnVsbDtcblxuXHRcdC8vY29uc29sZS5sb2coc2NlbmUpO1xuXHRcdHJldHVybiBzY2VuZTtcblx0fSxcblxuXHQvKiBDb2xsZWN0IG5vZGUgaWRzLCBpbiBjYXNlIHRoZXJlIGlzIGJvbmVzICh3aXRoIHNwYWNlcyBpbiBuYW1lKSBJIG5lZWQgdG8ga25vdyB0aGUgbm9kZW5hbWVzIGluIGFkdmFuY2UgKi9cblx0LypcbiByZWFkQWxsTm9kZU5hbWVzOiBmdW5jdGlvbih4bWxub2RlKVxuIHtcbiBcdHZhciBub2RlX2lkID0gdGhpcy5zYWZlU3RyaW5nKCB4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpICk7XG4gXHRpZihub2RlX2lkKVxuIFx0XHR0aGlzLl9ub2Rlc19ieV9pZFtub2RlX2lkXSA9IHRydWU7IC8vbm9kZSBmb3VuZFxuIFx0Ly9ub2RlcyBzZWVtIHRvIGhhdmUgdG8gcG9zc2libGUgaWRzLCBpZCBhbmQgc2lkLCBJIGd1ZXNzIG9uZSBpcyB1bmlxdWUsIHRoZSBvdGhlciB1c2VyLWRlZmluZWRcbiBcdHZhciBub2RlX3NpZCA9IHRoaXMuc2FmZVN0cmluZyggeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJzaWRcIikgKTtcbiBcdGlmKG5vZGVfc2lkKVxuIFx0XHR0aGlzLl9ub2Rlc19ieV9pZFtub2RlX3NpZF0gPSB0cnVlOyAvL25vZGUgZm91bmRcbiBcbiBcdGZvciggdmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrIClcbiBcdHtcbiBcdFx0dmFyIHhtbGNoaWxkID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG4gXHRcdFx0Ly9jaGlsZHJlblxuIFx0XHRpZih4bWxjaGlsZC5sb2NhbE5hbWUgIT0gXCJub2RlXCIpXG4gXHRcdFx0Y29udGludWU7XG4gXHRcdHRoaXMucmVhZEFsbE5vZGVOYW1lcyh4bWxjaGlsZCk7XG4gXHR9XG4gfSxcbiBcdCovXG5cblx0cmVhZEFzc2V0OiBmdW5jdGlvbiByZWFkQXNzZXQoeG1sYXNzZXQpIHtcblx0XHR2YXIgbWV0YWRhdGEgPSB7fTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sYXNzZXQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbGNoaWxkID0geG1sYXNzZXQuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKHhtbGNoaWxkLm5vZGVUeXBlICE9IDEpIC8vbm90IHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHN3aXRjaCAoeG1sY2hpbGQubG9jYWxOYW1lKSB7XG5cdFx0XHRcdGNhc2UgXCJjb250cmlidXRvclwiOlxuXHRcdFx0XHRcdHZhciB0b29sID0geG1sY2hpbGQucXVlcnlTZWxlY3RvcihcImF1dGhvcmluZ190b29sXCIpO1xuXHRcdFx0XHRcdGlmICh0b29sKSBtZXRhZGF0YVtcImF1dGhvcmluZ190b29sXCJdID0gdG9vbC50ZXh0Q29udGV4dDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInVuaXRcIjpcblx0XHRcdFx0XHRtZXRhZGF0YVtcInVuaXRcIl0gPSB4bWxjaGlsZC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO2JyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG1ldGFkYXRhW3htbGNoaWxkLmxvY2FsTmFtZV0gPSB4bWxjaGlsZC50ZXh0Q29udGVudDticmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWV0YWRhdGE7XG5cdH0sXG5cblx0cmVhZE5vZGVUcmVlOiBmdW5jdGlvbiByZWFkTm9kZVRyZWUoeG1sbm9kZSwgc2NlbmUsIGxldmVsLCBmbGlwKSB7XG5cdFx0dmFyIG5vZGVfaWQgPSB0aGlzLnNhZmVTdHJpbmcoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0dmFyIG5vZGVfc2lkID0gdGhpcy5zYWZlU3RyaW5nKHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwic2lkXCIpKTtcblxuXHRcdGlmICghbm9kZV9pZCAmJiAhbm9kZV9zaWQpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9oZXJlIHdlIGNyZWF0ZSB0aGUgbm9kZVxuXHRcdHZhciBub2RlID0ge1xuXHRcdFx0aWQ6IG5vZGVfc2lkIHx8IG5vZGVfaWQsXG5cdFx0XHRjaGlsZHJlbjogW10sXG5cdFx0XHRfZGVwdGg6IGxldmVsXG5cdFx0fTtcblxuXHRcdHZhciBub2RlX3R5cGUgPSB4bWxub2RlLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG5cdFx0aWYgKG5vZGVfdHlwZSkgbm9kZS50eXBlID0gbm9kZV90eXBlO1xuXG5cdFx0dmFyIG5vZGVfbmFtZSA9IHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcblx0XHRpZiAobm9kZV9uYW1lKSBub2RlLm5hbWUgPSBub2RlX25hbWU7XG5cdFx0dGhpcy5fbm9kZXNfYnlfaWRbbm9kZS5pZF0gPSBub2RlO1xuXHRcdGlmIChub2RlX2lkKSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlX2lkXSA9IG5vZGU7XG5cdFx0aWYgKG5vZGVfc2lkKSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlX3NpZF0gPSBub2RlO1xuXG5cdFx0Ly90cmFuc2Zvcm1cblx0XHRub2RlLm1vZGVsID0gdGhpcy5yZWFkVHJhbnNmb3JtKHhtbG5vZGUsIGxldmVsLCBmbGlwKTtcblxuXHRcdC8vbm9kZSBlbGVtZW50c1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sY2hpbGQgPSB4bWxub2RlLmNoaWxkTm9kZXMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxjaGlsZC5ub2RlVHlwZSAhPSAxKSAvL25vdCB0YWdcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vY2hpbGRyZW5cblx0XHRcdGlmICh4bWxjaGlsZC5sb2NhbE5hbWUgPT0gXCJub2RlXCIpIHtcblx0XHRcdFx0dmFyIGNoaWxkX25vZGUgPSB0aGlzLnJlYWROb2RlVHJlZSh4bWxjaGlsZCwgc2NlbmUsIGxldmVsICsgMSwgZmxpcCk7XG5cdFx0XHRcdGlmIChjaGlsZF9ub2RlKSBub2RlLmNoaWxkcmVuLnB1c2goY2hpbGRfbm9kZSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXG5cdHJlYWROb2RlSW5mbzogZnVuY3Rpb24gcmVhZE5vZGVJbmZvKHhtbG5vZGUsIHNjZW5lLCBsZXZlbCwgZmxpcCwgcGFyZW50KSB7XG5cdFx0dmFyIG5vZGVfaWQgPSB0aGlzLnNhZmVTdHJpbmcoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0dmFyIG5vZGVfc2lkID0gdGhpcy5zYWZlU3RyaW5nKHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwic2lkXCIpKTtcblxuXHRcdC8qXG4gIGlmKCFub2RlX2lkICYmICFub2RlX3NpZClcbiAge1xuICBcdGNvbnNvbGUud2FybihcIkNvbGxhZGE6IG5vZGUgd2l0aG91dCBpZCwgY3JlYXRpbmcgYSByYW5kb20gb25lXCIpO1xuICBcdG5vZGVfaWQgPSB0aGlzLmdlbmVyYXRlTmFtZShcIm5vZGVfXCIpO1xuICBcdHJldHVybiBudWxsO1xuICB9XG4gICovXG5cblx0XHR2YXIgbm9kZTtcblx0XHRpZiAoIW5vZGVfaWQgJiYgIW5vZGVfc2lkKSB7XG5cdFx0XHQvL2lmIHRoZXJlIGlzIG5vIGlkLCB0aGVuIGVpdGhlciBhbGwgb2YgdGhpcyBub2RlJ3MgcHJvcGVydGllcyBcblx0XHRcdC8vc2hvdWxkIGJlIGFzc2lnbmVkIGRpcmVjdGx5IHRvIGl0cyBwYXJlbnQgbm9kZSwgb3IgdGhlIG5vZGUgZG9lc24ndFxuXHRcdFx0Ly9oYXZlIGEgcGFyZW50IG5vZGUsIGluIHdoaWNoIGNhc2UgaXRzIGEgbGlnaHQgb3Igc29tZXRoaW5nLiBcblx0XHRcdC8vU28gd2UgZ2V0IHRoZSBwYXJlbnQgYnkgaXRzIGlkLCBhbmQgaWYgdGhlcmUgaXMgbm8gcGFyZW50LCB3ZSByZXR1cm4gbnVsbFxuXHRcdFx0aWYgKHBhcmVudCkgbm9kZSA9IHRoaXMuX25vZGVzX2J5X2lkW3BhcmVudC5pZCB8fCBwYXJlbnQuc2lkXTtlbHNlIHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSBub2RlID0gdGhpcy5fbm9kZXNfYnlfaWRbbm9kZV9pZCB8fCBub2RlX3NpZF07XG5cblx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdGNvbnNvbGUud2FybihcIkNvbGxhZGE6IE5vZGUgbm90IGZvdW5kIGJ5IGlkOiBcIiArIChub2RlX2lkIHx8IG5vZGVfc2lkKSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL25vZGUgZWxlbWVudHNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbGNoaWxkID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cdFx0XHRpZiAoeG1sY2hpbGQubm9kZVR5cGUgIT0gMSkgLy9ub3QgdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvL2NoaWxkcmVuXG5cdFx0XHRpZiAoeG1sY2hpbGQubG9jYWxOYW1lID09IFwibm9kZVwiKSB7XG5cdFx0XHRcdC8vcGFzcyBwYXJlbnQgbm9kZSBpbiBjYXNlIGNoaWxkIG5vZGUgaXMgYSAnZGVhZCcgbm9kZSAoaGFzIG5vIGlkIG9yIHNpZClcblx0XHRcdFx0dGhpcy5yZWFkTm9kZUluZm8oeG1sY2hpbGQsIHNjZW5lLCBsZXZlbCArIDEsIGZsaXAsIHhtbG5vZGUpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9nZW9tZXRyeVxuXHRcdFx0aWYgKHhtbGNoaWxkLmxvY2FsTmFtZSA9PSBcImluc3RhbmNlX2dlb21ldHJ5XCIpIHtcblx0XHRcdFx0dmFyIHVybCA9IHhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKTtcblx0XHRcdFx0dmFyIG1lc2hfaWQgPSB1cmwudG9TdHJpbmcoKS5zdWJzdHIoMSk7XG5cdFx0XHRcdG5vZGUubWVzaCA9IG1lc2hfaWQ7XG5cblx0XHRcdFx0aWYgKCFzY2VuZS5tZXNoZXNbdXJsXSkge1xuXHRcdFx0XHRcdHZhciBtZXNoX2RhdGEgPSB0aGlzLnJlYWRHZW9tZXRyeSh1cmwsIGZsaXApO1xuXHRcdFx0XHRcdGlmIChtZXNoX2RhdGEpIHtcblx0XHRcdFx0XHRcdG1lc2hfZGF0YS5uYW1lID0gbWVzaF9pZDtcblx0XHRcdFx0XHRcdHNjZW5lLm1lc2hlc1ttZXNoX2lkXSA9IG1lc2hfZGF0YTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2JpbmRlZCBtYXRlcmlhbFxuXHRcdFx0XHR2YXIgeG1sbWF0ZXJpYWxzID0geG1sY2hpbGQucXVlcnlTZWxlY3RvckFsbChcImluc3RhbmNlX21hdGVyaWFsXCIpO1xuXHRcdFx0XHRpZiAoeG1sbWF0ZXJpYWxzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaU1hdCA9IDA7IGlNYXQgPCB4bWxtYXRlcmlhbHMubGVuZ3RoOyArK2lNYXQpIHtcblx0XHRcdFx0XHRcdHZhciB4bWxtYXRlcmlhbCA9IHhtbG1hdGVyaWFscy5pdGVtKGlNYXQpO1xuXHRcdFx0XHRcdFx0aWYgKCF4bWxtYXRlcmlhbCkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJpbnN0YW5jZV9tYXRlcmlhbCBub3QgZm91bmQ6IFwiICsgaSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgbWF0bmFtZSA9IHhtbG1hdGVyaWFsLmdldEF0dHJpYnV0ZShcInRhcmdldFwiKS50b1N0cmluZygpLnN1YnN0cigxKTtcblx0XHRcdFx0XHRcdC8vbWF0bmFtZSA9IG1hdG5hbWUucmVwbGFjZSgvIC9nLFwiX1wiKTsgLy9uYW1lcyBjYW5ub3QgaGF2ZSBzcGFjZXNcblx0XHRcdFx0XHRcdGlmICghc2NlbmUubWF0ZXJpYWxzW21hdG5hbWVdKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5yZWFkTWF0ZXJpYWwobWF0bmFtZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChtYXRlcmlhbCkge1xuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmlkID0gbWF0bmFtZTtcblx0XHRcdFx0XHRcdFx0XHRzY2VuZS5tYXRlcmlhbHNbbWF0ZXJpYWwuaWRdID0gbWF0ZXJpYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChpTWF0ID09IDApIG5vZGUubWF0ZXJpYWwgPSBtYXRuYW1lO2Vsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoIW5vZGUubWF0ZXJpYWxzKSBub2RlLm1hdGVyaWFscyA9IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlLm1hdGVyaWFscy5wdXNoKG1hdG5hbWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL3RoaXMgbm9kZSBoYXMgYSBjb250cm9sbGVyOiBza2lubmluZywgbW9ycGggdGFyZ2V0cyBvciBldmVuIG11bHRpbWF0ZXJpYWwgYXJlIGNvbnRyb2xsZXJzXG5cdFx0XHQvL3dhcm5pbmc6IEkgZGV0ZWN0ZWQgdGhhdCBzb21lIG5vZGVzIGNvdWxkIGhhdmUgYSBjb250cm9sbGVyIGJ1dCB0aGV5IGFyZSBub3QgcmVmZXJlbmNlZCBoZXJlLiAgPz9cblx0XHRcdGlmICh4bWxjaGlsZC5sb2NhbE5hbWUgPT0gXCJpbnN0YW5jZV9jb250cm9sbGVyXCIpIHtcblx0XHRcdFx0dmFyIHVybCA9IHhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKTtcblx0XHRcdFx0dmFyIHhtbGNvbnRyb2xsZXIgPSB0aGlzLl94bWxyb290LnF1ZXJ5U2VsZWN0b3IoXCJjb250cm9sbGVyXCIgKyB1cmwpO1xuXG5cdFx0XHRcdGlmICh4bWxjb250cm9sbGVyKSB7XG5cblx0XHRcdFx0XHR2YXIgbWVzaF9kYXRhID0gdGhpcy5yZWFkQ29udHJvbGxlcih4bWxjb250cm9sbGVyLCBmbGlwLCBzY2VuZSk7XG5cblx0XHRcdFx0XHQvL2JpbmRlZCBtYXRlcmlhbHNcblx0XHRcdFx0XHR2YXIgeG1sYmluZF9tYXRlcmlhbCA9IHhtbGNoaWxkLnF1ZXJ5U2VsZWN0b3IoXCJiaW5kX21hdGVyaWFsXCIpO1xuXHRcdFx0XHRcdGlmICh4bWxiaW5kX21hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHQvL3JlbW92ZWQgcmVhZEJpbmRNYXRlcmlhbHMgdXAgaGVyZSBmb3IgY29uc2lzdGVuY3lcblx0XHRcdFx0XHRcdHZhciB4bWx0ZWNobmlxdWVzID0geG1sYmluZF9tYXRlcmlhbC5xdWVyeVNlbGVjdG9yQWxsKFwidGVjaG5pcXVlX2NvbW1vblwiKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGlUZWMgPSAwOyBpVGVjIDwgeG1sdGVjaG5pcXVlcy5sZW5ndGg7IGlUZWMrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgeG1sdGVjaG5pcXVlID0geG1sdGVjaG5pcXVlcy5pdGVtKGlUZWMpO1xuXHRcdFx0XHRcdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWxzID0geG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnN0YW5jZV9tYXRlcmlhbFwiKTtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaU1hdCA9IDA7IGlNYXQgPCB4bWxpbnN0YW5jZV9tYXRlcmlhbHMubGVuZ3RoOyBpTWF0KyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWwgPSB4bWxpbnN0YW5jZV9tYXRlcmlhbHMuaXRlbShpTWF0KTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXhtbGluc3RhbmNlX21hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJpbnN0YW5jZV9tYXRlcmlhbCBmb3IgY29udHJvbGxlciBub3QgZm91bmQ6IFwiICsgeG1saW5zdGFuY2VfbWF0ZXJpYWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXRuYW1lID0geG1saW5zdGFuY2VfbWF0ZXJpYWwuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpLnRvU3RyaW5nKCkuc3Vic3RyKDEpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghc2NlbmUubWF0ZXJpYWxzW21hdG5hbWVdKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IHRoaXMucmVhZE1hdGVyaWFsKG1hdG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG1hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmlkID0gbWF0bmFtZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2NlbmUubWF0ZXJpYWxzW21hdGVyaWFsLmlkXSA9IG1hdGVyaWFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaU1hdCA9PSAwKSBub2RlLm1hdGVyaWFsID0gbWF0bmFtZTtlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghbm9kZS5tYXRlcmlhbHMpIG5vZGUubWF0ZXJpYWxzID0gW107XG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLm1hdGVyaWFscy5wdXNoKG1hdG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChtZXNoX2RhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBtZXNoID0gbWVzaF9kYXRhO1xuXHRcdFx0XHRcdFx0aWYgKG1lc2hfZGF0YS50eXBlID09IFwibW9ycGhcIikge1xuXHRcdFx0XHRcdFx0XHRtZXNoID0gbWVzaF9kYXRhLm1lc2g7XG5cdFx0XHRcdFx0XHRcdG5vZGUubW9ycGhfdGFyZ2V0cyA9IG1lc2hfZGF0YS5tb3JwaF90YXJnZXRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtZXNoLm5hbWUgPSB1cmwudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdG5vZGUubWVzaCA9IHVybC50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0c2NlbmUubWVzaGVzW3VybF0gPSBtZXNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL2xpZ2h0XG5cdFx0XHRpZiAoeG1sY2hpbGQubG9jYWxOYW1lID09IFwiaW5zdGFuY2VfbGlnaHRcIikge1xuXHRcdFx0XHR2YXIgdXJsID0geG1sY2hpbGQuZ2V0QXR0cmlidXRlKFwidXJsXCIpO1xuXHRcdFx0XHR0aGlzLnJlYWRMaWdodChub2RlLCB1cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2NhbWVyYVxuXHRcdFx0aWYgKHhtbGNoaWxkLmxvY2FsTmFtZSA9PSBcImluc3RhbmNlX2NhbWVyYVwiKSB7XG5cdFx0XHRcdHZhciB1cmwgPSB4bWxjaGlsZC5nZXRBdHRyaWJ1dGUoXCJ1cmxcIik7XG5cdFx0XHRcdHRoaXMucmVhZENhbWVyYShub2RlLCB1cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL290aGVyIHBvc3NpYmxlIHRhZ3M/XG5cdFx0fVxuXHR9LFxuXG5cdC8vaWYgeW91IHdhbnQgdG8gcmVuYW1lIHNvbWUgbWF0ZXJpYWwgbmFtZXNcblx0bWF0ZXJpYWxfdHJhbnNsYXRlX3RhYmxlOiB7XG5cdFx0LypcbiAgdHJhbnNwYXJlbmN5OiBcIm9wYWNpdHlcIixcbiAgcmVmbGVjdGl2aXR5OiBcInJlZmxlY3Rpb25fZmFjdG9yXCIsXG4gIHNwZWN1bGFyOiBcInNwZWN1bGFyX2ZhY3RvclwiLFxuICBzaGluaW5lc3M6IFwic3BlY3VsYXJfZ2xvc3NcIixcbiAgZW1pc3Npb246IFwiZW1pc3NpdmVcIixcbiAgZGlmZnVzZTogXCJjb2xvclwiXG4gICovXG5cdH0sXG5cblx0bGlnaHRfdHJhbnNsYXRlX3RhYmxlOiB7XG5cblx0XHRwb2ludDogXCJvbW5pXCIsXG5cdFx0ZGlyZWN0aW9uYWw6IFwiZGlyZWN0aW9uYWxcIixcblx0XHRzcG90OiBcInNwb3RcIlxuXHR9LFxuXG5cdGNhbWVyYV90cmFuc2xhdGVfdGFibGU6IHtcblx0XHR4Zm92OiBcImZvdlwiLFxuXHRcdGFzcGVjdF9yYXRpbzogXCJhc3BlY3RcIixcblx0XHR6bmVhcjogXCJuZWFyXCIsXG5cdFx0emZhcjogXCJmYXJcIlxuXHR9LFxuXG5cdC8vdXNlZCB3aGVuIGlkIGhhdmUgc3BhY2VzIChyZWd1bGFyIHNlbGVjdG9yIGRvIG5vdCBzdXBwb3J0IHNwYWNlcylcblx0cXVlcnlTZWxlY3RvckFuZElkOiBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQW5kSWQocm9vdCwgc2VsZWN0b3IsIGlkKSB7XG5cdFx0dmFyIG5vZGVzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXR0cl9pZCA9IG5vZGVzLml0ZW0oaSkuZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRpZiAoIWF0dHJfaWQpIGNvbnRpbnVlO1xuXHRcdFx0YXR0cl9pZCA9IGF0dHJfaWQudG9TdHJpbmcoKTtcblx0XHRcdGlmIChhdHRyX2lkID09IGlkKSByZXR1cm4gbm9kZXMuaXRlbShpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Ly9yZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyBhIHRhZyBuYW1lLCBpZiBub3QgdGFnbmFtZSBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgdGFnIGVsZW1lbnRcblx0Z2V0Rmlyc3RDaGlsZEVsZW1lbnQ6IGZ1bmN0aW9uIGdldEZpcnN0Q2hpbGRFbGVtZW50KHJvb3QsIGxvY2FsTmFtZSkge1xuXHRcdHZhciBjID0gcm9vdC5jaGlsZE5vZGVzO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYy5sZW5ndGg7ICsraSkge1xuXHRcdFx0dmFyIGl0ZW0gPSBjLml0ZW0oaSk7XG5cdFx0XHRpZiAoaXRlbS5sb2NhbE5hbWUgJiYgIWxvY2FsTmFtZSB8fCBsb2NhbE5hbWUgJiYgbG9jYWxOYW1lID09IGl0ZW0ubG9jYWxOYW1lKSByZXR1cm4gaXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0cmVhZE1hdGVyaWFsOiBmdW5jdGlvbiByZWFkTWF0ZXJpYWwodXJsKSB7XG5cdFx0dmFyIHhtbG1hdGVyaWFsID0gdGhpcy5xdWVyeVNlbGVjdG9yQW5kSWQodGhpcy5feG1scm9vdCwgXCJsaWJyYXJ5X21hdGVyaWFscyBtYXRlcmlhbFwiLCB1cmwpO1xuXG5cdFx0aWYgKCF4bWxtYXRlcmlhbCkgcmV0dXJuIG51bGw7XG5cblx0XHQvL2dldCBlZmZlY3QgbmFtZVxuXHRcdHZhciB4bWxlZmZlY3QgPSB4bWxtYXRlcmlhbC5xdWVyeVNlbGVjdG9yKFwiaW5zdGFuY2VfZWZmZWN0XCIpO1xuXHRcdGlmICgheG1sZWZmZWN0KSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBlZmZlY3RfdXJsID0geG1sZWZmZWN0LmdldEF0dHJpYnV0ZShcInVybFwiKS5zdWJzdHIoMSk7XG5cblx0XHQvL2dldCBlZmZlY3Rcblx0XHR2YXIgeG1sZWZmZWN0cyA9IHRoaXMucXVlcnlTZWxlY3RvckFuZElkKHRoaXMuX3htbHJvb3QsIFwibGlicmFyeV9lZmZlY3RzIGVmZmVjdFwiLCBlZmZlY3RfdXJsKTtcblxuXHRcdGlmICgheG1sZWZmZWN0cykgcmV0dXJuIG51bGw7XG5cblx0XHQvL2dldCBjb21tb25cblx0XHR2YXIgeG1sdGVjaG5pcXVlID0geG1sZWZmZWN0cy5xdWVyeVNlbGVjdG9yKFwidGVjaG5pcXVlXCIpO1xuXHRcdGlmICgheG1sdGVjaG5pcXVlKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vZ2V0IG5ld3BhcmFtcyBhbmQgY29udmVydCB0byBqcyBvYmplY3Rcblx0XHR2YXIgeG1sbmV3cGFyYW1zID0geG1sZWZmZWN0cy5xdWVyeVNlbGVjdG9yQWxsKFwibmV3cGFyYW1cIik7XG5cdFx0dmFyIG5ld3BhcmFtcyA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbmV3cGFyYW1zLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdHZhciBpbml0X2Zyb20gPSB4bWxuZXdwYXJhbXNbaV0ucXVlcnlTZWxlY3RvcihcImluaXRfZnJvbVwiKTtcblx0XHRcdHZhciBwYXJlbnQ7XG5cdFx0XHRpZiAoaW5pdF9mcm9tKSBwYXJlbnQgPSBpbml0X2Zyb20uaW5uZXJIVE1MO2Vsc2Uge1xuXHRcdFx0XHR2YXIgc291cmNlID0geG1sbmV3cGFyYW1zW2ldLnF1ZXJ5U2VsZWN0b3IoXCJzb3VyY2VcIik7XG5cdFx0XHRcdHBhcmVudCA9IHNvdXJjZS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdG5ld3BhcmFtc1t4bWxuZXdwYXJhbXNbaV0uZ2V0QXR0cmlidXRlKFwic2lkXCIpXSA9IHtcblx0XHRcdFx0cGFyZW50OiBwYXJlbnRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIG1hdGVyaWFsID0ge307XG5cblx0XHQvL3JlYWQgdGhlIGltYWdlcyBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBhY2Nlc3MgdGhlbSB0byBhc3NpZ24gdGV4dHVyZSBuYW1lc1xuXHRcdHZhciBpbWFnZXMgPSB0aGlzLnJlYWRJbWFnZXModGhpcy5feG1scm9vdCk7XG5cblx0XHR2YXIgeG1scGhvbmcgPSB4bWx0ZWNobmlxdWUucXVlcnlTZWxlY3RvcihcInBob25nXCIpO1xuXHRcdGlmICgheG1scGhvbmcpIHhtbHBob25nID0geG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3IoXCJibGlublwiKTtcblx0XHRpZiAoIXhtbHBob25nKSB4bWxwaG9uZyA9IHhtbHRlY2huaXF1ZS5xdWVyeVNlbGVjdG9yKFwibGFtYmVydFwiKTtcblx0XHRpZiAoIXhtbHBob25nKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vZm9yIGV2ZXJ5IHRhZyBvZiBwcm9wZXJ0aWVzXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxwaG9uZy5jaGlsZE5vZGVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgeG1scGFyYW0gPSB4bWxwaG9uZy5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cblx0XHRcdGlmICgheG1scGFyYW0ubG9jYWxOYW1lKSAvL3RleHQgdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvL3RyYW5zbGF0ZSBuYW1lXG5cdFx0XHR2YXIgcGFyYW1fbmFtZSA9IHhtbHBhcmFtLmxvY2FsTmFtZS50b1N0cmluZygpO1xuXHRcdFx0aWYgKHRoaXMubWF0ZXJpYWxfdHJhbnNsYXRlX3RhYmxlW3BhcmFtX25hbWVdKSBwYXJhbV9uYW1lID0gdGhpcy5tYXRlcmlhbF90cmFuc2xhdGVfdGFibGVbcGFyYW1fbmFtZV07XG5cblx0XHRcdC8vdmFsdWVcblx0XHRcdHZhciB4bWxwYXJhbV92YWx1ZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZEVsZW1lbnQoeG1scGFyYW0pO1xuXHRcdFx0aWYgKCF4bWxwYXJhbV92YWx1ZSkgY29udGludWU7XG5cblx0XHRcdGlmICh4bWxwYXJhbV92YWx1ZS5sb2NhbE5hbWUudG9TdHJpbmcoKSA9PSBcImNvbG9yXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbHBhcmFtX3ZhbHVlKTtcblx0XHRcdFx0aWYgKHhtbHBhcmFtLmdldEF0dHJpYnV0ZShcIm9wYXF1ZVwiKSA9PSBcIlJHQl9aRVJPXCIpIG1hdGVyaWFsW3BhcmFtX25hbWVdID0gdmFsdWUuc3ViYXJyYXkoMCwgNCk7ZWxzZSBtYXRlcmlhbFtwYXJhbV9uYW1lXSA9IHZhbHVlLnN1YmFycmF5KDAsIDMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoeG1scGFyYW1fdmFsdWUubG9jYWxOYW1lLnRvU3RyaW5nKCkgPT0gXCJmbG9hdFwiKSB7XG5cdFx0XHRcdG1hdGVyaWFsW3BhcmFtX25hbWVdID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbHBhcmFtX3ZhbHVlKVswXTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKHhtbHBhcmFtX3ZhbHVlLmxvY2FsTmFtZS50b1N0cmluZygpID09IFwidGV4dHVyZVwiKSB7XG5cdFx0XHRcdGlmICghbWF0ZXJpYWwudGV4dHVyZXMpIG1hdGVyaWFsLnRleHR1cmVzID0ge307XG5cdFx0XHRcdHZhciBtYXBfaWQgPSB4bWxwYXJhbV92YWx1ZS5nZXRBdHRyaWJ1dGUoXCJ0ZXh0dXJlXCIpO1xuXHRcdFx0XHRpZiAoIW1hcF9pZCkgY29udGludWU7XG5cblx0XHRcdFx0Ly8gaWYgbWFwX2lkIGlzIG5vdCBhIGZpbGVuYW1lLCBsZXRzIGdvIGFuZCBsb29rIGZvciBpdC5cblx0XHRcdFx0aWYgKG1hcF9pZC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG5cdFx0XHRcdFx0Ly9jaGVjayBlZmZlY3QgcGFyZW50c1xuXHRcdFx0XHRcdG1hcF9pZCA9IHRoaXMuZ2V0UGFyZW50UGFyYW0obmV3cGFyYW1zLCBtYXBfaWQpO1xuXG5cdFx0XHRcdFx0aWYgKGltYWdlc1ttYXBfaWRdKSBtYXBfaWQgPSBpbWFnZXNbbWFwX2lkXS5wYXRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9ub3cgZ2V0IHRoZSB0ZXh0dXJlIGZpbGVuYW1lIGZyb20gaW1hZ2VzXG5cblx0XHRcdFx0dmFyIG1hcF9pbmZvID0geyBtYXBfaWQ6IG1hcF9pZCB9O1xuXHRcdFx0XHR2YXIgdXZzID0geG1scGFyYW1fdmFsdWUuZ2V0QXR0cmlidXRlKFwidGV4Y29vcmRcIik7XG5cdFx0XHRcdG1hcF9pbmZvLnV2cyA9IHV2cztcblx0XHRcdFx0bWF0ZXJpYWwudGV4dHVyZXNbcGFyYW1fbmFtZV0gPSBtYXBfaW5mbztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtYXRlcmlhbC5vYmplY3RfdHlwZSA9IFwiTWF0ZXJpYWxcIjtcblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cdH0sXG5cblx0Z2V0UGFyZW50UGFyYW06IGZ1bmN0aW9uIGdldFBhcmVudFBhcmFtKG5ld3BhcmFtcywgcGFyYW0pIHtcblx0XHRpZiAoIW5ld3BhcmFtc1twYXJhbV0pIHJldHVybiBwYXJhbTtcblxuXHRcdGlmIChuZXdwYXJhbXNbcGFyYW1dLnBhcmVudCkgcmV0dXJuIHRoaXMuZ2V0UGFyZW50UGFyYW0obmV3cGFyYW1zLCBuZXdwYXJhbXNbcGFyYW1dLnBhcmVudCk7ZWxzZSByZXR1cm4gcGFyYW07XG5cdH0sXG5cblx0cmVhZExpZ2h0OiBmdW5jdGlvbiByZWFkTGlnaHQobm9kZSwgdXJsKSB7XG5cdFx0dmFyIGxpZ2h0ID0ge307XG5cblx0XHR2YXIgeG1sbm9kZSA9IG51bGw7XG5cblx0XHRpZiAodXJsLmxlbmd0aCA+IDEpIC8vd2VpcmQgY2FzZXMgd2l0aCBpZCA9PSAjXG5cdFx0XHR4bWxub2RlID0gdGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9saWdodHMgXCIgKyB1cmwpO2Vsc2Uge1xuXHRcdFx0dmFyIHhtbGxpYmxpZ2h0cyA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImxpYnJhcnlfbGlnaHRzXCIpO1xuXHRcdFx0eG1sbm9kZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZEVsZW1lbnQoeG1sbGlibGlnaHRzLCBcImxpZ2h0XCIpO1xuXHRcdH1cblxuXHRcdGlmICgheG1sbm9kZSkgcmV0dXJuIG51bGw7XG5cblx0XHQvL3BhY2tcblx0XHR2YXIgY2hpbGRyZW4gPSBbXTtcblx0XHR2YXIgeG1sID0geG1sbm9kZS5xdWVyeVNlbGVjdG9yKFwidGVjaG5pcXVlX2NvbW1vblwiKTtcblx0XHRpZiAoeG1sKSBmb3IgKHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoeG1sLmNoaWxkTm9kZXMuaXRlbShpKS5ub2RlVHlwZSA9PSAxKSAvL3RhZ1xuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkpO1xuXHRcdH12YXIgeG1scyA9IHhtbG5vZGUucXVlcnlTZWxlY3RvckFsbChcInRlY2huaXF1ZVwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWwyID0geG1scy5pdGVtKGkpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB4bWwyLmNoaWxkTm9kZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKHhtbDIuY2hpbGROb2Rlcy5pdGVtKGopLm5vZGVUeXBlID09IDEpIC8vdGFnXG5cdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaCh4bWwyLmNoaWxkTm9kZXMuaXRlbShqKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9nZXRcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sID0gY2hpbGRyZW5baV07XG5cdFx0XHRzd2l0Y2ggKHhtbC5sb2NhbE5hbWUpIHtcblx0XHRcdFx0Y2FzZSBcInBvaW50XCI6XG5cdFx0XHRcdFx0bGlnaHQudHlwZSA9IHRoaXMubGlnaHRfdHJhbnNsYXRlX3RhYmxlW3htbC5sb2NhbE5hbWVdO1xuXHRcdFx0XHRcdHBhcnNlX3BhcmFtcyhsaWdodCwgeG1sKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRpcmVjdGlvbmFsXCI6XG5cdFx0XHRcdFx0bGlnaHQudHlwZSA9IHRoaXMubGlnaHRfdHJhbnNsYXRlX3RhYmxlW3htbC5sb2NhbE5hbWVdO1xuXHRcdFx0XHRcdHBhcnNlX3BhcmFtcyhsaWdodCwgeG1sKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInNwb3RcIjpcblx0XHRcdFx0XHRsaWdodC50eXBlID0gdGhpcy5saWdodF90cmFuc2xhdGVfdGFibGVbeG1sLmxvY2FsTmFtZV07XG5cdFx0XHRcdFx0cGFyc2VfcGFyYW1zKGxpZ2h0LCB4bWwpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJpbnRlbnNpdHlcIjpcblx0XHRcdFx0XHRsaWdodC5pbnRlbnNpdHkgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKVswXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZV9wYXJhbXMobGlnaHQsIHhtbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0XHRpZiAoIWNoaWxkIHx8IGNoaWxkLm5vZGVUeXBlICE9IDEpIC8vdGFnXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoIChjaGlsZC5sb2NhbE5hbWUpIHtcblx0XHRcdFx0XHRjYXNlIFwiY29sb3JcIjpcblx0XHRcdFx0XHRcdGxpZ2h0LmNvbG9yID0gQ29sbGFkYS5yZWFkQ29udGVudEFzRmxvYXRzKGNoaWxkKTticmVhaztcblx0XHRcdFx0XHRjYXNlIFwiZmFsbG9mZl9hbmdsZVwiOlxuXHRcdFx0XHRcdFx0bGlnaHQuYW5nbGVfZW5kID0gQ29sbGFkYS5yZWFkQ29udGVudEFzRmxvYXRzKGNoaWxkKVswXTtcblx0XHRcdFx0XHRcdGxpZ2h0LmFuZ2xlID0gbGlnaHQuYW5nbGVfZW5kIC0gMTA7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChub2RlLm1vZGVsKSB7XG5cdFx0XHQvL2xpZ2h0IHBvc2l0aW9uIGlzIGZpbmFsIGNvbHVtbiBvZiBtb2RlbFxuXHRcdFx0bGlnaHQucG9zaXRpb24gPSBbbm9kZS5tb2RlbFsxMl0sIG5vZGUubW9kZWxbMTNdLCBub2RlLm1vZGVsWzE0XV07XG5cdFx0XHQvL2xpZ2h0IGZvcndhcmQgdmVjdG9yIGlzIHJldmVyc2Ugb2YgdGhpcmQgY29sdW1uIG9mIG1vZGVsXG5cdFx0XHR2YXIgZm9yd2FyZCA9IFstbm9kZS5tb2RlbFs4XSwgLW5vZGUubW9kZWxbOV0sIC1ub2RlLm1vZGVsWzEwXV07XG5cdFx0XHQvL3NvIGxpZ2h0IHRhcmdldCBpcyBwb3NpdGlvbiArIGZvcndhcmRcblx0XHRcdGxpZ2h0LnRhcmdldCA9IFtsaWdodC5wb3NpdGlvblswXSArIGZvcndhcmRbMF0sIGxpZ2h0LnBvc2l0aW9uWzFdICsgZm9yd2FyZFsxXSwgbGlnaHQucG9zaXRpb25bMl0gKyBmb3J3YXJkWzJdXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiQ291bGQgbm90IHJlYWQgbGlnaHQgcG9zaXRpb24gZm9yIGxpZ2h0OiBcIiArIG5vZGUubmFtZSArIFwiLiBTZXR0aW5nIGRlZmF1bHRzLlwiKTtcblx0XHRcdGxpZ2h0LnBvc2l0aW9uID0gWzAsIDAsIDBdO1xuXHRcdFx0bGlnaHQudGFyZ2V0ID0gWzAsIC0xLCAwXTtcblx0XHR9XG5cblx0XHRub2RlLmxpZ2h0ID0gbGlnaHQ7XG5cdH0sXG5cblx0cmVhZENhbWVyYTogZnVuY3Rpb24gcmVhZENhbWVyYShub2RlLCB1cmwpIHtcblx0XHR2YXIgY2FtZXJhID0ge307XG5cblx0XHR2YXIgeG1sbm9kZSA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImxpYnJhcnlfY2FtZXJhcyBcIiArIHVybCk7XG5cdFx0aWYgKCF4bWxub2RlKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vcGFja1xuXHRcdHZhciBjaGlsZHJlbiA9IFtdO1xuXHRcdHZhciB4bWwgPSB4bWxub2RlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZWNobmlxdWVfY29tbW9uXCIpO1xuXHRcdGlmICh4bWwpIC8vZ3JhYiBhbGwgaW50ZXJuYWwgc3R1ZmZcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkubm9kZVR5cGUgPT0gMSkgLy90YWdcblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkpO1xuXHRcdFx0fSAvL1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB0YWcgPSBjaGlsZHJlbltpXTtcblx0XHRcdHBhcnNlX3BhcmFtcyhjYW1lcmEsIHRhZyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VfcGFyYW1zKGNhbWVyYSwgeG1sKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cdFx0XHRcdGlmICghY2hpbGQgfHwgY2hpbGQubm9kZVR5cGUgIT0gMSkgLy90YWdcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIHRyYW5zbGF0ZWQgPSBDb2xsYWRhLmNhbWVyYV90cmFuc2xhdGVfdGFibGVbY2hpbGQubG9jYWxOYW1lXSB8fCBjaGlsZC5sb2NhbE5hbWU7XG5cdFx0XHRcdGNhbWVyYVt0cmFuc2xhdGVkXSA9IHBhcnNlRmxvYXQoY2hpbGQudGV4dENvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vcGFyc2UgdG8gY29udmVydCB5Zm92IHRvIHN0YW5kYXJkICh4KSBmb3Zcblx0XHRpZiAoY2FtZXJhLnlmb3YgJiYgIWNhbWVyYS5mb3YpIHtcblx0XHRcdGlmIChjYW1lcmEuYXNwZWN0KSB7XG5cdFx0XHRcdGNhbWVyYS5mb3YgPSBjYW1lcmEueWZvdiAqIGNhbWVyYS5hc3BlY3Q7XG5cdFx0XHR9IGVsc2UgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGNvbnZlcnQgY2FtZXJhIHlmb3YgdG8geGZvdiBiZWNhdXNlIGFzcGVjdCByYXRpbyBub3Qgc2V0XCIpO1xuXHRcdH1cblxuXHRcdG5vZGUuY2FtZXJhID0gY2FtZXJhO1xuXHR9LFxuXG5cdHJlYWRUcmFuc2Zvcm06IGZ1bmN0aW9uIHJlYWRUcmFuc2Zvcm0oeG1sbm9kZSwgbGV2ZWwsIGZsaXApIHtcblx0XHQvL2lkZW50aXR5XG5cdFx0dmFyIG1hdHJpeCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdHZhciB0ZW1wID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dmFyIHRtcHEgPSBfZ2xNYXRyaXgucXVhdC5jcmVhdGUoKTtcblxuXHRcdHZhciBmbGlwX2ZpeCA9IGZhbHNlO1xuXG5cdFx0Ly9zZWFyY2ggZm9yIHRoZSBtYXRyaXhcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbCA9IHhtbG5vZGUuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKCF4bWwgfHwgeG1sLm5vZGVUeXBlICE9IDEpIC8vdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcIm1hdHJpeFwiKSB7XG5cdFx0XHRcdHZhciBtYXRyaXggPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIk5vZGVuYW1lOiBcIiArIHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIikpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKG1hdHJpeCk7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgbGV2ZWwgPT0gMCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2cobWF0cml4KTtcblx0XHRcdFx0cmV0dXJuIG1hdHJpeDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHhtbC5sb2NhbE5hbWUgPT0gXCJ0cmFuc2xhdGVcIikge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7XG5cdFx0XHRcdGlmIChmbGlwICYmIGxldmVsID4gMCkge1xuXHRcdFx0XHRcdHZhciB0bXAgPSB2YWx1ZXNbMV07XG5cdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdHZhbHVlc1syXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbE1hdHJpeC5tYXQ0LnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgdmFsdWVzKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vcm90YXRlXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInJvdGF0ZVwiKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPT0gNCkgLy94LHkseiwgYW5nbGVcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSB4bWwuZ2V0QXR0cmlidXRlKFwic2lkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKGlkID09IFwiam9pbnRPcmllbnRYXCIpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzNdICs9IDkwO1xuXHRcdFx0XHRcdFx0XHRmbGlwX2ZpeCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3JvdGF0ZVggJiByb3RhdGVZICYgcm90YXRlWiBkb25lIGJlbG93XG5cblx0XHRcdFx0XHRcdGlmIChmbGlwKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0bXAgPSB2YWx1ZXNbMV07XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1sxXSA9IHZhbHVlc1syXTtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzJdID0gLXRtcDsgLy9zd2FwIGNvb3Jkc1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodmFsdWVzWzNdICE9IDAuMCkge1xuXHRcdFx0XHRcdFx0XHRfZ2xNYXRyaXgucXVhdC5zZXRBeGlzQW5nbGUodG1wcSwgdmFsdWVzLnN1YmFycmF5KDAsIDMpLCB2YWx1ZXNbM10gKiBERUcyUkFEKTtcblx0XHRcdFx0XHRcdFx0X2dsTWF0cml4Lm1hdDQuZnJvbVF1YXQodGVtcCwgdG1wcSk7XG5cdFx0XHRcdFx0XHRcdF9nbE1hdHJpeC5tYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0ZW1wKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3NjYWxlXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInNjYWxlXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHRpZiAoZmxpcCkge1xuXHRcdFx0XHRcdHZhciB0bXAgPSB2YWx1ZXNbMV07XG5cdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdHZhbHVlc1syXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHRcdFx0fVxuXHRcdFx0XHRfZ2xNYXRyaXgubWF0NC5zY2FsZShtYXRyaXgsIG1hdHJpeCwgdmFsdWVzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9LFxuXG5cdHJlYWRUcmFuc2Zvcm0yOiBmdW5jdGlvbiByZWFkVHJhbnNmb3JtMih4bWxub2RlLCBsZXZlbCwgZmxpcCkge1xuXHRcdC8vaWRlbnRpdHlcblx0XHR2YXIgbWF0cml4ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dmFyIHJvdGF0aW9uID0gX2dsTWF0cml4LnF1YXQuY3JlYXRlKCk7XG5cdFx0dmFyIHRtcG1hdHJpeCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdHZhciB0bXBxID0gX2dsTWF0cml4LnF1YXQuY3JlYXRlKCk7XG5cdFx0dmFyIHRyYW5zbGF0ZSA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dmFyIHNjYWxlID0gdmVjMy5mcm9tVmFsdWVzKDEsIDEsIDEpO1xuXG5cdFx0dmFyIGZsaXBfZml4ID0gZmFsc2U7XG5cblx0XHQvL3NlYXJjaCBmb3IgdGhlIG1hdHJpeFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwibWF0cml4XCIpIHtcblx0XHRcdFx0dmFyIG1hdHJpeCA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiTm9kZW5hbWU6IFwiICsgeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2cobWF0cml4KTtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgobWF0cml4LCBsZXZlbCA9PSAwKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhtYXRyaXgpO1xuXHRcdFx0XHRyZXR1cm4gbWF0cml4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInRyYW5zbGF0ZVwiKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0dHJhbnNsYXRlLnNldCh2YWx1ZXMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9yb3RhdGVcblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwicm90YXRlXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PSA0KSAvL3gseSx6LCBhbmdsZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpZCA9IHhtbC5nZXRBdHRyaWJ1dGUoXCJzaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoaWQgPT0gXCJqb2ludE9yaWVudFhcIikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbM10gKz0gOTA7XG5cdFx0XHRcdFx0XHRcdGZsaXBfZml4ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRlWCAmIHJvdGF0ZVkgJiByb3RhdGVaIGRvbmUgYmVsb3dcblxuXHRcdFx0XHRcdFx0aWYgKGZsaXApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRtcCA9IHZhbHVlc1sxXTtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbMl0gPSAtdG1wOyAvL3N3YXAgY29vcmRzXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZXNbM10gIT0gMC4wKSB7XG5cdFx0XHRcdFx0XHRcdF9nbE1hdHJpeC5xdWF0LnNldEF4aXNBbmdsZSh0bXBxLCB2YWx1ZXMuc3ViYXJyYXkoMCwgMyksIHZhbHVlc1szXSAqIERFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHRfZ2xNYXRyaXgucXVhdC5tdWx0aXBseShyb3RhdGlvbiwgcm90YXRpb24sIHRtcHEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vc2NhbGVcblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwic2NhbGVcIikge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7XG5cdFx0XHRcdGlmIChmbGlwKSB7XG5cdFx0XHRcdFx0dmFyIHRtcCA9IHZhbHVlc1sxXTtcblx0XHRcdFx0XHR2YWx1ZXNbMV0gPSB2YWx1ZXNbMl07XG5cdFx0XHRcdFx0dmFsdWVzWzJdID0gLXRtcDsgLy9zd2FwIGNvb3Jkc1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjYWxlLnNldCh2YWx1ZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChmbGlwICYmIGxldmVsID4gMCkge1xuXHRcdFx0dmFyIHRtcCA9IHRyYW5zbGF0ZVsxXTtcblx0XHRcdHRyYW5zbGF0ZVsxXSA9IHRyYW5zbGF0ZVsyXTtcblx0XHRcdHRyYW5zbGF0ZVsyXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHR9XG5cdFx0X2dsTWF0cml4Lm1hdDQudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCB0cmFuc2xhdGUpO1xuXG5cdFx0X2dsTWF0cml4Lm1hdDQuZnJvbVF1YXQodG1wbWF0cml4LCByb3RhdGlvbik7XG5cdFx0Ly9tYXQ0LnJvdGF0ZVgodG1wbWF0cml4LCB0bXBtYXRyaXgsIE1hdGguUEkgKiAwLjUpO1xuXHRcdF9nbE1hdHJpeC5tYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0bXBtYXRyaXgpO1xuXHRcdF9nbE1hdHJpeC5tYXQ0LnNjYWxlKG1hdHJpeCwgbWF0cml4LCBzY2FsZSk7XG5cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9LFxuXG5cdC8vZm9yIGhlbHAgcmVhZCB0aGlzOiBodHRwczovL3d3dy5raHJvbm9zLm9yZy9jb2xsYWRhL3dpa2kvVXNpbmdfYWNjZXNzb3JzXG5cdHJlYWRHZW9tZXRyeTogZnVuY3Rpb24gcmVhZEdlb21ldHJ5KGlkLCBmbGlwLCBzY2VuZSkge1xuXHRcdC8vYWxyZWFkeSByZWFkLCBjb3VsZCBoYXBwZW5kIGlmIHNldmVyYWwgY29udHJvbGxlcnMgcG9pbnQgdG8gdGhlIHNhbWUgbWVzaFxuXHRcdGlmICh0aGlzLl9nZW9tZXRyaWVzX2ZvdW5kW2lkXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF07XG5cblx0XHQvL3ZhciB4bWxnZW9tZXRyeSA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImdlb21ldHJ5XCIgKyBpZCk7XG5cdFx0dmFyIHhtbGdlb21ldHJ5ID0gdGhpcy5feG1scm9vdC5nZXRFbGVtZW50QnlJZChpZC5zdWJzdHIoMSkpO1xuXHRcdGlmICgheG1sZ2VvbWV0cnkpIHtcblx0XHRcdGNvbnNvbGUud2FybihcInJlYWRHZW9tZXRyeTogZ2VvbWV0cnkgbm90IGZvdW5kOiBcIiArIGlkKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vaWYgdGhlIGdlb21ldHJ5IGhhcyBtb3JwaCB0YXJnZXRzIHRoZW4gaW5zdGVhZCBvZiBzdG9yaW5nIGl0IGluIGEgZ2VvbWV0cnksIGl0IGlzIGluIGEgY29udHJvbGxlclxuXHRcdGlmICh4bWxnZW9tZXRyeS5sb2NhbE5hbWUgPT0gXCJjb250cm9sbGVyXCIpIHtcblx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMucmVhZENvbnRyb2xsZXIoeG1sZ2VvbWV0cnksIGZsaXAsIHNjZW5lKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gZ2VvbWV0cnk7XG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cdFx0fVxuXG5cdFx0aWYgKHhtbGdlb21ldHJ5LmxvY2FsTmFtZSAhPSBcImdlb21ldHJ5XCIpIHtcblx0XHRcdGNvbnNvbGUud2FybihcInJlYWRHZW9tZXRyeTogdGFnIHNob3VsZCBiZSBnZW9tZXRyeSwgaW5zdGVhZCBpdCB3YXMgZm91bmQ6IFwiICsgeG1sZ2VvbWV0cnkubG9jYWxOYW1lKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciB4bWxtZXNoID0geG1sZ2VvbWV0cnkucXVlcnlTZWxlY3RvcihcIm1lc2hcIik7XG5cdFx0aWYgKCF4bWxtZXNoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJyZWFkR2VvbWV0cnk6IG1lc2ggbm90IGZvdW5kIGluIGdlb21ldHJ5OiBcIiArIGlkKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vZ2V0IGRhdGEgc291cmNlc1xuXHRcdHZhciBzb3VyY2VzID0ge307XG5cdFx0dmFyIHhtbHNvdXJjZXMgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sc291cmNlID0geG1sc291cmNlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKCF4bWxzb3VyY2UucXVlcnlTZWxlY3RvcikgY29udGludWU7XG5cdFx0XHR2YXIgZmxvYXRfYXJyYXkgPSB4bWxzb3VyY2UucXVlcnlTZWxlY3RvcihcImZsb2F0X2FycmF5XCIpO1xuXHRcdFx0aWYgKCFmbG9hdF9hcnJheSkgY29udGludWU7XG5cdFx0XHR2YXIgZmxvYXRzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKGZsb2F0X2FycmF5KTtcblxuXHRcdFx0dmFyIHhtbGFjY2Vzc29yID0geG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJhY2Nlc3NvclwiKTtcblx0XHRcdHZhciBzdHJpZGUgPSBwYXJzZUludCh4bWxhY2Nlc3Nvci5nZXRBdHRyaWJ1dGUoXCJzdHJpZGVcIikpO1xuXG5cdFx0XHRzb3VyY2VzW3htbHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSB7IHN0cmlkZTogc3RyaWRlLCBkYXRhOiBmbG9hdHMgfTtcblx0XHR9XG5cblx0XHQvL2dldCBzdHJlYW1zXG5cdFx0dmFyIHhtbHZlcnRpY2VzID0geG1sbWVzaC5xdWVyeVNlbGVjdG9yKFwidmVydGljZXMgaW5wdXRcIik7XG5cdFx0dmFyIHZlcnRpY2VzX3NvdXJjZSA9IHNvdXJjZXNbeG1sdmVydGljZXMuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0c291cmNlc1t4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJ2ZXJ0aWNlc1wiKS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSB2ZXJ0aWNlc19zb3VyY2U7XG5cblx0XHR2YXIgbWVzaCA9IG51bGw7XG5cdFx0dmFyIHhtbHBvbHlnb25zID0geG1sbWVzaC5xdWVyeVNlbGVjdG9yKFwicG9seWdvbnNcIik7XG5cdFx0aWYgKHhtbHBvbHlnb25zKSBtZXNoID0gdGhpcy5yZWFkVHJpYW5nbGVzKHhtbHBvbHlnb25zLCBzb3VyY2VzKTtcblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0dmFyIHhtbHRyaWFuZ2xlcyA9IHhtbG1lc2gucXVlcnlTZWxlY3RvckFsbChcInRyaWFuZ2xlc1wiKTtcblx0XHRcdGlmICh4bWx0cmlhbmdsZXMgJiYgeG1sdHJpYW5nbGVzLmxlbmd0aCkgbWVzaCA9IHRoaXMucmVhZFRyaWFuZ2xlcyh4bWx0cmlhbmdsZXMsIHNvdXJjZXMpO1xuXHRcdH1cblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0Ly9wb2x5bGlzdCA9IHRydWU7XG5cdFx0XHQvL3ZhciB2Y291bnQgPSBudWxsO1xuXHRcdFx0Ly92YXIgeG1sdmNvdW50ID0geG1scG9seWdvbnMucXVlcnlTZWxlY3RvcihcInZjb3VudFwiKTtcblx0XHRcdC8vdmFyIHZjb3VudCA9IHRoaXMucmVhZENvbnRlbnRBc1VJbnQzMiggeG1sdmNvdW50ICk7XG5cdFx0XHR2YXIgeG1scG9seWxpc3QgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJwb2x5bGlzdFwiKTtcblx0XHRcdGlmICh4bWxwb2x5bGlzdCkgbWVzaCA9IHRoaXMucmVhZFBvbHlsaXN0KHhtbHBvbHlsaXN0LCBzb3VyY2VzKTtcblx0XHR9XG5cblx0XHRpZiAoIW1lc2gpIHtcblx0XHRcdHZhciB4bWxsaW5lc3RyaXAgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJsaW5lc3RyaXBzXCIpO1xuXHRcdFx0aWYgKHhtbGxpbmVzdHJpcCkgbWVzaCA9IHRoaXMucmVhZExpbmVTdHJpcChzb3VyY2VzLCB4bWxsaW5lc3RyaXApO1xuXHRcdH1cblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJubyBwb2x5Z29ucyBvciB0cmlhbmdsZXMgaW4gbWVzaDogXCIgKyBpZCk7XG5cdFx0XHR0aGlzLl9nZW9tZXRyaWVzX2ZvdW5kW2lkXSA9IG51bGw7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL3N3YXAgY29vcmRzIChYLFksWikgLT4gKFgsWiwtWSlcblx0XHRpZiAoZmxpcCAmJiAhdGhpcy5ub19mbGlwKSB7XG5cdFx0XHR2YXIgdG1wID0gMDtcblx0XHRcdHZhciBhcnJheSA9IG1lc2gudmVydGljZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHR0bXAgPSBhcnJheVtpICsgMV07XG5cdFx0XHRcdGFycmF5W2kgKyAxXSA9IGFycmF5W2kgKyAyXTtcblx0XHRcdFx0YXJyYXlbaSArIDJdID0gLXRtcDtcblx0XHRcdH1cblxuXHRcdFx0YXJyYXkgPSBtZXNoLm5vcm1hbHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHR0bXAgPSBhcnJheVtpICsgMV07XG5cdFx0XHRcdGFycmF5W2kgKyAxXSA9IGFycmF5W2kgKyAyXTtcblx0XHRcdFx0YXJyYXlbaSArIDJdID0gLXRtcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL3RyYW5zZmVyYWJsZXMgZm9yIHdvcmtlclxuXHRcdGlmIChpc1dvcmtlciAmJiB0aGlzLnVzZV90cmFuc2ZlcmFibGVzKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG1lc2gpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBtZXNoW2ldO1xuXHRcdFx0XHRpZiAoZGF0YSAmJiBkYXRhLmJ1ZmZlciAmJiBkYXRhLmxlbmd0aCA+IDEwMCkge1xuXHRcdFx0XHRcdHRoaXMuX3RyYW5zZmVyYWJsZXMucHVzaChkYXRhLmJ1ZmZlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL2V4dHJhIGluZm9cblx0XHRtZXNoLmZpbGVuYW1lID0gaWQ7XG5cdFx0bWVzaC5vYmplY3RfdHlwZSA9IFwiTWVzaFwiO1xuXG5cdFx0dGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF0gPSBtZXNoO1xuXHRcdHJldHVybiBtZXNoO1xuXHR9LFxuXG5cdHJlYWRUcmlhbmdsZXM6IGZ1bmN0aW9uIHJlYWRUcmlhbmdsZXMoeG1sdHJpYW5nbGVzLCBzb3VyY2VzKSB7XG5cdFx0dmFyIHVzZV9pbmRpY2VzID0gZmFsc2U7XG5cblx0XHR2YXIgZ3JvdXBzID0gW107XG5cdFx0dmFyIGJ1ZmZlcnMgPSBbXTtcblx0XHR2YXIgbGFzdF9pbmRleCA9IDA7XG5cdFx0dmFyIGZhY2VtYXAgPSB7fTtcblx0XHR2YXIgdmVydGV4X3JlbWFwID0gW107IC8vbWFwcyBEQUUgdmVydGV4IGluZGV4IHRvIE1lc2ggdmVydGV4IGluZGV4IChiZWNhdXNlIHdoZW4gbWVzaGVzIGFyZSB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBhcmUgY2hhbmdlZFxuXHRcdHZhciBpbmRpY2VzQXJyYXkgPSBbXTtcblx0XHR2YXIgbGFzdF9zdGFydCA9IDA7XG5cdFx0dmFyIGdyb3VwX25hbWUgPSBcIlwiO1xuXHRcdHZhciBtYXRlcmlhbF9uYW1lID0gXCJcIjtcblxuXHRcdC8vZm9yIGV2ZXJ5IHRyaWFuZ2xlcyBzZXQgKHdhcm5pbmcsIHNvbWUgdGltZXMgdGhleSBhcmUgcmVwZWF0ZWQuLi4pXG5cdFx0Zm9yICh2YXIgdHJpcyA9IDA7IHRyaXMgPCB4bWx0cmlhbmdsZXMubGVuZ3RoOyB0cmlzKyspIHtcblx0XHRcdHZhciB4bWxfc2hhcGVfcm9vdCA9IHhtbHRyaWFuZ2xlcy5pdGVtKHRyaXMpO1xuXHRcdFx0dmFyIHRyaWFuZ2xlcyA9IHhtbF9zaGFwZV9yb290LmxvY2FsTmFtZSA9PSBcInRyaWFuZ2xlc1wiO1xuXG5cdFx0XHRtYXRlcmlhbF9uYW1lID0geG1sX3NoYXBlX3Jvb3QuZ2V0QXR0cmlidXRlKFwibWF0ZXJpYWxcIik7XG5cblx0XHRcdC8vZm9yIGVhY2ggYnVmZmVyIChpbnB1dCkgYnVpbGQgdGhlIHN0cnVjdHVyZSBpbmZvXG5cdFx0XHRpZiAodHJpcyA9PSAwKSBidWZmZXJzID0gdGhpcy5yZWFkU2hhcGVJbnB1dHMoeG1sX3NoYXBlX3Jvb3QsIHNvdXJjZXMpO1xuXG5cdFx0XHQvL2Fzc3VtaW5nIGJ1ZmZlcnMgYXJlIG9yZGVyZWQgYnkgb2Zmc2V0XG5cblx0XHRcdC8vaXRlcmF0ZSBkYXRhXG5cdFx0XHR2YXIgeG1scHMgPSB4bWxfc2hhcGVfcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwicFwiKTtcblx0XHRcdHZhciBudW1fZGF0YV92ZXJ0ZXggPSBidWZmZXJzLmxlbmd0aDsgLy9vbmUgdmFsdWUgcGVyIGlucHV0IGJ1ZmZlclxuXG5cdFx0XHQvL2ZvciBldmVyeSBwb2x5Z29uIChjb3VsZCBiZSBvbmUgd2l0aCBhbGwgdGhlIGluZGljZXMsIGNvdWxkIGJlIHNldmVyYWwsIGRlcGVuZHMgb24gdGhlIHByb2dyYW0pXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciB4bWxwID0geG1scHMuaXRlbShpKTtcblx0XHRcdFx0aWYgKCF4bWxwIHx8ICF4bWxwLnRleHRDb250ZW50KSBicmVhaztcblxuXHRcdFx0XHR2YXIgZGF0YSA9IHhtbHAudGV4dENvbnRlbnQudHJpbSgpLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0XHQvL3VzZWQgZm9yIHRyaWFuZ3VsYXRlIHBvbHlzXG5cdFx0XHRcdHZhciBmaXJzdF9pbmRleCA9IC0xO1xuXHRcdFx0XHR2YXIgY3VycmVudF9pbmRleCA9IC0xO1xuXHRcdFx0XHR2YXIgcHJldl9pbmRleCA9IC0xO1xuXG5cdFx0XHRcdC8vZGlzY29tbWVudCB0byBmb3JjZSAxNmJpdHMgaW5kaWNlc1xuXHRcdFx0XHQvL2lmKHVzZV9pbmRpY2VzICYmIGxhc3RfaW5kZXggPj0gMjU2KjI1Nilcblx0XHRcdFx0Ly9cdGJyZWFrO1xuXG5cdFx0XHRcdHZhciBudW1fdmFsdWVzX3Blcl92ZXJ0ZXggPSAxO1xuXHRcdFx0XHRmb3IgKHZhciBiIGluIGJ1ZmZlcnMpIHtcblx0XHRcdFx0XHRudW1fdmFsdWVzX3Blcl92ZXJ0ZXggPSBNYXRoLm1heChudW1fdmFsdWVzX3Blcl92ZXJ0ZXgsIGJ1ZmZlcnNbYl1bNF0gKyAxKTtcblx0XHRcdFx0fSAvL2ZvciBldmVyeSBwYWNrIG9mIGluZGljZXMgaW4gdGhlIHBvbHlnb24gKHZlcnRleCwgbm9ybWFsLCB1diwgLi4uIClcblx0XHRcdFx0dmFyIGN1cnJlbnRfZGF0YV9wb3MgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBrIDwgbDsgayArPSBudW1fdmFsdWVzX3Blcl92ZXJ0ZXgpIHtcblx0XHRcdFx0XHR2YXIgdmVydGV4X2lkID0gZGF0YS5zbGljZShrLCBrICsgbnVtX3ZhbHVlc19wZXJfdmVydGV4KS5qb2luKFwiIFwiKTsgLy9nZW5lcmF0ZSB1bmlxdWUgaWRcblxuXHRcdFx0XHRcdHByZXZfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRcdGlmIChmYWNlbWFwLmhhc093blByb3BlcnR5KHZlcnRleF9pZCkpIC8vYWRkIHRvIGFycmF5cywga2VlcCB0aGUgaW5kZXhcblx0XHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBmYWNlbWFwW3ZlcnRleF9pZF07ZWxzZSB7XG5cdFx0XHRcdFx0XHQvL2ZvciBldmVyeSBkYXRhIGJ1ZmZlciBhc3NvY2lhdGVkIHRvIHRoaXMgdmVydGV4XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG5cdFx0XHRcdFx0XHRcdHZhciBhcnJheSA9IGJ1ZmZlclsxXTsgLy9hcnJheSB3aGVyZSB3ZSBhY2N1bXVsYXRlIHRoZSBmaW5hbCBkYXRhIGFzIHdlIGV4dHJhY3QgaWYgZnJvbSBzb3VyY2VzXG5cdFx0XHRcdFx0XHRcdHZhciBzb3VyY2UgPSBidWZmZXJbM107IC8vd2hlcmUgdG8gcmVhZCB0aGUgZGF0YSBmcm9tXG5cblx0XHRcdFx0XHRcdFx0Ly9jb21wdXRlIHRoZSBpbmRleCBpbnNpZGUgdGhlIGRhdGEgc291cmNlIGFycmF5XG5cdFx0XHRcdFx0XHRcdC8vdmFyIGluZGV4ID0gcGFyc2VJbnQoZGF0YVtrICsgal0pO1xuXHRcdFx0XHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludChkYXRhW2sgKyBidWZmZXJbNF1dKTtcblx0XHRcdFx0XHRcdFx0Ly9jdXJyZW50X2RhdGFfcG9zICs9IGJ1ZmZlcls0XTtcblxuXHRcdFx0XHRcdFx0XHQvL3JlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZSB3ZSBuZWVkIHRvIHJlbWFwXG5cdFx0XHRcdFx0XHRcdGlmIChqID09IDApIHZlcnRleF9yZW1hcFthcnJheS5sZW5ndGggLyBidWZmZXJbMl1dID0gaW5kZXg7IC8vbm90IHN1cmUgaWYgYnVmZmVyWzJdLCBpdCBzaG91bGQgYmUgbnVtYmVyIG9mIGZsb2F0cyBwZXIgdmVydGV4ICh1c3VhbGx5IDMpXG5cdFx0XHRcdFx0XHRcdC8vdmVydGV4X3JlbWFwWyBhcnJheS5sZW5ndGggLyBudW1fZGF0YV92ZXJ0ZXggXSA9IGluZGV4O1xuXG5cdFx0XHRcdFx0XHRcdC8vY29tcHV0ZSB0aGUgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2UgYnVmZmVyIHdoZXJlIHRoZSBmaW5hbCBkYXRhIGlzIGxvY2F0ZWRcblx0XHRcdFx0XHRcdFx0aW5kZXggKj0gYnVmZmVyWzJdOyAvL3RoaXMgd29ya3MgaW4gbW9zdCBEQUVzIChub3QgYWxsKVxuXHRcdFx0XHRcdFx0XHQvL2luZGV4ID0gaW5kZXggKiBidWZmZXJbMl0gKyBidWZmZXJbNF07IC8vc3RyaWRlKDIpIG9mZnNldCg0KVxuXHRcdFx0XHRcdFx0XHQvL2luZGV4ICs9IGJ1ZmZlcls0XTsgLy9zdHJpZGUoMikgb2Zmc2V0KDQpXG5cdFx0XHRcdFx0XHRcdC8vZXh0cmFjdCBldmVyeSB2YWx1ZSBvZiB0aGlzIGVsZW1lbnQgYW5kIHN0b3JlIGl0IGluIGl0cyBmaW5hbCBhcnJheSAoZXZlcnkgeCx5LHosIGV0Yylcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCBidWZmZXJbMl07ICsreCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChzb3VyY2VbaW5kZXggKyB4XSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBcIlVOREVGSU5FRCFcIjsgLy9ERUJVR1xuXHRcdFx0XHRcdFx0XHRcdGFycmF5LnB1c2goc291cmNlW2luZGV4ICsgeF0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBsYXN0X2luZGV4O1xuXHRcdFx0XHRcdFx0bGFzdF9pbmRleCArPSAxO1xuXHRcdFx0XHRcdFx0ZmFjZW1hcFt2ZXJ0ZXhfaWRdID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXRyaWFuZ2xlcykgLy90aGUgeG1sIGVsZW1lbnQgaXMgbm90IHRyaWFuZ2xlcz8gdGhlbiBzcGxpdCBwb2x5Z29ucyBpbiB0cmlhbmdsZXNcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKGsgPT0gMCkgZmlyc3RfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRcdFx0XHQvL2lmKGsgPiAyICogbnVtX2RhdGFfdmVydGV4KSAvL25vdCBzdXJlIGlmIHVzZSB0aGlzIG9yIHRoZSBuZXh0IGxpbmUsIHRoZSBuZXh0IG9uZSB3b3JrcyBpbiBzb21lIERBRXMgYnV0IG5vdCBzdXJlIGlmIGl0IHdvcmtzIGluIGFsbFxuXHRcdFx0XHRcdFx0XHRpZiAoayA+IDIpIC8vdHJpYW5ndWxhdGUgcG9seWdvbnM6IGVuc3VyZSB0aGlzIHdvcmtzXG5cdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goZmlyc3RfaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2gocHJldl9pbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goY3VycmVudF9pbmRleCk7XG5cdFx0XHRcdH0gLy9wZXIgdmVydGV4XG5cdFx0XHR9IC8vcGVyIHBvbHlnb25cblxuXHRcdFx0dmFyIGdyb3VwID0ge1xuXHRcdFx0XHRuYW1lOiBncm91cF9uYW1lIHx8IFwiZ3JvdXBcIiArIHRyaXMsXG5cdFx0XHRcdHN0YXJ0OiBsYXN0X3N0YXJ0LFxuXHRcdFx0XHRsZW5ndGg6IGluZGljZXNBcnJheS5sZW5ndGggLSBsYXN0X3N0YXJ0LFxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWxfbmFtZSB8fCBcIlwiXG5cdFx0XHR9O1xuXHRcdFx0bGFzdF9zdGFydCA9IGluZGljZXNBcnJheS5sZW5ndGg7XG5cdFx0XHRncm91cHMucHVzaChncm91cCk7XG5cdFx0fSAvL3BlciB0cmlhbmdsZXMgZ3JvdXBcblxuXHRcdHZhciBtZXNoID0ge1xuXHRcdFx0dmVydGljZXM6IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyc1swXVsxXSksXG5cdFx0XHRpbmZvOiB7IGdyb3VwczogZ3JvdXBzIH0sXG5cdFx0XHRfcmVtYXA6IG5ldyBVaW50MzJBcnJheSh2ZXJ0ZXhfcmVtYXApXG5cdFx0fTtcblxuXHRcdHRoaXMudHJhbnNmb3JtTWVzaEluZm8obWVzaCwgYnVmZmVycywgaW5kaWNlc0FycmF5KTtcblxuXHRcdHJldHVybiBtZXNoO1xuXHR9LFxuXG5cdHJlYWRQb2x5bGlzdDogZnVuY3Rpb24gcmVhZFBvbHlsaXN0KHhtbF9zaGFwZV9yb290LCBzb3VyY2VzKSB7XG5cdFx0dmFyIHVzZV9pbmRpY2VzID0gZmFsc2U7XG5cblx0XHR2YXIgZ3JvdXBzID0gW107XG5cdFx0dmFyIGJ1ZmZlcnMgPSBbXTtcblx0XHR2YXIgbGFzdF9pbmRleCA9IDA7XG5cdFx0dmFyIGZhY2VtYXAgPSB7fTtcblx0XHR2YXIgdmVydGV4X3JlbWFwID0gW107XG5cdFx0dmFyIGluZGljZXNBcnJheSA9IFtdO1xuXHRcdHZhciBsYXN0X3N0YXJ0ID0gMDtcblx0XHR2YXIgZ3JvdXBfbmFtZSA9IFwiXCI7XG5cdFx0dmFyIG1hdGVyaWFsX25hbWUgPSBcIlwiO1xuXG5cdFx0bWF0ZXJpYWxfbmFtZSA9IHhtbF9zaGFwZV9yb290LmdldEF0dHJpYnV0ZShcIm1hdGVyaWFsXCIpO1xuXHRcdGJ1ZmZlcnMgPSB0aGlzLnJlYWRTaGFwZUlucHV0cyh4bWxfc2hhcGVfcm9vdCwgc291cmNlcyk7XG5cblx0XHR2YXIgeG1sdmNvdW50ID0geG1sX3NoYXBlX3Jvb3QucXVlcnlTZWxlY3RvcihcInZjb3VudFwiKTtcblx0XHR2YXIgdmNvdW50ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHZjb3VudCk7XG5cblx0XHR2YXIgeG1scCA9IHhtbF9zaGFwZV9yb290LnF1ZXJ5U2VsZWN0b3IoXCJwXCIpO1xuXHRcdHZhciBkYXRhID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHApO1xuXG5cdFx0dmFyIG51bV9kYXRhX3ZlcnRleCA9IGJ1ZmZlcnMubGVuZ3RoO1xuXG5cdFx0dmFyIHBvcyA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB2Y291bnQubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdFx0XHR2YXIgbnVtX3ZlcnRpY2VzID0gdmNvdW50W2ldO1xuXG5cdFx0XHR2YXIgZmlyc3RfaW5kZXggPSAtMTtcblx0XHRcdHZhciBjdXJyZW50X2luZGV4ID0gLTE7XG5cdFx0XHR2YXIgcHJldl9pbmRleCA9IC0xO1xuXG5cdFx0XHQvL2l0ZXJhdGUgdmVydGljZXMgb2YgdGhpcyBwb2x5Z29uXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IG51bV92ZXJ0aWNlczsgKytrKSB7XG5cdFx0XHRcdHZhciB2ZXJ0ZXhfaWQgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbnVtX2RhdGFfdmVydGV4KS5qb2luKFwiIFwiKTtcblxuXHRcdFx0XHRwcmV2X2luZGV4ID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0aWYgKGZhY2VtYXAuaGFzT3duUHJvcGVydHkodmVydGV4X2lkKSkgLy9hZGQgdG8gYXJyYXlzLCBrZWVwIHRoZSBpbmRleFxuXHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBmYWNlbWFwW3ZlcnRleF9pZF07ZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBidWZmZXJzLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdFx0XHR2YXIgYnVmZmVyID0gYnVmZmVyc1tqXTtcblx0XHRcdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KGRhdGFbcG9zICsgal0pOyAvL3Bcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IGJ1ZmZlclsxXTsgLy9hcnJheSB3aXRoIGFsbCB0aGUgZGF0YVxuXHRcdFx0XHRcdFx0dmFyIHNvdXJjZSA9IGJ1ZmZlclszXTsgLy93aGVyZSB0byByZWFkIHRoZSBkYXRhIGZyb21cblx0XHRcdFx0XHRcdGlmIChqID09IDApIHZlcnRleF9yZW1hcFthcnJheS5sZW5ndGggLyBudW1fZGF0YV92ZXJ0ZXhdID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRpbmRleCAqPSBidWZmZXJbMl07IC8vc3RyaWRlXG5cdFx0XHRcdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IGJ1ZmZlclsyXTsgKyt4KSB7XG5cdFx0XHRcdFx0XHRcdGFycmF5LnB1c2goc291cmNlW2luZGV4ICsgeF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBsYXN0X2luZGV4O1xuXHRcdFx0XHRcdGxhc3RfaW5kZXggKz0gMTtcblx0XHRcdFx0XHRmYWNlbWFwW3ZlcnRleF9pZF0gPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG51bV92ZXJ0aWNlcyA+IDMpIC8vc3BsaXQgcG9seWdvbnMgdGhlblxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChrID09IDApIGZpcnN0X2luZGV4ID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0XHRcdC8vaWYoayA+IDIgKiBudW1fZGF0YV92ZXJ0ZXgpIC8vbm90IHN1cmUgaWYgdXNlIHRoaXMgb3IgdGhlIG5leHQgbGluZSwgdGhlIG5leHQgb25lIHdvcmtzIGluIHNvbWUgREFFcyBidXQgbm90IHN1cmUgaWYgaXQgd29ya3MgaW4gYWxsXG5cdFx0XHRcdFx0XHRpZiAoayA+IDIpIC8vdHJpYW5ndWxhdGUgcG9seWdvbnM6IHRlc3RlZCwgdGhpcyB3b3Jrc1xuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goZmlyc3RfaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHRcdGluZGljZXNBcnJheS5wdXNoKHByZXZfaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZGljZXNBcnJheS5wdXNoKGN1cnJlbnRfaW5kZXgpO1xuXHRcdFx0XHRwb3MgKz0gbnVtX2RhdGFfdmVydGV4O1xuXHRcdFx0fSAvL3BlciB2ZXJ0ZXhcblx0XHR9IC8vcGVyIHBvbHlnb25cblxuXHRcdHZhciBtZXNoID0ge1xuXHRcdFx0dmVydGljZXM6IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyc1swXVsxXSksXG5cdFx0XHRpbmZvOiB7fSxcblx0XHRcdF9yZW1hcDogbmV3IFVpbnQzMkFycmF5KHZlcnRleF9yZW1hcClcblx0XHR9O1xuXG5cdFx0dGhpcy50cmFuc2Zvcm1NZXNoSW5mbyhtZXNoLCBidWZmZXJzLCBpbmRpY2VzQXJyYXkpO1xuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0cmVhZFNoYXBlSW5wdXRzOiBmdW5jdGlvbiByZWFkU2hhcGVJbnB1dHMoeG1sX3NoYXBlX3Jvb3QsIHNvdXJjZXMpIHtcblx0XHR2YXIgYnVmZmVycyA9IFtdO1xuXG5cdFx0dmFyIHhtbGlucHV0cyA9IHhtbF9zaGFwZV9yb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbGlucHV0ID0geG1saW5wdXRzLml0ZW0oaSk7XG5cdFx0XHRpZiAoIXhtbGlucHV0LmdldEF0dHJpYnV0ZSkgY29udGludWU7XG5cdFx0XHR2YXIgc2VtYW50aWMgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0dmFyIHN0cmVhbV9zb3VyY2UgPSBzb3VyY2VzW3htbGlucHV0LmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKS5zdWJzdHIoMSldO1xuXHRcdFx0dmFyIG9mZnNldCA9IHBhcnNlSW50KHhtbGlucHV0LmdldEF0dHJpYnV0ZShcIm9mZnNldFwiKSk7XG5cdFx0XHR2YXIgZGF0YV9zZXQgPSAwO1xuXHRcdFx0aWYgKHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNldFwiKSkgZGF0YV9zZXQgPSBwYXJzZUludCh4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZXRcIikpO1xuXHRcdFx0YnVmZmVycy5wdXNoKFtzZW1hbnRpYywgW10sIHN0cmVhbV9zb3VyY2Uuc3RyaWRlLCBzdHJlYW1fc291cmNlLmRhdGEsIG9mZnNldCwgZGF0YV9zZXRdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYnVmZmVycztcblx0fSxcblxuXHR0cmFuc2Zvcm1NZXNoSW5mbzogZnVuY3Rpb24gdHJhbnNmb3JtTWVzaEluZm8obWVzaCwgYnVmZmVycywgaW5kaWNlc0FycmF5KSB7XG5cdFx0Ly9yZW5hbWUgYnVmZmVycyAoREFFIGhhcyBvdGhlciBuYW1lcylcblx0XHR2YXIgdHJhbnNsYXRvciA9IHtcblx0XHRcdFwibm9ybWFsXCI6IFwibm9ybWFsc1wiLFxuXHRcdFx0XCJ0ZXhjb29yZFwiOiBcImNvb3Jkc1wiXG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciBuYW1lID0gYnVmZmVyc1tpXVswXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIGRhdGEgPSBidWZmZXJzW2ldWzFdO1xuXHRcdFx0aWYgKCFkYXRhLmxlbmd0aCkgY29udGludWU7XG5cblx0XHRcdGlmICh0cmFuc2xhdG9yW25hbWVdKSBuYW1lID0gdHJhbnNsYXRvcltuYW1lXTtcblx0XHRcdGlmIChtZXNoW25hbWVdKSBuYW1lID0gbmFtZSArIGJ1ZmZlcnNbaV1bNV07XG5cdFx0XHRtZXNoW25hbWVdID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTsgLy9hcmUgdGhleSBhbHdheXMgZmxvYXQzMj8gSSB0aGluayBzb1xuXHRcdH1cblxuXHRcdGlmIChpbmRpY2VzQXJyYXkgJiYgaW5kaWNlc0FycmF5Lmxlbmd0aCkge1xuXHRcdFx0aWYgKG1lc2gudmVydGljZXMubGVuZ3RoID4gMjU2ICogMjU2KSBtZXNoLnRyaWFuZ2xlcyA9IG5ldyBVaW50MzJBcnJheShpbmRpY2VzQXJyYXkpO2Vsc2UgbWVzaC50cmlhbmdsZXMgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlc0FycmF5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWVzaDtcblx0fSxcblxuXHRyZWFkTGluZVN0cmlwOiBmdW5jdGlvbiByZWFkTGluZVN0cmlwKHNvdXJjZXMsIHhtbGxpbmVzdHJpcCkge1xuXHRcdHZhciB1c2VfaW5kaWNlcyA9IGZhbHNlO1xuXG5cdFx0dmFyIGJ1ZmZlcnMgPSBbXTtcblx0XHR2YXIgbGFzdF9pbmRleCA9IDA7XG5cdFx0dmFyIGZhY2VtYXAgPSB7fTtcblx0XHR2YXIgdmVydGV4X3JlbWFwID0gW107XG5cdFx0dmFyIGluZGljZXNBcnJheSA9IFtdO1xuXHRcdHZhciBsYXN0X3N0YXJ0ID0gMDtcblx0XHR2YXIgZ3JvdXBfbmFtZSA9IFwiXCI7XG5cdFx0dmFyIG1hdGVyaWFsX25hbWUgPSBcIlwiO1xuXG5cdFx0dmFyIHRyaXMgPSAwOyAvL3VzZWQgaW4gY2FzZSB0aGVyZSBhcmUgc2V2ZXJhbCBzdHJpcHNcblxuXHRcdC8vZm9yIGVhY2ggYnVmZmVyIChpbnB1dCkgYnVpbGQgdGhlIHN0cnVjdHVyZSBpbmZvXG5cdFx0dmFyIHhtbGlucHV0cyA9IHhtbGxpbmVzdHJpcC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cdFx0aWYgKHRyaXMgPT0gMCkgLy9maXJzdCBpdGVyYXRpb24sIGNyZWF0ZSBidWZmZXJzXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHMuaXRlbShpKTtcblx0XHRcdFx0aWYgKCF4bWxpbnB1dC5nZXRBdHRyaWJ1dGUpIGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgc2VtYW50aWMgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgc3RyZWFtX3NvdXJjZSA9IHNvdXJjZXNbeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0XHRcdHZhciBvZmZzZXQgPSBwYXJzZUludCh4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJvZmZzZXRcIikpO1xuXHRcdFx0XHR2YXIgZGF0YV9zZXQgPSAwO1xuXHRcdFx0XHRpZiAoeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2V0XCIpKSBkYXRhX3NldCA9IHBhcnNlSW50KHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNldFwiKSk7XG5cblx0XHRcdFx0YnVmZmVycy5wdXNoKFtzZW1hbnRpYywgW10sIHN0cmVhbV9zb3VyY2Uuc3RyaWRlLCBzdHJlYW1fc291cmNlLmRhdGEsIG9mZnNldCwgZGF0YV9zZXRdKTtcblx0XHRcdH1cblx0XHQvL2Fzc3VtaW5nIGJ1ZmZlcnMgYXJlIG9yZGVyZWQgYnkgb2Zmc2V0XG5cblx0XHQvL2l0ZXJhdGUgZGF0YVxuXHRcdHZhciB4bWxwcyA9IHhtbGxpbmVzdHJpcC5xdWVyeVNlbGVjdG9yQWxsKFwicFwiKTtcblx0XHR2YXIgbnVtX2RhdGFfdmVydGV4ID0gYnVmZmVycy5sZW5ndGg7IC8vb25lIHZhbHVlIHBlciBpbnB1dCBidWZmZXJcblxuXHRcdC8vZm9yIGV2ZXJ5IHBvbHlnb24gKGNvdWxkIGJlIG9uZSB3aXRoIGFsbCB0aGUgaW5kaWNlcywgY291bGQgYmUgc2V2ZXJhbCwgZGVwZW5kcyBvbiB0aGUgcHJvZ3JhbSlcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1scCA9IHhtbHBzLml0ZW0oaSk7XG5cdFx0XHRpZiAoIXhtbHAgfHwgIXhtbHAudGV4dENvbnRlbnQpIGJyZWFrO1xuXG5cdFx0XHR2YXIgZGF0YSA9IHhtbHAudGV4dENvbnRlbnQudHJpbSgpLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0Ly91c2VkIGZvciB0cmlhbmd1bGF0ZSBwb2x5c1xuXHRcdFx0dmFyIGZpcnN0X2luZGV4ID0gLTE7XG5cdFx0XHR2YXIgY3VycmVudF9pbmRleCA9IC0xO1xuXHRcdFx0dmFyIHByZXZfaW5kZXggPSAtMTtcblxuXHRcdFx0Ly9pZih1c2VfaW5kaWNlcyAmJiBsYXN0X2luZGV4ID49IDI1NioyNTYpXG5cdFx0XHQvL1x0YnJlYWs7XG5cblx0XHRcdC8vZm9yIGV2ZXJ5IHBhY2sgb2YgaW5kaWNlcyBpbiB0aGUgcG9seWdvbiAodmVydGV4LCBub3JtYWwsIHV2LCAuLi4gKVxuXHRcdFx0Zm9yICh2YXIgayA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgayA8IGw7IGsgKz0gbnVtX2RhdGFfdmVydGV4KSB7XG5cdFx0XHRcdHZhciB2ZXJ0ZXhfaWQgPSBkYXRhLnNsaWNlKGssIGsgKyBudW1fZGF0YV92ZXJ0ZXgpLmpvaW4oXCIgXCIpOyAvL2dlbmVyYXRlIHVuaXF1ZSBpZFxuXG5cdFx0XHRcdHByZXZfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRpZiAoZmFjZW1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhfaWQpKSAvL2FkZCB0byBhcnJheXMsIGtlZXAgdGhlIGluZGV4XG5cdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGZhY2VtYXBbdmVydGV4X2lkXTtlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdHZhciBidWZmZXIgPSBidWZmZXJzW2pdO1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoZGF0YVtrICsgal0pO1xuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gYnVmZmVyWzFdOyAvL2FycmF5IHdpdGggYWxsIHRoZSBkYXRhXG5cdFx0XHRcdFx0XHR2YXIgc291cmNlID0gYnVmZmVyWzNdOyAvL3doZXJlIHRvIHJlYWQgdGhlIGRhdGEgZnJvbVxuXHRcdFx0XHRcdFx0aWYgKGogPT0gMCkgdmVydGV4X3JlbWFwW2FycmF5Lmxlbmd0aCAvIG51bV9kYXRhX3ZlcnRleF0gPSBpbmRleDtcblx0XHRcdFx0XHRcdGluZGV4ICo9IGJ1ZmZlclsyXTsgLy9zdHJpZGVcblx0XHRcdFx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgYnVmZmVyWzJdOyArK3gpIHtcblx0XHRcdFx0XHRcdFx0YXJyYXkucHVzaChzb3VyY2VbaW5kZXggKyB4XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGxhc3RfaW5kZXg7XG5cdFx0XHRcdFx0bGFzdF9pbmRleCArPSAxO1xuXHRcdFx0XHRcdGZhY2VtYXBbdmVydGV4X2lkXSA9IGN1cnJlbnRfaW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRpY2VzQXJyYXkucHVzaChjdXJyZW50X2luZGV4KTtcblx0XHRcdH0gLy9wZXIgdmVydGV4XG5cdFx0fSAvL3BlciBwb2x5Z29uXG5cblx0XHR2YXIgbWVzaCA9IHtcblx0XHRcdHByaW1pdGl2ZTogXCJsaW5lX3N0cmlwXCIsXG5cdFx0XHR2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShidWZmZXJzWzBdWzFdKSxcblx0XHRcdGluZm86IHt9XG5cdFx0fTtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybU1lc2hJbmZvKG1lc2gsIGJ1ZmZlcnMsIGluZGljZXNBcnJheSk7XG5cdH0sXG5cblx0Ly9saWtlIHF1ZXJ5U2VsZWN0b3IgYnV0IGFsbG93cyBzcGFjZXMgaW4gbmFtZXMgYmVjYXVzZSBDT0xMQURBIGFsbG93cyBzcGFjZSBpbiBuYW1lc1xuXHRmaW5kWE1MTm9kZUJ5SWQ6IGZ1bmN0aW9uIGZpbmRYTUxOb2RlQnlJZChyb290LCBub2RlbmFtZSwgaWQpIHtcblx0XHQvL3ByZWNvbXB1dGVkXG5cdFx0aWYgKHRoaXMuX3htbHJvb3QuX25vZGVzX2J5X2lkKSB7XG5cdFx0XHR2YXIgbiA9IHRoaXMuX3htbHJvb3QuX25vZGVzX2J5X2lkW2lkXTtcblx0XHRcdGlmIChuICYmIG4ubG9jYWxOYW1lID09IG5vZGVuYW1lKSByZXR1cm4gbjtcblx0XHR9IGVsc2UgLy9mb3IgdGhlIG5hdGl2ZSBwYXJzZXJcblx0XHRcdHtcblx0XHRcdFx0dmFyIG4gPSB0aGlzLl94bWxyb290LmdldEVsZW1lbnRCeUlkKGlkKTtcblx0XHRcdFx0aWYgKG4pIHJldHVybiBuO1xuXHRcdFx0fVxuXG5cdFx0Ly9yZWN1cnNpdmU6IHNsb3dcblx0XHR2YXIgY2hpbGRzID0gcm9vdC5jaGlsZE5vZGVzO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgeG1sbm9kZSA9IGNoaWxkcy5pdGVtKGkpO1xuXHRcdFx0aWYgKHhtbG5vZGUubm9kZVR5cGUgIT0gMSkgLy9ubyB0YWdcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRpZiAoeG1sbm9kZS5sb2NhbE5hbWUgIT0gbm9kZW5hbWUpIGNvbnRpbnVlO1xuXHRcdFx0dmFyIG5vZGVfaWQgPSB4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuXHRcdFx0aWYgKG5vZGVfaWQgPT0gaWQpIHJldHVybiB4bWxub2RlO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRyZWFkSW1hZ2VzOiBmdW5jdGlvbiByZWFkSW1hZ2VzKHJvb3QpIHtcblx0XHR2YXIgeG1saW1hZ2VzID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9pbWFnZXNcIik7XG5cdFx0aWYgKCF4bWxpbWFnZXMpIHJldHVybiBudWxsO1xuXG5cdFx0dmFyIGltYWdlcyA9IHt9O1xuXG5cdFx0dmFyIHhtbGltYWdlc19jaGlsZHMgPSB4bWxpbWFnZXMuY2hpbGROb2Rlcztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGltYWdlc19jaGlsZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB4bWxpbWFnZSA9IHhtbGltYWdlc19jaGlsZHMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxpbWFnZS5ub2RlVHlwZSAhPSAxKSAvL25vIHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0dmFyIHhtbGluaXRmcm9tID0geG1saW1hZ2UucXVlcnlTZWxlY3RvcihcImluaXRfZnJvbVwiKTtcblx0XHRcdGlmICgheG1saW5pdGZyb20pIGNvbnRpbnVlO1xuXHRcdFx0aWYgKHhtbGluaXRmcm9tLnRleHRDb250ZW50KSB7XG5cdFx0XHRcdHZhciBmaWxlbmFtZSA9IHRoaXMuZ2V0RmlsZW5hbWUoeG1saW5pdGZyb20udGV4dENvbnRlbnQpO1xuXHRcdFx0XHR2YXIgaWQgPSB4bWxpbWFnZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdFx0aW1hZ2VzW2lkXSA9IHsgZmlsZW5hbWU6IGZpbGVuYW1lLCBtYXA6IGlkLCBuYW1lOiB4bWxpbWFnZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpLCBwYXRoOiB4bWxpbml0ZnJvbS50ZXh0Q29udGVudCB9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZXM7XG5cdH0sXG5cblx0cmVhZEFuaW1hdGlvbnM6IGZ1bmN0aW9uIHJlYWRBbmltYXRpb25zKHJvb3QsIHNjZW5lKSB7XG5cdFx0dmFyIHhtbGFuaW1hdGlvbnMgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCJsaWJyYXJ5X2FuaW1hdGlvbnNcIik7XG5cdFx0aWYgKCF4bWxhbmltYXRpb25zKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciB4bWxhbmltYXRpb25fY2hpbGRzID0geG1sYW5pbWF0aW9ucy5jaGlsZE5vZGVzO1xuXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB7XG5cdFx0XHRvYmplY3RfdHlwZTogXCJBbmltYXRpb25cIixcblx0XHRcdHRha2VzOiB7fVxuXHRcdH07XG5cblx0XHR2YXIgZGVmYXVsdF90YWtlID0geyB0cmFja3M6IFtdIH07XG5cdFx0dmFyIHRyYWNrcyA9IGRlZmF1bHRfdGFrZS50cmFja3M7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGFuaW1hdGlvbl9jaGlsZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB4bWxhbmltYXRpb24gPSB4bWxhbmltYXRpb25fY2hpbGRzLml0ZW0oaSk7XG5cdFx0XHRpZiAoeG1sYW5pbWF0aW9uLm5vZGVUeXBlICE9IDEgfHwgeG1sYW5pbWF0aW9uLmxvY2FsTmFtZSAhPSBcImFuaW1hdGlvblwiKSAvL25vIHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0dmFyIGFuaW1faWQgPSB4bWxhbmltYXRpb24uZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRpZiAoIWFuaW1faWQpIC8vbmVzdGVkIGFuaW1hdGlvbiAoREFFIDEuNSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciB4bWxhbmltYXRpb24yX2NoaWxkcyA9IHhtbGFuaW1hdGlvbi5xdWVyeVNlbGVjdG9yQWxsKFwiYW5pbWF0aW9uXCIpO1xuXHRcdFx0XHRcdGlmICh4bWxhbmltYXRpb24yX2NoaWxkcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgeG1sYW5pbWF0aW9uMl9jaGlsZHMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdFx0dmFyIHhtbGFuaW1hdGlvbjIgPSB4bWxhbmltYXRpb24yX2NoaWxkcy5pdGVtKGopO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlYWRBbmltYXRpb24oeG1sYW5pbWF0aW9uMiwgdHJhY2tzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgLy9zb3VyY2UgdHJhY2tzP1xuXHRcdFx0XHRcdFx0dGhpcy5yZWFkQW5pbWF0aW9uKHhtbGFuaW1hdGlvbiwgdHJhY2tzKTtcblx0XHRcdFx0fSBlbHNlIC8vbm8gbmVzdGVkIChEQUUgMS40KVxuXHRcdFx0XHR0aGlzLnJlYWRBbmltYXRpb24oeG1sYW5pbWF0aW9uLCB0cmFja3MpO1xuXHRcdH1cblxuXHRcdGlmICghdHJhY2tzLmxlbmd0aCkgcmV0dXJuIG51bGw7IC8vZW1wdHkgYW5pbWF0aW9uXG5cblx0XHQvL2NvbXB1dGUgYW5pbWF0aW9uIGR1cmF0aW9uXG5cdFx0dmFyIG1heF90aW1lID0gMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0aWYgKG1heF90aW1lIDwgdHJhY2tzW2ldLmR1cmF0aW9uKSBtYXhfdGltZSA9IHRyYWNrc1tpXS5kdXJhdGlvbjtcblx0XHR9ZGVmYXVsdF90YWtlLm5hbWUgPSBcImRlZmF1bHRcIjtcblx0XHRkZWZhdWx0X3Rha2UuZHVyYXRpb24gPSBtYXhfdGltZTtcblx0XHRhbmltYXRpb25zLnRha2VzW2RlZmF1bHRfdGFrZS5uYW1lXSA9IGRlZmF1bHRfdGFrZTtcblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0fSxcblxuXHQvL2FuaW1hdGlvbiB4bWxcblx0cmVhZEFuaW1hdGlvbjogZnVuY3Rpb24gcmVhZEFuaW1hdGlvbih4bWxhbmltYXRpb24sIHJlc3VsdCkge1xuXHRcdGlmICh4bWxhbmltYXRpb24ubG9jYWxOYW1lICE9IFwiYW5pbWF0aW9uXCIpIHJldHVybiBudWxsO1xuXG5cdFx0Ly90aGlzIGNvdWxkIGJlIG1pc3Npbmcgd2hlbiB0aGVyZSBhcmUgbG90cyBvZiBhbmltcyBwYWNrZWQgaW4gb25lIDxhbmltYXRpb24+XG5cdFx0dmFyIGFuaW1faWQgPSB4bWxhbmltYXRpb24uZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cblx0XHQvL2NoYW5uZWxzIGFyZSBsaWtlIGFuaW1hdGVkIHByb3BlcnRpZXNcblx0XHR2YXIgeG1sY2hhbm5lbF9saXN0ID0geG1sYW5pbWF0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjaGFubmVsXCIpO1xuXHRcdGlmICgheG1sY2hhbm5lbF9saXN0Lmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgdHJhY2tzID0gcmVzdWx0IHx8IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxjaGFubmVsX2xpc3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciBhbmltID0gdGhpcy5yZWFkQ2hhbm5lbCh4bWxjaGFubmVsX2xpc3QuaXRlbShpKSwgeG1sYW5pbWF0aW9uKTtcblx0XHRcdGlmIChhbmltKSB0cmFja3MucHVzaChhbmltKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJhY2tzO1xuXHR9LFxuXG5cdHJlYWRDaGFubmVsOiBmdW5jdGlvbiByZWFkQ2hhbm5lbCh4bWxjaGFubmVsLCB4bWxhbmltYXRpb24pIHtcblx0XHRpZiAoeG1sY2hhbm5lbC5sb2NhbE5hbWUgIT0gXCJjaGFubmVsXCIgfHwgeG1sYW5pbWF0aW9uLmxvY2FsTmFtZSAhPSBcImFuaW1hdGlvblwiKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzb3VyY2UgPSB4bWxjaGFubmVsLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKTtcblx0XHR2YXIgdGFyZ2V0ID0geG1sY2hhbm5lbC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG5cblx0XHQvL3NhbXBsZXIsIGlzIGluIGNoYXJnZSBvZiB0aGUgaW50ZXJwb2xhdGlvblxuXHRcdC8vdmFyIHhtbHNhbXBsZXIgPSB4bWxhbmltYXRpb24ucXVlcnlTZWxlY3RvcihcInNhbXBsZXJcIiArIHNvdXJjZSk7XG5cdFx0dmFyIHhtbHNhbXBsZXIgPSB0aGlzLmZpbmRYTUxOb2RlQnlJZCh4bWxhbmltYXRpb24sIFwic2FtcGxlclwiLCBzb3VyY2Uuc3Vic3RyKDEpKTtcblx0XHRpZiAoIXhtbHNhbXBsZXIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBEQUU6IFNhbXBsZXIgbm90IGZvdW5kIGluIFwiICsgc291cmNlKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBpbnB1dHMgPSB7fTtcblx0XHR2YXIgcGFyYW1zID0ge307XG5cdFx0dmFyIHNvdXJjZXMgPSB7fTtcblx0XHR2YXIgeG1saW5wdXRzID0geG1sc2FtcGxlci5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cblx0XHR2YXIgdGltZV9kYXRhID0gbnVsbDtcblxuXHRcdC8vaXRlcmF0ZSBpbnB1dHM6IGNvbGxhZGEgc2VwYXJhdGVzIHRoZSBrZXlmcmFtZSBpbmZvIGluIGluZGVwZW5kZW50IHN0cmVhbXMsIGxpa2UgdGltZSwgaW50ZXJwb2xhdGlvbiBtZXRob2QsIHZhbHVlIClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHhtbGlucHV0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIHhtbGlucHV0ID0geG1saW5wdXRzLml0ZW0oaik7XG5cdFx0XHR2YXIgc291cmNlX25hbWUgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIik7XG5cblx0XHRcdC8vdGhlcmUgYXJlIHRocmVlIFxuXHRcdFx0dmFyIHNlbWFudGljID0geG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIik7XG5cblx0XHRcdC8vU2VhcmNoIGZvciBzb3VyY2Vcblx0XHRcdHZhciB4bWxzb3VyY2UgPSB0aGlzLmZpbmRYTUxOb2RlQnlJZCh4bWxhbmltYXRpb24sIFwic291cmNlXCIsIHNvdXJjZV9uYW1lLnN1YnN0cigxKSk7XG5cdFx0XHRpZiAoIXhtbHNvdXJjZSkgY29udGludWU7XG5cblx0XHRcdHZhciB4bWxwYXJhbSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwicGFyYW1cIik7XG5cdFx0XHRpZiAoIXhtbHBhcmFtKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIHR5cGUgPSB4bWxwYXJhbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXHRcdFx0aW5wdXRzW3NlbWFudGljXSA9IHsgc291cmNlOiBzb3VyY2VfbmFtZSwgdHlwZTogdHlwZSB9O1xuXG5cdFx0XHR2YXIgZGF0YV9hcnJheSA9IG51bGw7XG5cblx0XHRcdGlmICh0eXBlID09IFwiZmxvYXRcIiB8fCB0eXBlID09IFwiZmxvYXQ0eDRcIikge1xuXHRcdFx0XHR2YXIgeG1sZmxvYXRhcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiZmxvYXRfYXJyYXlcIik7XG5cdFx0XHRcdHZhciBmbG9hdHMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sZmxvYXRhcnJheSk7XG5cdFx0XHRcdHNvdXJjZXNbc291cmNlX25hbWVdID0gZmxvYXRzO1xuXHRcdFx0XHRkYXRhX2FycmF5ID0gZmxvYXRzO1xuXHRcdFx0fSBlbHNlIC8vb25seSBmbG9hdHMgYW5kIG1hdHJpY2VzIGFyZSBzdXBwb3J0ZWQgaW4gYW5pbWF0aW9uXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgcGFyYW1fbmFtZSA9IHhtbHBhcmFtLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG5cdFx0XHRpZiAocGFyYW1fbmFtZSA9PSBcIlRJTUVcIikgdGltZV9kYXRhID0gZGF0YV9hcnJheTtcblx0XHRcdGlmIChzZW1hbnRpYyA9PSBcIk9VVFBVVFwiKSBwYXJhbV9uYW1lID0gc2VtYW50aWM7XG5cdFx0XHRpZiAocGFyYW1fbmFtZSkgcGFyYW1zW3BhcmFtX25hbWVdID0gdHlwZTtlbHNlIGNvbnNvbGUud2FybihcIkNvbGxhZGE6IDxwYXJhbT4gd2l0aG91dCBuYW1lIGF0dHJpYnV0ZSBpbiA8YW5pbWF0aW9uPlwiKTtcblx0XHR9XG5cblx0XHRpZiAoIXRpbWVfZGF0YSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIERBRTogbm8gVElNRSBpbmZvIGZvdW5kIGluIDxjaGFubmVsPjogXCIgKyB4bWxjaGFubmVsLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL2NvbnN0cnVjdCBhbmltYXRpb25cblx0XHR2YXIgcGF0aCA9IHRhcmdldC5zcGxpdChcIi9cIik7XG5cblx0XHR2YXIgYW5pbSA9IHt9O1xuXHRcdHZhciBub2RlbmFtZSA9IHBhdGhbMF07IC8vc2FmZVN0cmluZyA/XG5cdFx0dmFyIG5vZGUgPSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlbmFtZV07XG5cdFx0dmFyIGxvY2F0b3IgPSBub2RlLmlkICsgXCIvXCIgKyBwYXRoWzFdO1xuXHRcdC8vYW5pbS5ub2RlbmFtZSA9IHRoaXMuc2FmZVN0cmluZyggcGF0aFswXSApOyAvL3doZXJlIGl0IGdvZXNcblx0XHRhbmltLm5hbWUgPSBwYXRoWzFdO1xuXHRcdGFuaW0ucHJvcGVydHkgPSBsb2NhdG9yO1xuXHRcdHZhciB0eXBlID0gXCJudW1iZXJcIjtcblx0XHR2YXIgZWxlbWVudF9zaXplID0gMTtcblx0XHR2YXIgcGFyYW1fdHlwZSA9IHBhcmFtc1tcIk9VVFBVVFwiXTtcblx0XHRzd2l0Y2ggKHBhcmFtX3R5cGUpIHtcblx0XHRcdGNhc2UgXCJmbG9hdFwiOlxuXHRcdFx0XHRlbGVtZW50X3NpemUgPSAxO2JyZWFrO1xuXHRcdFx0Y2FzZSBcImZsb2F0M3gzXCI6XG5cdFx0XHRcdGVsZW1lbnRfc2l6ZSA9IDk7dHlwZSA9IFwibWF0M1wiO2JyZWFrO1xuXHRcdFx0Y2FzZSBcImZsb2F0NHg0XCI6XG5cdFx0XHRcdGVsZW1lbnRfc2l6ZSA9IDE2O3R5cGUgPSBcIm1hdDRcIjticmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGFuaW0udHlwZSA9IHR5cGU7XG5cdFx0YW5pbS52YWx1ZV9zaXplID0gZWxlbWVudF9zaXplO1xuXHRcdGFuaW0uZHVyYXRpb24gPSB0aW1lX2RhdGFbdGltZV9kYXRhLmxlbmd0aCAtIDFdOyAvL2xhc3Qgc2FtcGxlXG5cblx0XHR2YXIgdmFsdWVfZGF0YSA9IHNvdXJjZXNbaW5wdXRzW1wiT1VUUFVUXCJdLnNvdXJjZV07XG5cdFx0aWYgKCF2YWx1ZV9kYXRhKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vUGFjayBkYXRhICoqKioqKioqKioqKioqKipcblx0XHR2YXIgbnVtX3NhbXBsZXMgPSB0aW1lX2RhdGEubGVuZ3RoO1xuXHRcdHZhciBzYW1wbGVfc2l6ZSA9IGVsZW1lbnRfc2l6ZSArIDE7XG5cdFx0dmFyIGFuaW1fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobnVtX3NhbXBsZXMgKiBzYW1wbGVfc2l6ZSk7XG5cdFx0Ly9mb3IgZXZlcnkgc2FtcGxlXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aW1lX2RhdGEubGVuZ3RoOyArK2opIHtcblx0XHRcdGFuaW1fZGF0YVtqICogc2FtcGxlX3NpemVdID0gdGltZV9kYXRhW2pdOyAvL3NldCB0aW1lXG5cdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZV9kYXRhLnN1YmFycmF5KGogKiBlbGVtZW50X3NpemUsIChqICsgMSkgKiBlbGVtZW50X3NpemUpO1xuXHRcdFx0aWYgKHBhcmFtX3R5cGUgPT0gXCJmbG9hdDR4NFwiKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3JtTWF0cml4KHZhbHVlLCBub2RlID8gbm9kZS5fZGVwdGggPT0gMCA6IDApO1xuXHRcdFx0XHQvL21hdDQudHJhbnNwb3NlKHZhbHVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRhbmltX2RhdGEuc2V0KHZhbHVlLCBqICogc2FtcGxlX3NpemUgKyAxKTsgLy9zZXQgZGF0YVxuXHRcdH1cblxuXHRcdGlmIChpc1dvcmtlciAmJiB0aGlzLnVzZV90cmFuc2ZlcmFibGVzKSB7XG5cdFx0XHR2YXIgZGF0YSA9IGFuaW1fZGF0YTtcblx0XHRcdGlmIChkYXRhICYmIGRhdGEuYnVmZmVyICYmIGRhdGEubGVuZ3RoID4gMTAwKSB0aGlzLl90cmFuc2ZlcmFibGVzLnB1c2goZGF0YS5idWZmZXIpO1xuXHRcdH1cblxuXHRcdGFuaW0uZGF0YSA9IGFuaW1fZGF0YTtcblx0XHRyZXR1cm4gYW5pbTtcblx0fSxcblxuXHRmaW5kTm9kZTogZnVuY3Rpb24gZmluZE5vZGUocm9vdCwgaWQpIHtcblx0XHRpZiAocm9vdC5pZCA9PSBpZCkgcmV0dXJuIHJvb3Q7XG5cdFx0aWYgKHJvb3QuY2hpbGRyZW4pIGZvciAodmFyIGkgaW4gcm9vdC5jaGlsZHJlbikge1xuXHRcdFx0dmFyIHJldCA9IHRoaXMuZmluZE5vZGUocm9vdC5jaGlsZHJlbltpXSwgaWQpO1xuXHRcdFx0aWYgKHJldCkgcmV0dXJuIHJldDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Ly9yZWFkcyBjb250cm9sbGVycyBhbmQgc3RvcmVzIHRoZW0gaW4gXG5cdHJlYWRMaWJyYXJ5Q29udHJvbGxlcnM6IGZ1bmN0aW9uIHJlYWRMaWJyYXJ5Q29udHJvbGxlcnMoc2NlbmUpIHtcblx0XHR2YXIgeG1sbGlicmFyeWNvbnRyb2xsZXJzID0gdGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9jb250cm9sbGVyc1wiKTtcblx0XHRpZiAoIXhtbGxpYnJhcnljb250cm9sbGVycykgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgeG1sbGlicmFyeWNvbnRyb2xsZXJzX2NoaWxkcyA9IHhtbGxpYnJhcnljb250cm9sbGVycy5jaGlsZE5vZGVzO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxsaWJyYXJ5Y29udHJvbGxlcnNfY2hpbGRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgeG1sY29udHJvbGxlciA9IHhtbGxpYnJhcnljb250cm9sbGVyc19jaGlsZHMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxjb250cm9sbGVyLm5vZGVUeXBlICE9IDEgfHwgeG1sY29udHJvbGxlci5sb2NhbE5hbWUgIT0gXCJjb250cm9sbGVyXCIpIC8vbm8gdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIGlkID0geG1sY29udHJvbGxlci5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdC8vd2UgaGF2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGlzIGNvbnRyb2xsZXJcblx0XHRcdGlmICh0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF0pIGNvbnRpbnVlO1xuXG5cdFx0XHQvL3JlYWQgaXQgKHdlIHdvbnQgdXNlIHRoZSByZXR1cm5zLCB3ZSB3aWxsIGdldCBpdCBmcm9tIHRoaXMuX2NvbnRyb2xsZXJzX2ZvdW5kXG5cdFx0XHR0aGlzLnJlYWRDb250cm9sbGVyKHhtbGNvbnRyb2xsZXIsIG51bGwsIHNjZW5lKTtcblx0XHR9XG5cdH0sXG5cblx0Ly91c2VkIGZvciBza2lubmluZyBhbmQgbW9ycGhpbmdcblx0cmVhZENvbnRyb2xsZXI6IGZ1bmN0aW9uIHJlYWRDb250cm9sbGVyKHhtbGNvbnRyb2xsZXIsIGZsaXAsIHNjZW5lKSB7XG5cdFx0aWYgKCF4bWxjb250cm9sbGVyLmxvY2FsTmFtZSA9PSBcImNvbnRyb2xsZXJcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKFwicmVhZENvbnRyb2xsZXI6IG5vdCBhIGNvbnRyb2xsZXI6IFwiICsgeG1sY29udHJvbGxlci5sb2NhbE5hbWUpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0geG1sY29udHJvbGxlci5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHQvL3VzZSBjYWNoZWRcblx0XHRpZiAodGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdKSByZXR1cm4gdGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdO1xuXG5cdFx0Ly9BR1VJTEFcblx0XHQvL1RPRE86IGRvZXMgdGhpcyB3b3JrP1xuXHRcdC8vIGlmICh0aGlzLl9jb250cm9sbGVyc19mb3VuZFsgaWQgXSlcblx0XHQvLyBcdHJldHVybiB0aGlzLl9jb250cm9sbGVyc19mb3VuZFsgaWQgXTtcblxuXHRcdHZhciB1c2VfaW5kaWNlcyA9IGZhbHNlO1xuXHRcdHZhciBtZXNoID0gbnVsbDtcblx0XHR2YXIgeG1sc2tpbiA9IHhtbGNvbnRyb2xsZXIucXVlcnlTZWxlY3RvcihcInNraW5cIik7XG5cdFx0aWYgKHhtbHNraW4pIHtcblx0XHRcdG1lc2ggPSB0aGlzLnJlYWRTa2luQ29udHJvbGxlcih4bWxza2luLCBmbGlwLCBzY2VuZSk7XG5cdFx0fVxuXG5cdFx0dmFyIHhtbG1vcnBoID0geG1sY29udHJvbGxlci5xdWVyeVNlbGVjdG9yKFwibW9ycGhcIik7XG5cdFx0aWYgKHhtbG1vcnBoKSBtZXNoID0gdGhpcy5yZWFkTW9ycGhDb250cm9sbGVyKHhtbG1vcnBoLCBmbGlwLCBzY2VuZSwgbWVzaCk7XG5cblx0XHQvL2NhY2hlIGFuZCByZXR1cm5cblx0XHRpZiAodGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdKSB7XG5cdFx0XHRpZCArPSBcIl8xYmxhaFwiOyAvLz8/PyB0aGlzIGRvZXNudCBkbyBhbnl0aGluZ1xuXHRcdH0gZWxzZSB0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF0gPSBtZXNoO1xuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0Ly9yZWFkIHRoaXMgdG8gbW9yZSBpbmZvIGFib3V0IERBRSBhbmQgc2tpbm5pbmcgaHR0cHM6Ly9jb2xsYWRhLm9yZy9tZWRpYXdpa2kvaW5kZXgucGhwL1NraW5uaW5nXG5cdHJlYWRTa2luQ29udHJvbGxlcjogZnVuY3Rpb24gcmVhZFNraW5Db250cm9sbGVyKHhtbHNraW4sIGZsaXAsIHNjZW5lKSB7XG5cdFx0Ly9iYXNlIGdlb21ldHJ5XG5cdFx0dmFyIGlkX2dlb21ldHJ5ID0geG1sc2tpbi5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIik7XG5cblx0XHR2YXIgbWVzaCA9IHRoaXMucmVhZEdlb21ldHJ5KGlkX2dlb21ldHJ5LCBmbGlwLCBzY2VuZSk7XG5cdFx0aWYgKCFtZXNoKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzb3VyY2VzID0gdGhpcy5yZWFkU291cmNlcyh4bWxza2luLCBmbGlwKTtcblx0XHRpZiAoIXNvdXJjZXMpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9tYXRyaXhcblx0XHR2YXIgYmluZF9tYXRyaXggPSBudWxsO1xuXHRcdHZhciB4bWxiaW5kbWF0cml4ID0geG1sc2tpbi5xdWVyeVNlbGVjdG9yKFwiYmluZF9zaGFwZV9tYXRyaXhcIik7XG5cdFx0aWYgKHhtbGJpbmRtYXRyaXgpIHtcblx0XHRcdGJpbmRfbWF0cml4ID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbGJpbmRtYXRyaXgpO1xuXHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgoYmluZF9tYXRyaXgsIHRydWUsIHRydWUpO1xuXHRcdH0gZWxzZSBiaW5kX21hdHJpeCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpOyAvL2lkZW50aXR5XG5cblx0XHQvL2pvaW50c1xuXHRcdHZhciBqb2ludHMgPSBbXTtcblx0XHR2YXIgeG1sam9pbnRzID0geG1sc2tpbi5xdWVyeVNlbGVjdG9yKFwiam9pbnRzXCIpO1xuXHRcdGlmICh4bWxqb2ludHMpIHtcblx0XHRcdHZhciBqb2ludHNfc291cmNlID0gbnVsbDsgLy93aGljaCBib25lc1xuXHRcdFx0dmFyIGludl9iaW5kX3NvdXJjZSA9IG51bGw7IC8vYmluZCBtYXRyaWNlc1xuXHRcdFx0dmFyIHhtbGlucHV0cyA9IHhtbGpvaW50cy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHNbaV07XG5cdFx0XHRcdHZhciBzZW0gPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgc3JjID0geG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpO1xuXHRcdFx0XHR2YXIgc291cmNlID0gc291cmNlc1tzcmMuc3Vic3RyKDEpXTtcblx0XHRcdFx0aWYgKHNlbSA9PSBcIkpPSU5UXCIpIGpvaW50c19zb3VyY2UgPSBzb3VyY2U7ZWxzZSBpZiAoc2VtID09IFwiSU5WX0JJTkRfTUFUUklYXCIpIGludl9iaW5kX3NvdXJjZSA9IHNvdXJjZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9zYXZlIGJvbmUgbmFtZXMgYW5kIGludiBtYXRyaXhcblx0XHRcdGlmICghaW52X2JpbmRfc291cmNlIHx8ICFqb2ludHNfc291cmNlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBEQUU6IG5vIGpvaW50cyBvciBpbnZfYmluZCBzb3VyY2VzIGZvdW5kXCIpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSBpbiBqb2ludHNfc291cmNlKSB7XG5cdFx0XHRcdC8vZ2V0IHRoZSBpbnZlcnNlIG9mIHRoZSBiaW5kIHBvc2Vcblx0XHRcdFx0dmFyIGludl9tYXQgPSBpbnZfYmluZF9zb3VyY2Uuc3ViYXJyYXkoaSAqIDE2LCBpICogMTYgKyAxNik7XG5cdFx0XHRcdHZhciBub2RlbmFtZSA9IGpvaW50c19zb3VyY2VbaV07XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5fbm9kZXNfYnlfaWRbbm9kZW5hbWVdO1xuXHRcdFx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJOb2RlIFwiICsgbm9kZW5hbWUgKyBcIiBub3QgZm91bmRcIik7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgoaW52X21hdCwgbm9kZS5fZGVwdGggPT0gMCwgdHJ1ZSk7XG5cdFx0XHRcdGpvaW50cy5wdXNoKFtub2RlbmFtZSwgaW52X21hdF0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vd2VpZ2h0c1xuXHRcdHZhciB4bWx2ZXJ0ZXh3ZWlnaHRzID0geG1sc2tpbi5xdWVyeVNlbGVjdG9yKFwidmVydGV4X3dlaWdodHNcIik7XG5cdFx0aWYgKHhtbHZlcnRleHdlaWdodHMpIHtcblxuXHRcdFx0Ly9oZXJlIHdlIHNlZSB0aGUgb3JkZXIgXG5cdFx0XHR2YXIgd2VpZ2h0c19pbmRleGVkX2FycmF5ID0gbnVsbDtcblx0XHRcdHZhciB4bWxpbnB1dHMgPSB4bWx2ZXJ0ZXh3ZWlnaHRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh4bWxpbnB1dHNbaV0uZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIikudG9VcHBlckNhc2UoKSA9PSBcIldFSUdIVFwiKSB3ZWlnaHRzX2luZGV4ZWRfYXJyYXkgPSBzb3VyY2VzW3htbGlucHV0cy5pdGVtKGkpLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKS5zdWJzdHIoMSldO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXdlaWdodHNfaW5kZXhlZF9hcnJheSkgdGhyb3cgXCJubyB3ZWlnaHRzIGZvdW5kXCI7XG5cblx0XHRcdHZhciB4bWx2Y291bnQgPSB4bWx2ZXJ0ZXh3ZWlnaHRzLnF1ZXJ5U2VsZWN0b3IoXCJ2Y291bnRcIik7XG5cdFx0XHR2YXIgdmNvdW50ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHZjb3VudCk7XG5cblx0XHRcdHZhciB4bWx2ID0geG1sdmVydGV4d2VpZ2h0cy5xdWVyeVNlbGVjdG9yKFwidlwiKTtcblx0XHRcdHZhciB2ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHYpO1xuXG5cdFx0XHR2YXIgbnVtX3ZlcnRpY2VzID0gbWVzaC52ZXJ0aWNlcy5sZW5ndGggLyAzOyAvLzMgY29tcG9uZW50cyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgd2VpZ2h0c19hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgYm9uZV9pbmRleF9hcnJheSA9IG5ldyBVaW50OEFycmF5KDQgKiBudW1fdmVydGljZXMpOyAvLzQgYm9uZXMgcGVyIHZlcnRleFxuXG5cdFx0XHR2YXIgcG9zID0gMDtcblx0XHRcdHZhciByZW1hcCA9IG1lc2guX3JlbWFwO1xuXHRcdFx0dmFyIG1heF9ib25lID0gMDsgLy9tYXggYm9uZSBhZmZlY3RlZFxuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZjb3VudC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0dmFyIG51bV9ib25lcyA9IHZjb3VudFtpXTsgLy9udW0gYm9uZXMgaW5mbHVlbmNpbmcgdGhpcyB2ZXJ0ZXhcblxuXHRcdFx0XHQvL2ZpbmQgNCB3aXRoIG1vcmUgaW5mbHVlbmNlXG5cdFx0XHRcdC8vdmFyIHZfdHVwbGV0cyA9IHYuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBudW1fYm9uZXMqMik7XG5cblx0XHRcdFx0dmFyIG9mZnNldCA9IHBvcztcblx0XHRcdFx0dmFyIGIgPSBib25lX2luZGV4X2FycmF5LnN1YmFycmF5KGkgKiA0LCBpICogNCArIDQpO1xuXHRcdFx0XHR2YXIgdyA9IHdlaWdodHNfYXJyYXkuc3ViYXJyYXkoaSAqIDQsIGkgKiA0ICsgNCk7XG5cblx0XHRcdFx0dmFyIHN1bSA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbnVtX2JvbmVzICYmIGogPCA0OyArK2opIHtcblx0XHRcdFx0XHRiW2pdID0gdltvZmZzZXQgKyBqICogMl07XG5cdFx0XHRcdFx0aWYgKGJbal0gPiBtYXhfYm9uZSkgbWF4X2JvbmUgPSBiW2pdO1xuXG5cdFx0XHRcdFx0d1tqXSA9IHdlaWdodHNfaW5kZXhlZF9hcnJheVt2W29mZnNldCArIGogKiAyICsgMV1dO1xuXHRcdFx0XHRcdHN1bSArPSB3W2pdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9ub3JtYWxpemUgd2VpZ2h0c1xuXHRcdFx0XHRpZiAobnVtX2JvbmVzID4gNCAmJiBzdW0gPCAxLjApIHtcblx0XHRcdFx0XHR2YXIgaW52X3N1bSA9IDEgLyBzdW07XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA0OyArK2opIHtcblx0XHRcdFx0XHRcdHdbal0gKj0gaW52X3N1bTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwb3MgKz0gbnVtX2JvbmVzICogMjtcblx0XHRcdH1cblxuXHRcdFx0Ly9yZW1hcDogYmVjYXVzZSB2ZXJ0aWNlcyBvcmRlciBpcyBub3cgY2hhbmdlZCBhZnRlciBwYXJzaW5nIHRoZSBtZXNoXG5cdFx0XHR2YXIgZmluYWxfd2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgZmluYWxfYm9uZV9pbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgdXNlZF9qb2ludHMgPSBbXTtcblxuXHRcdFx0Ly9mb3IgZXZlcnkgdmVydGV4IGluIHRoZSBtZXNoLCBwcm9jZXNzIGJvbmUgaW5kaWNlcyBhbmQgd2VpZ2h0c1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1fdmVydGljZXM7ICsraSkge1xuXHRcdFx0XHR2YXIgcCA9IHJlbWFwW2ldICogNDtcblx0XHRcdFx0dmFyIHcgPSB3ZWlnaHRzX2FycmF5LnN1YmFycmF5KHAsIHAgKyA0KTtcblx0XHRcdFx0dmFyIGIgPSBib25lX2luZGV4X2FycmF5LnN1YmFycmF5KHAsIHAgKyA0KTtcblxuXHRcdFx0XHQvL3NvcnQgYnkgd2VpZ2h0IHNvIHJlbGV2YW50IG9uZXMgZ29lcyBmaXJzdFxuXHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IDM7ICsraykge1xuXHRcdFx0XHRcdHZhciBtYXhfcG9zID0gaztcblx0XHRcdFx0XHR2YXIgbWF4X3ZhbHVlID0gd1trXTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gayArIDE7IGogPCA0OyArK2opIHtcblx0XHRcdFx0XHRcdGlmICh3W2pdIDw9IG1heF92YWx1ZSkgY29udGludWU7XG5cdFx0XHRcdFx0XHRtYXhfcG9zID0gajtcblx0XHRcdFx0XHRcdG1heF92YWx1ZSA9IHdbal07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYXhfcG9zICE9IGspIHtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSB3W2tdO1xuXHRcdFx0XHRcdFx0d1trXSA9IHdbbWF4X3Bvc107XG5cdFx0XHRcdFx0XHR3W21heF9wb3NdID0gdG1wO1xuXHRcdFx0XHRcdFx0dG1wID0gYltrXTtcblx0XHRcdFx0XHRcdGJba10gPSBiW21heF9wb3NdO1xuXHRcdFx0XHRcdFx0YlttYXhfcG9zXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3N0b3JlXG5cdFx0XHRcdGZpbmFsX3dlaWdodHMuc2V0KHcsIGkgKiA0KTtcblx0XHRcdFx0ZmluYWxfYm9uZV9pbmRpY2VzLnNldChiLCBpICogNCk7XG5cblx0XHRcdFx0Ly9tYXJrIGJvbmVzIHVzZWRcblx0XHRcdFx0aWYgKHdbMF0pIHVzZWRfam9pbnRzW2JbMF1dID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdbMV0pIHVzZWRfam9pbnRzW2JbMV1dID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdbMl0pIHVzZWRfam9pbnRzW2JbMl1dID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdbM10pIHVzZWRfam9pbnRzW2JbM11dID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1heF9ib25lID49IGpvaW50cy5sZW5ndGgpIGNvbnNvbGUud2FybihcIk1lc2ggdXNlcyBoaWdoZXIgYm9uZSBpbmRleCB0aGFuIGJvbmVzIGZvdW5kXCIpO1xuXG5cdFx0XHQvL3RyaW0gdW51c2VkIGJvbmVzIChjb2xsYWRhIGNvdWxkIGdpdmUgeW91IDEwMCBib25lcyBmb3IgYW4gb2JqZWN0IHRoYXQgb25seSB1c2VzIGEgZnJhY3Rpb24gb2YgdGhlbSlcblx0XHRcdGlmICgxKSB7XG5cdFx0XHRcdHZhciBuZXdfYm9uZXMgPSBbXTtcblx0XHRcdFx0dmFyIGJvbmVzX3RyYW5zbGF0aW9uID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdXNlZF9qb2ludHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRpZiAodXNlZF9qb2ludHNbaV0pIHtcblx0XHRcdFx0XHRcdGJvbmVzX3RyYW5zbGF0aW9uW2ldID0gbmV3X2JvbmVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdG5ld19ib25lcy5wdXNoKGpvaW50c1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vaW4gY2FzZSB0aGVyZSBhcmUgbGVzcyBib25lcyBpbiB1c2UuLi5cblx0XHRcdFx0aWYgKG5ld19ib25lcy5sZW5ndGggPCBqb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly9yZW1hcFxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxfYm9uZV9pbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRmaW5hbF9ib25lX2luZGljZXNbaV0gPSBib25lc190cmFuc2xhdGlvbltmaW5hbF9ib25lX2luZGljZXNbaV1dO1xuXHRcdFx0XHRcdH1qb2ludHMgPSBuZXdfYm9uZXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkJvbmVzOiBcIiwgam9pbnRzLmxlbmd0aCwgXCIgdXNlZDpcIiwgbnVtX3VzZWRfam9pbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vY29uc29sZS5sb2coXCJCb25lczogXCIsIGpvaW50cy5sZW5ndGgsIFwiTWF4IGJvbmU6IFwiLCBtYXhfYm9uZSk7XG5cblx0XHRcdG1lc2gud2VpZ2h0cyA9IGZpbmFsX3dlaWdodHM7XG5cdFx0XHRtZXNoLmJvbmVfaW5kaWNlcyA9IGZpbmFsX2JvbmVfaW5kaWNlcztcblx0XHRcdG1lc2guYm9uZXMgPSBqb2ludHM7XG5cdFx0XHRtZXNoLmJpbmRfbWF0cml4ID0gYmluZF9tYXRyaXg7XG5cblx0XHRcdC8vZGVsZXRlIG1lc2hbXCJfcmVtYXBcIl07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0Ly9OT1QgVEVTVEVEXG5cdHJlYWRNb3JwaENvbnRyb2xsZXI6IGZ1bmN0aW9uIHJlYWRNb3JwaENvbnRyb2xsZXIoeG1sbW9ycGgsIGZsaXAsIHNjZW5lLCBtZXNoKSB7XG5cdFx0dmFyIGlkX2dlb21ldHJ5ID0geG1sbW9ycGguZ2V0QXR0cmlidXRlKFwic291cmNlXCIpO1xuXHRcdHZhciBiYXNlX21lc2ggPSB0aGlzLnJlYWRHZW9tZXRyeShpZF9nZW9tZXRyeSwgZmxpcCwgc2NlbmUpO1xuXHRcdGlmICghYmFzZV9tZXNoKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vcmVhZCBzb3VyY2VzIHdpdGggYmxlbmQgc2hhcGVzIGluZm8gKHdoaWNoIG9uZXMsIGFuZCB0aGUgd2VpZ2h0KVxuXHRcdHZhciBzb3VyY2VzID0gdGhpcy5yZWFkU291cmNlcyh4bWxtb3JwaCwgZmxpcCk7XG5cblx0XHR2YXIgbW9ycGhzID0gW107XG5cblx0XHQvL3RhcmdldHNcblx0XHR2YXIgeG1sdGFyZ2V0cyA9IHhtbG1vcnBoLnF1ZXJ5U2VsZWN0b3IoXCJ0YXJnZXRzXCIpO1xuXHRcdGlmICgheG1sdGFyZ2V0cykgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgeG1saW5wdXRzID0geG1sdGFyZ2V0cy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cdFx0dmFyIHRhcmdldHMgPSBudWxsO1xuXHRcdHZhciB3ZWlnaHRzID0gbnVsbDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHMuaXRlbShpKTtcblx0XHRcdHZhciBzZW1hbnRpYyA9IHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNlbWFudGljXCIpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR2YXIgZGF0YSA9IHNvdXJjZXNbeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0XHRpZiAoc2VtYW50aWMgPT0gXCJNT1JQSF9UQVJHRVRcIikgdGFyZ2V0cyA9IGRhdGE7ZWxzZSBpZiAoc2VtYW50aWMgPT0gXCJNT1JQSF9XRUlHSFRcIikgd2VpZ2h0cyA9IGRhdGE7XG5cdFx0fVxuXG5cdFx0aWYgKCF0YXJnZXRzIHx8ICF3ZWlnaHRzKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJNb3JwaCBjb250cm9sbGVyIHdpdGhvdXQgdGFyZ2V0cyBvciB3ZWlnaHRzLiBTa2lwcGluZyBpdC5cIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL2dldCB0YXJnZXRzXG5cdFx0Zm9yICh2YXIgaSBpbiB0YXJnZXRzKSB7XG5cdFx0XHR2YXIgaWQgPSBcIiNcIiArIHRhcmdldHNbaV07XG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLnJlYWRHZW9tZXRyeShpZCwgZmxpcCwgc2NlbmUpO1xuXHRcdFx0c2NlbmUubWVzaGVzW2lkXSA9IGdlb21ldHJ5O1xuXHRcdFx0bW9ycGhzLnB1c2goeyBtZXNoOiBpZCwgd2VpZ2h0OiB3ZWlnaHRzW2ldIH0pO1xuXHRcdH1cblxuXHRcdGJhc2VfbWVzaC5tb3JwaF90YXJnZXRzID0gbW9ycGhzO1xuXHRcdHJldHVybiBiYXNlX21lc2g7XG5cdH0sXG5cblx0cmVhZEJpbmRNYXRlcmlhbHM6IGZ1bmN0aW9uIHJlYWRCaW5kTWF0ZXJpYWxzKHhtbGJpbmRfbWF0ZXJpYWwsIG1lc2gpIHtcblx0XHR2YXIgbWF0ZXJpYWxzID0gW107XG5cblx0XHR2YXIgeG1sdGVjaG5pcXVlcyA9IHhtbGJpbmRfbWF0ZXJpYWwucXVlcnlTZWxlY3RvckFsbChcInRlY2huaXF1ZV9jb21tb25cIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWx0ZWNobmlxdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sdGVjaG5pcXVlID0geG1sdGVjaG5pcXVlcy5pdGVtKGkpO1xuXHRcdFx0dmFyIHhtbGluc3RhbmNlX21hdGVyaWFscyA9IHhtbHRlY2huaXF1ZS5xdWVyeVNlbGVjdG9yQWxsKFwiaW5zdGFuY2VfbWF0ZXJpYWxcIik7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHhtbGluc3RhbmNlX21hdGVyaWFscy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWwgPSB4bWxpbnN0YW5jZV9tYXRlcmlhbHMuaXRlbShqKTtcblx0XHRcdFx0aWYgKHhtbGluc3RhbmNlX21hdGVyaWFsKSBtYXRlcmlhbHMucHVzaCh4bWxpbnN0YW5jZV9tYXRlcmlhbC5nZXRBdHRyaWJ1dGUoXCJzeW1ib2xcIikpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cdH0sXG5cblx0cmVhZFNvdXJjZXM6IGZ1bmN0aW9uIHJlYWRTb3VyY2VzKHhtbG5vZGUsIGZsaXApIHtcblx0XHQvL2ZvciBkYXRhIHNvdXJjZXNcblx0XHR2YXIgc291cmNlcyA9IHt9O1xuXHRcdHZhciB4bWxzb3VyY2VzID0geG1sbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sc291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbHNvdXJjZSA9IHhtbHNvdXJjZXMuaXRlbShpKTtcblx0XHRcdGlmICgheG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IpIC8vPz9cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdHZhciBmbG9hdF9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiZmxvYXRfYXJyYXlcIik7XG5cdFx0XHRpZiAoZmxvYXRfYXJyYXkpIHtcblx0XHRcdFx0dmFyIGZsb2F0cyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWxzb3VyY2UpO1xuXHRcdFx0XHRzb3VyY2VzW3htbHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSBmbG9hdHM7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmFtZV9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiTmFtZV9hcnJheVwiKTtcblx0XHRcdGlmIChuYW1lX2FycmF5KSB7XG5cdFx0XHRcdHZhciBuYW1lcyA9IHRoaXMucmVhZENvbnRlbnRBc1N0cmluZ3NBcnJheShuYW1lX2FycmF5KTtcblx0XHRcdFx0aWYgKCFuYW1lcykgY29udGludWU7XG5cdFx0XHRcdHNvdXJjZXNbeG1sc291cmNlLmdldEF0dHJpYnV0ZShcImlkXCIpXSA9IG5hbWVzO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlZl9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiSURSRUZfYXJyYXlcIik7XG5cdFx0XHRpZiAocmVmX2FycmF5KSB7XG5cdFx0XHRcdHZhciBuYW1lcyA9IHRoaXMucmVhZENvbnRlbnRBc1N0cmluZ3NBcnJheShyZWZfYXJyYXkpO1xuXHRcdFx0XHRpZiAoIW5hbWVzKSBjb250aW51ZTtcblx0XHRcdFx0c291cmNlc1t4bWxzb3VyY2UuZ2V0QXR0cmlidXRlKFwiaWRcIildID0gbmFtZXM7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzb3VyY2VzO1xuXHR9LFxuXG5cdHJlYWRDb250ZW50QXNVSW50MzI6IGZ1bmN0aW9uIHJlYWRDb250ZW50QXNVSW50MzIoeG1sbm9kZSkge1xuXHRcdGlmICgheG1sbm9kZSkgcmV0dXJuIG51bGw7XG5cdFx0dmFyIHRleHQgPSB4bWxub2RlLnRleHRDb250ZW50O1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi9naSwgXCIgXCIpOyAvL3JlbW92ZSBsaW5lIGJyZWFrc1xuXHRcdHRleHQgPSB0ZXh0LnRyaW0oKTsgLy9yZW1vdmUgZW1wdHkgc3BhY2VzXG5cdFx0aWYgKHRleHQubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuXHRcdHZhciBudW1iZXJzID0gdGV4dC5zcGxpdChcIiBcIik7IC8vY3JlYXRlIGFycmF5XG5cdFx0dmFyIGZsb2F0cyA9IG5ldyBVaW50MzJBcnJheShudW1iZXJzLmxlbmd0aCk7XG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBudW1iZXJzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRmbG9hdHNba10gPSBwYXJzZUludChudW1iZXJzW2tdKTtcblx0XHR9cmV0dXJuIGZsb2F0cztcblx0fSxcblxuXHRyZWFkQ29udGVudEFzRmxvYXRzOiBmdW5jdGlvbiByZWFkQ29udGVudEFzRmxvYXRzKHhtbG5vZGUpIHtcblx0XHRpZiAoIXhtbG5vZGUpIHJldHVybiBudWxsO1xuXHRcdHZhciB0ZXh0ID0geG1sbm9kZS50ZXh0Q29udGVudDtcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZ2ksIFwiIFwiKTsgLy9yZW1vdmUgbGluZSBicmVha3Ncblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHNcXHMrL2dpLCBcIiBcIik7XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFx0L2dpLCBcIlwiKTtcblx0XHR0ZXh0ID0gdGV4dC50cmltKCk7IC8vcmVtb3ZlIGVtcHR5IHNwYWNlc1xuXHRcdHZhciBudW1iZXJzID0gdGV4dC5zcGxpdChcIiBcIik7IC8vY3JlYXRlIGFycmF5XG5cdFx0dmFyIGNvdW50ID0geG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb3VudFwiKTtcblx0XHR2YXIgbGVuZ3RoID0gY291bnQgPyBwYXJzZUludChjb3VudCkgOiBudW1iZXJzLmxlbmd0aDtcblx0XHR2YXIgZmxvYXRzID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbnVtYmVycy5sZW5ndGg7IGsrKykge1xuXHRcdFx0ZmxvYXRzW2tdID0gcGFyc2VGbG9hdChudW1iZXJzW2tdKTtcblx0XHR9cmV0dXJuIGZsb2F0cztcblx0fSxcblxuXHRyZWFkQ29udGVudEFzU3RyaW5nc0FycmF5OiBmdW5jdGlvbiByZWFkQ29udGVudEFzU3RyaW5nc0FycmF5KHhtbG5vZGUpIHtcblx0XHRpZiAoIXhtbG5vZGUpIHJldHVybiBudWxsO1xuXHRcdHZhciB0ZXh0ID0geG1sbm9kZS50ZXh0Q29udGVudDtcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZ2ksIFwiIFwiKTsgLy9yZW1vdmUgbGluZSBicmVha3Ncblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHNcXHMvZ2ksIFwiIFwiKTtcblx0XHR0ZXh0ID0gdGV4dC50cmltKCk7IC8vcmVtb3ZlIGVtcHR5IHNwYWNlc1xuXHRcdHZhciB3b3JkcyA9IHRleHQuc3BsaXQoXCIgXCIpOyAvL2NyZWF0ZSBhcnJheVxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgd29yZHMubGVuZ3RoOyBrKyspIHtcblx0XHRcdHdvcmRzW2tdID0gd29yZHNba10udHJpbSgpO1xuXHRcdH1pZiAoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb3VudFwiKSAmJiBwYXJzZUludCh4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpKSAhPSB3b3Jkcy5sZW5ndGgpIHtcblx0XHRcdHZhciBtZXJnZWRfd29yZHMgPSBbXTtcblx0XHRcdHZhciBuYW1lID0gXCJcIjtcblx0XHRcdGZvciAodmFyIGkgaW4gd29yZHMpIHtcblx0XHRcdFx0aWYgKCFuYW1lKSBuYW1lID0gd29yZHNbaV07ZWxzZSBuYW1lICs9IFwiIFwiICsgd29yZHNbaV07XG5cdFx0XHRcdGlmICghdGhpcy5fbm9kZXNfYnlfaWRbdGhpcy5zYWZlU3RyaW5nKG5hbWUpXSkgY29udGludWU7XG5cdFx0XHRcdG1lcmdlZF93b3Jkcy5wdXNoKHRoaXMuc2FmZVN0cmluZyhuYW1lKSk7XG5cdFx0XHRcdG5hbWUgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY291bnQgPSBwYXJzZUludCh4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpKTtcblx0XHRcdGlmIChtZXJnZWRfd29yZHMubGVuZ3RoID09IGNvdW50KSByZXR1cm4gbWVyZ2VkX3dvcmRzO1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3I6IGJvbmUgbmFtZXMgaGF2ZSBzcGFjZXMsIGF2b2lkIHVzaW5nIHNwYWNlcyBpbiBuYW1lc1wiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gd29yZHM7XG5cdH0sXG5cblx0bWF4M2RfbWF0cml4XzA6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIC0xLCAwLCAwLCAwLCAwLCAtMSwgMCwgMSwgMCwgMCwgLTAsIDAsIDAsIDAsIDFdKSxcblx0Ly9tYXgzZF9tYXRyaXhfb3RoZXI6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIC0xLCAwLCAwLCAwLCAwLCAtMSwgMCwgMSwgMCwgMCwgLTAsIDAsIDAsIDAsIDFdKSxcblxuXHR0cmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIGZpcnN0X2xldmVsLCBpbnZlcnRlZCkge1xuXHRcdF9nbE1hdHJpeC5tYXQ0LnRyYW5zcG9zZShtYXRyaXgsIG1hdHJpeCk7XG5cblx0XHRpZiAodGhpcy5ub19mbGlwKSByZXR1cm4gbWF0cml4O1xuXG5cdFx0Ly9XQVJOSU5HOiBETyBOT1QgQ0hBTkdFIFRISVMgRlVOQ1RJT04sIFRIRSBTS1kgV0lMTCBGQUxMXG5cdFx0aWYgKGZpcnN0X2xldmVsKSB7XG5cblx0XHRcdC8vZmxpcCByb3cgdHdvIGFuZCB0cmVlXG5cdFx0XHR2YXIgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkobWF0cml4LnN1YmFycmF5KDQsIDgpKTsgLy9zd2FwIHJvd3Ncblx0XHRcdG1hdHJpeC5zZXQobWF0cml4LnN1YmFycmF5KDgsIDEyKSwgNCk7XG5cdFx0XHRtYXRyaXguc2V0KHRlbXAsIDgpO1xuXG5cdFx0XHQvL3JldmVyc2UgWlxuXHRcdFx0dGVtcCA9IG1hdHJpeC5zdWJhcnJheSg4LCAxMik7XG5cdFx0XHR2ZWM0LnNjYWxlKHRlbXAsIHRlbXAsIC0xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIE0gPSBfZ2xNYXRyaXgubWF0NC5jcmVhdGUoKTtcblx0XHRcdHZhciBtID0gbWF0cml4O1xuXG5cdFx0XHQvL2lmKGludmVydGVkKSBtYXQ0LmludmVydChtLG0pO1xuXG5cdFx0XHQvKiBub24gdHJhc3Bvc2VkXG4gICBNLnNldChbbVswXSxtWzhdLC1tWzRdXSwgMCk7XG4gICBNLnNldChbbVsyXSxtWzEwXSwtbVs2XV0sIDQpO1xuICAgTS5zZXQoWy1tWzFdLC1tWzldLG1bNV1dLCA4KTtcbiAgIE0uc2V0KFttWzNdLG1bMTFdLC1tWzddXSwgMTIpO1xuICAgKi9cblxuXHRcdFx0TS5zZXQoW21bMF0sIG1bMl0sIC1tWzFdXSwgMCk7XG5cdFx0XHRNLnNldChbbVs4XSwgbVsxMF0sIC1tWzldXSwgNCk7XG5cdFx0XHRNLnNldChbLW1bNF0sIC1tWzZdLCBtWzVdXSwgOCk7XG5cdFx0XHRNLnNldChbbVsxMl0sIG1bMTRdLCAtbVsxM11dLCAxMik7XG5cblx0XHRcdG0uc2V0KE0pO1xuXG5cdFx0XHQvL2lmKGludmVydGVkKSBtYXQ0LmludmVydChtLG0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsYWRhO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xsYWRhLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbGxhZGEtcGFyc2VyL2xpYi9Db2xsYWRhLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdsdGZMb2FkZXIuanNcblxuaW1wb3J0IHhociBmcm9tICcuL3hocic7XG5pbXBvcnQgbG9hZEltYWdlcyBmcm9tICcuL2xvYWRJbWFnZXMnO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4uL0dlb21ldHJ5JztcbmltcG9ydCBNYXRlcmlhbCBmcm9tICcuLi9NYXRlcmlhbCc7XG5pbXBvcnQgTWVzaCBmcm9tICcuLi9NZXNoJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgU2hhZGVyTGlicyBmcm9tICcuLi9zaGFkZXJzL1NoYWRlckxpYnMnO1xuaW1wb3J0IFNoYWRlcnMgZnJvbSAnLi4vc2hhZGVycy9TaGFkZXJzJztcblxuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuLi9HTFRleHR1cmUnO1xuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4uL29iamVjdHMvT2JqZWN0M0QnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAncHJvbWlzZS1wb2x5ZmlsbCc7XG5pbXBvcnQgb2JqZWN0QXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nO1xuaW1wb3J0IFdlYmdsTnVtYmVyIGZyb20gJy4uL3V0aWxzL1dlYmdsTnVtYmVyJztcblxuXG5cbmNvbnN0IEFSUkFZX0NUT1JfTUFQID0ge1xuXHQ1MTIwOiBJbnQ4QXJyYXksXG5cdDUxMjE6IFVpbnQ4QXJyYXksXG5cdDUxMjI6IEludDE2QXJyYXksXG5cdDUxMjM6IFVpbnQxNkFycmF5LFxuXHQ1MTI1OiBVaW50MzJBcnJheSxcblx0NTEyNjogRmxvYXQzMkFycmF5XG59O1xuXG5jb25zdCBTSVpFX01BUCA9IHtcblx0U0NBTEFSOiAxLFxuXHRWRUMyOiAyLFxuXHRWRUMzOiAzLFxuXHRWRUM0OiA0LFxuXHRNQVQyOiA0LFxuXHRNQVQzOiA5LFxuXHRNQVQ0OiAxNlxufTtcblxuY29uc3Qgc2VtYW50aWNBdHRyaWJ1dGVNYXAgPSB7XG5cdE5PUk1BTDogJ2FOb3JtYWwnLFxuXHRQT1NJVElPTjogJ2FWZXJ0ZXhQb3NpdGlvbicsXG5cdC8vICdUQU5HRU5UJzogJ2FUYW5nZW50Jyxcblx0VEVYQ09PUkRfMDogJ2FUZXh0dXJlQ29vcmQnLFxuXHQvLyBURVhDT09SRF8xOiAnYVRleHR1cmVDb29yZDEnLFxuXHRXRUlHSFRTXzA6ICdhV2VpZ2h0Jyxcblx0Sk9JTlRTXzA6ICdhSm9pbnQnLFxuXHRDT0xPUjogJ2FDb2xvcidcbn07XG5cbmxldCBiYXNlO1xuXG5jb25zdCBsb2FkID0gKG1Tb3VyY2UpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0aWYoKHR5cGVvZiBtU291cmNlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRiYXNlID0gbVNvdXJjZS5zdWJzdHJpbmcoMCwgbVNvdXJjZS5sYXN0SW5kZXhPZignLycpKzEpO1xuXHR9IGVsc2Uge1xuXHRcdGJhc2UgPSAnJztcblx0fVxuXG5cdF9sb2FkR2x0ZihtU291cmNlKVxuXHRcdC50aGVuKF9sb2FkQmluKVxuXHRcdC50aGVuKF9sb2FkVGV4dHVyZXMpXG5cdFx0LnRoZW4oX2dldEJ1ZmZlclZpZXdEYXRhKVxuXHRcdC50aGVuKF9wYXJzZU1hdGVyaWFscylcblx0XHQudGhlbihfcGFyc2VNZXNoKVxuXHRcdC50aGVuKF9wYXJzZU5vZGVzKVxuXHRcdC50aGVuKChnbHRmSW5mbyk9Pntcblx0XHRcdHJlc29sdmUoZ2x0ZkluZm8pO1xuXHRcdH0pXG5cdFx0LmNhdGNoKGUgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coJ0Vycm9yOicsIGUpO1xuXHRcdH0pO1xufSk7XG5cblxuY29uc3QgX3BhcnNlTm9kZXMgPSAoZ2x0ZikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7IG5vZGVzLCBzY2VuZXMgfSA9IGdsdGY7XG5cblx0Y29uc3QgZ2V0VHJlZSA9IChub2RlSW5kZXgpID0+IHtcblx0XHRjb25zdCBub2RlID0gbm9kZXNbbm9kZUluZGV4XTtcblx0XHRjb25zdCBvYmozRCA9IG5vZGUubWVzaCA9PT0gdW5kZWZpbmVkID8gbmV3IE9iamVjdDNEKCkgOiBnbHRmLm91dHB1dC5tZXNoZXNbbm9kZS5tZXNoXTtcblxuXG5cdFx0aWYobm9kZS5zY2FsZSkge1xuXHRcdFx0b2JqM0Quc2NhbGVYID0gbm9kZS5zY2FsZVswXTtcblx0XHRcdG9iajNELnNjYWxlWSA9IG5vZGUuc2NhbGVbMV07XG5cdFx0XHRvYmozRC5zY2FsZVogPSBub2RlLnNjYWxlWzJdO1xuXHRcdH1cblxuXHRcdGlmKG5vZGUucm90YXRpb24pIHtcblx0XHRcdG9iajNELnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24obm9kZS5yb3RhdGlvbik7XG5cdFx0fVxuXG5cdFx0aWYobm9kZS50cmFuc2xhdGlvbikge1xuXHRcdFx0b2JqM0QueCA9IG5vZGUudHJhbnNsYXRpb25bMF07XG5cdFx0XHRvYmozRC55ID0gbm9kZS50cmFuc2xhdGlvblsxXTtcblx0XHRcdG9iajNELnogPSBub2RlLnRyYW5zbGF0aW9uWzJdO1xuXHRcdH1cblxuXHRcdGlmKG5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGNvbnN0IF9jaGlsZCA9IGdldFRyZWUoY2hpbGQpO1xuXHRcdFx0XHRvYmozRC5hZGRDaGlsZChfY2hpbGQpO1xuXHRcdFx0fSk7XHRcblx0XHR9XG5cdFx0XG5cblx0XHRyZXR1cm4gb2JqM0Q7XG5cdH07XG5cblx0Z2x0Zi5vdXRwdXQuc2NlbmVzID0gc2NlbmVzLm1hcChzY2VuZSA9PiB7XG5cdFx0Y29uc3QgY29udGFpbmVyID0gbmV3IE9iamVjdDNEKCk7XG5cdFx0c2NlbmUubm9kZXMuZm9yRWFjaChub2RlSW5kZXggPT4ge1xuXHRcdFx0Y29uc3QgY2hpbGRUcmVlID0gZ2V0VHJlZShub2RlSW5kZXgpO1xuXHRcdFx0Y29udGFpbmVyLmFkZENoaWxkKGNoaWxkVHJlZSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9KTtcblxuXHRyZXNvbHZlKGdsdGYpO1xufSk7XG5cblxuY29uc3QgX3BhcnNlTWVzaCA9IChnbHRmKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHsgbWVzaGVzIH0gPSBnbHRmO1xuXHRcblxuXHRtZXNoZXMuZm9yRWFjaCggbWVzaCA9PiB7XG5cdFx0Y29uc3QgeyBwcmltaXRpdmVzIH0gPSBtZXNoO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlJbmZvID0ge307XG5cblx0XHRwcmltaXRpdmVzLmZvckVhY2goIHByaW1pdGl2ZUluZm8gPT4ge1xuXHRcdFx0Y29uc3Qgc2VtYW50aWNzID0gT2JqZWN0LmtleXMocHJpbWl0aXZlSW5mby5hdHRyaWJ1dGVzKTtcblx0XHRcdGxldCBkZWZpbmVzID0ge307XG5cblx0XHRcdHNlbWFudGljcy5mb3JFYWNoKCBzZW1hbnRpYyA9PiB7XG5cdFx0XHRcdGNvbnN0IGFjY2Vzc29ySWR4ID0gcHJpbWl0aXZlSW5mby5hdHRyaWJ1dGVzW3NlbWFudGljXTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlSW5mbyA9IGdsdGYuYWNjZXNzb3JzW2FjY2Vzc29ySWR4XTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlTmFtZSA9IHNlbWFudGljQXR0cmlidXRlTWFwW3NlbWFudGljXTtcblx0XHRcdFx0aWYoIWF0dHJpYnV0ZU5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoc2VtYW50aWMgPT09ICdOT1JNQUwnKSB7XG5cdFx0XHRcdFx0ZGVmaW5lcy5IQVNfTk9STUFMUyA9IDE7XG5cdFx0XHRcdH0gXG5cdFx0XHRcdGlmKHNlbWFudGljLmluZGV4T2YoJ1RFWENPT1JEJykgPiAtMSkge1xuXHRcdFx0XHRcdGRlZmluZXMuSEFTX1VWID0gMTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Y29uc3Qgc2l6ZSA9IFNJWkVfTUFQW2F0dHJpYnV0ZUluZm8udHlwZV07XG5cdFx0XHRcdGxldCBhdHRyaWJ1dGVBcnJheSA9IF9nZXRBY2Nlc3NvckRhdGEoZ2x0ZiwgYWNjZXNzb3JJZHgpO1xuXHRcdFx0XHRpZiAoYXR0cmlidXRlQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhdHRyaWJ1dGVBcnJheSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihzZW1hbnRpYyA9PT0gJ1RFWENPT1JEXzEnKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coc2l6ZSwgYXR0cmlidXRlQXJyYXkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnlJbmZvW2F0dHJpYnV0ZU5hbWVdID0ge1xuXHRcdFx0XHRcdHZhbHVlOmF0dHJpYnV0ZUFycmF5LFxuXHRcdFx0XHRcdHNpemUsXG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdhdHRyaWJ1dGUnLCBhdHRyaWJ1dGVOYW1lLCBnZW9tZXRyeVthdHRyaWJ1dGVOYW1lXSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly9cdHBhcnNlIGluZGV4XG5cdFx0XHRpZiAocHJpbWl0aXZlSW5mby5pbmRpY2VzICE9IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkgPSBfZ2V0QWNjZXNzb3JEYXRhKGdsdGYsIHByaW1pdGl2ZUluZm8uaW5kaWNlcywgdHJ1ZSk7XG5cdFx0XHRcdGdlb21ldHJ5SW5mby5pbmRpY2VzID0ge1xuXHRcdFx0XHRcdHZhbHVlOmF0dHJpYnV0ZUFycmF5LFxuXHRcdFx0XHRcdHNpemU6MVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xuXG5cdFx0XHRmb3IoY29uc3QgcyBpbiBnZW9tZXRyeUluZm8pIHtcblx0XHRcdFx0Y29uc3QgZGF0YSA9IGdlb21ldHJ5SW5mb1tzXTtcblx0XHRcdFx0aWYocyAhPT0gJ2luZGljZXMnKSB7XG5cdFx0XHRcdFx0Z2VvbWV0cnkuYnVmZmVyRmxhdHRlbkRhdGEoZGF0YS52YWx1ZSwgcywgZGF0YS5zaXplKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRnZW9tZXRyeS5idWZmZXJJbmRleChkYXRhLnZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtYXRlcmlhbEluZm8gPSBnbHRmLm91dHB1dC5tYXRlcmlhbEluZm9bcHJpbWl0aXZlSW5mby5tYXRlcmlhbF07XG5cdFx0XHRkZWZpbmVzID0gb2JqZWN0QXNzaWduKGRlZmluZXMsIG1hdGVyaWFsSW5mby5kZWZpbmVzKTtcblx0XHRcdFxuXG5cdFx0XHRjb25zdCB7XG5cdFx0XHRcdGVtaXNzaXZlRmFjb3RyLFxuXHRcdFx0XHRub3JtYWxUZXh0dXJlLFxuXHRcdFx0XHRvY2NsdXNpb25UZXh0dXJlLFxuXHRcdFx0XHRwYnJNZXRhbGxpY1JvdWdobmVzcyxcblx0XHRcdH0gPSBtYXRlcmlhbEluZm87XG5cblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0YmFzZUNvbG9yVGV4dHVyZSxcblx0XHRcdFx0bWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlXG5cdFx0XHR9ID0gcGJyTWV0YWxsaWNSb3VnaG5lc3M7XG5cblx0XHRcdGNvbnN0IHVuaWZvcm1zID0ge1xuXHRcdFx0XHR1RW1pc3NpdmVGYWN0b3I6ZW1pc3NpdmVGYWNvdHIgfHwgWzAsIDAsIDBdLFxuXHRcdFx0XHR1QmFzZUNvbG9yOnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciB8fCBbMSwgMSwgMSwgMV0sXG5cdFx0XHRcdHVSb3VnaG5lc3M6cGJyTWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yIHx8IDEsXG5cdFx0XHRcdHVNZXRhbGxpYzpwYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciB8fCAxLFxuXHRcdFx0XHR1U2NhbGVEaWZmQmFzZU1SOlswLCAwLCAwLCAwXSxcblx0XHRcdFx0dVNjYWxlRkdEU3BlYzpbMCwgMCwgMCwgMF0sXG5cdFx0XHRcdHVTY2FsZUlCTEFtYmllbnQ6WzEsIDEsIDEsIDFdLFxuXHRcdFx0XHR1TGlnaHREaXJlY3Rpb246WzEsIDEsIDFdLFxuXHRcdFx0XHR1TGlnaHRDb2xvcjpbMSwgMSwgMV0sXG5cdFx0XHRcdHVHYW1tYToxXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoYmFzZUNvbG9yVGV4dHVyZSkge1xuXHRcdFx0XHR1bmlmb3Jtcy51Q29sb3JNYXAgPSBiYXNlQ29sb3JUZXh0dXJlLmdsVGV4dHVyZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkge1xuXHRcdFx0XHR1bmlmb3Jtcy51TWV0YWxsaWNSb3VnaG5lc3NNYXAgPSBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUuZ2xUZXh0dXJlO1x0XG5cdFx0XHR9XG5cblx0XHRcdGlmIChub3JtYWxUZXh0dXJlKSB7XG5cdFx0XHRcdHVuaWZvcm1zLnVOb3JtYWxTY2FsZSA9IG5vcm1hbFRleHR1cmUuc2NhbGUgfHwgMTtcblx0XHRcdFx0dW5pZm9ybXMudU5vcm1hbE1hcCA9IG5vcm1hbFRleHR1cmUuZ2xUZXh0dXJlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2NjbHVzaW9uVGV4dHVyZSkge1xuXHRcdFx0XHR1bmlmb3Jtcy51QW9NYXAgPSBvY2NsdXNpb25UZXh0dXJlLmdsVGV4dHVyZTtcblx0XHRcdFx0dW5pZm9ybXMudU9jY2x1c2lvblN0cmVuZ3RoID0gb2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCB8fCAxO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChTaGFkZXJMaWJzLmdsdGZWZXJ0LCBTaGFkZXJMaWJzLmdsdGZGcmFnLCB1bmlmb3JtcywgZGVmaW5lcyk7XG5cdFx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdGdsdGYub3V0cHV0Lm1lc2hlcy5wdXNoKG1lc2gpO1xuXHRcdH0pO1xuXHR9KTtcblxuXHRyZXNvbHZlKGdsdGYpO1xufSk7XG5cbmNvbnN0IF9nZXRCdWZmZXJWaWV3RGF0YSA9IChnbHRmSW5mbykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7IGJ1ZmZlclZpZXdzLCBidWZmZXJzIH0gPSBnbHRmSW5mbztcblxuXHRidWZmZXJWaWV3cy5mb3JFYWNoKChidWZmZXJWaWV3SW5mbywgaSkgPT4ge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbYnVmZmVyVmlld0luZm8uYnVmZmVyXS5kYXRhO1xuXHRcdGJ1ZmZlclZpZXdJbmZvLmRhdGEgPSBidWZmZXIuc2xpY2UoYnVmZmVyVmlld0luZm8uYnl0ZU9mZnNldCB8fCAwLCAoYnVmZmVyVmlld0luZm8uYnl0ZU9mZnNldCB8fCAwKSArIChidWZmZXJWaWV3SW5mby5ieXRlTGVuZ3RoIHx8IDApKTtcblx0fSk7XG5cdHJlc29sdmUoZ2x0ZkluZm8pO1xufSk7XG5cbmNvbnN0IF9sb2FkR2x0ZiA9IChtU291cmNlKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGlmKCh0eXBlb2YgbVNvdXJjZSkgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmVzb2x2ZShtU291cmNlKTtcblx0fSBlbHNlIHtcblx0XHR4aHIobVNvdXJjZSkudGhlbigobyk9Pntcblx0XHRcdGNvbnN0IGdsdGZJbmZvID0gSlNPTi5wYXJzZShvKTtcblx0XHRcdGdsdGZJbmZvLm91dHB1dCA9IHtcblx0XHRcdFx0bWVzaGVzOltdLFxuXHRcdFx0XHRzY2VuZXM6W10sXG5cdFx0XHRcdHRleHR1cmVzOltdLFxuXHRcdFx0XHRtYXRlcmlhbDpbXSxcblx0XHRcdFx0bWF0ZXJpYWxJbmZvOltdXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXNvbHZlKGdsdGZJbmZvKTtcblx0XHR9LCAoZSk9PiB7XG5cdFx0XHRyZWplY3QoZSk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmNvbnN0IF9sb2FkQmluID0gKGdsdGZJbmZvKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFxuXHRpZihnbHRmSW5mby5idWZmZXJzKSB7XG5cdFx0bGV0IGNvdW50ID0gZ2x0ZkluZm8uYnVmZmVycy5sZW5ndGg7XG5cblx0XHRnbHRmSW5mby5idWZmZXJzLmZvckVhY2goYnVmZmVyID0+IHtcblxuXHRcdFx0Y29uc3QgdXJsQmluID0gYCR7YmFzZX0ke2dsdGZJbmZvLmJ1ZmZlcnNbMF0udXJpfWA7XG5cdFx0XHR4aHIodXJsQmluLCB0cnVlKS50aGVuKChvKT0+IHtcblx0XHRcdFx0YnVmZmVyLmRhdGEgPSBvO1xuXG5cdFx0XHRcdGNvdW50IC0tO1xuXHRcdFx0XHRpZihjb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc29sdmUoZ2x0ZkluZm8pO1x0XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9LCBlID0+IHtcblx0XHRcdFx0cmVqZWN0KGUpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0XG5cdH0gZWxzZSB7XG5cdFx0cmVzb2x2ZShnbHRmSW5mbyk7XHRcblx0fVxuXHRcbn0pO1xuXG5jb25zdCBfbG9hZFRleHR1cmVzID0gKGdsdGZJbmZvKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHsgdGV4dHVyZXMsIGltYWdlcywgc2FtcGxlcnMgfSA9IGdsdGZJbmZvO1xuXHRpZighaW1hZ2VzKSB7XG5cdFx0cmVzb2x2ZShnbHRmSW5mbyk7XG5cdH1cblxuXHRjb25zdCBpbWFnZXNUb0xvYWQgPSBpbWFnZXMubWFwKGltZyA9PiBgJHtiYXNlfSR7aW1nLnVyaX1gKTtcblxuXHRsb2FkSW1hZ2VzKGltYWdlc1RvTG9hZCkudGhlbigobykgPT4ge1xuXHRcdGdsdGZJbmZvLm91dHB1dC50ZXh0dXJlcyA9IG8ubWFwKChpbWcsIGkpID0+IHtcblx0XHRcdGNvbnN0IHNldHRpbmdzID0gb2JqZWN0QXNzaWduKHt9LCBzYW1wbGVycyA/IHNhbXBsZXJzW3RleHR1cmVzW2ldLnNhbXBsZXJdIDoge30pO1xuXHRcdFx0cmV0dXJuIG5ldyBHTFRleHR1cmUoaW1nLCBzZXR0aW5ncyk7XG5cdFx0fSk7XG5cdFx0cmVzb2x2ZShnbHRmSW5mbyk7XG5cdH0sIChlKT0+IHtcblx0XHRyZWplY3QoZSk7XG5cdH0pO1xufSk7XG5cbmNvbnN0IF9wYXJzZU1hdGVyaWFscyA9IChnbHRmSW5mbykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7IG1hdGVyaWFscyB9ID0gZ2x0ZkluZm87XG5cdGNvbnN0IHsgdGV4dHVyZXMgfSA9IGdsdGZJbmZvLm91dHB1dDtcblx0XG5cblx0Z2x0ZkluZm8ub3V0cHV0Lm1hdGVyaWFsSW5mbyA9IG1hdGVyaWFscy5tYXAobWF0ZXJpYWwgPT4ge1xuXHRcdG1hdGVyaWFsLmRlZmluZXMgPSB7XG5cdFx0XHRVU0VfSUJMOjFcblx0XHR9O1xuXG5cdFx0aWYobWF0ZXJpYWwubm9ybWFsVGV4dHVyZSkge1xuXHRcdFx0bWF0ZXJpYWwuZGVmaW5lcy5IQVNfTk9STUFMTUFQID0gMTtcblx0XHRcdG1hdGVyaWFsLm5vcm1hbFRleHR1cmUuZ2xUZXh0dXJlID0gdGV4dHVyZXNbbWF0ZXJpYWwubm9ybWFsVGV4dHVyZS5pbmRleF07XG5cdFx0fVxuXG5cdFx0aWYobWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZSkge1xuXHRcdFx0bWF0ZXJpYWwuZGVmaW5lcy5IQVNfT0NDTFVTSU9OTUFQID0gMTtcblx0XHRcdG1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUuZ2xUZXh0dXJlID0gdGV4dHVyZXNbbWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZS5pbmRleF07XHRcblx0XHR9XG5cblxuXHRcdC8vIGlmKG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzKSB7XG5cdFx0aWYobWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSkge1xuXHRcdFx0bWF0ZXJpYWwuZGVmaW5lcy5IQVNfQkFTRUNPTE9STUFQID0gMTtcblx0XHRcdG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUuZ2xUZXh0dXJlID0gdGV4dHVyZXNbbWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZS5pbmRleF07XHRcblx0XHR9XG5cblx0XHRpZihtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpIHtcblx0XHRcdG1hdGVyaWFsLmRlZmluZXMuSEFTX01FVEFMUk9VR0hORVNTTUFQID0gMTtcblx0XHRcdG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZS5nbFRleHR1cmUgPSB0ZXh0dXJlc1ttYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUuaW5kZXhdO1x0XG5cdFx0fVxuXG5cdFx0Ly8gfVxuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXHR9KTtcblxuXG5cdHJlc29sdmUoZ2x0ZkluZm8pO1xufSk7XG5cbmNvbnN0IHBhcnNlID0gKG1HbHRmSW5mbywgbUJpbikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRyZXNvbHZlKG1Tb3VyY2UpO1xufSk7XG5cblxuY29uc3QgX2dldEFjY2Vzc29yRGF0YSA9IChnbHRmLCBhY2Nlc3NvcklkeCwgaXNJbmRpY2VzID0gZmFsc2UpID0+IHtcblx0Y29uc3QgYWNjZXNzb3JJbmZvID0gZ2x0Zi5hY2Nlc3NvcnNbYWNjZXNzb3JJZHhdO1xuXHRjb25zdCBidWZmZXIgPSBnbHRmLmJ1ZmZlclZpZXdzW2FjY2Vzc29ySW5mby5idWZmZXJWaWV3XS5kYXRhO1xuXHRjb25zdCBieXRlT2Zmc2V0ID0gYWNjZXNzb3JJbmZvLmJ5dGVPZmZzZXQgfHwgMDtcblx0Y29uc3QgQXJyYXlDdG9yID0gQVJSQVlfQ1RPUl9NQVBbYWNjZXNzb3JJbmZvLmNvbXBvbmVudFR5cGVdIHx8IEZsb2F0MzJBcnJheTtcblx0bGV0IHNpemUgPSBTSVpFX01BUFthY2Nlc3NvckluZm8udHlwZV07XG5cdGlmIChzaXplID09IG51bGwgJiYgaXNJbmRpY2VzKSB7XG5cdFx0c2l6ZSA9IDE7XG5cdH1cblx0bGV0IGFyciA9IG5ldyBBcnJheUN0b3IoYnVmZmVyLCBieXRlT2Zmc2V0LCBzaXplICogYWNjZXNzb3JJbmZvLmNvdW50KTtcblx0Y29uc3QgcXVhbnRpemVFeHRlbnNpb24gPSBhY2Nlc3NvckluZm8uZXh0ZW5zaW9ucyAmJiBhY2Nlc3NvckluZm8uZXh0ZW5zaW9uc1snV0VCM0RfcXVhbnRpemVkX2F0dHJpYnV0ZXMnXTtcblx0aWYgKHF1YW50aXplRXh0ZW5zaW9uKSB7XG5cdFx0Y29uc3QgZGVjb2RlZEFyciA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIGFjY2Vzc29ySW5mby5jb3VudCk7XG5cdFx0Y29uc3QgZGVjb2RlTWF0cml4ID0gcXVhbnRpemVFeHRlbnNpb24uZGVjb2RlTWF0cml4O1xuXHRcdGNvbnN0IGRlY29kZU9mZnNldCA9IG5ldyBBcnJheShzaXplKTtcblx0XHRjb25zdCBkZWNvZGVTY2FsZSA9IG5ldyBBcnJheShzaXplKTtcblx0XHRmb3IgKGxldCBrID0gMDsgayA8IHNpemU7IGsrKykge1xuXHRcdFx0ZGVjb2RlT2Zmc2V0W2tdID0gZGVjb2RlTWF0cml4W3NpemUgKiAoc2l6ZSArIDEpICsga107XG5cdFx0XHRkZWNvZGVTY2FsZVtrXSA9IGRlY29kZU1hdHJpeFtrICogKHNpemUgKyAxKSArIGtdO1xuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFjY2Vzc29ySW5mby5jb3VudDsgaSsrKSB7XG5cdFx0XHRmb3IgKGxldCBrID0gMDsgayA8IHNpemU7IGsrKykge1xuXHRcdFx0XHRkZWNvZGVkQXJyW2kgKiBzaXplICsga10gPSBhcnJbaSAqIHNpemUgKyBrXSAqIGRlY29kZVNjYWxlW2tdICsgZGVjb2RlT2Zmc2V0W2tdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFyciA9IGRlY29kZWRBcnI7XG5cdH1cblxuXHQvLyBjb25zb2xlLmxvZyh7YnVmZmVyLCBieXRlT2Zmc2V0LCBBcnJheUN0b3IsIHNpemUsIGFycn0pO1xuXG5cdHJldHVybiBhcnI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGxvYWQsXG5cdHBhcnNlXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvR2x0ZkxvYWRlci5qcyIsIi8vIHhoci5qc1xuXG5jb25zdCBsb2FkID0gKG1QYXRoLCBpc0FycmF5QnVmZmVyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRyZXEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChlKSA9PiB7XG5cdFx0cmVzb2x2ZShyZXEucmVzcG9uc2UpO1xuXHR9KTtcblxuXHRyZXEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZSkgPT4ge1xuXHRcdHJlamVjdChlKTtcblx0fSk7XG5cblx0aWYoaXNBcnJheUJ1ZmZlcikge1xuXHRcdHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHR9XG5cblx0cmVxLm9wZW4oJ0dFVCcsIG1QYXRoKTtcblx0cmVxLnNlbmQoKTtcblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGxvYWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy94aHIuanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEVmZmVjdENvbXBvc2VyLmpzXG5cbmltcG9ydCBQYXNzIGZyb20gJy4vUGFzcyc7XG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEZyYW1lQnVmZmVyIGZyb20gJy4uL0ZyYW1lQnVmZmVyJztcblxuY2xhc3MgRWZmZWN0Q29tcG9zZXIge1xuXHRjb25zdHJ1Y3RvcihtV2lkdGgsIG1IZWlnaHQsIG1QYXJtYXMgPSB7fSkge1xuXHRcdHRoaXMuX3dpZHRoID0gbVdpZHRoIHx8IEdMLndpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IG1IZWlnaHQgfHwgR0wuaGVpZ2h0O1xuXG5cdFx0dGhpcy5fcGFyYW1zID0ge307XG5cdFx0dGhpcy5zZXRTaXplKG1XaWR0aCwgbUhlaWdodCk7XG5cdFx0dGhpcy5fZ2VvbWV0cnkgPSBHZW9tLmJpZ1RyaWFuZ2xlKCk7XG5cdFx0dGhpcy5fcGFzc2VzID0gW107XG5cdFx0dGhpcy5fcmV0dXJuVGV4dHVyZTtcblx0fVxuXG5cblx0YWRkUGFzcyhwYXNzKSB7XG5cdFx0aWYocGFzcy5wYXNzZXMpIHtcblx0XHRcdHRoaXMuYWRkUGFzcyhwYXNzLnBhc3Nlcyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChwYXNzLmxlbmd0aCkge1xuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IHBhc3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcGFzc2VzLnB1c2gocGFzc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Bhc3Nlcy5wdXNoKHBhc3MpO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcihtU291cmNlKSB7XG5cdFx0bGV0IHNvdXJjZSA9IG1Tb3VyY2U7XG5cdFx0bGV0IGZib1RhcmdldDtcblxuXHRcdHRoaXMuX3Bhc3Nlcy5mb3JFYWNoKChwYXNzKSA9PiB7XG5cblx0XHRcdC8vXHRnZXQgdGFyZ2V0XG5cdFx0XHRpZihwYXNzLmhhc0Zibykge1xuXHRcdFx0XHRmYm9UYXJnZXQgPSBwYXNzLmZibztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZib1RhcmdldCA9IHRoaXMuX2Zib1RhcmdldDtcblx0XHRcdH1cblxuXHRcdFx0Ly9cdHJlbmRlclxuXHRcdFx0ZmJvVGFyZ2V0LmJpbmQoKTtcblx0XHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXHRcdFx0cGFzcy5yZW5kZXIoc291cmNlKTtcblx0XHRcdEdMLmRyYXcodGhpcy5fZ2VvbWV0cnkpO1xuXHRcdFx0ZmJvVGFyZ2V0LnVuYmluZCgpO1xuXG5cdFx0XHQvL1x0cmVzZXQgc291cmNlXG5cdFx0XHRpZihwYXNzLmhhc0Zibykge1xuXHRcdFx0XHRzb3VyY2UgPSBwYXNzLmZiby5nZXRUZXh0dXJlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zd2FwKCk7XHRcblx0XHRcdFx0c291cmNlID0gdGhpcy5fZmJvQ3VycmVudC5nZXRUZXh0dXJlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9yZXR1cm5UZXh0dXJlID0gc291cmNlO1xuXG5cdFx0cmV0dXJuIHNvdXJjZTtcblx0fVxuXG5cblx0X3N3YXAoKSB7XG5cdFx0Y29uc3QgdG1wID0gdGhpcy5fZmJvQ3VycmVudDtcblx0XHR0aGlzLl9mYm9DdXJyZW50ID0gdGhpcy5fZmJvVGFyZ2V0O1xuXHRcdHRoaXMuX2Zib1RhcmdldCA9IHRtcDtcblxuXHRcdHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9mYm9DdXJyZW50O1xuXHRcdHRoaXMuX3RhcmdldCA9IHRoaXMuX2Zib1RhcmdldDtcblx0fVxuXG5cdHNldFNpemUobVdpZHRoLCBtSGVpZ2h0KSB7XG5cdFx0dGhpcy5fd2lkdGggPSBtV2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gbUhlaWdodDtcblx0XHR0aGlzLl9mYm9DdXJyZW50ID0gbmV3IEZyYW1lQnVmZmVyKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHRoaXMuX3BhcmFtcyk7XG5cdFx0dGhpcy5fZmJvVGFyZ2V0ID0gbmV3IEZyYW1lQnVmZmVyKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHRoaXMuX3BhcmFtcyk7XG5cdH1cblxuXHRnZXQgcGFzc2VzKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXNzZXM7XG5cdH1cblxuXHRnZXRUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZXR1cm5UZXh0dXJlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVmZmVjdENvbXBvc2VyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvRWZmZWN0Q29tcG9zZXIuanMiLCIvLyBQYXNzQmx1ci5qc1xuXG5pbXBvcnQgUGFzc1ZCbHVyIGZyb20gJy4vUGFzc1ZCbHVyJztcbmltcG9ydCBQYXNzSEJsdXIgZnJvbSAnLi9QYXNzSEJsdXInO1xuaW1wb3J0IFBhc3NNYWNybyBmcm9tICcuL1Bhc3NNYWNybyc7XG5cbmNsYXNzIFBhc3NCbHVyIGV4dGVuZHMgUGFzc01hY3JvIHtcblx0Y29uc3RydWN0b3IobVF1YWxpdHkgPSA5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpIHtcblx0XHRzdXBlcigpO1xuXHRcdGNvbnN0IHZCbHVyID0gbmV3IFBhc3NWQmx1cihtUXVhbGl0eSwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKTtcblx0XHRjb25zdCBoQmx1ciA9IG5ldyBQYXNzSEJsdXIobVF1YWxpdHksIG1XaWR0aCwgbUhlaWdodCwgbVBhcmFtcyk7XG5cblx0XHR0aGlzLmFkZFBhc3ModkJsdXIpO1xuXHRcdHRoaXMuYWRkUGFzcyhoQmx1cik7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFzc0JsdXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NCbHVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJsdXI1LmZyYWdcXG4vLyBzb3VyY2UgIDogaHR0cHM6Ly9naXRodWIuY29tL0phbTMvZ2xzbC1mYXN0LWdhdXNzaWFuLWJsdXJcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJMVVJfNVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVEaXJlY3Rpb247XFxudW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xcblxcbnZlYzQgYmx1cjUoc2FtcGxlcjJEIGltYWdlLCB2ZWMyIHV2LCB2ZWMyIHJlc29sdXRpb24sIHZlYzIgZGlyZWN0aW9uKSB7XFxuXFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXHR2ZWMyIG9mZjEgPSB2ZWMyKDEuMzMzMzMzMzMzMzMzMzMzMykgKiBkaXJlY3Rpb247XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1dikgKiAwLjI5NDExNzY0NzA1ODgyMzU0O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzUyOTQxMTc2NDcwNTg4MjY7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zNTI5NDExNzY0NzA1ODgyNjtcXG5cXHRyZXR1cm4gY29sb3I7IFxcbn1cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSBibHVyNSh0ZXh0dXJlLCB2VGV4dHVyZUNvb3JkLCB1UmVzb2x1dGlvbiwgdURpcmVjdGlvbik7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2JsdXI1LmZyYWdcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJsdXI5LmZyYWdcXG4vLyBzb3VyY2UgIDogaHR0cHM6Ly9naXRodWIuY29tL0phbTMvZ2xzbC1mYXN0LWdhdXNzaWFuLWJsdXJcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJMVVJfOVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVEaXJlY3Rpb247XFxudW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xcblxcbnZlYzQgYmx1cjkoc2FtcGxlcjJEIGltYWdlLCB2ZWMyIHV2LCB2ZWMyIHJlc29sdXRpb24sIHZlYzIgZGlyZWN0aW9uKSB7XFxuXFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXHR2ZWMyIG9mZjEgPSB2ZWMyKDEuMzg0NjE1Mzg0NikgKiBkaXJlY3Rpb247XFxuXFx0dmVjMiBvZmYyID0gdmVjMigzLjIzMDc2OTIzMDgpICogZGlyZWN0aW9uO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYpICogMC4yMjcwMjcwMjcwO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzE2MjE2MjE2MjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjMxNjIxNjIxNjI7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wNzAyNzAyNzAzO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDcwMjcwMjcwMztcXG5cXHRyZXR1cm4gY29sb3I7XFxufVxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGJsdXI5KHRleHR1cmUsIHZUZXh0dXJlQ29vcmQsIHVSZXNvbHV0aW9uLCB1RGlyZWN0aW9uKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYmx1cjkuZnJhZ1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmx1cjEzLmZyYWdcXG4vLyBzb3VyY2UgIDogaHR0cHM6Ly9naXRodWIuY29tL0phbTMvZ2xzbC1mYXN0LWdhdXNzaWFuLWJsdXJcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJMVVJfMTNcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1RGlyZWN0aW9uO1xcbnVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjtcXG5cXG52ZWM0IGJsdXIxMyhzYW1wbGVyMkQgaW1hZ2UsIHZlYzIgdXYsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiBkaXJlY3Rpb24pIHtcXG5cXHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcdHZlYzIgb2ZmMSA9IHZlYzIoMS40MTE3NjQ3MDU4ODIzNTMpICogZGlyZWN0aW9uO1xcblxcdHZlYzIgb2ZmMiA9IHZlYzIoMy4yOTQxMTc2NDcwNTg4MjM0KSAqIGRpcmVjdGlvbjtcXG5cXHR2ZWMyIG9mZjMgPSB2ZWMyKDUuMTc2NDcwNTg4MjM1Mjk0KSAqIGRpcmVjdGlvbjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2KSAqIDAuMTk2NDgyNTUwMTUxMTQwNDtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjI5NjkwNjk2NDY3MjgzNDQ7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4yOTY5MDY5NjQ2NzI4MzQ0O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDk0NDcwMzk3ODUwNDQ3MzI7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wOTQ0NzAzOTc4NTA0NDczMjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjMgLyByZXNvbHV0aW9uKSkgKiAwLjAxMDM4MTM2MjQwMTE0ODA1NztcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjMgLyByZXNvbHV0aW9uKSkgKiAwLjAxMDM4MTM2MjQwMTE0ODA1NztcXG5cXHRyZXR1cm4gY29sb3I7XFxufVxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGJsdXIxMyh0ZXh0dXJlLCB2VGV4dHVyZUNvb3JkLCB1UmVzb2x1dGlvbiwgdURpcmVjdGlvbik7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2JsdXIxMy5mcmFnXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFBhc3NGeGFhLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IFBhc3MgZnJvbSAnLi9QYXNzJztcbmltcG9ydCBmc0Z4YWEgZnJvbSAnLi4vZ2xzbC9meGFhLmZyYWcnO1xuXG5jbGFzcyBQYXNzRnhhYSBleHRlbmRzIFBhc3Mge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihmc0Z4YWEpO1xuXHRcdHRoaXMudW5pZm9ybSgndVJlc29sdXRpb24nLCBbMS9HTC53aWR0aCwgMS9HTC5oZWlnaHRdKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzRnhhYTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NGeGFhLmpzIiwiLy8gQmF0Y2hDb3B5LmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9iaWdUcmlhbmdsZS52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2dsc2wvY29weS5mcmFnJyk7XG5cbmNsYXNzIEJhdGNoQ29weSBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBtZXNoID0gR2VvbS5iaWdUcmlhbmdsZSgpO1xuXHRcdGNvbnN0IHNoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1xuXHRcdHN1cGVyKG1lc2gsIHNoYWRlcik7XG5cblx0XHRzaGFkZXIuYmluZCgpO1xuXHRcdHNoYWRlci51bmlmb3JtKCd0ZXh0dXJlJywgJ3VuaWZvcm0xaScsIDApO1xuXHR9XG5cblxuXHRkcmF3KHRleHR1cmUpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGV4dHVyZS5iaW5kKDApO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoQ29weTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoQ29weS5qcyIsIi8vIEJhdGNoQXhpcy5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuLi9HZW9tZXRyeSc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9nbHNsL2F4aXMudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9nbHNsL2F4aXMuZnJhZycpO1xuXG5cbmNsYXNzIEJhdGNoQXhpcyBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0XHRjb25zdCBjb2xvcnMgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzID0gWzAsIDEsIDIsIDMsIDQsIDVdO1xuXHRcdGNvbnN0IHIgPSA5OTk5O1xuXG5cdFx0cG9zaXRpb25zLnB1c2goWy1yLCAgMCwgIDBdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbciwgIDAsICAwXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsIC1yLCAgMF0pO1xuXHRcdHBvc2l0aW9ucy5wdXNoKFswLCAgciwgIDBdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgIDAsIC1yXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsICAwLCAgcl0pO1xuXG5cblx0XHRjb2xvcnMucHVzaChbMSwgMCwgMF0pO1xuXHRcdGNvbG9ycy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0Y29sb3JzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRjb2xvcnMucHVzaChbMCwgMSwgMF0pO1xuXHRcdGNvbG9ycy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0Y29sb3JzLnB1c2goWzAsIDAsIDFdKTtcblxuXHRcdGNvbnN0IG1lc2ggPSBuZXcgR2VvbWV0cnkoR0wuTElORVMpO1xuXHRcdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdFx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0XHRtZXNoLmJ1ZmZlckRhdGEoY29sb3JzLCAnYUNvbG9yJywgMyk7XG5cblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblxuXHRcdHN1cGVyKG1lc2gsIHNoYWRlcik7XG5cblx0fVxuXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBCYXRjaEF4aXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaEF4aXMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYXhpcy52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCQVNJQ19WRVJURVhcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzMgYUNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuICAgIHZDb2xvciA9IGFDb2xvcjtcXG4gICAgdk5vcm1hbCA9IGFOb3JtYWw7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2F4aXMudmVydFxuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYXhpcy5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBTSU1QTEVfVEVYVFVSRVxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMzIHZDb2xvcjtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdC8vIHZlYzMgY29sb3IgPSB2Tm9ybWFsO1xcblxcdHZlYzMgY29sb3IgPSB2Q29sb3IgKyB2Tm9ybWFsICogMC4wMDAxO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9heGlzLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQmF0Y2hCYWxsLmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9nZW5lcmFsLnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZ2xzbC9zaW1wbGVDb2xvci5mcmFnJyk7XG5cbmNsYXNzIEJhdGNoQmFsbCBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBnZW9tZXRyeSA9IEdlb20uc3BoZXJlKDEsIDI0KTtcblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblx0XHRzdXBlcihnZW9tZXRyeSwgc2hhZGVyKTtcblx0fVxuXG5cblx0ZHJhdyhwb3NpdGlvbiA9IFswLCAwLCAwXSwgc2NhbGUgPSBbMSwgMSwgMV0sIGNvbG9yID0gWzEsIDEsIDFdLCBvcGFjaXR5ID0gMSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdwb3NpdGlvbicsICd1bmlmb3JtM2Z2JywgcG9zaXRpb24pO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3NjYWxlJywgJ3VuaWZvcm0zZnYnLCBzY2FsZSk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgnY29sb3InLCAndW5pZm9ybTNmdicsIGNvbG9yKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdvcGFjaXR5JywgJ3VuaWZvcm0xZicsIG9wYWNpdHkpO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoQmFsbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoQmFsbC5qcyIsIi8vIEJhdGNoRG90c1BsYW5lLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4uL0dlb21ldHJ5JztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuXG5jb25zdCB2cyA9IHJlcXVpcmUoJy4uL2dsc2wvZG90c1BsYW5lLnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZ2xzbC9zaW1wbGVDb2xvci5mcmFnJyk7XG5cbmNsYXNzIEJhdGNoRG90c1BsYW5lIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgICA9IFtdO1xuXHRcdGxldCBpbmRleCAgICAgICA9IDA7XG5cdFx0Y29uc3Qgc2l6ZSAgICAgID0gMTAwO1xuXHRcdGxldCBpLCBqO1xuXG5cdFx0Zm9yKGkgPSAtc2l6ZTsgaSA8IHNpemU7IGkgKz0gMSkge1xuXHRcdFx0Zm9yKGogPSAtc2l6ZTsgaiA8IHNpemU7IGogKz0gMSkge1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbaSwgaiwgMF0pO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goaW5kZXgpO1xuXHRcdFx0XHRpbmRleCsrO1xuXG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFtpLCAwLCBqXSk7XG5cdFx0XHRcdGluZGljZXMucHVzaChpbmRleCk7XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnN0IGdlb21ldHJ5ICAgICA9IG5ldyBHZW9tZXRyeShHTC5QT0lOVFMpO1xuXHRcdGdlb21ldHJ5LmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRcdGdlb21ldHJ5LmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXHRcdFxuXHRcdGNvbnN0IHNoYWRlciAgID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cdFx0XG5cdFx0c3VwZXIoZ2VvbWV0cnksIHNoYWRlcik7XG5cdFx0XG5cdFx0dGhpcy5jb2xvciAgID0gWzEsIDEsIDFdO1xuXHRcdHRoaXMub3BhY2l0eSA9IDAuNTtcblx0fVxuXG5cblx0ZHJhdygpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgnY29sb3InLCAndW5pZm9ybTNmdicsIHRoaXMuY29sb3IpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ29wYWNpdHknLCAndW5pZm9ybTFmJywgdGhpcy5vcGFjaXR5KTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hEb3RzUGxhbmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaERvdHNQbGFuZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiYXNpYy52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBET1RTX1BMQU5FX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiArIGFOb3JtYWwgKiAwLjAwMDAwMSwgMS4wKTtcXG4gICAgZ2xfUG9pbnRTaXplID0gMS4wO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvZG90c1BsYW5lLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQmF0Y2hMaW5lLmpzXG5cblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi4vR2VvbWV0cnknO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9iYXNpYy52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2dsc2wvc2ltcGxlQ29sb3IuZnJhZycpO1xuXG5cblxuY2xhc3MgQmF0Y2hBeGlzIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbMCwgMV07XG5cdFx0Y29uc3QgY29vcmRzID0gW1swLCAwXSwgWzEsIDFdXTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgIDAsICAwXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsICAwLCAgMF0pO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoR0wuTElORVMpO1xuXHRcdGdlb21ldHJ5LmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRcdGdlb21ldHJ5LmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XG5cdFx0Z2VvbWV0cnkuYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblxuXHRcdHN1cGVyKGdlb21ldHJ5LCBzaGFkZXIpO1xuXHR9XG5cblxuXHRkcmF3KG1Qb3NpdGlvbkEsIG1Qb3NpdGlvbkIsIGNvbG9yID0gWzEsIDEsIDFdLCBvcGFjaXR5ID0gMS4wKSB7XG5cdFx0dGhpcy5fZ2VvbWV0cnkuYnVmZmVyVmVydGV4KFttUG9zaXRpb25BLCBtUG9zaXRpb25CXSk7XG5cblx0XHR0aGlzLl9zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuX3NoYWRlci51bmlmb3JtKCdjb2xvcicsICd2ZWMzJywgY29sb3IpO1xuXHRcdHRoaXMuX3NoYWRlci51bmlmb3JtKCdvcGFjaXR5JywgJ2Zsb2F0Jywgb3BhY2l0eSk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG5cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoQXhpcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZS5qcyIsIi8vIEJhdGNoU2t5Ym94LmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9za3lib3gudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9nbHNsL3NreWJveC5mcmFnJyk7XG5cblxuY2xhc3MgQmF0Y2hTa3lib3ggZXh0ZW5kcyBCYXRjaCB7XG5cblx0Y29uc3RydWN0b3Ioc2l6ZSA9IDIwKSB7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBHZW9tLnNreWJveChzaXplKTtcblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblxuXHRcdHN1cGVyKGdlb21ldHJ5LCBzaGFkZXIpO1xuXHR9XG5cblx0ZHJhdyh0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cblxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hTa3lib3g7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaFNreWJveC5qcyIsIi8vIEJhdGNoU2t5LmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9za3kudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9nbHNsL2NvcHkuZnJhZycpO1xuXG5cbmNsYXNzIEJhdGNoU2t5IGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKHNpemUgPSA1MCwgc2VnID0gMjQpIHtcblx0XHRjb25zdCBnZW9tZXRyeSA9IEdlb20uc3BoZXJlKHNpemUsIHNlZywgdHJ1ZSk7XG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cblx0XHRzdXBlcihnZW9tZXRyeSwgc2hhZGVyKTtcblx0fVxuXG5cdGRyYXcodGV4dHVyZSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0ZXh0dXJlLmJpbmQoMCk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoU2t5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3kuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gc2t5LnZlcnRcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdG1hdDQgbWF0VmlldyA9IHVWaWV3TWF0cml4O1xcblxcdG1hdFZpZXdbM11bMF0gPSAwLjA7XFxuXFx0bWF0Vmlld1szXVsxXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzJdID0gMC4wO1xcblxcdFxcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogbWF0VmlldyAqIHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdk5vcm1hbCA9IGFOb3JtYWw7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL3NreS52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBCYXRjaEZYQUEuanNcbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IEdlb20gZnJvbSAnLi4vR2VvbSc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9nbHNsL2JpZ1RyaWFuZ2xlLnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZ2xzbC9meGFhLmZyYWcnKTtcblxuY2xhc3MgQmF0Y2hGWEFBIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gR2VvbS5iaWdUcmlhbmdsZSgpO1xuXHRcdGNvbnN0IHNoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1xuXHRcdHN1cGVyKGdlb21ldHJ5LCBzaGFkZXIpO1xuXG5cdFx0c2hhZGVyLmJpbmQoKTtcblx0XHRzaGFkZXIudW5pZm9ybSgndGV4dHVyZScsICd1bmlmb3JtMWknLCAwKTtcblx0fVxuXG5cblx0ZHJhdyh0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1UmVzb2x1dGlvbicsICd2ZWMyJywgWzEvR0wud2lkdGgsIDEvR0wuaGVpZ2h0XSk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hGWEFBO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hGWEFBLmpzIiwiLy8gU2NlbmUuanNcblxuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IENhbWVyYVBlcnNwZWN0aXZlIGZyb20gJy4uL2NhbWVyYXMvQ2FtZXJhUGVyc3BlY3RpdmUnO1xuaW1wb3J0IENhbWVyYU9ydGhvIGZyb20gJy4uL2NhbWVyYXMvQ2FtZXJhT3J0aG8nO1xuaW1wb3J0IE9yYml0YWxDb250cm9sIGZyb20gJy4uL3V0aWxzL09yYml0YWxDb250cm9sJztcblxuXG5jbGFzcyBTY2VuZSB7XG5cblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX21hdHJpeElkZW50aXR5ID0gbWF0NC5jcmVhdGUoKTtcblx0XHRHTC5lbmFibGVBbHBoYUJsZW5kaW5nKCk7XG5cblx0XHR0aGlzLl9pbml0KCk7XG5cdFx0dGhpcy5faW5pdFRleHR1cmVzKCk7XG5cdFx0dGhpcy5faW5pdFZpZXdzKCk7XG5cblx0XHR0aGlzLl9lZkluZGV4ID0gU2NoZWR1bGVyLmFkZEVGKCgpPT50aGlzLl9sb29wKCkpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKT0+dGhpcy5yZXNpemUoKSk7XG5cdH1cblxuXG5cdFxuXHQvL1x0UFVCTElDIE1FVEhPRFNcblxuXHR1cGRhdGUoKSB7XG5cblx0fVxuXG5cdHJlbmRlcigpIHtcblxuXHR9XG5cblxuXHRzdG9wKCkge1xuXHRcdGlmKHRoaXMuX2VmSW5kZXggPT09IC0xKSB7XHRyZXR1cm47IH1cblx0XHR0aGlzLl9lZkluZGV4ID0gU2NoZWR1bGVyLnJlbW92ZUVGKHRoaXMuX2VmSW5kZXgpO1xuXHR9XG5cblxuXHRzdGFydCgpIHtcblx0XHRpZih0aGlzLl9lZkluZGV4ICE9PSAtMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gXG5cblx0XHR0aGlzLl9lZkluZGV4ID0gU2NoZWR1bGVyLmFkZEVGKCgpPT50aGlzLl9sb29wKCkpO1xuXHR9XG5cblxuXHRyZXNpemUoKSB7XG5cdFx0R0wuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcblx0XHR0aGlzLmNhbWVyYS5zZXRBc3BlY3RSYXRpbyhHTC5hc3BlY3RSYXRpbyk7XG5cdH1cblxuXG5cdGFkZENoaWxkKG1DaGlsZCkge1xuXHRcdHRoaXMuX2NoaWxkcmVuLnB1c2gobUNoaWxkKTtcblx0fVxuXG5cdHJlbW92ZUNoaWxkKG1DaGlsZCkge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihtQ2hpbGQpO1xuXHRcdGlmKGluZGV4ID09IC0xKSB7XHRjb25zb2xlLndhcm4oJ0NoaWxkIG5vIGV4aXN0Jyk7IHJldHVybjtcdH1cblxuXHRcdHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXG5cdC8vXHRQUk9URUNURUQgTUVUSE9EUyBUTyBCRSBPVkVSUklERU4gQlkgQ0hJTERSRU5cblxuXHRfaW5pdFRleHR1cmVzKCkge1xuXG5cdH1cblxuXG5cdF9pbml0Vmlld3MoKSB7XG5cblx0fVxuXG5cblx0X3JlbmRlckNoaWxkcmVuKCkge1xuXHRcdGxldCBjaGlsZDtcblx0XHRmb3IobGV0IGk9MDsgaTx0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcblx0XHRcdGNoaWxkLnRvUmVuZGVyKCk7XG5cdFx0fVxuXG5cdFx0R0wucm90YXRlKHRoaXMuX21hdHJpeElkZW50aXR5KTtcblx0fVxuXG5cdC8vXHRQUklWQVRFIE1FVEhPRFNcblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLmNhbWVyYSAgICAgICAgICAgICAgICAgPSBuZXcgQ2FtZXJhUGVyc3BlY3RpdmUoKTtcblx0XHR0aGlzLmNhbWVyYS5zZXRQZXJzcGVjdGl2ZSg0NSAqIE1hdGguUEkgLyAxODAsIEdMLmFzcGVjdFJhdGlvLCAwLjEsIDEwMCk7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbCAgICAgICAgICA9IG5ldyBPcmJpdGFsQ29udHJvbCh0aGlzLmNhbWVyYSwgd2luZG93LCAxNSk7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yYWRpdXMudmFsdWUgPSAxMDtcblx0XHRcblx0XHR0aGlzLmNhbWVyYU9ydGhvICAgICAgICAgICAgPSBuZXcgQ2FtZXJhT3J0aG8oKTtcblx0fVxuXG5cdF9sb29wKCkge1xuXG5cdFx0Ly9cdFJFU0VUIFZJRVdQT1JUXG5cdFx0R0wudmlld3BvcnQoMCwgMCwgR0wud2lkdGgsIEdMLmhlaWdodCk7XG5cblx0XHQvL1x0UkVTRVQgQ0FNRVJBXG5cdFx0R0wuc2V0TWF0cmljZXModGhpcy5jYW1lcmEpO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLl9yZW5kZXJDaGlsZHJlbigpO1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNjZW5lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvU2NlbmUuanMiLCIvLyBWaWV3LmpzXG5cbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5cbmNsYXNzIFZpZXcge1xuXHRjb25zdHJ1Y3RvcihtU3RyVmVydGV4LCBtU3RyRnJhZykge1xuXHRcdHRoaXMuc2hhZGVyID0gbmV3IEdMU2hhZGVyKG1TdHJWZXJ0ZXgsIG1TdHJGcmFnKTtcblxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0Ly9cdFBST1RFQ1RFRCBNRVRIT0RTXG5cblx0X2luaXQoKSB7XG5cblx0fVxuXG5cdC8vIFx0UFVCTElDIE1FVEhPRFNcblxuXHRyZW5kZXIoKSB7XG5cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvVmlldy5qcyIsIi8vIFZpZXczRC5qc1xuXG5pbXBvcnQgT2JqZWN0M0QgZnJvbSAnLi4vb2JqZWN0cy9PYmplY3QzRCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5cbmNsYXNzIFZpZXczRCBleHRlbmRzIE9iamVjdDNEIHtcblx0Y29uc3RydWN0b3IobVN0clZlcnRleCwgbVN0ckZyYWcpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLnNoYWRlciA9IG5ldyBHTFNoYWRlcihtU3RyVmVydGV4LCBtU3RyRnJhZyk7XG5cdFx0dGhpcy5faW5pdCgpO1xuXHRcdHRoaXMuX21hdHJpeFRlbXAgPSBtYXQ0LmNyZWF0ZSgpO1xuXHR9XG5cblxuXHQvL1x0UFJPVEVDVEVEIE1FVEhPRFNcblxuXHRfaW5pdCgpIHtcblxuXHR9XG5cblx0Ly8gXHRQVUJMSUMgTUVUSE9EU1xuXG5cdGFkZENoaWxkKG1DaGlsZCkge1xuXHRcdHRoaXMuX2NoaWxkcmVuLnB1c2gobUNoaWxkKTtcblx0fVxuXG5cdHJlbW92ZUNoaWxkKG1DaGlsZCkge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihtQ2hpbGQpO1xuXHRcdGlmKGluZGV4ID09IC0xKSB7XHRjb25zb2xlLndhcm4oJ0NoaWxkIG5vIGV4aXN0Jyk7IHJldHVybjtcdH1cblxuXHRcdHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXG5cdHRvUmVuZGVyKG1hdHJpeCkge1xuXHRcdGlmKG1hdHJpeCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdH1cblx0XHRtYXQ0Lm11bCh0aGlzLl9tYXRyaXhUZW1wLCBtYXRyaXgsIHRoaXMubWF0cml4KTtcblx0XHRHTC5yb3RhdGUodGhpcy5fbWF0cml4VGVtcCk7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblxuXHRcdGZvcihsZXQgaT0wOyBpPHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0Y2hpbGQudG9SZW5kZXIodGhpcy5tYXRyaXgpO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcigpIHtcblxuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVmlldzNEO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvVmlldzNELmpzIiwiLy8gQXNzZXRzLmpzXG5cbmltcG9ydCBhc3NldHNUb0xvYWQgZnJvbSAnLi9hc3NldC1saXN0JztcbmltcG9ydCBhbGZyaWQsIHsgR0xUZXh0dXJlLCBHTEN1YmVUZXh0dXJlLCBNZXNoLCBPYmpMb2FkZXIgfSBmcm9tICdhbGZyaWQnO1xuXG5jb25zdCBBc3NldHMgPSB7fTtcbmxldCBfYXNzZXRzID0gW107XG5cbmNvbnN0IGdldEFzc2V0ID0gZnVuY3Rpb24oaWQpIHtcblx0cmV0dXJuIGFzc2V0cy5maW5kKCAoYSkgPT4gYS5pZCA9PT0gaWQpLmZpbGU7XG59XG5cbmNvbnN0IGdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uKG1GaWxlKSB7XG5cdGNvbnN0IGFyeSA9IG1GaWxlLnNwbGl0KCcuJyk7XG5cdHJldHVybiBhcnlbYXJ5Lmxlbmd0aCAtIDFdO1xufVxuXG5Bc3NldHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRsZXQgaGRyQ3ViZW1hcHMgPSB7fTtcblx0X2Fzc2V0cyA9IGFzc2V0c1RvTG9hZC5tYXAoKG8pPT4ge1xuXHRcdGNvbnN0IGV4dCA9IGdldEV4dGVuc2lvbihvLnVybCk7XG5cdFx0Y29uc3QgZmlsZSA9IGdldEFzc2V0KG8uaWQpO1xuXHRcdGxldCB0ZXh0dXJlO1xuXG5cdFx0c3dpdGNoKGV4dCkge1xuXHRcdFx0Y2FzZSAnanBnJzpcblx0XHRcdGNhc2UgJ3BuZyc6XG5cdFx0XHRcdHRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGZpbGUpO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGlkOm8uaWQsXG5cdFx0XHRcdFx0ZmlsZTp0ZXh0dXJlXG5cdFx0XHRcdH07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdoZHInOlxuXHRcdFx0XHRsZXQgY3ViZW1hcE5hbWUgPSBvLmlkLnNwbGl0KCdfJylbMF07XG5cdFx0XHRcdHRleHR1cmUgPSBhbGZyaWQuSERSTG9hZGVyLnBhcnNlKGZpbGUpO1xuXG5cdFx0XHRcdGNvbnN0IG9Bc3NldCA9IHtcblx0XHRcdFx0XHRpZDpvLmlkLFxuXHRcdFx0XHRcdGZpbGU6dGV4dHVyZVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmKCFoZHJDdWJlbWFwc1tjdWJlbWFwTmFtZV0pIHtcblx0XHRcdFx0XHRoZHJDdWJlbWFwc1tjdWJlbWFwTmFtZV0gPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGhkckN1YmVtYXBzW2N1YmVtYXBOYW1lXS5wdXNoKG9Bc3NldCk7XG5cdFx0XHRcdHJldHVybiBvQXNzZXQ7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkZHMnOlxuXHRcdFx0XHR0ZXh0dXJlID0gR0xDdWJlVGV4dHVyZS5wYXJzZUREUyhmaWxlKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZDpvLmlkLFxuXHRcdFx0XHRcdGZpbGU6dGV4dHVyZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnb2JqJzpcblx0XHRcdFx0Y29uc3QgbWVzaCA9IE9iakxvYWRlci5wYXJzZShmaWxlKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZDpvLmlkLFxuXHRcdFx0XHRcdGZpbGU6bWVzaFxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHR9KTtcblxuXHRmb3IobGV0IHMgaW4gaGRyQ3ViZW1hcHMpIHtcblx0XHRpZihoZHJDdWJlbWFwc1tzXS5sZW5ndGggPT0gNikge1xuXHRcdFx0Y29uc29sZS5sb2coJ0dlbmVyYXRlIEN1YmVtYXAgOicsIHMpO1xuXG5cdFx0XHRjb25zdCBhcnkgPSBbXG5cdFx0XHRcdEFzc2V0cy5nZXQoYCR7c31fcG9zeGApLFxuXHRcdFx0XHRBc3NldHMuZ2V0KGAke3N9X25lZ3hgKSxcblx0XHRcdFx0QXNzZXRzLmdldChgJHtzfV9wb3N5YCksXG5cdFx0XHRcdEFzc2V0cy5nZXQoYCR7c31fbmVneWApLFxuXHRcdFx0XHRBc3NldHMuZ2V0KGAke3N9X3Bvc3pgKSxcblx0XHRcdFx0QXNzZXRzLmdldChgJHtzfV9uZWd6YClcblx0XHRcdF07XG5cblx0XHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgYWxmcmlkLkdMQ3ViZVRleHR1cmUoYXJ5KTtcblx0XHRcdF9hc3NldHMucHVzaCh7XG5cdFx0XHRcdGlkOnMsXG5cdFx0XHRcdGZpbGU6dGV4dHVyZVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHRpZihfYXNzZXRzLmxlbmd0aCA+IDApIHtcblx0XHRjb25zb2xlLmRlYnVnKCdBU1NFVFM6Jyk7XG5cdFx0Y29uc29sZS50YWJsZShfYXNzZXRzKTtcdFxuXHR9XG5cdFxufVxuXG5Bc3NldHMuZ2V0ID0gZnVuY3Rpb24obUlkKSB7XG5cdHJldHVybiBfYXNzZXRzLmZpbmQoKGEpID0+IHtcblx0XHRyZXR1cm4gYS5pZCA9PT0gbUlkO1xuXHR9KS5maWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBBc3NldHM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL0Fzc2V0cy5qcyIsIlxuY29uc3QgYXNzZXRzVG9Mb2FkID0gW1xuXHR7XCJpZFwiOlwiYWxiZWRvXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvYWxiZWRvLmpwZ1wiLFwidHlwZVwiOlwianBnXCJ9LFxuXHR7XCJpZFwiOlwiYW9cIixcInVybFwiOlwiYXNzZXRzL2ltZy9hby5qcGdcIixcInR5cGVcIjpcImpwZ1wifSxcblx0e1wiaWRcIjpcImJyZGZMVVRcIixcInVybFwiOlwiYXNzZXRzL2ltZy9icmRmTFVULnBuZ1wiLFwidHlwZVwiOlwicG5nXCJ9LFxuXHR7XCJpZFwiOlwibWV0YWxHbG9zc1wiLFwidXJsXCI6XCJhc3NldHMvaW1nL21ldGFsR2xvc3MuanBnXCIsXCJ0eXBlXCI6XCJqcGdcIn0sXG5cdHtcImlkXCI6XCJub3JtYWxcIixcInVybFwiOlwiYXNzZXRzL2ltZy9ub3JtYWwuanBnXCIsXCJ0eXBlXCI6XCJqcGdcIn0sXG5cdHtcImlkXCI6XCJwaXNhX2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9waXNhX2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJwaXNhX3JhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvcGlzYV9yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzEwX2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8xMF9pcnJhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMTBfcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8xMF9yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzExX2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8xMV9pcnJhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMTFfcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8xMV9yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzEyX2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8xMl9pcnJhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMTJfcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8xMl9yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzFfaXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzFfaXJyYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzFfcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8xX3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMl9pcnJhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvMl9pcnJhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvMl9yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzJfcmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW8zX2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW8zX2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW8zX3JhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvM19yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzRfaXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzRfaXJyYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzRfcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW80X3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvNV9pcnJhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvNV9pcnJhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvNV9yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzVfcmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW82X2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW82X2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW82X3JhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvNl9yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzdfaXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzdfaXJyYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInN0dWRpbzdfcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW83X3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvOF9pcnJhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvOF9pcnJhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9LFxuXHR7XCJpZFwiOlwic3R1ZGlvOF9yYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3N0dWRpbzhfcmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW85X2lycmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy9zdHVkaW85X2lycmFkaWFuY2UuZGRzXCIsXCJ0eXBlXCI6XCJiaW5hcnlcIn0sXG5cdHtcImlkXCI6XCJzdHVkaW85X3JhZGlhbmNlXCIsXCJ1cmxcIjpcImFzc2V0cy9pbWcvc3R1ZGlvOV9yYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInZhdGljYW5faXJyYWRpYW5jZVwiLFwidXJsXCI6XCJhc3NldHMvaW1nL3ZhdGljYW5faXJyYWRpYW5jZS5kZHNcIixcInR5cGVcIjpcImJpbmFyeVwifSxcblx0e1wiaWRcIjpcInZhdGljYW5fcmFkaWFuY2VcIixcInVybFwiOlwiYXNzZXRzL2ltZy92YXRpY2FuX3JhZGlhbmNlLmRkc1wiLFwidHlwZVwiOlwiYmluYXJ5XCJ9XG5dO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGFzc2V0c1RvTG9hZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvYXNzZXQtbGlzdC5qcyIsIi8vIENvbmZpZy5qc1xuXG5leHBvcnQgZGVmYXVsdCB7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL0NvbmZpZy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygyMCk7XG59XG5cbkVtaXR0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbkVtaXR0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW1pdHRlcjtcblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnModHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvZW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbWJzOiAwLFxuICAgIHNlY3M6IDAsXG4gICAgdXBkYXRlOiBmdW5jdGlvbihyZXF1ZXN0LCBzdGFydFRpbWUsIHVybCwgbG9nKSB7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBoZWFkZXJzID0gcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcbiAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGhlYWRlcnMubWF0Y2goL2NvbnRlbnQtbGVuZ3RoOiAoXFxkKykvaSk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFyIGxlbmd0aCA9IHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IHBhcnNlSW50KGxlbmd0aCwgMTApO1xuICAgICAgICAgICAgdmFyIG1icyA9IGxlbmd0aCAvIDEwMjQgLyAxMDI0O1xuICAgICAgICAgICAgdmFyIHNlY3MgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwO1xuICAgICAgICAgICAgdGhpcy5zZWNzICs9IHNlY3M7XG4gICAgICAgICAgICB0aGlzLm1icyArPSBtYnM7XG4gICAgICAgICAgICBpZiAobG9nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2codXJsLCBtYnMsIHNlY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYobG9nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4uY2FsbChjb25zb2xlLCAnQ2FuXFwndCBnZXQgQ29udGVudC1MZW5ndGg6JywgdXJsKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbG9nOiBmdW5jdGlvbih1cmwsIG1icywgc2Vjcykge1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICB2YXIgZmlsZSA9ICdGaWxlIGxvYWRlZDogJyArXG4gICAgICAgICAgICAgICAgdXJsLnN1YnN0cih1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpICtcbiAgICAgICAgICAgICAgICAnIHNpemU6JyArIG1icy50b0ZpeGVkKDIpICsgJ21iJyArXG4gICAgICAgICAgICAgICAgJyB0aW1lOicgKyBzZWNzLnRvRml4ZWQoMikgKyAncycgK1xuICAgICAgICAgICAgICAgICcgc3BlZWQ6JyArIChtYnMgLyBzZWNzKS50b0ZpeGVkKDIpICsgJ21icHMnO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZy5jYWxsKGNvbnNvbGUsIGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3RhbCA9ICdUb3RhbCBsb2FkZWQ6ICcgKyB0aGlzLm1icy50b0ZpeGVkKDIpICsgJ21iJyArXG4gICAgICAgICAgICAnIHRpbWU6JyArIHRoaXMuc2Vjcy50b0ZpeGVkKDIpICsgJ3MnICtcbiAgICAgICAgICAgICcgc3BlZWQ6JyArIHRoaXMuZ2V0TWJwcygpLnRvRml4ZWQoMikgKyAnbWJwcyc7XG4gICAgICAgIGNvbnNvbGUubG9nLmNhbGwoY29uc29sZSwgdG90YWwpO1xuICAgIH0sXG4gICAgZ2V0TWJwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1icyAvIHRoaXMuc2VjcztcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYXNzZXRzLWxvYWRlci9zcmMvc3RhdHMuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3Njc3MvZ2xvYmFsLnNjc3MnO1xuaW1wb3J0IGRlYnVnUG9seWZpbGwgZnJvbSAnLi9kZWJ1Zy9kZWJ1Z1BvbHlmaWxsJztcbmltcG9ydCBhbGZyaWQsIHsgR0wgfSBmcm9tICdhbGZyaWQnO1xuaW1wb3J0IFNjZW5lQXBwIGZyb20gJy4vU2NlbmVBcHAnO1xuaW1wb3J0IEFzc2V0c0xvYWRlciBmcm9tICdhc3NldHMtbG9hZGVyJztcblxuaW1wb3J0IGFzc2V0cyBmcm9tICcuL2Fzc2V0LWxpc3QnO1xuaW1wb3J0IEFzc2V0cyBmcm9tICcuL0Fzc2V0cyc7XG5cbmlmKGRvY3VtZW50LmJvZHkpIHtcblx0X2luaXQoKTtcbn0gZWxzZSB7XG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgX2luaXQpO1xufVxuXG5cbmZ1bmN0aW9uIF9pbml0KCkge1xuXG5cdC8vXHRMT0FESU5HIEFTU0VUU1xuXHRpZihhc3NldHMubGVuZ3RoID4gMCkge1xuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnaXNMb2FkaW5nJyk7XG5cblx0XHRjb25zdCBsb2FkZXIgPSBuZXcgQXNzZXRzTG9hZGVyKHtcblx0XHRcdGFzc2V0czphc3NldHNcblx0XHR9KVxuXHRcdC5vbignZXJyb3InLCAoZXJyb3IpPT57XG5cdFx0XHRjb25zb2xlLmxvZygnRXJyb3IgOicsIGVycm9yKTtcblx0XHR9KVxuXHRcdC5vbigncHJvZ3Jlc3MnLCAocCkgPT4ge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ1Byb2dyZXNzIDogJywgcCk7XG5cdFx0XHRjb25zdCBsb2FkZXIgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJy5Mb2FkaW5nLUJhcicpO1xuXHRcdFx0aWYobG9hZGVyKSBsb2FkZXIuc3R5bGUud2lkdGggPSBgJHsocCAqIDEwMCl9JWA7XG5cdFx0fSlcblx0XHQub24oJ2NvbXBsZXRlJywgX29uSW1hZ2VMb2FkZWQpXG5cdFx0LnN0YXJ0KCk7XG5cblx0fSBlbHNlIHtcblx0XHRfaW5pdDNEKCk7XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBfb25JbWFnZUxvYWRlZChvKSB7XG5cdC8vXHRBU1NFVFNcblx0Y29uc29sZS5sb2coJ0ltYWdlIExvYWRlZCA6ICcsIG8pO1xuXHR3aW5kb3cuYXNzZXRzID0gbztcblx0Y29uc3QgbG9hZGVyID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKCcuTG9hZGluZy1CYXInKTtcblx0Y29uc29sZS5sb2coJ0xvYWRlciA6JywgbG9hZGVyKTtcblx0bG9hZGVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXG5cdF9pbml0M0QoKTtcblxuXHRzZXRUaW1lb3V0KCgpPT4ge1xuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnaXNMb2FkaW5nJyk7XG5cdH0sIDI1MCk7XG59XG5cblxuZnVuY3Rpb24gX2luaXQzRCgpIHtcblx0Ly9cdENSRUFURSBDQU5WQVNcblx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdGNhbnZhcy5jbGFzc05hbWUgPSAnTWFpbi1DYW52YXMnO1xuXHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cblx0Ly9cdElOSVQgM0QgVE9PTFxuXHRHTC5pbml0KGNhbnZhcywge2lnbm9yZVdlYmdsMjp0cnVlfSk7XG5cblx0Ly9cdElOSVQgQVNTRVRTXG5cdEFzc2V0cy5pbml0KCk7XG5cblx0Ly9cdENSRUFURSBTQ0VORVxuXHRjb25zdCBzY2VuZSA9IG5ldyBTY2VuZUFwcCgpO1xuXG5cdFxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9hcHAuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/dXJsPWZhbHNlIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vZ2xvYmFsLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3VybD1mYWxzZSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2dsb2JhbC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz91cmw9ZmFsc2UhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9nbG9iYWwuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2Nzcy9nbG9iYWwuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBmbi5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWVtb1tzZWxlY3Rvcl1cblx0fTtcbn0pKGZ1bmN0aW9uICh0YXJnZXQpIHtcblx0cmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KVxufSk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gZGVidWdQb2x5ZmlsbC5qc1xuXG53aW5kb3cuZ3VpID0ge1xuXHRhZGQ6KCk9PntcblxuXHR9XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9kZWJ1Zy9kZWJ1Z1BvbHlmaWxsLmpzIiwiLy8gU2NlbmVBcHAuanNcblxuaW1wb3J0IGFsZnJpZCwgeyBTY2VuZSwgR0wsIEdMVEZMb2FkZXIgfSBmcm9tICdhbGZyaWQnO1xuaW1wb3J0IEFzc2V0cyBmcm9tICcuL0Fzc2V0cyc7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi9TZXR0aW5ncyc7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vQ29uZmlnJztcblxuY2xhc3MgU2NlbmVBcHAgZXh0ZW5kcyBTY2VuZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdFNldHRpbmdzLmluaXQoKTtcblxuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5yZXNpemUoKTtcblx0XHRHTC5lbmFibGVBbHBoYUJsZW5kaW5nKCk7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yeC52YWx1ZSA9IHRoaXMub3JiaXRhbENvbnRyb2wucnkudmFsdWUgPSAwLjM7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yYWRpdXMudmFsdWUgPSA1O1xuXHR9XG5cblx0X2luaXRUZXh0dXJlcygpIHtcblx0XHR0aGlzLnRleHR1cmVCcmRmID0gQXNzZXRzLmdldCgnYnJkZkxVVCcpO1xuXHRcdHRoaXMuZW52ID0gJ3N0dWRpbzEnO1xuXHRcdFxuXHRcdGNvbnN0IGVudnMgPSBbJ3Bpc2EnLCAndmF0aWNhbiddO1xuXHRcdGZvcihsZXQgaT0xOyBpPD0xMjsgaSsrKSB7XG5cdFx0XHRlbnZzLnB1c2goYHN0dWRpbyR7aX1gKTtcblx0XHR9XG5cblx0XHR0aGlzLl91cGRhdGVFbnZNYXAoKTtcblxuXHRcdGd1aS5hZGQodGhpcywgJ2VudicsIGVudnMpLm9uRmluaXNoQ2hhbmdlKCgpPT50aGlzLl91cGRhdGVFbnZNYXAoKSk7XG5cblx0fVxuXG5cblx0X2luaXRWaWV3cygpIHtcblx0XHRjb25zb2xlLmxvZygnaW5pdCB2aWV3cycpO1xuXG5cdFx0dGhpcy5fYkNvcHkgPSBuZXcgYWxmcmlkLkJhdGNoQ29weSgpO1xuXHRcdHRoaXMuX2JBeGlzID0gbmV3IGFsZnJpZC5CYXRjaEF4aXMoKTtcblx0XHR0aGlzLl9iRG90cyA9IG5ldyBhbGZyaWQuQmF0Y2hEb3RzUGxhbmUoKTtcblx0XHR0aGlzLl9iU2t5ID0gbmV3IGFsZnJpZC5CYXRjaFNreWJveCgpO1xuXG5cdFx0Y29uc3QgdXJsID0gJ2Fzc2V0cy9nbHRmL0ZsaWdodEhlbG1ldC5nbHRmJztcblx0XHRHTFRGTG9hZGVyLmxvYWQodXJsKVxuXHRcdC50aGVuKChnbHRmSW5mbyk9PiB7XG5cdFx0XHR0aGlzLmdsdGYgPSBnbHRmSW5mbztcblx0XHRcdGNvbnN0IHsgbWVzaGVzIH0gPSBnbHRmSW5mby5vdXRwdXQ7XG5cdFx0XHR0aGlzLnNjZW5lcyA9IGdsdGZJbmZvLm91dHB1dC5zY2VuZXM7XG5cblx0XHRcdG1lc2hlcy5mb3JFYWNoKCBtZXNoID0+IHtcblx0XHRcdFx0bWVzaC5tYXRlcmlhbC51bmlmb3Jtcy51QlJERk1hcCA9IHRoaXMudGV4dHVyZUJyZGY7XG5cdFx0XHRcdG1lc2gubWF0ZXJpYWwudW5pZm9ybXMudUlycmFkaWFuY2VNYXAgPSB0aGlzLnRleHR1cmVJcnI7XG5cdFx0XHRcdG1lc2gubWF0ZXJpYWwudW5pZm9ybXMudVJhZGlhbmNlTWFwID0gdGhpcy50ZXh0dXJlUmFkO1xuXHRcdFx0fSk7XG5cblx0XHR9KVxuXHRcdC5jYXRjaChlID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKCdFcnJvciBsb2FkaW5nIGdsdGY6JywgZSk7XG5cdFx0fSk7XG5cdH1cblxuXG5cdF91cGRhdGVFbnZNYXAoKSB7XG5cdFx0dGhpcy50ZXh0dXJlSXJyID0gQXNzZXRzLmdldChgJHt0aGlzLmVudn1faXJyYWRpYW5jZWApO1xuXHRcdHRoaXMudGV4dHVyZVJhZCA9IEFzc2V0cy5nZXQoYCR7dGhpcy5lbnZ9X3JhZGlhbmNlYCk7XG5cblx0XHRpZih0aGlzLmdsdGYpIHtcblx0XHRcdGNvbnN0IHsgbWVzaGVzIH0gPSB0aGlzLmdsdGYub3V0cHV0O1xuXG5cdFx0XHRtZXNoZXMuZm9yRWFjaCggbWVzaCA9PiB7XG5cdFx0XHRcdG1lc2gubWF0ZXJpYWwudW5pZm9ybXMudUJSREZNYXAgPSB0aGlzLnRleHR1cmVCcmRmO1xuXHRcdFx0XHRtZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnVJcnJhZGlhbmNlTWFwID0gdGhpcy50ZXh0dXJlSXJyO1xuXHRcdFx0XHRtZXNoLm1hdGVyaWFsLnVuaWZvcm1zLnVSYWRpYW5jZU1hcCA9IHRoaXMudGV4dHVyZVJhZDtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cblx0cmVuZGVyKCkge1xuXHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXG5cdFx0dGhpcy5fYlNreS5kcmF3KHRoaXMudGV4dHVyZVJhZCk7XG5cblx0XHRpZih0aGlzLnNjZW5lcykge1xuXHRcdFx0dGhpcy5zY2VuZXMuZm9yRWFjaCggc2NlbmUgPT4ge1xuXHRcdFx0XHRHTC5kcmF3KHNjZW5lKTtcblx0XHRcdH0pO1x0XG5cdFx0fVxuXHR9XG5cblxuXHRyZXNpemUoKSB7XG5cdFx0Y29uc3QgeyBpbm5lcldpZHRoLCBpbm5lckhlaWdodCwgZGV2aWNlUGl4ZWxSYXRpbyB9ID0gd2luZG93O1xuXHRcdEdMLnNldFNpemUoaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQpO1xuXHRcdHRoaXMuY2FtZXJhLnNldEFzcGVjdFJhdGlvKEdMLmFzcGVjdFJhdGlvKTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNjZW5lQXBwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9TY2VuZUFwcC5qcyIsIi8vIFNldHRpbmdzLmpzXG5cbmltcG9ydCBDb25maWcgZnJvbSAnLi9Db25maWcnO1xuaW1wb3J0IHVybCBmcm9tICdmYXN0LXVybC1wYXJzZXInO1xudXJsLnF1ZXJ5U3RyaW5nID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5ncGFyc2VyXCIpO1xuXG5sZXQgZW5hYmxlZCA9IHRydWU7XG5cblxuY29uc3QgcmVsb2FkID0gKCkgPT4ge1xuXHRpZighZW5hYmxlZCkge1xuXHRcdHJldHVybjtcblx0fVxuXHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4rd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgJz9jb25maWc9JyArIEpTT04uc3RyaW5naWZ5KENvbmZpZyk7XG59XG5cbmNvbnN0IHJlZnJlc2ggPSAoKSA9PiB7XG5cdGlmKCFlbmFibGVkKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSgnZXhwZXJpbWVudCcsICdUaXRsZScsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4rd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgJz9jb25maWc9JyArIEpTT04uc3RyaW5naWZ5KENvbmZpZykpO1x0XG59XG5cblxubGV0IGRlbGF5SW5kZXggPSAtMTtcblxuY29uc3QgZGVsYXlSZWxvYWQgPSAoKSA9PiB7XG5cdGlmKCFlbmFibGVkKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHdpbmRvdy5jbGVhclRpbWVvdXQoZGVsYXlJbmRleCk7XG5cblx0ZGVsYXlJbmRleCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpPT4ge1xuXHRcdHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbit3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyAnP2NvbmZpZz0nICsgSlNPTi5zdHJpbmdpZnkoQ29uZmlnKTtcblx0fSwgNTAwKTtcbn1cblxuXG5jb25zdCBpbml0ID0gKG1FbmFibGVkPXRydWUpID0+IHtcblx0ZW5hYmxlZCA9IG1FbmFibGVkO1xuXHRjb25zdCBwYXJzZWQgPSB1cmwucGFyc2Uod2luZG93LmxvY2F0aW9uLnNlYXJjaCwgdHJ1ZSk7XG5cblx0aWYocGFyc2VkLnF1ZXJ5LmNvbmZpZykge1xuXHRcdGNvbnN0IG9Db25maWcgPSBKU09OLnBhcnNlKHBhcnNlZC5xdWVyeS5jb25maWcpO1xuXG5cdFx0Zm9yKGxldCBrZXkgaW4gb0NvbmZpZykge1xuXHRcdFx0Q29uZmlnW2tleV0gPSBvQ29uZmlnW2tleV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc29sZS5sb2coJ0NvbmZpZyA6JywgQ29uZmlnKTtcblx0cmVmcmVzaCgpO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0ZW5hYmxlZCxcblx0cmVsb2FkLFxuXHRyZWZyZXNoLFxuXHRkZWxheVJlbG9hZCxcblx0aW5pdFxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9TZXR0aW5ncy5qcyIsIlwidXNlIHN0cmljdFwiO1xuLypcbkNvcHlyaWdodCAoYykgMjAxNCBQZXRrYSBBbnRvbm92XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuZnVuY3Rpb24gVXJsKCkge1xuICAgIC8vRm9yIG1vcmUgZWZmaWNpZW50IGludGVybmFsIHJlcHJlc2VudGF0aW9uIGFuZCBsYXppbmVzcy5cbiAgICAvL1RoZSBub24tdW5kZXJzY29yZSB2ZXJzaW9ucyBvZiB0aGVzZSBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NvciBmdW5jdGlvbnNcbiAgICAvL2RlZmluZWQgb24gdGhlIHByb3RvdHlwZS5cbiAgICB0aGlzLl9wcm90b2NvbCA9IG51bGw7XG4gICAgdGhpcy5faHJlZiA9IFwiXCI7XG4gICAgdGhpcy5fcG9ydCA9IC0xO1xuICAgIHRoaXMuX3F1ZXJ5ID0gbnVsbDtcblxuICAgIHRoaXMuYXV0aCA9IG51bGw7XG4gICAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgICB0aGlzLmhvc3QgPSBudWxsO1xuICAgIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICAgIHRoaXMuaGFzaCA9IG51bGw7XG4gICAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICAgIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuXG4gICAgdGhpcy5fcHJlcGVuZFNsYXNoID0gZmFsc2U7XG59XG5cbnZhciBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcblxuVXJsLnF1ZXJ5U3RyaW5nID0gcXVlcnlzdHJpbmc7XG5cblVybC5wcm90b3R5cGUucGFyc2UgPVxuZnVuY3Rpb24gVXJsJHBhcnNlKHN0ciwgcGFyc2VRdWVyeVN0cmluZywgaG9zdERlbm90ZXNTbGFzaCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICtcbiAgICAgICAgICAgIHR5cGVvZiBzdHIpO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBlbmQgPSBzdHIubGVuZ3RoIC0gMTtcblxuICAgIC8vVHJpbSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3c1xuICAgIHdoaWxlIChzdHIuY2hhckNvZGVBdChzdGFydCkgPD0gMHgyMCAvKicgJyovKSBzdGFydCsrO1xuICAgIHdoaWxlIChzdHIuY2hhckNvZGVBdChlbmQpIDw9IDB4MjAgLyonICcqLykgZW5kLS07XG5cbiAgICBzdGFydCA9IHRoaXMuX3BhcnNlUHJvdG9jb2woc3RyLCBzdGFydCwgZW5kKTtcblxuICAgIC8vSmF2YXNjcmlwdCBkb2Vzbid0IGhhdmUgaG9zdFxuICAgIGlmICh0aGlzLl9wcm90b2NvbCAhPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9wYXJzZUhvc3Qoc3RyLCBzdGFydCwgZW5kLCBob3N0RGVub3Rlc1NsYXNoKTtcbiAgICAgICAgdmFyIHByb3RvID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgICAgIGlmICghdGhpcy5ob3N0bmFtZSAmJlxuICAgICAgICAgICAgKHRoaXMuc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoUHJvdG9jb2xzW3Byb3RvXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgyRiAvKicvJyovIHx8IGNoID09PSAweDVDIC8qJ1xcJyovKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVBhdGgoc3RyLCBzdGFydCwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVF1ZXJ5KHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MjMgLyonIycqLykge1xuICAgICAgICAgIHRoaXMuX3BhcnNlSGFzaChzdHIsIHN0YXJ0LCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Byb3RvY29sICE9PSBcImphdmFzY3JpcHRcIikge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vRm9yIGphdmFzY3JpcHQgdGhlIHBhdGhuYW1lIGlzIGp1c3QgdGhlIHJlc3Qgb2YgaXRcbiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEgKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBhdGhuYW1lICYmIHRoaXMuaG9zdG5hbWUgJiZcbiAgICAgICAgdGhpcy5fc2xhc2hQcm90b2NvbHNbdGhpcy5fcHJvdG9jb2xdKSB7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBcIi9cIjtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2g7XG4gICAgICAgIGlmIChzZWFyY2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VhcmNoID0gdGhpcy5zZWFyY2ggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2guY2hhckNvZGVBdCgwKSA9PT0gMHgzRiAvKic/JyovKSB7XG4gICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGlzIGNhbGxzIGEgc2V0dGVyIGZ1bmN0aW9uLCB0aGVyZSBpcyBubyAucXVlcnkgZGF0YSBwcm9wZXJ0eVxuICAgICAgICB0aGlzLnF1ZXJ5ID0gVXJsLnF1ZXJ5U3RyaW5nLnBhcnNlKHNlYXJjaCk7XG4gICAgfVxufTtcblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gVXJsJHJlc29sdmUocmVsYXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KFVybC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gVXJsJGZvcm1hdCgpIHtcbiAgICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCBcIlwiO1xuXG4gICAgaWYgKGF1dGgpIHtcbiAgICAgICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICAgICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksIFwiOlwiKTtcbiAgICAgICAgYXV0aCArPSBcIkBcIjtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8IFwiXCI7XG4gICAgdmFyIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCBcIlwiO1xuICAgIHZhciBoYXNoID0gdGhpcy5oYXNoIHx8IFwiXCI7XG4gICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IFwiXCI7XG4gICAgdmFyIHF1ZXJ5ID0gXCJcIjtcbiAgICB2YXIgaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8IFwiXCI7XG4gICAgdmFyIHBvcnQgPSB0aGlzLnBvcnQgfHwgXCJcIjtcbiAgICB2YXIgaG9zdCA9IGZhbHNlO1xuICAgIHZhciBzY2hlbWUgPSBcIlwiO1xuXG4gICAgLy9DYWNoZSB0aGUgcmVzdWx0IG9mIHRoZSBnZXR0ZXIgZnVuY3Rpb25cbiAgICB2YXIgcSA9IHRoaXMucXVlcnk7XG4gICAgaWYgKHEgJiYgdHlwZW9mIHEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcXVlcnkgPSBVcmwucXVlcnlTdHJpbmcuc3RyaW5naWZ5KHEpO1xuICAgIH1cblxuICAgIGlmICghc2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaCA9IHF1ZXJ5ID8gXCI/XCIgKyBxdWVyeSA6IFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJDb2RlQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09IDB4M0EgLyonOicqLylcbiAgICAgICAgcHJvdG9jb2wgKz0gXCI6XCI7XG5cbiAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICAgIH1cbiAgICBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgICAgICB2YXIgaXA2ID0gaG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPiAtMTtcbiAgICAgICAgaWYgKGlwNikgaG9zdG5hbWUgPSBcIltcIiArIGhvc3RuYW1lICsgXCJdXCI7XG4gICAgICAgIGhvc3QgPSBhdXRoICsgaG9zdG5hbWUgKyAocG9ydCA/IFwiOlwiICsgcG9ydCA6IFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBzbGFzaGVzID0gdGhpcy5zbGFzaGVzIHx8XG4gICAgICAgICgoIXByb3RvY29sIHx8XG4gICAgICAgIHNsYXNoUHJvdG9jb2xzW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpO1xuXG5cbiAgICBpZiAocHJvdG9jb2wpIHNjaGVtZSA9IHByb3RvY29sICsgKHNsYXNoZXMgPyBcIi8vXCIgOiBcIlwiKTtcbiAgICBlbHNlIGlmIChzbGFzaGVzKSBzY2hlbWUgPSBcIi8vXCI7XG5cbiAgICBpZiAoc2xhc2hlcyAmJiBwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQ29kZUF0KDApICE9PSAweDJGIC8qJy8nKi8pIHtcbiAgICAgICAgcGF0aG5hbWUgPSBcIi9cIiArIHBhdGhuYW1lO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQ29kZUF0KDApICE9PSAweDNGIC8qJz8nKi8pXG4gICAgICAgIHNlYXJjaCA9IFwiP1wiICsgc2VhcmNoO1xuICAgIGlmIChoYXNoICYmIGhhc2guY2hhckNvZGVBdCgwKSAhPT0gMHgyMyAvKicjJyovKVxuICAgICAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuXG4gICAgcGF0aG5hbWUgPSBlc2NhcGVQYXRoTmFtZShwYXRobmFtZSk7XG4gICAgc2VhcmNoID0gZXNjYXBlU2VhcmNoKHNlYXJjaCk7XG5cbiAgICByZXR1cm4gc2NoZW1lICsgKGhvc3QgPT09IGZhbHNlID8gXCJcIiA6IGhvc3QpICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gVXJsJHJlc29sdmVPYmplY3QocmVsYXRpdmUpIHtcbiAgICBpZiAodHlwZW9mIHJlbGF0aXZlID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZWxhdGl2ZSA9IFVybC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Nsb25lKCk7XG5cbiAgICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlXCJzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICAgIGlmICghcmVsYXRpdmUuaHJlZikge1xuICAgICAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICAgIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5fcHJvdG9jb2wpIHtcbiAgICAgICAgcmVsYXRpdmUuX2NvcHlQcm9wc1RvKHJlc3VsdCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHNsYXNoUHJvdG9jb2xzW3Jlc3VsdC5fcHJvdG9jb2xdICYmXG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAocmVsYXRpdmUuX3Byb3RvY29sICYmIHJlbGF0aXZlLl9wcm90b2NvbCAhPT0gcmVzdWx0Ll9wcm90b2NvbCkge1xuICAgICAgICAvLyBpZiBpdFwicyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgICAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAgICAgLy8gZmlyc3QsIGlmIGl0XCJzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgICAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgICAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhhdFwicyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgICAgICBpZiAoIXNsYXNoUHJvdG9jb2xzW3JlbGF0aXZlLl9wcm90b2NvbF0pIHtcbiAgICAgICAgICAgIHJlbGF0aXZlLl9jb3B5UHJvcHNUbyhyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0Ll9wcm90b2NvbCA9IHJlbGF0aXZlLl9wcm90b2NvbDtcbiAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmIHJlbGF0aXZlLl9wcm90b2NvbCAhPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAocmVsUGF0aFswXSAhPT0gXCJcIikgcmVsUGF0aC51bnNoaWZ0KFwiXCIpO1xuICAgICAgICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KFwiXCIpO1xuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8IFwiXCI7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgcmVzdWx0Ll9wb3J0ID0gcmVsYXRpdmUuX3BvcnQ7XG4gICAgICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgaXNTb3VyY2VBYnMgPVxuICAgICAgICAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQ29kZUF0KDApID09PSAweDJGIC8qJy8nKi8pO1xuICAgIHZhciBpc1JlbEFicyA9IChcbiAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICAgIChyZWxhdGl2ZS5wYXRobmFtZSAmJlxuICAgICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUuY2hhckNvZGVBdCgwKSA9PT0gMHgyRiAvKicvJyovKVxuICAgICAgICApO1xuICAgIHZhciBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKTtcblxuICAgIHZhciByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicztcblxuICAgIHZhciBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdChcIi9cIikgfHwgW107XG4gICAgdmFyIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdChcIi9cIikgfHwgW107XG4gICAgdmFyIHBzeWNob3RpYyA9IHJlc3VsdC5fcHJvdG9jb2wgJiYgIXNsYXNoUHJvdG9jb2xzW3Jlc3VsdC5fcHJvdG9jb2xdO1xuXG4gICAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAgIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gICAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgIHJlc3VsdC5fcG9ydCA9IC0xO1xuICAgICAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgICAgICAgIGlmIChzcmNQYXRoWzBdID09PSBcIlwiKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICAgICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lmhvc3QgPSBcIlwiO1xuICAgICAgICBpZiAocmVsYXRpdmUuX3Byb3RvY29sKSB7XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IFwiXCI7XG4gICAgICAgICAgICByZWxhdGl2ZS5fcG9ydCA9IC0xO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gXCJcIikgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gXCJcIiB8fCBzcmNQYXRoWzBdID09PSBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWxBYnMpIHtcbiAgICAgICAgLy8gaXRcInMgYWJzb2x1dGUuXG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCA/XG4gICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lID9cbiAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gICAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgICAgICAvLyBpdFwicyByZWxhdGl2ZVxuICAgICAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICAgICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgICAgIHNyY1BhdGgucG9wKCk7XG4gICAgICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICB9IGVsc2UgaWYgKHJlbGF0aXZlLnNlYXJjaCkge1xuICAgICAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgICAgIC8vIGxpa2UgaHJlZj1cIj9mb29cIi5cbiAgICAgICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoXCJtYWlsdG86bG9jYWwxQGRvbWFpbjFcIiwgXCJsb2NhbDJAZG9tYWluMlwiKVxuICAgICAgICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKFwiQFwiKSA+IDAgP1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KFwiQFwiKSA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICByZXN1bHQuX2hyZWYgPSBcIlwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgICAgICAvLyB3ZVwidmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAgICAgcmVzdWx0Ll9ocmVmID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gICAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gXCIuXCIgfHwgbGFzdCA9PT0gXCIuLlwiKSB8fFxuICAgICAgICBsYXN0ID09PSBcIlwiKTtcblxuICAgIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICAgIHZhciB1cCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICAgICAgaWYgKGxhc3QgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdXArKztcbiAgICAgICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB1cC0tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICAgIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgICAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdChcIi4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gXCJcIiAmJlxuICAgICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQ29kZUF0KDApICE9PSAweDJGIC8qJy8nKi8pKSB7XG4gICAgICAgIHNyY1BhdGgudW5zaGlmdChcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKFwiL1wiKS5zdWJzdHIoLTEpICE9PSBcIi9cIikpIHtcbiAgICAgICAgc3JjUGF0aC5wdXNoKFwiXCIpO1xuICAgIH1cblxuICAgIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gXCJcIiB8fFxuICAgICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJDb2RlQXQoMCkgPT09IDB4MkYgLyonLycqLyk7XG5cbiAgICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gXCJcIiA6XG4gICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6IFwiXCI7XG4gICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgLy91cmwucmVzb2x2ZU9iamVjdChcIm1haWx0bzpsb2NhbDFAZG9tYWluMVwiLCBcImxvY2FsMkBkb21haW4yXCIpXG4gICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZihcIkBcIikgPiAwID9cbiAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KFwiQFwiKSA6IGZhbHNlO1xuICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgICBzcmNQYXRoLnVuc2hpZnQoXCJcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5sZW5ndGggPT09IDAgPyBudWxsIDogc3JjUGF0aC5qb2luKFwiL1wiKTtcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5faHJlZiA9IFwiXCI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoXCJwdW55Y29kZVwiKTtcblVybC5wcm90b3R5cGUuX2hvc3RJZG5hID0gZnVuY3Rpb24gVXJsJF9ob3N0SWRuYShob3N0bmFtZSkge1xuICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICByZXR1cm4gcHVueWNvZGUudG9BU0NJSShob3N0bmFtZSk7XG59O1xuXG52YXIgZXNjYXBlUGF0aE5hbWUgPSBVcmwucHJvdG90eXBlLl9lc2NhcGVQYXRoTmFtZSA9XG5mdW5jdGlvbiBVcmwkX2VzY2FwZVBhdGhOYW1lKHBhdGhuYW1lKSB7XG4gICAgaWYgKCFjb250YWluc0NoYXJhY3RlcjIocGF0aG5hbWUsIDB4MjMgLyonIycqLywgMHgzRiAvKic/JyovKSkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vQXZvaWQgY2xvc3VyZSBjcmVhdGlvbiB0byBrZWVwIHRoaXMgaW5saW5hYmxlXG4gICAgcmV0dXJuIF9lc2NhcGVQYXRoKHBhdGhuYW1lKTtcbn07XG5cbnZhciBlc2NhcGVTZWFyY2ggPSBVcmwucHJvdG90eXBlLl9lc2NhcGVTZWFyY2ggPVxuZnVuY3Rpb24gVXJsJF9lc2NhcGVTZWFyY2goc2VhcmNoKSB7XG4gICAgaWYgKCFjb250YWluc0NoYXJhY3RlcjIoc2VhcmNoLCAweDIzIC8qJyMnKi8sIC0xKSkgcmV0dXJuIHNlYXJjaDtcbiAgICAvL0F2b2lkIGNsb3N1cmUgY3JlYXRpb24gdG8ga2VlcCB0aGlzIGlubGluYWJsZVxuICAgIHJldHVybiBfZXNjYXBlU2VhcmNoKHNlYXJjaCk7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZVByb3RvY29sID0gZnVuY3Rpb24gVXJsJF9wYXJzZVByb3RvY29sKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBkb0xvd2VyQ2FzZSA9IGZhbHNlO1xuICAgIHZhciBwcm90b2NvbENoYXJhY3RlcnMgPSB0aGlzLl9wcm90b2NvbENoYXJhY3RlcnM7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IHN0ci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICBpZiAoZG9Mb3dlckNhc2UpIHByb3RvY29sID0gcHJvdG9jb2wudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICAgICAgICByZXR1cm4gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdG9jb2xDaGFyYWN0ZXJzW2NoXSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGNoIDwgMHg2MSAvKidhJyovKVxuICAgICAgICAgICAgICAgIGRvTG93ZXJDYXNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiBzdGFydDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlQXV0aCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VBdXRoKHN0ciwgc3RhcnQsIGVuZCwgZGVjb2RlKSB7XG4gICAgdmFyIGF1dGggPSBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xuICAgIGlmIChkZWNvZGUpIHtcbiAgICAgICAgYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG4gICAgdGhpcy5hdXRoID0gYXV0aDtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlUG9ydCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VQb3J0KHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIC8vSW50ZXJuYWwgZm9ybWF0IGlzIGludGVnZXIgZm9yIG1vcmUgZWZmaWNpZW50IHBhcnNpbmdcbiAgICAvL2FuZCBmb3IgZWZmaWNpZW50IHRyaW1taW5nIG9mIGxlYWRpbmcgemVyb3NcbiAgICB2YXIgcG9ydCA9IDA7XG4gICAgLy9EaXN0aW5ndWlzaCBiZXR3ZWVuIDowIGFuZCA6IChubyBwb3J0IG51bWJlciBhdCBhbGwpXG4gICAgdmFyIGhhZENoYXJzID0gZmFsc2U7XG4gICAgdmFyIHZhbGlkUG9ydCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKDB4MzAgLyonMCcqLyA8PSBjaCAmJiBjaCA8PSAweDM5IC8qJzknKi8pIHtcbiAgICAgICAgICAgIHBvcnQgPSAoMTAgKiBwb3J0KSArIChjaCAtIDB4MzAgLyonMCcqLyk7XG4gICAgICAgICAgICBoYWRDaGFycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZFBvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qy8qJ1xcJyovIHx8IGNoID09PSAweDJGLyonLycqLykge1xuICAgICAgICAgICAgICAgIHZhbGlkUG9ydCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIGlmICgocG9ydCA9PT0gMCAmJiAhaGFkQ2hhcnMpIHx8ICF2YWxpZFBvcnQpIHtcbiAgICAgICAgaWYgKCF2YWxpZFBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcnQgPSAtMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICByZXR1cm4gaSAtIHN0YXJ0O1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VIb3N0ID1cbmZ1bmN0aW9uIFVybCRfcGFyc2VIb3N0KHN0ciwgc3RhcnQsIGVuZCwgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgICB2YXIgaG9zdEVuZGluZ0NoYXJhY3RlcnMgPSB0aGlzLl9ob3N0RW5kaW5nQ2hhcmFjdGVycztcbiAgICB2YXIgZmlyc3QgPSBzdHIuY2hhckNvZGVBdChzdGFydCk7XG4gICAgdmFyIHNlY29uZCA9IHN0ci5jaGFyQ29kZUF0KHN0YXJ0ICsgMSk7XG4gICAgaWYgKChmaXJzdCA9PT0gMHgyRiAvKicvJyovIHx8IGZpcnN0ID09PSAweDVDIC8qJ1xcJyovKSAmJlxuICAgICAgICAoc2Vjb25kID09PSAweDJGIC8qJy8nKi8gfHwgc2Vjb25kID09PSAweDVDIC8qJ1xcJyovKSkge1xuICAgICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuXG4gICAgICAgIC8vVGhlIHN0cmluZyBzdGFydHMgd2l0aCAvL1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vVGhlIHN0cmluZyBpcyBqdXN0IFwiLy9cIlxuICAgICAgICAgICAgaWYgKGVuZCA8IDIpIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIC8vSWYgc2xhc2hlcyBkbyBub3QgZGVub3RlIGhvc3QgYW5kIHRoZXJlIGlzIG5vIGF1dGgsXG4gICAgICAgICAgICAvL3RoZXJlIGlzIG5vIGhvc3Qgd2hlbiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIC8vXG4gICAgICAgICAgICB2YXIgaGFzQXV0aCA9XG4gICAgICAgICAgICAgICAgY29udGFpbnNDaGFyYWN0ZXIoc3RyLCAweDQwIC8qJ0AnKi8sIDIsIGhvc3RFbmRpbmdDaGFyYWN0ZXJzKTtcbiAgICAgICAgICAgIGlmICghaGFzQXV0aCAmJiAhc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1RoZXJlIGlzIGEgaG9zdCB0aGF0IHN0YXJ0cyBhZnRlciB0aGUgLy9cbiAgICAgICAgc3RhcnQgKz0gMjtcbiAgICB9XG4gICAgLy9JZiB0aGVyZSBpcyBubyBzbGFzaGVzLCB0aGVyZSBpcyBubyBob3N0bmFtZSBpZlxuICAgIC8vMS4gdGhlcmUgd2FzIG5vIHByb3RvY29sIGF0IGFsbFxuICAgIGVsc2UgaWYgKCF0aGlzLl9wcm90b2NvbCB8fFxuICAgICAgICAvLzIuIHRoZXJlIHdhcyBhIHByb3RvY29sIHRoYXQgcmVxdWlyZXMgc2xhc2hlc1xuICAgICAgICAvL2UuZy4gaW4gJ2h0dHA6YXNkJyAnYXNkJyBpcyBub3QgYSBob3N0bmFtZVxuICAgICAgICBzbGFzaFByb3RvY29sc1t0aGlzLl9wcm90b2NvbF1cbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cblxuICAgIHZhciBkb0xvd2VyQ2FzZSA9IGZhbHNlO1xuICAgIHZhciBpZG5hID0gZmFsc2U7XG4gICAgdmFyIGhvc3ROYW1lU3RhcnQgPSBzdGFydDtcbiAgICB2YXIgaG9zdE5hbWVFbmQgPSBlbmQ7XG4gICAgdmFyIGxhc3RDaCA9IC0xO1xuICAgIHZhciBwb3J0TGVuZ3RoID0gMDtcbiAgICB2YXIgY2hhcnNBZnRlckRvdCA9IDA7XG4gICAgdmFyIGF1dGhOZWVkc0RlY29kaW5nID0gZmFsc2U7XG5cbiAgICB2YXIgaiA9IC0xO1xuXG4gICAgLy9GaW5kIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYW4gQC1zaWduIHVudGlsIGhvc3RlbmRpbmcgY2hhcmFjdGVyIGlzIG1ldFxuICAgIC8vYWxzbyBtYXJrIGlmIGRlY29kaW5nIGlzIG5lZWRlZCBmb3IgdGhlIGF1dGggcG9ydGlvblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4NDAgLyonQCcqLykge1xuICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgLy9UaGlzIGNoZWNrIGlzIHZlcnksIHZlcnkgY2hlYXAuIFVubmVlZGVkIGRlY29kZVVSSUNvbXBvbmVudCBpcyB2ZXJ5XG4gICAgICAgIC8vdmVyeSBleHBlbnNpdmVcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IDB4MjUgLyonJScqLykge1xuICAgICAgICAgICAgYXV0aE5lZWRzRGVjb2RpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvc3RFbmRpbmdDaGFyYWN0ZXJzW2NoXSA9PT0gMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL0Atc2lnbiB3YXMgZm91bmQgYXQgaW5kZXggaiwgZXZlcnl0aGluZyB0byB0aGUgbGVmdCBmcm9tIGl0XG4gICAgLy9pcyBhdXRoIHBhcnRcbiAgICBpZiAoaiA+IC0xKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlQXV0aChzdHIsIHN0YXJ0LCBqIC0gMSwgYXV0aE5lZWRzRGVjb2RpbmcpO1xuICAgICAgICAvL2hvc3RuYW1lIHN0YXJ0cyBhZnRlciB0aGUgbGFzdCBALXNpZ25cbiAgICAgICAgc3RhcnQgPSBob3N0TmFtZVN0YXJ0ID0gaiArIDE7XG4gICAgfVxuXG4gICAgLy9Ib3N0IG5hbWUgaXMgc3RhcnRpbmcgd2l0aCBhIFtcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoc3RhcnQpID09PSAweDVCIC8qJ1snKi8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICAgIC8vQXNzdW1lIHZhbGlkIElQNiBpcyBiZXR3ZWVuIHRoZSBicmFja2V0c1xuICAgICAgICAgICAgaWYgKGNoID09PSAweDVEIC8qJ10nKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSArIDEpID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydExlbmd0aCA9IHRoaXMuX3BhcnNlUG9ydChzdHIsIGkgKyAyLCBlbmQpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGhvc3RuYW1lID0gc3RyLnNsaWNlKHN0YXJ0ICsgMSwgaSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gaG9zdG5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0ID0gdGhpcy5fcG9ydCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICBcIltcIiArIGhvc3RuYW1lICsgXCJdOlwiICsgdGhpcy5fcG9ydCA6XG4gICAgICAgICAgICAgICAgICAgIFwiW1wiICsgaG9zdG5hbWUgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gXCIvXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyBwb3J0TGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL0VtcHR5IGhvc3RuYW1lLCBbIHN0YXJ0cyBhIHBhdGhcbiAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICBpZiAoY2hhcnNBZnRlckRvdCA+IDYyKSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0ID0gc3RyLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gMHgzQSAvKic6JyovKSB7XG4gICAgICAgICAgICBwb3J0TGVuZ3RoID0gdGhpcy5fcGFyc2VQb3J0KHN0ciwgaSArIDEsIGVuZCkgKyAxO1xuICAgICAgICAgICAgaG9zdE5hbWVFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoIDwgMHg2MSAvKidhJyovKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDB4MkUgLyonLicqLykge1xuICAgICAgICAgICAgICAgIC8vTm9kZS5qcyBpZ25vcmVzIHRoaXMgZXJyb3JcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2ggPT09IERPVCB8fCBsYXN0Q2ggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3QgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY2hhcnNBZnRlckRvdCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoMHg0MSAvKidBJyovIDw9IGNoICYmIGNoIDw9IDB4NUEgLyonWicqLykge1xuICAgICAgICAgICAgICAgIGRvTG93ZXJDYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vVmFsaWQgY2hhcmFjdGVycyBvdGhlciB0aGFuIEFTQ0lJIGxldHRlcnMgLSwgXywgKywgMC05XG4gICAgICAgICAgICBlbHNlIGlmICghKGNoID09PSAweDJEIC8qJy0nKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2ggPT09IDB4NUYgLyonXycqLyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaCA9PT0gMHgyQiAvKicrJyovIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICgweDMwIC8qJzAnKi8gPD0gY2ggJiYgY2ggPD0gMHgzOSAvKic5JyovKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdEVuZGluZ0NoYXJhY3RlcnNbY2hdID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVyc1tjaF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlcGVuZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdE5hbWVFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA+PSAweDdCIC8qJ3snKi8pIHtcbiAgICAgICAgICAgIGlmIChjaCA8PSAweDdFIC8qJ34nKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbm9QcmVwZW5kU2xhc2hIb3N0RW5kZXJzW2NoXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVwZW5kU2xhc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBob3N0TmFtZUVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRuYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENoID0gY2g7XG4gICAgICAgIGNoYXJzQWZ0ZXJEb3QrKztcbiAgICB9XG5cbiAgICAvL05vZGUuanMgaWdub3JlcyB0aGlzIGVycm9yXG4gICAgLypcbiAgICBpZiAobGFzdENoID09PSBET1QpIHtcbiAgICAgICAgaG9zdE5hbWVFbmQtLTtcbiAgICB9XG4gICAgKi9cblxuICAgIGlmIChob3N0TmFtZUVuZCArIDEgIT09IHN0YXJ0ICYmXG4gICAgICAgIGhvc3ROYW1lRW5kIC0gaG9zdE5hbWVTdGFydCA8PSAyNTYpIHtcbiAgICAgICAgdmFyIGhvc3RuYW1lID0gc3RyLnNsaWNlKGhvc3ROYW1lU3RhcnQsIGhvc3ROYW1lRW5kICsgMSk7XG4gICAgICAgIGlmIChkb0xvd2VyQ2FzZSkgaG9zdG5hbWUgPSBob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaWRuYSkgaG9zdG5hbWUgPSB0aGlzLl9ob3N0SWRuYShob3N0bmFtZSk7XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSBob3N0bmFtZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gdGhpcy5fcG9ydCA+IDAgPyBob3N0bmFtZSArIFwiOlwiICsgdGhpcy5fcG9ydCA6IGhvc3RuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBob3N0TmFtZUVuZCArIDEgKyBwb3J0TGVuZ3RoO1xuXG59O1xuXG5VcmwucHJvdG90eXBlLl9jb3B5UHJvcHNUbyA9IGZ1bmN0aW9uIFVybCRfY29weVByb3BzVG8oaW5wdXQsIG5vUHJvdG9jb2wpIHtcbiAgICBpZiAoIW5vUHJvdG9jb2wpIHtcbiAgICAgICAgaW5wdXQuX3Byb3RvY29sID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgfVxuICAgIGlucHV0Ll9ocmVmID0gdGhpcy5faHJlZjtcbiAgICBpbnB1dC5fcG9ydCA9IHRoaXMuX3BvcnQ7XG4gICAgaW5wdXQuX3ByZXBlbmRTbGFzaCA9IHRoaXMuX3ByZXBlbmRTbGFzaDtcbiAgICBpbnB1dC5hdXRoID0gdGhpcy5hdXRoO1xuICAgIGlucHV0LnNsYXNoZXMgPSB0aGlzLnNsYXNoZXM7XG4gICAgaW5wdXQuaG9zdCA9IHRoaXMuaG9zdDtcbiAgICBpbnB1dC5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWU7XG4gICAgaW5wdXQuaGFzaCA9IHRoaXMuaGFzaDtcbiAgICBpbnB1dC5zZWFyY2ggPSB0aGlzLnNlYXJjaDtcbiAgICBpbnB1dC5wYXRobmFtZSA9IHRoaXMucGF0aG5hbWU7XG59O1xuXG5VcmwucHJvdG90eXBlLl9jbG9uZSA9IGZ1bmN0aW9uIFVybCRfY2xvbmUoKSB7XG4gICAgdmFyIHJldCA9IG5ldyBVcmwoKTtcbiAgICByZXQuX3Byb3RvY29sID0gdGhpcy5fcHJvdG9jb2w7XG4gICAgcmV0Ll9ocmVmID0gdGhpcy5faHJlZjtcbiAgICByZXQuX3BvcnQgPSB0aGlzLl9wb3J0O1xuICAgIHJldC5fcHJlcGVuZFNsYXNoID0gdGhpcy5fcHJlcGVuZFNsYXNoO1xuICAgIHJldC5hdXRoID0gdGhpcy5hdXRoO1xuICAgIHJldC5zbGFzaGVzID0gdGhpcy5zbGFzaGVzO1xuICAgIHJldC5ob3N0ID0gdGhpcy5ob3N0O1xuICAgIHJldC5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWU7XG4gICAgcmV0Lmhhc2ggPSB0aGlzLmhhc2g7XG4gICAgcmV0LnNlYXJjaCA9IHRoaXMuc2VhcmNoO1xuICAgIHJldC5wYXRobmFtZSA9IHRoaXMucGF0aG5hbWU7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblVybC5wcm90b3R5cGUuX2dldENvbXBvbmVudEVzY2FwZWQgPVxuZnVuY3Rpb24gVXJsJF9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgc3RhcnQsIGVuZCwgaXNBZnRlclF1ZXJ5KSB7XG4gICAgdmFyIGN1ciA9IHN0YXJ0O1xuICAgIHZhciBpID0gc3RhcnQ7XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgdmFyIGF1dG9Fc2NhcGVNYXAgPSBpc0FmdGVyUXVlcnkgP1xuICAgICAgICB0aGlzLl9hZnRlclF1ZXJ5QXV0b0VzY2FwZU1hcCA6IHRoaXMuX2F1dG9Fc2NhcGVNYXA7XG4gICAgZm9yICg7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBlc2NhcGVkID0gYXV0b0VzY2FwZU1hcFtjaF07XG5cbiAgICAgICAgaWYgKGVzY2FwZWQgIT09IFwiXCIgJiYgZXNjYXBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY3VyIDwgaSkgcmV0ICs9IHN0ci5zbGljZShjdXIsIGkpO1xuICAgICAgICAgICAgcmV0ICs9IGVzY2FwZWQ7XG4gICAgICAgICAgICBjdXIgPSBpICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VyIDwgaSArIDEpIHJldCArPSBzdHIuc2xpY2UoY3VyLCBpKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuVXJsLnByb3RvdHlwZS5fcGFyc2VQYXRoID1cbmZ1bmN0aW9uIFVybCRfcGFyc2VQYXRoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIHZhciBwYXRoU3RhcnQgPSBzdGFydDtcbiAgICB2YXIgcGF0aEVuZCA9IGVuZDtcbiAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgdmFyIGF1dG9Fc2NhcGVDaGFyYWN0ZXJzID0gdGhpcy5fYXV0b0VzY2FwZUNoYXJhY3RlcnM7XG4gICAgdmFyIHByZVBhdGggPSB0aGlzLl9wb3J0ID09PSAtMiA/IFwiLzpcIiA6IFwiXCI7XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICAgICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaCA9PT0gMHgyMyAvKicjJyovKSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VIYXNoKHN0ciwgaSwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgICAgIHBhdGhFbmQgPSBpIC0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAweDNGIC8qJz8nKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUXVlcnkoc3RyLCBpLCBlbmQsIGRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgICAgICAgICAgcGF0aEVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRpc2FibGVBdXRvRXNjYXBlQ2hhcnMgJiYgIWVzY2FwZSAmJiBhdXRvRXNjYXBlQ2hhcmFjdGVyc1tjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aFN0YXJ0ID4gcGF0aEVuZCkge1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gcHJlUGF0aCA9PT0gXCJcIiA/IFwiL1wiIDogcHJlUGF0aDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoO1xuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgcGF0aCA9IHRoaXMuX2dldENvbXBvbmVudEVzY2FwZWQoc3RyLCBwYXRoU3RhcnQsIHBhdGhFbmQsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhdGggPSBzdHIuc2xpY2UocGF0aFN0YXJ0LCBwYXRoRW5kICsgMSk7XG4gICAgfVxuICAgIHRoaXMucGF0aG5hbWUgPSBwcmVQYXRoID09PSBcIlwiXG4gICAgICAgID8gKHRoaXMuX3ByZXBlbmRTbGFzaCA/IFwiL1wiICsgcGF0aCA6IHBhdGgpXG4gICAgICAgIDogcHJlUGF0aCArIHBhdGg7XG59O1xuXG5VcmwucHJvdG90eXBlLl9wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24gVXJsJF9wYXJzZVF1ZXJ5KHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIHZhciBxdWVyeVN0YXJ0ID0gc3RhcnQ7XG4gICAgdmFyIHF1ZXJ5RW5kID0gZW5kO1xuICAgIHZhciBlc2NhcGUgPSBmYWxzZTtcbiAgICB2YXIgYXV0b0VzY2FwZUNoYXJhY3RlcnMgPSB0aGlzLl9hdXRvRXNjYXBlQ2hhcmFjdGVycztcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDB4MjMgLyonIycqLykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VIYXNoKHN0ciwgaSwgZW5kLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKTtcbiAgICAgICAgICAgIHF1ZXJ5RW5kID0gaSAtIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyAmJiAhZXNjYXBlICYmIGF1dG9Fc2NhcGVDaGFyYWN0ZXJzW2NoXSA9PT0gMSkge1xuICAgICAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChxdWVyeVN0YXJ0ID4gcXVlcnlFbmQpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBcIlwiO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXJ5O1xuICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgcXVlcnkgPSB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgcXVlcnlTdGFydCwgcXVlcnlFbmQsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVlcnkgPSBzdHIuc2xpY2UocXVlcnlTdGFydCwgcXVlcnlFbmQgKyAxKTtcbiAgICB9XG4gICAgdGhpcy5zZWFyY2ggPSBxdWVyeTtcbn07XG5cblVybC5wcm90b3R5cGUuX3BhcnNlSGFzaCA9IGZ1bmN0aW9uIFVybCRfcGFyc2VIYXNoKHN0ciwgc3RhcnQsIGVuZCwgZGlzYWJsZUF1dG9Fc2NhcGVDaGFycykge1xuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICB0aGlzLmhhc2ggPSBcIlwiO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5oYXNoID0gZGlzYWJsZUF1dG9Fc2NhcGVDaGFycyA/XG4gICAgICAgIHN0ci5zbGljZShzdGFydCwgZW5kICsgMSkgOiB0aGlzLl9nZXRDb21wb25lbnRFc2NhcGVkKHN0ciwgc3RhcnQsIGVuZCwgdHJ1ZSk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJwb3J0XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fcG9ydCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiXCIgKyB0aGlzLl9wb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gcGFyc2VJbnQodiwgMTApO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShVcmwucHJvdG90eXBlLCBcInF1ZXJ5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeTtcbiAgICAgICAgaWYgKHF1ZXJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2g7XG5cbiAgICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5jaGFyQ29kZUF0KDApID09PSAweDNGIC8qJz8nKi8pIHtcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBzZWFyY2guc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VhcmNoICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnkgPSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5ID0gdjtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8IFwiXCI7XG4gICAgICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgXCJcIjtcbiAgICAgICAgaWYgKHAgfHwgcykge1xuICAgICAgICAgICAgcmV0dXJuIHAgKyBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAocCA9PSBudWxsICYmIHMpID8gKFwiL1wiICsgcykgOiBudWxsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbigpIHt9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVybC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm90byA9IHRoaXMuX3Byb3RvY29sO1xuICAgICAgICByZXR1cm4gcHJvdG8gPyBwcm90byArIFwiOlwiIDogcHJvdG87XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gdi5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKHYuY2hhckNvZGVBdChlbmQpID09PSAweDNBIC8qJzonKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbCA9IHYuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVXJsLnByb3RvdHlwZSwgXCJocmVmXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHJlZiA9IHRoaXMuX2hyZWY7XG4gICAgICAgIGlmICghaHJlZikge1xuICAgICAgICAgICAgaHJlZiA9IHRoaXMuX2hyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBocmVmO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX2hyZWYgPSB2O1xuICAgIH1cbn0pO1xuXG5VcmwucGFyc2UgPSBmdW5jdGlvbiBVcmwkUGFyc2Uoc3RyLCBwYXJzZVF1ZXJ5U3RyaW5nLCBob3N0RGVub3Rlc1NsYXNoLCBkaXNhYmxlQXV0b0VzY2FwZUNoYXJzKSB7XG4gICAgaWYgKHN0ciBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHN0cjtcbiAgICB2YXIgcmV0ID0gbmV3IFVybCgpO1xuICAgIHJldC5wYXJzZShzdHIsICEhcGFyc2VRdWVyeVN0cmluZywgISFob3N0RGVub3Rlc1NsYXNoLCAhIWRpc2FibGVBdXRvRXNjYXBlQ2hhcnMpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG5VcmwuZm9ybWF0ID0gZnVuY3Rpb24gVXJsJEZvcm1hdChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvYmogPSBVcmwucGFyc2Uob2JqKTtcbiAgICB9XG4gICAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkge1xuICAgICAgICByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufTtcblxuVXJsLnJlc29sdmUgPSBmdW5jdGlvbiBVcmwkUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gICAgcmV0dXJuIFVybC5wYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn07XG5cblVybC5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gVXJsJFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICAgIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gICAgcmV0dXJuIFVybC5wYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn07XG5cbmZ1bmN0aW9uIF9lc2NhcGVQYXRoKHBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9lc2NhcGVTZWFyY2goc2VhcmNoKSB7XG4gICAgcmV0dXJuIHNlYXJjaC5yZXBsYWNlKC8jL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICAgIH0pO1xufVxuXG4vL1NlYXJjaCBgY2hhcjFgIChpbnRlZ2VyIGNvZGUgZm9yIGEgY2hhcmFjdGVyKSBpbiBgc3RyaW5nYFxuLy9zdGFydGluZyBmcm9tIGBmcm9tSW5kZXhgIGFuZCBlbmRpbmcgYXQgYHN0cmluZy5sZW5ndGggLSAxYFxuLy9vciB3aGVuIGEgc3RvcCBjaGFyYWN0ZXIgaXMgZm91bmRcbmZ1bmN0aW9uIGNvbnRhaW5zQ2hhcmFjdGVyKHN0cmluZywgY2hhcjEsIGZyb21JbmRleCwgc3RvcENoYXJhY3RlclRhYmxlKSB7XG4gICAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IGZyb21JbmRleDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gY2hhcjEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0b3BDaGFyYWN0ZXJUYWJsZVtjaF0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vU2VlIGlmIGBjaGFyMWAgb3IgYGNoYXIyYCAoaW50ZWdlciBjb2RlcyBmb3IgY2hhcmFjdGVycylcbi8vaXMgY29udGFpbmVkIGluIGBzdHJpbmdgXG5mdW5jdGlvbiBjb250YWluc0NoYXJhY3RlcjIoc3RyaW5nLCBjaGFyMSwgY2hhcjIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09IGNoYXIxIHx8IGNoID09PSBjaGFyMikgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy9NYWtlcyBhbiBhcnJheSBvZiAxMjggdWludDgncyB3aGljaCByZXByZXNlbnQgYm9vbGVhbiB2YWx1ZXMuXG4vL1NwZWMgaXMgYW4gYXJyYXkgb2YgYXNjaWkgY29kZSBwb2ludHMgb3IgYXNjaWkgY29kZSBwb2ludCByYW5nZXNcbi8vcmFuZ2VzIGFyZSBleHByZXNzZWQgYXMgW3N0YXJ0LCBlbmRdXG5cbi8vQ3JlYXRlIGEgdGFibGUgd2l0aCB0aGUgY2hhcmFjdGVycyAweDMwLTB4MzkgKGRlY2ltYWxzICcwJyAtICc5JykgYW5kXG4vLzB4N0EgKGxvd2VyY2FzZWxldHRlciAneicpIGFzIGB0cnVlYDpcbi8vXG4vL3ZhciBhID0gbWFrZUFzY2lpVGFibGUoW1sweDMwLCAweDM5XSwgMHg3QV0pO1xuLy9hWzB4MzBdOyAvLzFcbi8vYVsweDE1XTsgLy8wXG4vL2FbMHgzNV07IC8vMVxuZnVuY3Rpb24gbWFrZUFzY2lpVGFibGUoc3BlYykge1xuICAgIHZhciByZXQgPSBuZXcgVWludDhBcnJheSgxMjgpO1xuICAgIHNwZWMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXRbaXRlbV0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaXRlbVswXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpdGVtWzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmV0W2pdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuXG52YXIgYXV0b0VzY2FwZSA9IFtcIjxcIiwgXCI+XCIsIFwiXFxcIlwiLCBcImBcIiwgXCIgXCIsIFwiXFxyXCIsIFwiXFxuXCIsXG4gICAgXCJcXHRcIiwgXCJ7XCIsIFwifVwiLCBcInxcIiwgXCJcXFxcXCIsIFwiXlwiLCBcImBcIiwgXCInXCJdO1xuXG52YXIgYXV0b0VzY2FwZU1hcCA9IG5ldyBBcnJheSgxMjgpO1xuXG5cblxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF1dG9Fc2NhcGVNYXAubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBhdXRvRXNjYXBlTWFwW2ldID0gXCJcIjtcbn1cblxuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgYyA9IGF1dG9Fc2NhcGVbaV07XG4gICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChjKTtcbiAgICBpZiAoZXNjID09PSBjKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShjKTtcbiAgICB9XG4gICAgYXV0b0VzY2FwZU1hcFtjLmNoYXJDb2RlQXQoMCldID0gZXNjO1xufVxudmFyIGFmdGVyUXVlcnlBdXRvRXNjYXBlTWFwID0gYXV0b0VzY2FwZU1hcC5zbGljZSgpO1xuYXV0b0VzY2FwZU1hcFsweDVDIC8qJ1xcJyovXSA9IFwiL1wiO1xuXG52YXIgc2xhc2hQcm90b2NvbHMgPSBVcmwucHJvdG90eXBlLl9zbGFzaFByb3RvY29scyA9IHtcbiAgICBodHRwOiB0cnVlLFxuICAgIGh0dHBzOiB0cnVlLFxuICAgIGdvcGhlcjogdHJ1ZSxcbiAgICBmaWxlOiB0cnVlLFxuICAgIGZ0cDogdHJ1ZSxcblxuICAgIFwiaHR0cDpcIjogdHJ1ZSxcbiAgICBcImh0dHBzOlwiOiB0cnVlLFxuICAgIFwiZ29waGVyOlwiOiB0cnVlLFxuICAgIFwiZmlsZTpcIjogdHJ1ZSxcbiAgICBcImZ0cDpcIjogdHJ1ZVxufTtcblxuLy9PcHRpbWl6ZSBiYWNrIGZyb20gbm9ybWFsaXplZCBvYmplY3QgY2F1c2VkIGJ5IG5vbi1pZGVudGlmaWVyIGtleXNcbmZ1bmN0aW9uIGYoKXt9XG5mLnByb3RvdHlwZSA9IHNsYXNoUHJvdG9jb2xzO1xuXG5VcmwucHJvdG90eXBlLl9wcm90b2NvbENoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShbXG4gICAgWzB4NjEgLyonYScqLywgMHg3QSAvKid6JyovXSxcbiAgICBbMHg0MSAvKidBJyovLCAweDVBIC8qJ1onKi9dLFxuICAgIDB4MkUgLyonLicqLywgMHgyQiAvKicrJyovLCAweDJEIC8qJy0nKi9cbl0pO1xuXG5VcmwucHJvdG90eXBlLl9ob3N0RW5kaW5nQ2hhcmFjdGVycyA9IG1ha2VBc2NpaVRhYmxlKFtcbiAgICAweDIzIC8qJyMnKi8sIDB4M0YgLyonPycqLywgMHgyRiAvKicvJyovLCAweDVDIC8qJ1xcJyovXG5dKTtcblxuVXJsLnByb3RvdHlwZS5fYXV0b0VzY2FwZUNoYXJhY3RlcnMgPSBtYWtlQXNjaWlUYWJsZShcbiAgICBhdXRvRXNjYXBlLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2LmNoYXJDb2RlQXQoMCk7XG4gICAgfSlcbik7XG5cbi8vSWYgdGhlc2UgY2hhcmFjdGVycyBlbmQgYSBob3N0IG5hbWUsIHRoZSBwYXRoIHdpbGwgbm90IGJlIHByZXBlbmRlZCBhIC9cblVybC5wcm90b3R5cGUuX25vUHJlcGVuZFNsYXNoSG9zdEVuZGVycyA9IG1ha2VBc2NpaVRhYmxlKFxuICAgIFtcbiAgICAgICAgXCI8XCIsIFwiPlwiLCBcIidcIiwgXCJgXCIsIFwiIFwiLCBcIlxcclwiLFxuICAgICAgICBcIlxcblwiLCBcIlxcdFwiLCBcIntcIiwgXCJ9XCIsIFwifFwiLFxuICAgICAgICBcIl5cIiwgXCJgXCIsIFwiXFxcIlwiLCBcIiVcIiwgXCI7XCJcbiAgICBdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2LmNoYXJDb2RlQXQoMCk7XG4gICAgfSlcbik7XG5cblVybC5wcm90b3R5cGUuX2F1dG9Fc2NhcGVNYXAgPSBhdXRvRXNjYXBlTWFwO1xuVXJsLnByb3RvdHlwZS5fYWZ0ZXJRdWVyeUF1dG9Fc2NhcGVNYXAgPSBhZnRlclF1ZXJ5QXV0b0VzY2FwZU1hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG5cblVybC5yZXBsYWNlID0gZnVuY3Rpb24gVXJsJFJlcGxhY2UoKSB7XG4gICAgcmVxdWlyZS5jYWNoZS51cmwgPSB7XG4gICAgICAgIGV4cG9ydHM6IFVybFxuICAgIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmFzdC11cmwtcGFyc2VyL3NyYy91cmxwYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgUGV0a2EgQW50b25vdlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6PC9wPlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgUXVlcnlTdHJpbmdTZXJpYWxpemVyID0gcmVxdWlyZShcIi4vcXVlcnlzdHJpbmdzZXJpYWxpemVyLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBRdWVyeVN0cmluZ1BhcnNlcjtcblxudmFyIHJwbHVzID0gL1xcKy9nO1xudmFyIHJpbnQgPSAvXlswLTldKyQvO1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xudmFyIGhhdmVQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyKCkge1xuICAgIHRoaXMuY29udGFpbnNTcGFyc2UgPSBmYWxzZTtcbiAgICB0aGlzLmNhY2hlS2V5ID0gXCJcIjtcbiAgICB0aGlzLmNhY2hlVmFsID0gbnVsbDtcbn1cblxuUXVlcnlTdHJpbmdQYXJzZXIubWF4TGVuZ3RoID0gMzI3Njg7XG5RdWVyeVN0cmluZ1BhcnNlci5tYXhEZXB0aCA9IDQ7XG5RdWVyeVN0cmluZ1BhcnNlci5tYXhLZXlzID0gMjU2O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIFF1ZXJ5U3RyaW5nUGFyc2VyJFBhcnNlKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBtYXhMZW5ndGggPSBRdWVyeVN0cmluZ1BhcnNlci5tYXhMZW5ndGg7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICAgICBcInN0ciBpcyB0b28gbGFyZ2UgKFwiICtcbiAgICAgICAgICAgICAgICBcIlF1ZXJ5U3RyaW5nUGFyc2VyLm1heExlbmd0aD1cIiArIG1heExlbmd0aCArIFwiKVwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgUXVlcnlTdHJpbmdQYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZVN0cmluZyhzdHIsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RyICE9PSBudWxsICYmIHR5cGVvZiBzdHIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBRdWVyeVN0cmluZ1BhcnNlcigpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlT2JqZWN0KHN0cik7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnN0cmluZ2lmeSA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRTdHJpbmdpZnkodmFsdWUpIHtcbiAgICB2YXIgc2VyaWFsaXplciA9IG5ldyBRdWVyeVN0cmluZ1NlcmlhbGl6ZXIoKTtcbiAgICByZXR1cm4gc2VyaWFsaXplci5zZXJpYWxpemUodmFsdWUpO1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLmRlY29kZSA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRkZWNvZGUoc3RyLCBzaG91bGREZWNvZGUsIGNvbnRhaW5zUGx1cykge1xuICAgIGlmIChzaG91bGREZWNvZGUgPT09IGZhbHNlKSByZXR1cm4gc3RyO1xuICAgIGlmIChjb250YWluc1BsdXMgPT09IHRydWUpIHN0ciA9IHN0ci5yZXBsYWNlKHJwbHVzLCBcIiBcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5tYXliZUFycmF5SW5kZXggPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkbWF5YmVBcnJheUluZGV4KHN0ciwgYXJyYXlMZW5ndGgpIHtcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhcnJheUxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGNoID0gc3RyLmNoYXJDb2RlQXQoMCk7XG5cbiAgICBpZiAoY2ggPT09IDQ4KSB7XG4gICAgICAgIHJldHVybiBsZW4gPiAxID8gLTEgOiAwO1xuICAgIH1cbiAgICBlbHNlIGlmICg0OCA8PSBjaCAmJiBjaCA8PSA1Nykge1xuICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2ggLSA0ODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyaW50LnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdmFyIHYgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICAgICAgICAgIGlmICgwIDwgdiAmJiB2IDw9IDEwNzM3NDE4MjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUuZ2V0U2xvdCA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRnZXRTbG90KGRpY3Rpb25hcnksIHByZXZLZXksIGN1cktleSkge1xuICAgIHZhciBzbG90O1xuICAgIGlmICghKGhhdmVQcm9wLmNhbGwoZGljdGlvbmFyeSwgcHJldktleSkpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubWF5YmVBcnJheUluZGV4KGN1cktleSwgMCk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBzbG90ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzbG90ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGljdGlvbmFyeVtwcmV2S2V5XSA9IHNsb3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzbG90ID0gZGljdGlvbmFyeVtwcmV2S2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHNsb3Q7XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUucGxhY2VOZXN0ZWRWYWx1ZSA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRwbGFjZU5lc3RlZFZhbHVlXG4oZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgaSwgcHJldktleSwgY3VyS2V5KSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLmdldFNsb3QoZGljdGlvbmFyeSwgcHJldktleSwgY3VyS2V5KTtcbiAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgIGlmIChpc0FycmF5KHNsb3QpKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5tYXliZUFycmF5SW5kZXgoY3VyS2V5LCBzbG90Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGtleS5sZW5ndGg7XG4gICAgdmFyIGRlcHRoID0gMjtcbiAgICB2YXIgbWF4RGVwdGggPSBRdWVyeVN0cmluZ1BhcnNlci5tYXhEZXB0aDtcbiAgICB2YXIgc3RhcnQgPSAtMTtcbiAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHZhciBjaCA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2ggPT09IDkxKSB7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSA5MyAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIHByZXZLZXkgPSBjdXJLZXk7XG4gICAgICAgICAgICBjdXJLZXkgPSBzdGFydCA9PT0gaSA/IFwiXCIgOiBrZXkuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gLTE7XG4gICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgaWYgKGRlcHRoID4gbWF4RGVwdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5lc3RpbmcgZGVwdGggb2Yga2V5cyBpcyB0b28gbGFyZ2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIihRdWVyeVN0cmluZ1BhcnNlci5tYXhEZXB0aD1cIittYXhEZXB0aCtcIilcIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2xvdCA9IHRoaXMuZ2V0U2xvdChzbG90LCBwcmV2S2V5LCBjdXJLZXkpO1xuXG4gICAgICAgICAgICBpbmRleCA9IGlzQXJyYXkoc2xvdClcbiAgICAgICAgICAgICAgICA/IHRoaXMubWF5YmVBcnJheUluZGV4KGN1cktleSwgc2xvdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKGluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHNsb3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbnNTcGFyc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNsb3RbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHNsb3QsIGN1cktleSwgdmFsdWUpO1xuICAgIH1cbn07XG5cblF1ZXJ5U3RyaW5nUGFyc2VyLnByb3RvdHlwZS5pbnNlcnQgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkaW5zZXJ0KGRpY3Rpb25hcnksIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICBpZiAoaGF2ZVByb3AuY2FsbChkaWN0aW9uYXJ5LCBrZXkpKSB7XG4gICAgICAgIHZhciBwcmV2ID0gZGljdGlvbmFyeVtrZXldO1xuICAgICAgICBpZiggaXNBcnJheShwcmV2KSApIHtcbiAgICAgICAgICAgIHByZXYucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gW3ByZXYsIHZhbHVlXTtcbiAgICAgICAgICAgIGRpY3Rpb25hcnlba2V5XSA9IHJldDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGljdGlvbmFyeVtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUucHVzaCA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRwdXNoKGRpY3Rpb25hcnksIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgcmV0ID0gbnVsbDtcbiAgICBpZiAoaGF2ZVByb3AuY2FsbChkaWN0aW9uYXJ5LCBrZXkpKSB7XG4gICAgICAgIHZhciBwcmV2ID0gZGljdGlvbmFyeVtrZXldO1xuICAgICAgICBwcmV2LnB1c2godmFsdWUpO1xuICAgICAgICByZXQgPSBwcmV2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0ID0gW3ZhbHVlXTtcbiAgICAgICAgZGljdGlvbmFyeVtrZXldID0gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLm1heWJlUGxhY2VOZXN0ZWRWYWx1ZSA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRtYXliZVBsYWNlTmVzdGVkVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGlmIChrZXkuY2hhckNvZGVBdChsZW4gLSAxKSAhPT0gOTMpIHtcbiAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc3RhcnQgPSAtMTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgY3VyS2V5O1xuICAgIHZhciBwcmV2S2V5O1xuXG4gICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBrZXkuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDkxKSB7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgcHJldktleSA9IGtleS5zbGljZSgwLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gOTMpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cktleSA9IHN0YXJ0ID09PSBpID8gXCJcIiA6IGtleS5zbGljZShzdGFydCwgaSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJLZXkgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLnBsYWNlVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cktleSA9PT0gXCJcIiAmJiB2YWx1ZSAhPT0gXCJcIiAmJiBpID09PSBsZW4pIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdGhpcy5jYWNoZUtleSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZVZhbC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVLZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlVmFsID0gdGhpcy5wdXNoKGRpY3Rpb25hcnksIHByZXZLZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5wbGFjZU5lc3RlZFZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIGksIHByZXZLZXksIGN1cktleSk7XG4gICAgfVxufTtcblxuUXVlcnlTdHJpbmdQYXJzZXIucHJvdG90eXBlLnBsYWNlVmFsdWUgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcGxhY2VWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlLCBwb3NzaWJseU5lc3RlZCkge1xuICAgIGlmIChwb3NzaWJseU5lc3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUGxhY2VOZXN0ZWRWYWx1ZShkaWN0aW9uYXJ5LCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSB0aGlzLmNhY2hlS2V5KSB7XG4gICAgICAgIHRoaXMuY2FjaGVWYWwucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gdGhpcy5pbnNlcnQoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSk7XG4gICAgaWYgKGNhY2hlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2FjaGVLZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuY2FjaGVWYWwgPSBjYWNoZTtcbiAgICB9XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUuY29tcGFjdCA9XG5mdW5jdGlvbiBRdWVyeVN0cmluZ1BhcnNlciRjb21wYWN0KG9iaikge1xuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciggdmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpICkge1xuICAgICAgICAgICAgcmV0LnB1c2gob2JqW2tleXNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kgKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIG9ialtrZXldID0gdGhpcy5jb21wYWN0KG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VPYmplY3QgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcGFyc2VPYmplY3Qob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGVuLS07XG4gICAgdmFyIHJldCA9IFwiXCI7XG4gICAgdmFyIGtleTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGxlbjsgKytpICkge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXQgKz0ga2V5ICsgXCI9XCIgKyBvYmpba2V5XSArIFwiJlwiO1xuICAgIH1cbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHJldCArPSBrZXkgKyBcIj1cIiArIG9ialtrZXldO1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKHJldCwgdHJ1ZSk7XG59O1xuXG5RdWVyeVN0cmluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPVxuZnVuY3Rpb24gUXVlcnlTdHJpbmdQYXJzZXIkcGFyc2VTdHJpbmcoc3RyLCBub0RlY29kZSkge1xuICAgIHZhciBtYXhLZXlzID0gUXVlcnlTdHJpbmdQYXJzZXIubWF4S2V5cztcbiAgICB2YXIga2V5cyA9IDA7XG4gICAgdmFyIGRlY29kZUtleSA9IGZhbHNlO1xuICAgIHZhciBkZWNvZGVWYWx1ZSA9IGZhbHNlO1xuICAgIHZhciBwb3NzaWJseU5lc3RlZCA9IGZhbHNlO1xuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZGljdGlvbmFyeSA9IHt9O1xuICAgIHZhciBrZXlTdGFydCA9IDA7XG4gICAgdmFyIGtleUVuZCA9IDA7XG4gICAgdmFyIHZhbHVlU3RhcnQgPSAwO1xuICAgIHZhciB2YWx1ZUVuZCA9IDA7XG4gICAgdmFyIGxlZnQgPSAwO1xuICAgIHZhciBsYXN0SW5kZXggPSBsZW4gLSAxO1xuICAgIHZhciBjb250YWluc1BsdXMgPSBmYWxzZTtcblxuXG4gICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgY2ggPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoY2ggPT09IDkxKSB7XG4gICAgICAgICAgICBsZWZ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVmdCA+IDAgJiYgY2ggPT09IDkzKSB7XG4gICAgICAgICAgICBwb3NzaWJseU5lc3RlZCA9IHRydWU7XG4gICAgICAgICAgICBsZWZ0LS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVmdCA9PT0gMCAmJiBjaCA9PT0gNjEpIHtcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG5cbiAgICAgICAgICAgIGtleUVuZCA9IGkgLSAxO1xuICAgICAgICAgICAgdmFsdWVFbmQgPSB2YWx1ZVN0YXJ0ID0gajtcbiAgICAgICAgICAgIHZhciBrZXkgPSBzdHIuc2xpY2Uoa2V5U3RhcnQsIGtleUVuZCArIDEpO1xuICAgICAgICAgICAga2V5ID0gdGhpcy5kZWNvZGUoa2V5LCBkZWNvZGVLZXksIGNvbnRhaW5zUGx1cyk7XG4gICAgICAgICAgICBkZWNvZGVLZXkgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICg7IGogPCBsZW47ICsraikge1xuICAgICAgICAgICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKChjaCA9PT0gNDMgfHwgY2ggPT09IDM3KSAmJiAhbm9EZWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0MykgY29udGFpbnNQbHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDM4IHx8IGogPT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUVuZCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBqO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gMzgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRW5kLS07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHIuc2xpY2UodmFsdWVTdGFydCwgdmFsdWVFbmQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmRlY29kZSh2YWx1ZSwgZGVjb2RlVmFsdWUsIGNvbnRhaW5zUGx1cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGFjZVZhbHVlKGRpY3Rpb25hcnksIGtleSwgdmFsdWUsIHBvc3NpYmx5TmVzdGVkKTtcblxuICAgICAgICAgICAgICAgICAgICBjb250YWluc1BsdXMgPSBkZWNvZGVWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwb3NzaWJseU5lc3RlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGtleVN0YXJ0ID0gaiArIDE7XG4gICAgICAgICAgICAgICAgICAgIGtleXMrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXMgPiBtYXhLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFtb3VudCBvZiBrZXlzIGlzIHRvbyBsYXJnZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoUXVlcnlTdHJpbmdQYXJzZXIubWF4S2V5cz1cIiArIG1heEtleXMgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjaCA9PT0gNDMgfHwgY2ggPT09IDM3KSAmJiAhbm9EZWNvZGUpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gNDMpIGNvbnRhaW5zUGx1cyA9IHRydWU7XG4gICAgICAgICAgICBkZWNvZGVLZXkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlTdGFydCAhPT0gbGVuKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIHZhciBrZXkgPSBzdHIuc2xpY2Uoa2V5U3RhcnQsIGxlbik7XG4gICAgICAgIGtleSA9IHRoaXMuZGVjb2RlKGtleSwgZGVjb2RlS2V5LCBjb250YWluc1BsdXMpO1xuICAgICAgICB0aGlzLnBsYWNlVmFsdWUoZGljdGlvbmFyeSwga2V5LCB2YWx1ZSwgcG9zc2libHlOZXN0ZWQpO1xuICAgIH1cblxuXG4gICAgaWYgKHRoaXMuY29udGFpbnNTcGFyc2UpIHtcbiAgICAgICAgdGhpcy5jb21wYWN0KGRpY3Rpb25hcnkpO1xuICAgIH1cblxuICAgIHJldHVybiBkaWN0aW9uYXJ5O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5ncGFyc2VyL2pzL3F1ZXJ5c3RyaW5ncGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgUGV0a2EgQW50b25vdlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6PC9wPlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5U3RyaW5nU2VyaWFsaXplcjtcbnZhciBlbmMgPSBlbmNvZGVVUklDb21wb25lbnQ7XG52YXIgQVJSQVkgPSBbXTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvUHJvdG8gPSBnZXRQcm90byh7fSk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwcm90byA9IGdldFByb3RvKG9iaik7XG5cbiAgICByZXR1cm4gcHJvdG8gPT09IG9Qcm90byB8fCBwcm90byA9PT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gUXVlcnlTdHJpbmdTZXJpYWxpemVyKCkge1xuXG59XG5cblF1ZXJ5U3RyaW5nU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID1cbmZ1bmN0aW9uIFF1ZXJ5U3RyaW5nU2VyaWFsaXplciRzZXJpYWxpemUob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGUgb2JqIHRvIHN0cmluZ2lmeSBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgYXJyYXkgPSBBUlJBWTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgdmFyIGN1ciA9IG9iajtcbiAgICB2YXIga2V5UHJlZml4ID0gXCJcIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMgPT09IGFycmF5ID8gaSA6IGtleXNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGN1cltrZXldO1xuICAgICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGtleVByZWZpeCwgY3VyLCBrZXlzLCBsZW4sIGkpO1xuXG4gICAgICAgICAgICBpZiAoa2V5UHJlZml4ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAga2V5UHJlZml4ID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5UHJlZml4ID0ga2V5UHJlZml4ICsgXCJbXCIgKyBlbmMoa2V5KSArIFwiXVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBrZXlzID0gYXJyYXk7XG4gICAgICAgICAgICAgICAgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIGN1ciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZEtleSA9IGtleVByZWZpeCA9PT0gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVuYyhrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoga2V5UHJlZml4ICsgXCJbXCIgKyBlbmMoa2V5KSArIFwiXVwiO1xuICAgICAgICAgICAgcmV0LnB1c2goc2VyaWFsaXplZEtleSArIFwiPVwiICsgZW5jKHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihpID09PSBsZW4gLSAxICYmIHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxlbiA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAga2V5cyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY3VyID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBrZXlQcmVmaXggPSBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQuam9pbihcIiZcIik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdwYXJzZXIvanMvcXVlcnlzdHJpbmdzZXJpYWxpemVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXRzTG9hZGVyID0gcmVxdWlyZSgnLi9ncm91cCcpO1xuYXNzZXRzTG9hZGVyLnN0YXRzID0gcmVxdWlyZSgnLi9zdGF0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2V0c0xvYWRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlci5qcycpO1xudmFyIGNyZWF0ZUxvYWRlciA9IHJlcXVpcmUoJy4vbG9hZGVyJyk7XG52YXIgYXV0b0lkID0gMDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVHcm91cChjb25maWcpIHtcbiAgICB2YXIgZ3JvdXA7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIHZhciBhc3NldHMgPSBbXTtcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgbnVtTG9hZGVkID0gMDtcbiAgICB2YXIgbnVtVG90YWwgPSAwO1xuICAgIHZhciBsb2FkZXJzID0ge307XG5cbiAgICB2YXIgYWRkID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAvLyBjb25zb2xlLmRlYnVnKCdhZGQnLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZm9yRWFjaChhZGQpO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpc0dyb3VwID0gISFvcHRpb25zLmFzc2V0cyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYXNzZXRzKTtcbiAgICAgICAgLy8gY29uc29sZS5kZWJ1ZygnaXNHcm91cCcsIGlzR3JvdXApO1xuICAgICAgICB2YXIgbG9hZGVyO1xuICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgbG9hZGVyID0gY3JlYXRlR3JvdXAoY29uZmlndXJlKG9wdGlvbnMsIGNvbmZpZykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZGVyID0gY3JlYXRlTG9hZGVyKGNvbmZpZ3VyZShvcHRpb25zLCBjb25maWcpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIub25jZSgnZGVzdHJveScsIGRlc3Ryb3lIYW5kbGVyKTtcbiAgICAgICAgcXVldWUucHVzaChsb2FkZXIpO1xuICAgICAgICBsb2FkZXJzW2xvYWRlci5pZF0gPSBsb2FkZXI7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xuXG4gICAgdmFyIGdldCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwW2lkXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcFtpZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRlcnNbaWRdO1xuICAgIH07XG5cbiAgICB2YXIgZmluZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIGlmIChnZXQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KGlkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm91bmQgPSBudWxsO1xuICAgICAgICBPYmplY3Qua2V5cyhsb2FkZXJzKS5zb21lKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZm91bmQgPSBsb2FkZXJzW2tleV0uZmluZCAmJiBsb2FkZXJzW2tleV0uZmluZChpZCk7XG4gICAgICAgICAgICByZXR1cm4gISFmb3VuZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICByZXR1cm4gdXJsICYmIHVybC5zcGxpdCgnPycpWzBdLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbmZpZ3VyZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmlzVG91Y2hMb2NrZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5pc1RvdWNoTG9ja2VkID0gZGVmYXVsdHMuaXNUb3VjaExvY2tlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmJsb2IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5ibG9iID0gZGVmYXVsdHMuYmxvYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmJhc2VQYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYmFzZVBhdGggPSBkZWZhdWx0cy5iYXNlUGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuaWQgPSBvcHRpb25zLmlkIHx8IG9wdGlvbnMudXJsIHx8IFN0cmluZygrK2F1dG9JZCk7XG4gICAgICAgIG9wdGlvbnMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCBnZXRFeHRlbnNpb24ob3B0aW9ucy51cmwpO1xuICAgICAgICBvcHRpb25zLmNyb3NzT3JpZ2luID0gb3B0aW9ucy5jcm9zc09yaWdpbiB8fCBkZWZhdWx0cy5jcm9zc09yaWdpbjtcbiAgICAgICAgb3B0aW9ucy53ZWJBdWRpb0NvbnRleHQgPSBvcHRpb25zLndlYkF1ZGlvQ29udGV4dCB8fCBkZWZhdWx0cy53ZWJBdWRpb0NvbnRleHQ7XG4gICAgICAgIG9wdGlvbnMubG9nID0gZGVmYXVsdHMubG9nO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH07XG5cbiAgICB2YXIgc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbnVtVG90YWwgPSBxdWV1ZS5sZW5ndGg7XG5cbiAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbihsb2FkZXIpIHtcbiAgICAgICAgICAgIGxvYWRlclxuICAgICAgICAgICAgICAgIC5vbigncHJvZ3Jlc3MnLCBwcm9ncmVzc0hhbmRsZXIpXG4gICAgICAgICAgICAgICAgLm9uY2UoJ2NvbXBsZXRlJywgY29tcGxldGVIYW5kbGVyKVxuICAgICAgICAgICAgICAgIC5vbmNlKCdlcnJvcicsIGVycm9ySGFuZGxlcilcbiAgICAgICAgICAgICAgICAuc3RhcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcXVldWUgPSBbXTtcblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfTtcblxuICAgIHZhciBwcm9ncmVzc0hhbmRsZXIgPSBmdW5jdGlvbihwcm9ncmVzcykge1xuICAgICAgICB2YXIgbG9hZGVkID0gbnVtTG9hZGVkICsgcHJvZ3Jlc3M7XG4gICAgICAgIGdyb3VwLmVtaXQoJ3Byb2dyZXNzJywgbG9hZGVkIC8gbnVtVG90YWwpO1xuICAgIH07XG5cbiAgICB2YXIgY29tcGxldGVIYW5kbGVyID0gZnVuY3Rpb24oYXNzZXQsIGlkLCB0eXBlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzc2V0KSkge1xuICAgICAgICAgICAgYXNzZXQgPSB7IGlkOiBpZCwgZmlsZTogYXNzZXQsIHR5cGU6IHR5cGUgfTtcbiAgICAgICAgfVxuICAgICAgICBudW1Mb2FkZWQrKztcbiAgICAgICAgZ3JvdXAuZW1pdCgncHJvZ3Jlc3MnLCBudW1Mb2FkZWQgLyBudW1Ub3RhbCk7XG4gICAgICAgIG1hcFthc3NldC5pZF0gPSBhc3NldC5maWxlO1xuICAgICAgICBhc3NldHMucHVzaChhc3NldCk7XG4gICAgICAgIGdyb3VwLmVtaXQoJ2NoaWxkY29tcGxldGUnLCBhc3NldCk7XG4gICAgICAgIGNoZWNrQ29tcGxldGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICBudW1Ub3RhbC0tO1xuICAgICAgICBpZiAoZ3JvdXAubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgICAgICAgICAgZ3JvdXAuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ29tcGxldGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIGRlc3Ryb3lIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgbG9hZGVyc1tpZF0gPSBudWxsO1xuICAgICAgICBkZWxldGUgbG9hZGVyc1tpZF07XG5cbiAgICAgICAgbWFwW2lkXSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBtYXBbaWRdO1xuXG4gICAgICAgIGFzc2V0cy5zb21lKGZ1bmN0aW9uKGFzc2V0LCBpKSB7XG4gICAgICAgICAgICBpZiAoYXNzZXQuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgYXNzZXRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjaGVja0NvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChudW1Mb2FkZWQgPj0gbnVtVG90YWwpIHtcbiAgICAgICAgICAgIGdyb3VwLmVtaXQoJ2NvbXBsZXRlJywgYXNzZXRzLCBtYXAsIGNvbmZpZy5pZCwgJ2dyb3VwJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcXVldWUucG9wKCkuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwLm9mZignZXJyb3InKTtcbiAgICAgICAgZ3JvdXAub2ZmKCdwcm9ncmVzcycpO1xuICAgICAgICBncm91cC5vZmYoJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFzc2V0cyA9IFtdO1xuICAgICAgICBtYXAgPSB7fTtcbiAgICAgICAgY29uZmlnLndlYkF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgICAgIG51bVRvdGFsID0gMDtcbiAgICAgICAgbnVtTG9hZGVkID0gMDtcblxuICAgICAgICBPYmplY3Qua2V5cyhsb2FkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgbG9hZGVyc1trZXldLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvYWRlcnMgPSB7fTtcblxuICAgICAgICBncm91cC5lbWl0KCdkZXN0cm95JywgZ3JvdXAuaWQpO1xuXG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xuXG4gICAgLy8gZW1pdHM6IHByb2dyZXNzLCBlcnJvciwgY29tcGxldGUsIGRlc3Ryb3lcblxuICAgIGdyb3VwID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSwge1xuICAgICAgICBfZXZlbnRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSxcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkOiB7XG4gICAgICAgICAgICB2YWx1ZTogYWRkXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB2YWx1ZTogc3RhcnRcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiB7XG4gICAgICAgICAgICB2YWx1ZTogZ2V0XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmaW5kXG4gICAgICAgIH0sXG4gICAgICAgIGdldExvYWRlcjoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlcnNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsb2FkZWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bUxvYWRlZCA+PSBudW1Ub3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiB7XG4gICAgICAgICAgICB2YWx1ZTogZGVzdHJveVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25maWcgPSBjb25maWd1cmUoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIGJhc2VQYXRoOiAnJyxcbiAgICAgICAgYmxvYjogZmFsc2UsXG4gICAgICAgIHRvdWNoTG9ja2VkOiBmYWxzZSxcbiAgICAgICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgICAgIHdlYkF1ZGlvQ29udGV4dDogbnVsbCxcbiAgICAgICAgbG9nOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLmFzc2V0cykpIHtcbiAgICAgICAgYWRkKGNvbmZpZy5hc3NldHMpO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGdyb3VwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9ncm91cC5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnLi9lbWl0dGVyLmpzJyk7XG52YXIgYnJvd3Nlckhhc0Jsb2IgPSByZXF1aXJlKCcuL2Jyb3dzZXItaGFzLWJsb2IuanMnKTtcbnZhciBzdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGlkID0gb3B0aW9ucy5pZDtcbiAgICB2YXIgYmFzZVBhdGggPSBvcHRpb25zLmJhc2VQYXRoIHx8ICcnO1xuICAgIHZhciB1cmwgPSBvcHRpb25zLnVybDtcbiAgICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICB2YXIgY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luO1xuICAgIHZhciBpc1RvdWNoTG9ja2VkID0gb3B0aW9ucy5pc1RvdWNoTG9ja2VkO1xuICAgIHZhciBibG9iID0gb3B0aW9ucy5ibG9iICYmIGJyb3dzZXJIYXNCbG9iO1xuICAgIHZhciB3ZWJBdWRpb0NvbnRleHQgPSBvcHRpb25zLndlYkF1ZGlvQ29udGV4dDtcbiAgICB2YXIgbG9nID0gb3B0aW9ucy5sb2c7XG5cbiAgICB2YXIgbG9hZGVyO1xuICAgIHZhciBsb2FkSGFuZGxlcjtcbiAgICB2YXIgcmVxdWVzdDtcbiAgICB2YXIgc3RhcnRUaW1lO1xuICAgIHZhciB0aW1lb3V0O1xuICAgIHZhciBmaWxlO1xuXG4gICAgdmFyIHN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBsb2FkSlNPTigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnanBnJzpcbiAgICAgICAgICAgIGNhc2UgJ3BuZyc6XG4gICAgICAgICAgICBjYXNlICdnaWYnOlxuICAgICAgICAgICAgY2FzZSAnd2VicCc6XG4gICAgICAgICAgICAgICAgbG9hZEltYWdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgICAgY2FzZSAnb2dnJzpcbiAgICAgICAgICAgIGNhc2UgJ29wdXMnOlxuICAgICAgICAgICAgY2FzZSAnd2F2JzpcbiAgICAgICAgICAgIGNhc2UgJ200YSc6XG4gICAgICAgICAgICAgICAgbG9hZEF1ZGlvKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvZ3YnOlxuICAgICAgICAgICAgY2FzZSAnbXA0JzpcbiAgICAgICAgICAgIGNhc2UgJ3dlYm0nOlxuICAgICAgICAgICAgY2FzZSAnaGxzJzpcbiAgICAgICAgICAgICAgICBsb2FkVmlkZW8oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jpbic6XG4gICAgICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgICAgICAgIGxvYWRYSFIoJ2FycmF5YnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0eHQnOlxuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgbG9hZFhIUigndGV4dCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXNzZXRzTG9hZGVyIEVSUk9SOiBVbmtub3duIHR5cGUgZm9yIGZpbGUgd2l0aCBVUkw6ICcgKyBiYXNlUGF0aCArIHVybCArICcgKCcgKyB0eXBlICsgJyknO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkaXNwYXRjaENvbXBsZXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaWxlID0ge2lkOiBpZCwgZmlsZTogZGF0YSwgdHlwZTogdHlwZX07XG4gICAgICAgIGxvYWRlci5lbWl0KCdwcm9ncmVzcycsIDEpO1xuICAgICAgICBsb2FkZXIuZW1pdCgnY29tcGxldGUnLCBmaWxlLCBpZCwgdHlwZSk7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgIH07XG5cbiAgICB2YXIgbG9hZFhIUiA9IGZ1bmN0aW9uKHJlc3BvbnNlVHlwZSwgY3VzdG9tTG9hZEhhbmRsZXIpIHtcbiAgICAgICAgbG9hZEhhbmRsZXIgPSBjdXN0b21Mb2FkSGFuZGxlciB8fCBjb21wbGV0ZUhhbmRsZXI7XG5cbiAgICAgICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIGJhc2VQYXRoICsgdXJsLCB0cnVlKTtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0hhbmRsZXIpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkSGFuZGxlcik7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICB9O1xuXG4gICAgdmFyIHByb2dyZXNzSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICBsb2FkZXIuZW1pdCgncHJvZ3Jlc3MnLCBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNvbXBsZXRlSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc3VjY2VzcygpKSB7XG4gICAgICAgICAgICBkaXNwYXRjaENvbXBsZXRlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzdWNjZXNzJywgdXJsLCByZXF1ZXN0LnN0YXR1cyk7XG4gICAgICAgIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3Quc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgICBzdGF0cy51cGRhdGUocmVxdWVzdCwgc3RhcnRUaW1lLCB1cmwsIGxvZyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvckhhbmRsZXIocmVxdWVzdCAmJiByZXF1ZXN0LnN0YXR1c1RleHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIGpzb25cblxuICAgIHZhciBsb2FkSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkWEhSKCdqc29uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2VzcygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoQ29tcGxldGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBpbWFnZVxuXG4gICAgdmFyIGxvYWRJbWFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYmxvYikge1xuICAgICAgICAgICAgbG9hZEltYWdlQmxvYigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9hZEltYWdlRWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsb2FkSW1hZ2VFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlcXVlc3QgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaWYgKGNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlciwgZmFsc2UpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBlbGVtZW50TG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgcmVxdWVzdC5zcmMgPSBiYXNlUGF0aCArIHVybDtcbiAgICB9O1xuXG4gICAgdmFyIGVsZW1lbnRMb2FkSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGlmICghZXZlbnQgJiYgKHJlcXVlc3QuZXJyb3IgfHwgIXJlcXVlc3QucmVhZHlTdGF0ZSkpIHtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoQ29tcGxldGUocmVxdWVzdCk7XG4gICAgfTtcblxuICAgIHZhciBsb2FkSW1hZ2VCbG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRYSFIoJ2Jsb2InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKCkpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGltYWdlQmxvYkhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGltYWdlQmxvYkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwocmVxdWVzdC5zcmMpO1xuICAgICAgICBkaXNwYXRjaENvbXBsZXRlKHJlcXVlc3QpO1xuICAgIH07XG5cbiAgICAvLyBhdWRpb1xuXG4gICAgdmFyIGxvYWRBdWRpbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAod2ViQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICBsb2FkQXVkaW9CdWZmZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRNZWRpYUVsZW1lbnQoJ2F1ZGlvJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdmlkZW9cblxuICAgIHZhciBsb2FkVmlkZW8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGJsb2IpIHtcbiAgICAgICAgICAgIGxvYWRYSFIoJ2Jsb2InKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvYWRNZWRpYUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYXVkaW8gYnVmZmVyXG5cbiAgICB2YXIgbG9hZEF1ZGlvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRYSFIoJ2FycmF5YnVmZmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2VzcygpKSB7XG4gICAgICAgICAgICAgICAgd2ViQXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ29tcGxldGUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIG1lZGlhIGVsZW1lbnRcblxuICAgIHZhciBsb2FkTWVkaWFFbGVtZW50ID0gZnVuY3Rpb24odGFnTmFtZSkge1xuICAgICAgICByZXF1ZXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICAgICAgICBpZiAoIWlzVG91Y2hMb2NrZWQpIHtcbiAgICAgICAgICAgIC8vIHRpbWVvdXQgYmVjYXVzZSBzb21ldGltZXMgY2FucGxheXRocm91Z2ggZG9lc24ndCBmaXJlXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGVsZW1lbnRMb2FkSGFuZGxlciwgMjAwMCk7XG4gICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgZWxlbWVudExvYWRIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHJlcXVlc3QucHJlbG9hZCA9ICdhdXRvJztcbiAgICAgICAgcmVxdWVzdC5zcmMgPSBiYXNlUGF0aCArIHVybDtcbiAgICAgICAgcmVxdWVzdC5sb2FkKCk7XG5cbiAgICAgICAgaWYgKGlzVG91Y2hMb2NrZWQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tcGxldGUocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZXJyb3JcblxuICAgIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2Vycm9ySGFuZGxlcicsIHVybCwgZXJyKTtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9IGVycjtcblxuICAgICAgICBpZiAocmVxdWVzdCAmJiByZXF1ZXN0LnRhZ05hbWUgJiYgcmVxdWVzdC5lcnJvcikge1xuICAgICAgICAgICAgdmFyIEVSUk9SX1NUQVRFID0gWycnLCAnQUJPUlRFRCcsICdORVRXT1JLJywgJ0RFQ09ERScsICdTUkNfTk9UX1NVUFBPUlRFRCddO1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdNZWRpYUVycm9yOiAnICsgRVJST1JfU1RBVEVbcmVxdWVzdC5lcnJvci5jb2RlXSArICcgJyArIHJlcXVlc3Quc3JjO1xuICAgICAgICB9IGVsc2UgaWYgKHJlcXVlc3QgJiYgcmVxdWVzdC5zdGF0dXNUZXh0KSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gcmVxdWVzdC5zdGF0dXNUZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKGVyciAmJiBlcnIubWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgICB9IGVsc2UgaWYgKGVyciAmJiBlcnIudHlwZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVyci50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZGVyLmVtaXQoJ2Vycm9yJywgJ0Vycm9yIGxvYWRpbmcgXCInICsgYmFzZVBhdGggKyB1cmwgKyAnXCIgJyArIG1lc3NhZ2UpO1xuXG4gICAgICAgIGRlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgLy8gY2xlYW4gdXBcblxuICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZGVyLm9mZignZXJyb3InKTtcbiAgICAgICAgbG9hZGVyLm9mZigncHJvZ3Jlc3MnKTtcbiAgICAgICAgbG9hZGVyLm9mZignY29tcGxldGUnKTtcblxuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHByb2dyZXNzSGFuZGxlcik7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkSGFuZGxlcik7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGVsZW1lbnRMb2FkSGFuZGxlcik7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgZWxlbWVudExvYWRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGltYWdlQmxvYkhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3QuYWJvcnQgJiYgcmVxdWVzdC5yZWFkeVN0YXRlIDwgNCkge1xuICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICAgIHdlYkF1ZGlvQ29udGV4dCA9IG51bGw7XG4gICAgICAgIGZpbGUgPSBudWxsO1xuXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICAgICAgbG9hZGVyLmVtaXQoJ2Rlc3Ryb3knLCBpZCk7XG4gICAgfTtcblxuICAgIC8vIGVtaXRzOiBwcm9ncmVzcywgZXJyb3IsIGNvbXBsZXRlXG5cbiAgICBsb2FkZXIgPSBPYmplY3QuY3JlYXRlKEVtaXR0ZXIucHJvdG90eXBlLCB7XG4gICAgICAgIF9ldmVudHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9LFxuICAgICAgICBpZDoge1xuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnMuaWRcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiBzdGFydFxuICAgICAgICB9LFxuICAgICAgICBsb2FkZWQ6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveToge1xuICAgICAgICAgICAgdmFsdWU6IGRlc3Ryb3lcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobG9hZGVyKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hc3NldHMtbG9hZGVyL3NyYy9sb2FkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIW5ldyBCbG9iKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Fzc2V0cy1sb2FkZXIvc3JjL2Jyb3dzZXItaGFzLWJsb2IuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9