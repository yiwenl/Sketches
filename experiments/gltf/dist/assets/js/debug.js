/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(requestTimeout) { // eslint-disable-line no-unused-vars
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "60c187a5f53c109dfdcc"; // eslint-disable-line no-unused-vars
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 1;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve().then(function() {
/******/ 				return hotApply(hotApplyOnUpdate);
/******/ 			}).then(
/******/ 				function(result) {
/******/ 					deferred.resolve(result);
/******/ 				},
/******/ 				function(err) {
/******/ 					deferred.reject(err);
/******/ 				}
/******/ 			);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if(cb) {
/******/ 							if(callbacks.indexOf(cb) >= 0) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for(i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch(err) {
/******/ 							if(options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if(!options.ignoreErrored) {
/******/ 								if(!error)
/******/ 									error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err, // TODO remove in webpack 4
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(132)(__webpack_require__.s = 132);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTool.js

var _glMatrix = __webpack_require__(2);

var _getAndApplyExtension = __webpack_require__(54);

var _getAndApplyExtension2 = _interopRequireDefault(_getAndApplyExtension);

var _exposeAttributes = __webpack_require__(55);

var _exposeAttributes2 = _interopRequireDefault(_exposeAttributes);

var _getFloat = __webpack_require__(56);

var _getFloat2 = _interopRequireDefault(_getFloat);

var _getHalfFloat = __webpack_require__(57);

var _getHalfFloat2 = _interopRequireDefault(_getHalfFloat);

var _getAttribLoc = __webpack_require__(33);

var _getAttribLoc2 = _interopRequireDefault(_getAttribLoc);

var _ExtensionsList = __webpack_require__(58);

var _ExtensionsList2 = _interopRequireDefault(_ExtensionsList);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _Mesh = __webpack_require__(13);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _Object3D = __webpack_require__(8);

var _Object3D2 = _interopRequireDefault(_Object3D);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var GLTool = function () {
	function GLTool() {
		_classCallCheck(this, GLTool);

		this.canvas;
		this._viewport = [0, 0, 0, 0];
		this._enabledVertexAttribute = [];
		this.identityMatrix = _glMatrix.mat4.create();
		this._normalMatrix = _glMatrix.mat3.create();
		this._inverseModelViewMatrix = _glMatrix.mat3.create();
		this._modelMatrix = _glMatrix.mat4.create();
		this._matrix = _glMatrix.mat4.create();
		this._matrixStacks = [];
		this._lastMesh = null;
		this._useWebGL2 = false;
		this._hasArrayInstance;
		this._extArrayInstance;
		this._hasCheckedExt = false;
		_glMatrix.mat4.identity(this.identityMatrix, this.identityMatrix);

		this.isMobile = false;
		if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
			this.isMobile = true;
		}
	}

	//	INITIALIZE

	_createClass(GLTool, [{
		key: 'init',
		value: function init(mCanvas) {
			var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


			if (mCanvas === null || mCanvas === undefined) {
				console.error('Canvas not exist');
				return;
			}

			if (this.canvas !== undefined && this.canvas !== null) {
				this.destroy();
			}

			this.canvas = mCanvas;
			this.setSize(window.innerWidth, window.innerHeight);

			mParameters.useWebgl2 = mParameters.useWebgl2 || false;

			var ctx = void 0;
			if (mParameters.useWebgl2) {
				ctx = this.canvas.getContext('experimental-webgl2', mParameters) || this.canvas.getContext('webgl2', mParameters);

				if (!ctx) {
					ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
					this._useWebGL2 = false;
				} else {
					this._useWebGL2 = true;
				}
			} else {
				// ctx = this.canvas.getContext('experimental-webgl2', mParameters) || this.canvas.getContext('webgl2', mParameters);
				// if(ctx) {
				// 	this._useWebGL2 = true;
				// } else {
				// 	ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
				// }

				ctx = this.canvas.getContext('webgl', mParameters) || this.canvas.getContext('experimental-webgl', mParameters);
				this._useWebGL2 = false;
			}

			console.log('Using WebGL 2 ?', this.webgl2);

			//	extensions
			this.initWithGL(ctx);
		}
	}, {
		key: 'initWithGL',
		value: function initWithGL(ctx) {
			if (!this.canvas) {
				this.canvas = ctx.canvas;
			}
			gl = this.gl = ctx;

			this.extensions = {};
			for (var i = 0; i < _ExtensionsList2.default.length; i++) {
				this.extensions[_ExtensionsList2.default[i]] = gl.getExtension(_ExtensionsList2.default[i]);
			}

			//	Copy gl Attributes
			(0, _exposeAttributes2.default)();
			(0, _getAndApplyExtension2.default)(gl, 'OES_vertex_array_object');
			(0, _getAndApplyExtension2.default)(gl, 'ANGLE_instanced_arrays');
			(0, _getAndApplyExtension2.default)(gl, 'WEBGL_draw_buffers');

			this.enable(this.DEPTH_TEST);
			this.enable(this.CULL_FACE);
			this.enable(this.BLEND);
			this.enableAlphaBlending();
		}

		//	PUBLIC METHODS

	}, {
		key: 'setViewport',
		value: function setViewport(x, y, w, h) {
			var hasChanged = false;
			if (x !== this._viewport[0]) {
				hasChanged = true;
			}
			if (y !== this._viewport[1]) {
				hasChanged = true;
			}
			if (w !== this._viewport[2]) {
				hasChanged = true;
			}
			if (h !== this._viewport[3]) {
				hasChanged = true;
			}

			if (hasChanged) {
				gl.viewport(x, y, w, h);
				this._viewport = [x, y, w, h];
			}
		}
	}, {
		key: 'scissor',
		value: function scissor(x, y, w, h) {
			gl.scissor(x, y, w, h);
		}
	}, {
		key: 'clear',
		value: function clear(r, g, b, a) {
			gl.clearColor(r, g, b, a);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		}
	}, {
		key: 'cullFace',
		value: function cullFace(mValue) {
			gl.cullFace(mValue);
		}
	}, {
		key: 'setMatrices',
		value: function setMatrices(mCamera) {
			this.camera = mCamera;
			this.rotate(this.identityMatrix);
		}
	}, {
		key: 'useShader',
		value: function useShader(mShader) {
			this.shader = mShader;
			this.shaderProgram = this.shader.shaderProgram;
		}
	}, {
		key: 'rotate',
		value: function rotate(mRotation) {
			_glMatrix.mat4.copy(this._modelMatrix, mRotation);
			_glMatrix.mat4.multiply(this._matrix, this.camera.matrix, this._modelMatrix);
			_glMatrix.mat3.fromMat4(this._normalMatrix, this._matrix);
			_glMatrix.mat3.invert(this._normalMatrix, this._normalMatrix);
			_glMatrix.mat3.transpose(this._normalMatrix, this._normalMatrix);

			_glMatrix.mat3.fromMat4(this._inverseModelViewMatrix, this._matrix);
			_glMatrix.mat3.invert(this._inverseModelViewMatrix, this._inverseModelViewMatrix);
		}
	}, {
		key: 'drawGeometry',
		value: function drawGeometry(mGeometry, modelMatrix) {
			if (mGeometry.length) {
				for (var i = 0; i < mGeometry.length; i++) {
					this.draw(mGeometry[i]);
				}
				return;
			}

			mGeometry.bind(this.shaderProgram);

			//	DEFAULT UNIFORMS
			if (this.camera !== undefined) {
				this.shader.uniform('uProjectionMatrix', 'mat4', this.camera.projection);
				this.shader.uniform('uViewMatrix', 'mat4', this.camera.matrix);
			}

			this.shader.uniform('uCameraPos', 'vec3', this.camera.position);
			this.shader.uniform('uModelMatrix', 'mat4', modelMatrix || this._modelMatrix);
			this.shader.uniform('uNormalMatrix', 'mat3', this._normalMatrix);
			this.shader.uniform('uModelViewMatrixInverse', 'mat3', this._inverseModelViewMatrix);

			var drawType = mGeometry.drawType;

			if (mGeometry.isInstanced) {
				gl.drawElementsInstanced(mGeometry.drawType, mGeometry.iBuffer.numItems, gl.UNSIGNED_SHORT, 0, mGeometry.numInstance);
			} else {
				if (drawType === gl.POINTS) {
					gl.drawArrays(drawType, 0, mGeometry.vertexSize);
				} else {
					gl.drawElements(drawType, mGeometry.iBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				}
			}

			mGeometry.unbind();
		}
	}, {
		key: 'drawMesh',
		value: function drawMesh(mMesh) {
			var material = mMesh.material,
			    geometry = mMesh.geometry;


			if (material.doubleSided) {
				this.disable(GL.CULL_FACE);
			} else {
				this.enable(GL.CULL_FACE);
			}

			material.update();
			this.drawGeometry(geometry, mMesh.matrix);
		}
	}, {
		key: 'draw',
		value: function draw(mObj) {
			var _this = this;

			if (mObj instanceof _Geometry2.default) {
				this.drawGeometry(mObj);
			} else if (mObj instanceof _Mesh2.default) {
				this.drawMesh(mObj);
			} else if (mObj instanceof _Object3D2.default) {
				// console.log('here');
				mObj.updateMatrix();
				mObj.children.forEach(function (child) {
					_this.draw(child);
				});
			}
		}
	}, {
		key: 'drawTransformFeedback',
		value: function drawTransformFeedback(mTransformObject) {
			var meshSource = mTransformObject.meshSource,
			    meshDestination = mTransformObject.meshDestination,
			    numPoints = mTransformObject.numPoints,
			    transformFeedback = mTransformObject.transformFeedback;

			//	BIND SOURCE BUFFERS -> setupVertexAttr(sourceVAO)

			meshSource.bind(this.shaderProgram);
			meshDestination.generateBuffers(this.shaderProgram);

			//	BIND DESTINATION BUFFERS
			gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);

			meshDestination.attributes.forEach(function (attr, i) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attr.buffer);
			});

			gl.enable(gl.RASTERIZER_DISCARD);

			gl.beginTransformFeedback(gl.POINTS);
			gl.drawArrays(gl.POINTS, 0, numPoints);
			gl.endTransformFeedback();

			//	reset state
			gl.disable(gl.RASTERIZER_DISCARD);
			gl.useProgram(null);
			gl.bindBuffer(gl.ARRAY_BUFFER, null);
			meshDestination.attributes.forEach(function (attr, i) {
				gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, null);
			});
			gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

			meshSource.unbind();
		}
	}, {
		key: 'setSize',
		value: function setSize(mWidth, mHeight) {
			this._width = mWidth;
			this._height = mHeight;
			this.canvas.width = this._width;
			this.canvas.height = this._height;
			this._aspectRatio = this._width / this._height;

			if (gl) {
				this.viewport(0, 0, this._width, this._height);
			}
		}
	}, {
		key: 'showExtensions',
		value: function showExtensions() {
			console.log('Extensions : ', this.extensions);
			for (var ext in this.extensions) {
				if (this.extensions[ext]) {
					console.log(ext, ':', this.extensions[ext]);
				}
			}
		}
	}, {
		key: 'checkExtension',
		value: function checkExtension(mExtension) {
			return !!this.extensions[mExtension];
		}
	}, {
		key: 'getExtension',
		value: function getExtension(mExtension) {
			return this.extensions[mExtension];
		}

		//	BLEND MODES

	}, {
		key: 'enableAlphaBlending',
		value: function enableAlphaBlending() {
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		}
	}, {
		key: 'enableAdditiveBlending',
		value: function enableAdditiveBlending() {
			gl.blendFunc(gl.ONE, gl.ONE);
		}

		//	matrices

	}, {
		key: 'pushMatrix',
		value: function pushMatrix() {
			var mtx = _glMatrix.mat4.clone(this._modelMatrix);
			this._matrixStacks.push(mtx);
		}
	}, {
		key: 'popMatrix',
		value: function popMatrix() {
			if (this._matrixStacks.length == 0) {
				return null;
			}
			var mtx = this._matrixStacks.pop();
			this.rotate(mtx);
		}

		//	GL NATIVE FUNCTIONS

	}, {
		key: 'enable',
		value: function enable(mParameter) {
			gl.enable(mParameter);
		}
	}, {
		key: 'disable',
		value: function disable(mParameter) {
			gl.disable(mParameter);
		}
	}, {
		key: 'viewport',
		value: function viewport(x, y, w, h) {
			this.setViewport(x, y, w, h);
		}

		//	GETTER AND SETTERS

	}, {
		key: 'destroy',


		//	DESTROY

		value: function destroy() {

			if (this.canvas.parentNode) {
				try {
					this.canvas.parentNode.removeChild(this.canvas);
				} catch (e) {
					console.log('Error : ', e);
				}
			}

			this.canvas = null;
		}
	}, {
		key: 'FLOAT',
		get: function get() {
			return (0, _getFloat2.default)();
		}
	}, {
		key: 'HALF_FLOAT',
		get: function get() {
			return (0, _getHalfFloat2.default)();
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'aspectRatio',
		get: function get() {
			return this._aspectRatio;
		}
	}, {
		key: 'webgl2',
		get: function get() {
			return this._useWebGL2;
		}
	}]);

	return GLTool;
}();

var GL = new GLTool();

exports.default = GL;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GLShader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _GLCubeTexture = __webpack_require__(14);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var glslify = __webpack_require__(61);
var isSame = function isSame(array1, array2) {
	if (array1.length !== array2.length) {
		return false;
	}

	for (var i = 0; i < array1.length; i++) {
		if (array1[i] !== array2[i]) {
			return false;
		}
	}

	return true;
};

var addLineNumbers = function addLineNumbers(string) {
	var lines = string.split('\n');
	for (var i = 0; i < lines.length; i++) {
		lines[i] = i + 1 + ': ' + lines[i];
	}
	return lines.join('\n');
};

var cloneArray = function cloneArray(mArray) {
	if (mArray.slice) {
		return mArray.slice(0);
	} else {
		return new Float32Array(mArray);
	}
};

var gl = void 0;
var defaultVertexShader = __webpack_require__(15);
var defaultFragmentShader = __webpack_require__(62);

var uniformMapping = {
	float: 'uniform1f',
	vec2: 'uniform2fv',
	vec3: 'uniform3fv',
	vec4: 'uniform4fv',
	int: 'uniform1i',
	mat3: 'uniformMatrix3fv',
	mat4: 'uniformMatrix4fv'
};

var GLShader = function () {
	function GLShader() {
		var strVertexShader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultVertexShader;
		var strFragmentShader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultFragmentShader;
		var mVaryings = arguments[2];

		_classCallCheck(this, GLShader);

		gl = _GLTool2.default.gl;
		this.parameters = [];
		this._uniformTextures = [];
		this._varyings = mVaryings;

		if (!strVertexShader) {
			strVertexShader = defaultVertexShader;
		}
		if (!strFragmentShader) {
			strFragmentShader = defaultVertexShader;
		}

		var vsShader = this._createShaderProgram(strVertexShader, true);
		var fsShader = this._createShaderProgram(strFragmentShader, false);
		this._attachShaderProgram(vsShader, fsShader);
	}

	_createClass(GLShader, [{
		key: 'bind',
		value: function bind() {

			if (_GLTool2.default.shader === this) {
				return;
			}
			gl.useProgram(this.shaderProgram);
			_GLTool2.default.useShader(this);
			// this.uniformTextures = [];
		}
	}, {
		key: 'uniform',
		value: function uniform(mName, mType, mValue) {
			if ((typeof mName === 'undefined' ? 'undefined' : _typeof(mName)) === 'object') {
				this.uniformObject(mName);
				return;
			}
			/*
   if(!!mValue === undefined || mValue === null) {
   	console.warn('mValue Error:', mName);
   	return;
   }
   */
			var uniformType = uniformMapping[mType] || mType;

			var hasUniform = false;
			var oUniform = void 0;
			var parameterIndex = -1;

			for (var i = 0; i < this.parameters.length; i++) {
				oUniform = this.parameters[i];
				if (oUniform.name === mName) {
					hasUniform = true;
					parameterIndex = i;
					break;
				}
			}

			var isNumber = false;

			if (!hasUniform) {
				isNumber = uniformType === 'uniform1i' || uniformType === 'uniform1f';
				this.shaderProgram[mName] = gl.getUniformLocation(this.shaderProgram, mName);
				if (isNumber) {
					this.parameters.push({ name: mName, type: uniformType, value: mValue, uniformLoc: this.shaderProgram[mName], isNumber: isNumber });
				} else {
					this.parameters.push({ name: mName, type: uniformType, value: cloneArray(mValue), uniformLoc: this.shaderProgram[mName], isNumber: isNumber });
				}

				parameterIndex = this.parameters.length - 1;
			} else {
				this.shaderProgram[mName] = oUniform.uniformLoc;
				isNumber = oUniform.isNumber;
			}

			if (!this.parameters[parameterIndex].uniformLoc) {
				return;
			}

			if (uniformType.indexOf('Matrix') === -1) {
				if (!isNumber) {
					if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
						gl[uniformType](this.shaderProgram[mName], mValue);
						this.parameters[parameterIndex].value = cloneArray(mValue);
					}
				} else {
					var needUpdate = this.parameters[parameterIndex].value !== mValue || !hasUniform;
					if (needUpdate) {
						gl[uniformType](this.shaderProgram[mName], mValue);
						this.parameters[parameterIndex].value = mValue;
					}
				}
			} else {
				if (!isSame(this.parameters[parameterIndex].value, mValue) || !hasUniform) {
					gl[uniformType](this.shaderProgram[mName], false, mValue);
					this.parameters[parameterIndex].value = cloneArray(mValue);
				}
			}
		}
	}, {
		key: 'uniformObject',
		value: function uniformObject(mUniformObj) {
			var _this = this;

			var _loop = function _loop(uniformName) {

				if (mUniformObj[uniformName] instanceof _GLTexture2.default || mUniformObj[uniformName] instanceof _GLCubeTexture2.default) {
					var texture = mUniformObj[uniformName];

					var textureIndex = -1;;
					_this._uniformTextures.forEach(function (ut, i) {
						if (ut.name === uniformName) {
							textureIndex = i;
							ut.texture = texture;
						}
					});

					if (textureIndex === -1) {
						textureIndex = _this._uniformTextures.length;
						_this._uniformTextures.push({
							name: uniformName,
							texture: texture
						});
					}

					_this.uniform(uniformName, 'uniform1i', textureIndex);
					texture.bind(textureIndex);
				} else {
					var uniformValue = mUniformObj[uniformName];
					var uniformType = GLShader.getUniformType(uniformValue);

					if (uniformValue.concat && uniformValue[0].concat) {
						var tmp = [];
						for (var i = 0; i < uniformValue.length; i++) {
							tmp = tmp.concat(uniformValue[i]);
						}
						uniformValue = tmp;
					}

					_this.uniform(uniformName, uniformType, uniformValue);
				}
			};

			for (var uniformName in mUniformObj) {
				_loop(uniformName);
			}
		}
	}, {
		key: '_createShaderProgram',
		value: function _createShaderProgram(mShaderStr, isVertexShader) {

			var shaderType = isVertexShader ? _GLTool2.default.VERTEX_SHADER : _GLTool2.default.FRAGMENT_SHADER;
			var shader = gl.createShader(shaderType);

			gl.shaderSource(shader, mShaderStr);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				console.warn('Error in Shader : ', gl.getShaderInfoLog(shader));
				console.log(addLineNumbers(mShaderStr));
				return null;
			}

			return shader;
		}
	}, {
		key: '_attachShaderProgram',
		value: function _attachShaderProgram(mVertexShader, mFragmentShader) {

			this.shaderProgram = gl.createProgram();
			gl.attachShader(this.shaderProgram, mVertexShader);
			gl.attachShader(this.shaderProgram, mFragmentShader);

			gl.deleteShader(mVertexShader);
			gl.deleteShader(mFragmentShader);

			if (this._varyings) {
				console.log('Transform feedback setup : ', this._varyings);
				gl.transformFeedbackVaryings(this.shaderProgram, this._varyings, gl.SEPARATE_ATTRIBS);
			}

			gl.linkProgram(this.shaderProgram);
		}
	}]);

	return GLShader;
}();

GLShader.getUniformType = function (mValue) {
	var isArray = !!mValue.concat;

	var getArrayUniformType = function getArrayUniformType(mValue) {
		if (mValue.length === 9) {
			return 'uniformMatrix3fv';
		} else if (mValue.length === 16) {
			return 'uniformMatrix4fv';
		} else {
			return 'vec' + mValue.length;
		}
	};

	if (!isArray) {
		return 'float';
	} else {
		if (!mValue[0].concat) {
			return getArrayUniformType(mValue);
		} else {
			return getArrayUniformType(mValue[0]);
		}
	}
};

exports.default = GLShader;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__ = __webpack_require__(31);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return __WEBPACK_IMPORTED_MODULE_6__gl_matrix_vec2__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec3__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec4__; });
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.4.0
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER













/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _glMatrix = __webpack_require__(2);

var _getAttribLoc = __webpack_require__(33);

var _getAttribLoc2 = _interopRequireDefault(_getAttribLoc);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var STATIC_DRAW = 35044;

var getBuffer = function getBuffer(attr) {
	var buffer = void 0;

	if (attr.buffer !== undefined) {
		buffer = attr.buffer;
	} else {
		buffer = gl.createBuffer();
		attr.buffer = buffer;
	}

	return buffer;
};

var formBuffer = function formBuffer(mData, mNum) {
	var ary = [];

	for (var i = 0; i < mData.length; i += mNum) {
		var o = [];
		for (var j = 0; j < mNum; j++) {
			o.push(mData[i + j]);
		}

		ary.push(o);
	}

	return ary;
};

var Geometry = function () {
	function Geometry() {
		var mDrawingType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;
		var mUseVao = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

		_classCallCheck(this, Geometry);

		gl = _GLTool2.default.gl;
		this.drawType = mDrawingType;
		this._attributes = [];
		this._numInstance = -1;
		this._enabledVertexAttribute = [];

		this._indices = [];
		this._faces = [];
		this._bufferChanged = [];
		this._hasIndexBufferChanged = false;
		this._hasVAO = false;
		this._isInstanced = false;

		this._extVAO = !!_GLTool2.default.gl.createVertexArray;
		this._useVAO = !!this._extVAO && mUseVao;
		// this._useVAO = false;
	}

	_createClass(Geometry, [{
		key: 'bufferVertex',
		value: function bufferVertex(mArrayVertices) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mArrayVertices, 'aVertexPosition', 3, mDrawType);

			if (this.normals.length < this.vertices.length) {
				this.bufferNormal(mArrayVertices, mDrawType);
			}

			return this;
		}
	}, {
		key: 'bufferTexCoord',
		value: function bufferTexCoord(mArrayTexCoords) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mArrayTexCoords, 'aTextureCoord', 2, mDrawType);
			return this;
		}
	}, {
		key: 'bufferNormal',
		value: function bufferNormal(mNormals) {
			var mDrawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STATIC_DRAW;


			this.bufferData(mNormals, 'aNormal', 3, mDrawType);
			return this;
		}
	}, {
		key: 'bufferIndex',
		value: function bufferIndex(mArrayIndices) {
			var isDynamic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

			this._drawType = isDynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
			if (mArrayIndices instanceof Array) {
				this._indices = new Uint16Array(mArrayIndices);
			} else {
				this._indices = mArrayIndices;
			}

			this._numItems = this._indices.length;
			return this;
		}
	}, {
		key: 'bufferFlattenData',
		value: function bufferFlattenData(mData, mName, mItemSize) {
			var mDrawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STATIC_DRAW;
			var isInstanced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;


			var data = formBuffer(mData, mItemSize);
			this.bufferData(data, mName, mItemSize, mDrawType = STATIC_DRAW, isInstanced = false);
			return this;
		}
	}, {
		key: 'bufferData',
		value: function bufferData(mData, mName, mItemSize) {
			var mDrawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STATIC_DRAW;
			var isInstanced = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

			var i = 0;
			var drawType = mDrawType;
			if (!drawType) debugger;

			var bufferData = [];
			if (!mItemSize) {
				mItemSize = mData[0].length;
			}
			this._isInstanced = isInstanced || this._isInstanced;

			//	flatten buffer data		
			for (i = 0; i < mData.length; i++) {
				for (var j = 0; j < mData[i].length; j++) {
					bufferData.push(mData[i][j]);
				}
			}
			var dataArray = new Float32Array(bufferData);
			var attribute = this.getAttribute(mName);

			if (attribute) {
				//	attribute existed, replace with new data
				attribute.itemSize = mItemSize;
				attribute.dataArray = dataArray;
				attribute.source = mData;
			} else {
				//	attribute not exist yet, create new attribute object
				this._attributes.push({ name: mName, source: mData, itemSize: mItemSize, drawType: drawType, dataArray: dataArray, isInstanced: isInstanced });
			}

			this._bufferChanged.push(mName);
			return this;
		}
	}, {
		key: 'bufferInstance',
		value: function bufferInstance(mData, mName) {
			if (!_GLTool2.default.gl.vertexAttribDivisor) {
				console.error('Extension : ANGLE_instanced_arrays is not supported with this device !');
				return;
			}

			var itemSize = mData[0].length;
			this._numInstance = mData.length;
			this.bufferData(mData, mName, itemSize, STATIC_DRAW, true);
		}
	}, {
		key: 'bind',
		value: function bind(mShaderProgram) {
			this.generateBuffers(mShaderProgram);

			if (this.hasVAO) {
				gl.bindVertexArray(this.vao);
			} else {
				this.attributes.forEach(function (attribute) {
					gl.bindBuffer(gl.ARRAY_BUFFER, attribute.buffer);
					var attrPosition = attribute.attrPosition;
					gl.vertexAttribPointer(attrPosition, attribute.itemSize, gl.FLOAT, false, 0, 0);

					if (attribute.isInstanced) {
						gl.vertexAttribDivisor(attrPosition, 1);
					}
				});

				//	BIND INDEX BUFFER
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
			}
		}
	}, {
		key: 'generateBuffers',
		value: function generateBuffers(mShaderProgram) {
			var _this = this;

			if (this._bufferChanged.length == 0) {
				return;
			}

			if (this._useVAO) {
				//	IF SUPPORTED, CREATE VAO

				//	CREATE & BIND VAO
				if (!this._vao) {
					this._vao = gl.createVertexArray();
				}

				gl.bindVertexArray(this._vao);

				//	UPDATE BUFFERS
				this._attributes.forEach(function (attrObj) {

					if (_this._bufferChanged.indexOf(attrObj.name) !== -1) {
						var buffer = getBuffer(attrObj);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);

						var attrPosition = (0, _getAttribLoc2.default)(gl, mShaderProgram, attrObj.name);
						gl.enableVertexAttribArray(attrPosition);
						gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
						attrObj.attrPosition = attrPosition;

						if (attrObj.isInstanced) {
							gl.vertexAttribDivisor(attrPosition, 1);
						}
					}
				});

				//	check index buffer
				this._updateIndexBuffer();

				//	UNBIND VAO
				gl.bindVertexArray(null);

				this._hasVAO = true;
			} else {
				//	ELSE, USE TRADITIONAL METHOD

				this._attributes.forEach(function (attrObj) {
					//	SKIP IF BUFFER HASN'T CHANGED
					if (_this._bufferChanged.indexOf(attrObj.name) !== -1) {
						var buffer = getBuffer(attrObj);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.bufferData(gl.ARRAY_BUFFER, attrObj.dataArray, attrObj.drawType);

						var attrPosition = (0, _getAttribLoc2.default)(gl, mShaderProgram, attrObj.name);
						gl.enableVertexAttribArray(attrPosition);
						gl.vertexAttribPointer(attrPosition, attrObj.itemSize, gl.FLOAT, false, 0, 0);
						attrObj.attrPosition = attrPosition;

						if (attrObj.isInstanced) {
							gl.vertexAttribDivisor(attrPosition, 1);
						}
					}
				});

				this._updateIndexBuffer();
			}

			this._hasIndexBufferChanged = false;
			this._bufferChanged = [];
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			if (this._useVAO) {
				gl.bindVertexArray(null);
			}

			this._attributes.forEach(function (attribute) {
				if (attribute.isInstanced) {
					gl.vertexAttribDivisor(attribute.attrPosition, 0);
				}
			});
		}
	}, {
		key: '_updateIndexBuffer',
		value: function _updateIndexBuffer() {
			if (!this._hasIndexBufferChanged) {
				if (!this.iBuffer) {
					this.iBuffer = gl.createBuffer();
				}
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, this._drawType);
				this.iBuffer.itemSize = 1;
				this.iBuffer.numItems = this._numItems;
			}
		}
	}, {
		key: 'computeNormals',
		value: function computeNormals() {
			var usingFaceNormals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


			this.generateFaces();

			if (usingFaceNormals) {
				this._computeFaceNormals();
			} else {
				this._computeVertexNormals();
			}
		}

		//	PRIVATE METHODS

	}, {
		key: '_computeFaceNormals',
		value: function _computeFaceNormals() {

			var faceIndex = void 0;
			var face = void 0;
			var normals = [];

			for (var i = 0; i < this._indices.length; i += 3) {
				faceIndex = i / 3;
				face = this._faces[faceIndex];
				var N = face.normal;

				normals[face.indices[0]] = N;
				normals[face.indices[1]] = N;
				normals[face.indices[2]] = N;
			}

			this.bufferNormal(normals);
		}
	}, {
		key: '_computeVertexNormals',
		value: function _computeVertexNormals() {
			//	loop through all vertices
			var face = void 0;
			var sumNormal = _glMatrix.vec3.create();
			var normals = [];
			var vertices = this.vertices;


			for (var i = 0; i < vertices.length; i++) {

				_glMatrix.vec3.set(sumNormal, 0, 0, 0);

				for (var j = 0; j < this._faces.length; j++) {
					face = this._faces[j];

					//	if vertex exist in the face, add the normal to sum normal
					if (face.indices.indexOf(i) >= 0) {

						sumNormal[0] += face.normal[0];
						sumNormal[1] += face.normal[1];
						sumNormal[2] += face.normal[2];
					}
				}

				_glMatrix.vec3.normalize(sumNormal, sumNormal);
				normals.push([sumNormal[0], sumNormal[1], sumNormal[2]]);
			}

			this.bufferNormal(normals);
		}
	}, {
		key: 'generateFaces',
		value: function generateFaces() {
			var ia = void 0,
			    ib = void 0,
			    ic = void 0;
			var a = void 0,
			    b = void 0,
			    c = void 0;
			var vba = _glMatrix.vec3.create(),
			    vca = _glMatrix.vec3.create(),
			    vNormal = _glMatrix.vec3.create();
			var vertices = this.vertices;


			for (var i = 0; i < this._indices.length; i += 3) {

				ia = this._indices[i];
				ib = this._indices[i + 1];
				ic = this._indices[i + 2];

				a = vertices[ia];
				b = vertices[ib];
				c = vertices[ic];

				var face = {
					indices: [ia, ib, ic],
					vertices: [a, b, c]
				};

				this._faces.push(face);
			}
		}
	}, {
		key: 'getAttribute',
		value: function getAttribute(mName) {
			return this._attributes.find(function (a) {
				return a.name === mName;
			});
		}
	}, {
		key: 'getSource',
		value: function getSource(mName) {
			var attr = this.getAttribute(mName);
			return attr ? attr.source : [];
		}

		//	GETTER AND SETTERS

	}, {
		key: 'vertices',
		get: function get() {
			return this.getSource('aVertexPosition');
		}
	}, {
		key: 'normals',
		get: function get() {
			return this.getSource('aNormal');
		}
	}, {
		key: 'coords',
		get: function get() {
			return this.getSource('aTextureCoord');
		}
	}, {
		key: 'indices',
		get: function get() {
			return this._indices;
		}
	}, {
		key: 'vertexSize',
		get: function get() {
			return this.vertices.length;
		}
	}, {
		key: 'faces',
		get: function get() {
			return this._faces;
		}
	}, {
		key: 'attributes',
		get: function get() {
			return this._attributes;
		}
	}, {
		key: 'hasVAO',
		get: function get() {
			return this._hasVAO;
		}
	}, {
		key: 'vao',
		get: function get() {
			return this._vao;
		}
	}, {
		key: 'numInstance',
		get: function get() {
			return this._numInstance;
		}
	}, {
		key: 'isInstanced',
		get: function get() {
			return this._isInstanced;
		}
	}]);

	return Geometry;
}();

exports.default = Geometry;

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (immutable) */ __webpack_exports__["setMatrixArrayType"] = setMatrixArrayType;
/* harmony export (immutable) */ __webpack_exports__["toRadian"] = toRadian;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
const EPSILON = 0.000001;
/* harmony export (immutable) */ __webpack_exports__["EPSILON"] = EPSILON;

let ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
const RANDOM = Math.random;
/* harmony export (immutable) */ __webpack_exports__["RANDOM"] = RANDOM;


/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

const degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Batch.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Batch = function () {
	function Batch(mGeometry, mShader) {
		_classCallCheck(this, Batch);

		this._geometry = mGeometry;
		this._shader = mShader;
	}

	//	PUBLIC METHODS

	_createClass(Batch, [{
		key: 'draw',
		value: function draw() {
			this._shader.bind();
			_GLTool2.default.draw(this._geometry);
		}

		//	GETTER AND SETTER

	}, {
		key: 'geometry',
		get: function get() {
			return this._geometry;
		}
	}, {
		key: 'shader',
		get: function get() {
			return this._shader;
		}
	}]);

	return Batch;
}();

exports.default = Batch;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
// Scheduler.js


class Scheduler {

	constructor() {
		this._delayTasks = [];
		this._nextTasks = [];
		this._deferTasks = [];
		this._highTasks = [];
		this._usurpTask = [];
		this._enterframeTasks = [];
		this._idTable = 0;
		this.frameRate = 60;
		this._startTime = new Date().getTime();

		this._deltaTime = 0;

		this._loop();
	}


	//  PUBLIC METHODS

	addEF(func, params) {
		params = params || [];
		const id = this._idTable;
		this._enterframeTasks[id] = { func, params };
		this._idTable ++;
		return id;
	}

	removeEF(id) {
		if (this._enterframeTasks[id] !== undefined) {
			this._enterframeTasks[id] = null;
		}
		return -1;
	}

	delay(func, params, delay) {
		const time = new Date().getTime();
		const t = { func, params, delay, time };
		this._delayTasks.push(t);
	}

	defer(func, params) {
		const t = { func, params };
		this._deferTasks.push(t);
	}

	next(func, params) {
		const t = { func, params };
		this._nextTasks.push(t);
	}

	usurp(func, params) {
		const t = { func, params };
		this._usurpTask.push(t);
	}


	//  PRIVATE METHODS

	_process() {
		let i = 0;
		let task;
		let interval;
		let current;
		for (i = 0; i < this._enterframeTasks.length; i++) {
			task = this._enterframeTasks[i];
			if (task !== null && task !== undefined) {
				task.func(task.params);
			}
		}

		while (this._highTasks.length > 0) {
			task = this._highTasks.pop();
			task.func(task.params);
		}


		let startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;

		for (i = 0; i < this._delayTasks.length; i++) {
			task = this._delayTasks[i];
			if (startTime - task.time > task.delay) {
				task.func(task.params);
				this._delayTasks.splice(i, 1);
			}
		}

		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / this.frameRate;
		while (this._deferTasks.length > 0) {
			task = this._deferTasks.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			} else {
				this._deferTasks.unshift(task);
				break;
			}
		}


		startTime = new Date().getTime();
		this._deltaTime = (startTime - this._startTime)/1000;
		interval = 1000 / this.frameRate;
		while (this._usurpTask.length > 0) {
			task = this._usurpTask.shift();
			current = new Date().getTime();
			if (current - startTime < interval) {
				task.func(task.params);
			}
		}

		this._highTasks = this._highTasks.concat(this._nextTasks);
		this._nextTasks = [];
		this._usurpTask = [];
	}


	_loop() {
		this._process();
		window.requestAnimationFrame(() => this._loop());
	}

	get deltaTime() {
		return this._deltaTime;
	}
}

const scheduler = new Scheduler();

/* harmony default export */ __webpack_exports__["default"] = (scheduler);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Geom.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Geom = {};
var meshTri = void 0;

Geom.plane = function plane(width, height, numSegments) {
	var axis = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'xy';
	var drawType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];

	var gapX = width / numSegments;
	var gapY = height / numSegments;
	var gapUV = 1 / numSegments;
	var sx = -width * 0.5;
	var sy = -height * 0.5;
	var index = 0;

	for (var i = 0; i < numSegments; i++) {
		for (var j = 0; j < numSegments; j++) {
			var tx = gapX * i + sx;
			var ty = gapY * j + sy;

			var u = i / numSegments;
			var v = j / numSegments;

			if (axis === 'xz') {
				positions.push([tx, 0, ty + gapY]);
				positions.push([tx + gapX, 0, ty + gapY]);
				positions.push([tx + gapX, 0, ty]);
				positions.push([tx, 0, ty]);

				coords.push([u, 1.0 - (v + gapUV)]);
				coords.push([u + gapUV, 1.0 - (v + gapUV)]);
				coords.push([u + gapUV, 1.0 - v]);
				coords.push([u, 1.0 - v]);

				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
				normals.push([0, 1, 0]);
			} else if (axis === 'yz') {
				positions.push([0, ty, tx]);
				positions.push([0, ty, tx + gapX]);
				positions.push([0, ty + gapY, tx + gapX]);
				positions.push([0, ty + gapY, tx]);

				coords.push([u, v]);
				coords.push([u + gapUV, v]);
				coords.push([u + gapUV, v + gapUV]);
				coords.push([u, v + gapUV]);

				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
				normals.push([1, 0, 0]);
			} else {
				positions.push([tx, ty, 0]);
				positions.push([tx + gapX, ty, 0]);
				positions.push([tx + gapX, ty + gapY, 0]);
				positions.push([tx, ty + gapY, 0]);

				coords.push([u, v]);
				coords.push([u + gapUV, v]);
				coords.push([u + gapUV, v + gapUV]);
				coords.push([u, v + gapUV]);

				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
				normals.push([0, 0, 1]);
			}

			indices.push(index * 4 + 0);
			indices.push(index * 4 + 1);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 0);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 3);

			index++;
		}
	}

	var mesh = new _Geometry2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.sphere = function sphere(size, numSegments) {
	var isInvert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	var drawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var gapUV = 1 / numSegments;
	var index = 0;

	function getPosition(i, j) {
		var isNormal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		//	rx : -90 ~ 90 , ry : 0 ~ 360
		var rx = i / numSegments * Math.PI - Math.PI * 0.5;
		var ry = j / numSegments * Math.PI * 2;
		var r = isNormal ? 1 : size;
		var pos = [];
		pos[1] = Math.sin(rx) * r;
		var t = Math.cos(rx) * r;
		pos[0] = Math.cos(ry) * t;
		pos[2] = Math.sin(ry) * t;

		var precision = 10000;
		pos[0] = Math.floor(pos[0] * precision) / precision;
		pos[1] = Math.floor(pos[1] * precision) / precision;
		pos[2] = Math.floor(pos[2] * precision) / precision;

		return pos;
	};

	for (var i = 0; i < numSegments; i++) {
		for (var j = 0; j < numSegments; j++) {
			positions.push(getPosition(i, j));
			positions.push(getPosition(i + 1, j));
			positions.push(getPosition(i + 1, j + 1));
			positions.push(getPosition(i, j + 1));

			normals.push(getPosition(i, j, true));
			normals.push(getPosition(i + 1, j, true));
			normals.push(getPosition(i + 1, j + 1, true));
			normals.push(getPosition(i, j + 1, true));

			var u = j / numSegments;
			var v = i / numSegments;

			coords.push([1.0 - u, v]);
			coords.push([1.0 - u, v + gapUV]);
			coords.push([1.0 - u - gapUV, v + gapUV]);
			coords.push([1.0 - u - gapUV, v]);

			indices.push(index * 4 + 0);
			indices.push(index * 4 + 1);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 0);
			indices.push(index * 4 + 2);
			indices.push(index * 4 + 3);

			index++;
		}
	}

	if (isInvert) {
		indices.reverse();
	}

	var mesh = new _Geometry2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.cube = function cube(w, h, d) {
	var drawType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 4;

	h = h || w;
	d = d || w;

	var x = w / 2;
	var y = h / 2;
	var z = d / 2;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var count = 0;

	// BACK
	positions.push([-x, y, -z]);
	positions.push([x, y, -z]);
	positions.push([x, -y, -z]);
	positions.push([-x, -y, -z]);

	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// RIGHT
	positions.push([x, y, -z]);
	positions.push([x, y, z]);
	positions.push([x, -y, z]);
	positions.push([x, -y, -z]);

	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// FRONT
	positions.push([x, y, z]);
	positions.push([-x, y, z]);
	positions.push([-x, -y, z]);
	positions.push([x, -y, z]);

	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// LEFT
	positions.push([-x, y, z]);
	positions.push([-x, y, -z]);
	positions.push([-x, -y, -z]);
	positions.push([-x, -y, z]);

	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// TOP
	positions.push([x, y, -z]);
	positions.push([-x, y, -z]);
	positions.push([-x, y, z]);
	positions.push([x, y, z]);

	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// BOTTOM
	positions.push([x, -y, z]);
	positions.push([-x, -y, z]);
	positions.push([-x, -y, -z]);
	positions.push([x, -y, -z]);

	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	var mesh = new _Geometry2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.skybox = function skybox(size) {
	var drawType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;

	var positions = [];
	var coords = [];
	var indices = [];
	var normals = [];
	var count = 0;

	// BACK
	positions.push([size, size, -size]);
	positions.push([-size, size, -size]);
	positions.push([-size, -size, -size]);
	positions.push([size, -size, -size]);

	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);
	normals.push([0, 0, -1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// RIGHT
	positions.push([size, -size, -size]);
	positions.push([size, -size, size]);
	positions.push([size, size, size]);
	positions.push([size, size, -size]);

	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);
	normals.push([1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// FRONT
	positions.push([-size, size, size]);
	positions.push([size, size, size]);
	positions.push([size, -size, size]);
	positions.push([-size, -size, size]);

	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);
	normals.push([0, 0, 1]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// LEFT
	positions.push([-size, -size, size]);
	positions.push([-size, -size, -size]);
	positions.push([-size, size, -size]);
	positions.push([-size, size, size]);

	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);
	normals.push([-1, 0, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// TOP
	positions.push([size, size, size]);
	positions.push([-size, size, size]);
	positions.push([-size, size, -size]);
	positions.push([size, size, -size]);

	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);
	normals.push([0, 1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	count++;

	// BOTTOM
	positions.push([size, -size, -size]);
	positions.push([-size, -size, -size]);
	positions.push([-size, -size, size]);
	positions.push([size, -size, size]);

	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);
	normals.push([0, -1, 0]);

	coords.push([0, 0]);
	coords.push([1, 0]);
	coords.push([1, 1]);
	coords.push([0, 1]);

	indices.push(count * 4 + 0);
	indices.push(count * 4 + 1);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 0);
	indices.push(count * 4 + 2);
	indices.push(count * 4 + 3);

	var mesh = new _Geometry2.default(drawType);
	mesh.bufferVertex(positions);
	mesh.bufferTexCoord(coords);
	mesh.bufferIndex(indices);
	mesh.bufferNormal(normals);

	return mesh;
};

Geom.bigTriangle = function bigTriangle() {

	if (!meshTri) {
		var indices = [2, 1, 0];
		var positions = [[-1, -1], [-1, 4], [4, -1]];

		meshTri = new _Geometry2.default();
		meshTri.bufferData(positions, 'aPosition', 2);
		meshTri.bufferIndex(indices);
	}

	return meshTri;
};

exports.default = Geom;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Object3D.js

var _glMatrix = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Object3D = function () {
	function Object3D() {
		_classCallCheck(this, Object3D);

		this._needUpdate = true;

		this._x = 0;
		this._y = 0;
		this._z = 0;

		this._sx = 1;
		this._sy = 1;
		this._sz = 1;

		this._rx = 0;
		this._ry = 0;
		this._rz = 0;

		this._position = _glMatrix.vec3.create();
		this._scale = _glMatrix.vec3.fromValues(1, 1, 1);
		this._rotation = _glMatrix.vec3.create();

		this._matrix = _glMatrix.mat4.create();
		this._matrixParent = _glMatrix.mat4.create();
		this._matrixRotation = _glMatrix.mat4.create();
		this._matrixScale = _glMatrix.mat4.create();
		this._matrixTranslation = _glMatrix.mat4.create();
		this._matrixQuaternion = _glMatrix.mat4.create();
		this._quat = _glMatrix.quat.create();

		this._children = [];
	}

	_createClass(Object3D, [{
		key: 'updateMatrix',
		value: function updateMatrix() {
			var _this = this;

			if (!this._needUpdate) {
				return;
			}

			_glMatrix.vec3.set(this._scale, this._sx, this._sy, this._sz);
			_glMatrix.vec3.set(this._rotation, this._rx, this._ry, this._rz);
			_glMatrix.vec3.set(this._position, this._x, this._y, this._z);

			_glMatrix.mat4.identity(this._matrixTranslation, this._matrixTranslation);
			_glMatrix.mat4.identity(this._matrixScale, this._matrixScale);
			_glMatrix.mat4.identity(this._matrixRotation, this._matrixRotation);

			_glMatrix.mat4.rotateX(this._matrixRotation, this._matrixRotation, this._rx);
			_glMatrix.mat4.rotateY(this._matrixRotation, this._matrixRotation, this._ry);
			_glMatrix.mat4.rotateZ(this._matrixRotation, this._matrixRotation, this._rz);

			_glMatrix.mat4.fromQuat(this._matrixQuaternion, this._quat);
			_glMatrix.mat4.mul(this._matrixRotation, this._matrixQuaternion, this._matrixRotation);

			_glMatrix.mat4.scale(this._matrixScale, this._matrixScale, this._scale);
			_glMatrix.mat4.translate(this._matrixTranslation, this._matrixTranslation, this._position);

			_glMatrix.mat4.mul(this._matrix, this._matrixTranslation, this._matrixRotation);
			_glMatrix.mat4.mul(this._matrix, this._matrix, this._matrixScale);
			_glMatrix.mat4.mul(this._matrix, this._matrixParent, this._matrix);

			this._children.forEach(function (child) {
				child.updateParentMatrix(_this._matrix);
			});

			this._needUpdate = false;
		}
	}, {
		key: 'updateParentMatrix',
		value: function updateParentMatrix(mParentMatrix) {
			mParentMatrix = mParentMatrix || _glMatrix.mat4.create();
			_glMatrix.mat4.copy(this._matrixParent, mParentMatrix);
			this._needUpdate = true;
		}
	}, {
		key: 'setRotationFromQuaternion',
		value: function setRotationFromQuaternion(mQuat) {
			_glMatrix.quat.copy(this._quat, mQuat);
			this._needUpdate = true;
		}
	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}
	}, {
		key: 'matrix',
		get: function get() {
			this.updateMatrix();
			return this._matrix;
		}
	}, {
		key: 'x',
		get: function get() {
			return this._x;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._x = mValue;
		}
	}, {
		key: 'y',
		get: function get() {
			return this._y;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._y = mValue;
		}
	}, {
		key: 'z',
		get: function get() {
			return this._z;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._z = mValue;
		}
	}, {
		key: 'scaleX',
		get: function get() {
			return this._sx;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sx = mValue;
		}
	}, {
		key: 'scaleY',
		get: function get() {
			return this._sy;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sy = mValue;
		}
	}, {
		key: 'scaleZ',
		get: function get() {
			return this._sz;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._sz = mValue;
		}
	}, {
		key: 'rotationX',
		get: function get() {
			return this._rx;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._rx = mValue;
		}
	}, {
		key: 'rotationY',
		get: function get() {
			return this._ry;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._ry = mValue;
		}
	}, {
		key: 'rotationZ',
		get: function get() {
			return this._rz;
		},
		set: function set(mValue) {
			this._needUpdate = true;
			this._rz = mValue;
		}
	}, {
		key: 'children',
		get: function get() {
			return this._children;
		}
	}]);

	return Object3D;
}();

exports.default = Object3D;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // GLTexture.js

var _getTextureParameters = __webpack_require__(59);

var _getTextureParameters2 = _interopRequireDefault(_getTextureParameters);

var _WebglNumber = __webpack_require__(10);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var GLTexture = function () {
	function GLTexture(mSource) {
		var mParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var _this = this;

		var mWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
		var mHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

		_classCallCheck(this, GLTexture);

		gl = _GLTool2.default.gl;

		this._source = mSource;
		this._getDimension(mSource, mWidth, mHeight);
		this._sourceType = mParam.type || getSourceType(mSource);
		this._checkSource();
		this._texelType = this._getTexelType();
		this._isTextureReady = true;

		this._params = (0, _getTextureParameters2.default)(mParam, mSource, this._width, this._height);
		this._checkMipmap();
		this._checkWrapping();

		//	setup texture
		this._texture = gl.createTexture();

		if (this._sourceType === 'video') {
			this._isTextureReady = false;
			_scheduling2.default.addEF(function () {
				return _this._loop();
			});
		} else {
			this._uploadTexture();
		}
	}

	_createClass(GLTexture, [{
		key: '_loop',
		value: function _loop() {
			if (this._source.readyState == 4) {
				this._isTextureReady = true;
				this._uploadTexture();
			}
		}
	}, {
		key: '_uploadTexture',
		value: function _uploadTexture() {
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

			if (this._isSourceHtmlElement()) {
				gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._params.format, this._texelType, this._source);
			} else {
				gl.texImage2D(gl.TEXTURE_2D, 0, this._params.internalFormat, this._width, this._height, 0, this._params.format, this._texelType, this._source);
			}

			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._params.premultiplyAlpha);

			if (this._params.anisotropy > 0) {
				var ext = _GLTool2.default.getExtension('EXT_texture_filter_anisotropic');
				if (ext) {
					var max = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
					var level = Math.min(max, this._params.anisotropy);
					gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, level);
				}
			}

			if (this._generateMipmap) {
				gl.generateMipmap(gl.TEXTURE_2D);
			}

			//	unbind texture
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'bind',
		value: function bind(index) {
			if (index === undefined) {
				index = 0;
			}
			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			if (this._isTextureReady) {
				gl.bindTexture(gl.TEXTURE_2D, this._texture);
			} else {
				gl.bindTexture(gl.TEXTURE_2D, GLTexture.blackTexture().texture);
			}

			this._bindIndex = index;
		}
	}, {
		key: 'updateTexture',
		value: function updateTexture(mSource) {
			this._source = mSource;
			this._checkSource();
			this._uploadTexture();
		}
	}, {
		key: 'generateMipmap',
		value: function generateMipmap() {
			if (!this._generateMipmap) {
				return;
			}
			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.generateMipmap(gl.TEXTURE_2D);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'showParameters',
		value: function showParameters() {
			console.log('Source type : ', _WebglNumber2.default[this._sourceType] || this._sourceType);
			console.log('Texel type:', _WebglNumber2.default[this.texelType]);
			console.log('Dimension :', this._width, this._height);
			for (var s in this._params) {
				console.log(s, _WebglNumber2.default[this._params[s]] || this._params[s]);
			}

			console.log('Mipmapping :', this._generateMipmap);
		}
	}, {
		key: '_getDimension',
		value: function _getDimension(mSource, mWidth, mHeight) {
			if (mSource) {
				//	for html image / video element
				this._width = mSource.width || mSource.videoWidth;
				this._height = mSource.height || mSource.videoWidth;

				//	for manual width / height settings
				this._width = this._width || mWidth;
				this._height = this._height || mHeight;

				//	auto detect ( data array) ? not sure is good idea ? 
				//	todo : check HDR 
				if (!this._width || !this._height) {
					this._width = this._height = Math.sqrt(mSource.length / 4);
					// console.log('Auto detect, data dimension : ', this._width, this._height);	
				}
			} else {
				this._width = mWidth;
				this._height = mHeight;
			}
		}
	}, {
		key: '_checkSource',
		value: function _checkSource() {
			if (!this._source) {
				return;
			}

			if (this._sourceType === _GLTool2.default.UNSIGNED_BYTE) {
				if (!(this._source instanceof Uint8Array)) {
					// console.log('Converting to Uint8Array');
					this._source = new Uint8Array(this._source);
				}
			} else if (this._sourceType === _GLTool2.default.FLOAT) {
				if (!(this._source instanceof Float32Array)) {
					// console.log('Converting to Float32Array');
					this._source = new Float32Array(this._source);
				}
			}
		}
	}, {
		key: '_getTexelType',
		value: function _getTexelType() {
			if (this._isSourceHtmlElement()) {
				return _GLTool2.default.UNSIGNED_BYTE;
			}

			//	bad code here, if the type is not on the webglNumber list, it doesn't work
			return _GLTool2.default[_WebglNumber2.default[this._sourceType]] || this._sourceType;
		}
	}, {
		key: '_checkMipmap',
		value: function _checkMipmap() {
			this._generateMipmap = this._params.mipmap;

			if (!(isPowerOfTwo(this._width) && isPowerOfTwo(this._height))) {
				this._generateMipmap = false;
			}

			var minFilter = _WebglNumber2.default[this._params.minFilter];
			if (minFilter.indexOf('MIPMAP') == -1) {
				this._generateMipmap = false;
			}
		}
	}, {
		key: '_checkWrapping',
		value: function _checkWrapping() {
			if (!this._generateMipmap) {
				this._params.wrapS = _GLTool2.default.CLAMP_TO_EDGE;
				this._params.wrapT = _GLTool2.default.CLAMP_TO_EDGE;
			}
		}
	}, {
		key: '_isSourceHtmlElement',
		value: function _isSourceHtmlElement() {
			return this._sourceType === 'image' || this._sourceType === 'video' || this._sourceType === 'canvas';
		}
	}, {
		key: 'minFilter',
		get: function get() {
			return this._params.minFilter;
		},
		set: function set(mValue) {
			this._params.minFilter = mValue;
			this._checkMipmap();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._params.minFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);

			this.generateMipmap();
		}
	}, {
		key: 'magFilter',
		get: function get() {
			return this._params.minFilter;
		},
		set: function set(mValue) {
			this._params.magFilter = mValue;

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._params.magFilter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'wrapS',
		get: function get() {
			return this._params.wrapS;
		},
		set: function set(mValue) {
			this._params.wrapS = mValue;
			this._checkWrapping();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._params.wrapS);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'wrapT',
		get: function get() {
			return this._params.wrapT;
		},
		set: function set(mValue) {
			this._params.wrapT = mValue;
			this._checkWrapping();

			gl.bindTexture(gl.TEXTURE_2D, this._texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._params.wrapT);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: 'texelType',
		get: function get() {
			return this._texelType;
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'texture',
		get: function get() {
			return this._texture;
		}
	}, {
		key: 'isTextureReady',
		get: function get() {
			return this._isTextureReady;
		}
	}]);

	return GLTexture;
}();

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

function getSourceType(mSource) {
	//	possible source type : Image / Video / Unit8Array / Float32Array
	//	this list must be flexible

	var type = _GLTool2.default.UNSIGNED_BYTE;

	if (mSource instanceof Array) {
		type = _GLTool2.default.UNSIGNED_BYTE;
	} else if (mSource instanceof Uint8Array) {
		type = _GLTool2.default.UNSIGNED_BYTE;
	} else if (mSource instanceof Float32Array) {
		type = _GLTool2.default.FLOAT;
	} else if (mSource instanceof HTMLImageElement) {
		type = 'image';
	} else if (mSource instanceof HTMLCanvasElement) {
		type = 'canvas';
	} else if (mSource instanceof HTMLVideoElement) {
		type = 'video';
	}
	return type;
}

var _whiteTexture = void 0,
    _greyTexture = void 0,
    _blackTexture = void 0;

GLTexture.whiteTexture = function whiteTexture() {
	if (_whiteTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = '#fff';
		ctx.fillRect(0, 0, 2, 2);
		_whiteTexture = new GLTexture(canvas);
	}

	return _whiteTexture;
};

GLTexture.greyTexture = function greyTexture() {
	if (_greyTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(127, 127, 127)';
		ctx.fillRect(0, 0, 2, 2);
		_greyTexture = new GLTexture(canvas);
	}
	return _greyTexture;
};

GLTexture.blackTexture = function blackTexture() {
	if (_blackTexture === undefined) {
		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 2;
		var ctx = canvas.getContext('2d');
		ctx.fillStyle = 'rgb(0, 0, 0)';
		ctx.fillRect(0, 0, 2, 2);
		_blackTexture = new GLTexture(canvas);
	}
	return _blackTexture;
};

exports.default = GLTexture;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^
module.exports = {
	0: 'NONE',
	1: 'ONE',
	2: 'LINE_LOOP',
	3: 'LINE_STRIP',
	4: 'TRIANGLES',
	5: 'TRIANGLE_STRIP',
	6: 'TRIANGLE_FAN',
	256: 'DEPTH_BUFFER_BIT',
	512: 'NEVER',
	513: 'LESS',
	514: 'EQUAL',
	515: 'LEQUAL',
	516: 'GREATER',
	517: 'NOTEQUAL',
	518: 'GEQUAL',
	519: 'ALWAYS',
	768: 'SRC_COLOR',
	769: 'ONE_MINUS_SRC_COLOR',
	770: 'SRC_ALPHA',
	771: 'ONE_MINUS_SRC_ALPHA',
	772: 'DST_ALPHA',
	773: 'ONE_MINUS_DST_ALPHA',
	774: 'DST_COLOR',
	775: 'ONE_MINUS_DST_COLOR',
	776: 'SRC_ALPHA_SATURATE',
	1024: 'STENCIL_BUFFER_BIT',
	1028: 'FRONT',
	1029: 'BACK',
	1032: 'FRONT_AND_BACK',
	1280: 'INVALID_ENUM',
	1281: 'INVALID_VALUE',
	1282: 'INVALID_OPERATION',
	1285: 'OUT_OF_MEMORY',
	1286: 'INVALID_FRAMEBUFFER_OPERATION',
	2304: 'CW',
	2305: 'CCW',
	2849: 'LINE_WIDTH',
	2884: 'CULL_FACE',
	2885: 'CULL_FACE_MODE',
	2886: 'FRONT_FACE',
	2928: 'DEPTH_RANGE',
	2929: 'DEPTH_TEST',
	2930: 'DEPTH_WRITEMASK',
	2931: 'DEPTH_CLEAR_VALUE',
	2932: 'DEPTH_FUNC',
	2960: 'STENCIL_TEST',
	2961: 'STENCIL_CLEAR_VALUE',
	2962: 'STENCIL_FUNC',
	2963: 'STENCIL_VALUE_MASK',
	2964: 'STENCIL_FAIL',
	2965: 'STENCIL_PASS_DEPTH_FAIL',
	2966: 'STENCIL_PASS_DEPTH_PASS',
	2967: 'STENCIL_REF',
	2968: 'STENCIL_WRITEMASK',
	2978: 'VIEWPORT',
	3024: 'DITHER',
	3042: 'BLEND',
	3088: 'SCISSOR_BOX',
	3089: 'SCISSOR_TEST',
	3106: 'COLOR_CLEAR_VALUE',
	3107: 'COLOR_WRITEMASK',
	3317: 'UNPACK_ALIGNMENT',
	3333: 'PACK_ALIGNMENT',
	3379: 'MAX_TEXTURE_SIZE',
	3386: 'MAX_VIEWPORT_DIMS',
	3408: 'SUBPIXEL_BITS',
	3410: 'RED_BITS',
	3411: 'GREEN_BITS',
	3412: 'BLUE_BITS',
	3413: 'ALPHA_BITS',
	3414: 'DEPTH_BITS',
	3415: 'STENCIL_BITS',
	3553: 'TEXTURE_2D',
	4352: 'DONT_CARE',
	4353: 'FASTEST',
	4354: 'NICEST',
	5120: 'BYTE',
	5121: 'UNSIGNED_BYTE',
	5122: 'SHORT',
	5123: 'UNSIGNED_SHORT',
	5124: 'INT',
	5125: 'UNSIGNED_INT',
	5126: 'FLOAT',
	5386: 'INVERT',
	5890: 'TEXTURE',
	6401: 'STENCIL_INDEX',
	6402: 'DEPTH_COMPONENT',
	6403: 'RED',
	6406: 'ALPHA',
	6407: 'RGB',
	6408: 'RGBA',
	6409: 'LUMINANCE',
	6410: 'LUMINANCE_ALPHA',
	7680: 'KEEP',
	7681: 'REPLACE',
	7682: 'INCR',
	7683: 'DECR',
	7936: 'VENDOR',
	7937: 'RENDERER',
	7938: 'VERSION',
	9728: 'NEAREST',
	9729: 'LINEAR',
	9984: 'NEAREST_MIPMAP_NEAREST',
	9985: 'LINEAR_MIPMAP_NEAREST',
	9986: 'NEAREST_MIPMAP_LINEAR',
	9987: 'LINEAR_MIPMAP_LINEAR',
	10240: 'TEXTURE_MAG_FILTER',
	10241: 'TEXTURE_MIN_FILTER',
	10242: 'TEXTURE_WRAP_S',
	10243: 'TEXTURE_WRAP_T',
	10497: 'REPEAT',
	10752: 'POLYGON_OFFSET_UNITS',
	16384: 'COLOR_BUFFER_BIT',
	32769: 'CONSTANT_COLOR',
	32770: 'ONE_MINUS_CONSTANT_COLOR',
	32771: 'CONSTANT_ALPHA',
	32772: 'ONE_MINUS_CONSTANT_ALPHA',
	32773: 'BLEND_COLOR',
	32774: 'FUNC_ADD',
	32777: 'BLEND_EQUATION_RGB',
	32778: 'FUNC_SUBTRACT',
	32779: 'FUNC_REVERSE_SUBTRACT',
	32819: 'UNSIGNED_SHORT_4_4_4_4',
	32820: 'UNSIGNED_SHORT_5_5_5_1',
	32823: 'POLYGON_OFFSET_FILL',
	32824: 'POLYGON_OFFSET_FACTOR',
	32854: 'RGBA4',
	32855: 'RGB5_A1',
	32873: 'TEXTURE_BINDING_2D',
	32926: 'SAMPLE_ALPHA_TO_COVERAGE',
	32928: 'SAMPLE_COVERAGE',
	32936: 'SAMPLE_BUFFERS',
	32937: 'SAMPLES',
	32938: 'SAMPLE_COVERAGE_VALUE',
	32939: 'SAMPLE_COVERAGE_INVERT',
	32968: 'BLEND_DST_RGB',
	32969: 'BLEND_SRC_RGB',
	32970: 'BLEND_DST_ALPHA',
	32971: 'BLEND_SRC_ALPHA',
	33071: 'CLAMP_TO_EDGE',
	33170: 'GENERATE_MIPMAP_HINT',
	33189: 'DEPTH_COMPONENT16',
	33306: 'DEPTH_STENCIL_ATTACHMENT',
	33321: 'R8',
	33635: 'UNSIGNED_SHORT_5_6_5',
	33648: 'MIRRORED_REPEAT',
	33901: 'ALIASED_POINT_SIZE_RANGE',
	33902: 'ALIASED_LINE_WIDTH_RANGE',
	33984: 'TEXTURE0',
	33985: 'TEXTURE1',
	33986: 'TEXTURE2',
	33987: 'TEXTURE3',
	33988: 'TEXTURE4',
	33989: 'TEXTURE5',
	33990: 'TEXTURE6',
	33991: 'TEXTURE7',
	33992: 'TEXTURE8',
	33993: 'TEXTURE9',
	33994: 'TEXTURE10',
	33995: 'TEXTURE11',
	33996: 'TEXTURE12',
	33997: 'TEXTURE13',
	33998: 'TEXTURE14',
	33999: 'TEXTURE15',
	34000: 'TEXTURE16',
	34001: 'TEXTURE17',
	34002: 'TEXTURE18',
	34003: 'TEXTURE19',
	34004: 'TEXTURE20',
	34005: 'TEXTURE21',
	34006: 'TEXTURE22',
	34007: 'TEXTURE23',
	34008: 'TEXTURE24',
	34009: 'TEXTURE25',
	34010: 'TEXTURE26',
	34011: 'TEXTURE27',
	34012: 'TEXTURE28',
	34013: 'TEXTURE29',
	34014: 'TEXTURE30',
	34015: 'TEXTURE31',
	34016: 'ACTIVE_TEXTURE',
	34024: 'MAX_RENDERBUFFER_SIZE',
	34041: 'DEPTH_STENCIL',
	34055: 'INCR_WRAP',
	34056: 'DECR_WRAP',
	34067: 'TEXTURE_CUBE_MAP',
	34068: 'TEXTURE_BINDING_CUBE_MAP',
	34069: 'TEXTURE_CUBE_MAP_POSITIVE_X',
	34070: 'TEXTURE_CUBE_MAP_NEGATIVE_X',
	34071: 'TEXTURE_CUBE_MAP_POSITIVE_Y',
	34072: 'TEXTURE_CUBE_MAP_NEGATIVE_Y',
	34073: 'TEXTURE_CUBE_MAP_POSITIVE_Z',
	34074: 'TEXTURE_CUBE_MAP_NEGATIVE_Z',
	34076: 'MAX_CUBE_MAP_TEXTURE_SIZE',
	34338: 'VERTEX_ATTRIB_ARRAY_ENABLED',
	34339: 'VERTEX_ATTRIB_ARRAY_SIZE',
	34340: 'VERTEX_ATTRIB_ARRAY_STRIDE',
	34341: 'VERTEX_ATTRIB_ARRAY_TYPE',
	34342: 'CURRENT_VERTEX_ATTRIB',
	34373: 'VERTEX_ATTRIB_ARRAY_POINTER',
	34466: 'NUM_COMPRESSED_TEXTURE_FORMATS',
	34467: 'COMPRESSED_TEXTURE_FORMATS',
	34660: 'BUFFER_SIZE',
	34661: 'BUFFER_USAGE',
	34816: 'STENCIL_BACK_FUNC',
	34817: 'STENCIL_BACK_FAIL',
	34818: 'STENCIL_BACK_PASS_DEPTH_FAIL',
	34819: 'STENCIL_BACK_PASS_DEPTH_PASS',
	34877: 'BLEND_EQUATION_ALPHA',
	34921: 'MAX_VERTEX_ATTRIBS',
	34922: 'VERTEX_ATTRIB_ARRAY_NORMALIZED',
	34930: 'MAX_TEXTURE_IMAGE_UNITS',
	34962: 'ARRAY_BUFFER',
	34963: 'ELEMENT_ARRAY_BUFFER',
	34964: 'ARRAY_BUFFER_BINDING',
	34965: 'ELEMENT_ARRAY_BUFFER_BINDING',
	34975: 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING',
	35040: 'STREAM_DRAW',
	35044: 'STATIC_DRAW',
	35048: 'DYNAMIC_DRAW',
	35632: 'FRAGMENT_SHADER',
	35633: 'VERTEX_SHADER',
	35660: 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
	35661: 'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
	35663: 'SHADER_TYPE',
	35664: 'FLOAT_VEC2',
	35665: 'FLOAT_VEC3',
	35666: 'FLOAT_VEC4',
	35667: 'INT_VEC2',
	35668: 'INT_VEC3',
	35669: 'INT_VEC4',
	35670: 'BOOL',
	35671: 'BOOL_VEC2',
	35672: 'BOOL_VEC3',
	35673: 'BOOL_VEC4',
	35674: 'FLOAT_MAT2',
	35675: 'FLOAT_MAT3',
	35676: 'FLOAT_MAT4',
	35678: 'SAMPLER_2D',
	35680: 'SAMPLER_CUBE',
	35712: 'DELETE_STATUS',
	35713: 'COMPILE_STATUS',
	35714: 'LINK_STATUS',
	35715: 'VALIDATE_STATUS',
	35716: 'INFO_LOG_LENGTH',
	35717: 'ATTACHED_SHADERS',
	35718: 'ACTIVE_UNIFORMS',
	35719: 'ACTIVE_UNIFORM_MAX_LENGTH',
	35720: 'SHADER_SOURCE_LENGTH',
	35721: 'ACTIVE_ATTRIBUTES',
	35722: 'ACTIVE_ATTRIBUTE_MAX_LENGTH',
	35724: 'SHADING_LANGUAGE_VERSION',
	35725: 'CURRENT_PROGRAM',
	36003: 'STENCIL_BACK_REF',
	36004: 'STENCIL_BACK_VALUE_MASK',
	36005: 'STENCIL_BACK_WRITEMASK',
	36006: 'FRAMEBUFFER_BINDING',
	36007: 'RENDERBUFFER_BINDING',
	36048: 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE',
	36049: 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME',
	36050: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL',
	36051: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE',
	36053: 'FRAMEBUFFER_COMPLETE',
	36054: 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',
	36055: 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',
	36057: 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',
	36061: 'FRAMEBUFFER_UNSUPPORTED',
	36064: 'COLOR_ATTACHMENT0',
	36096: 'DEPTH_ATTACHMENT',
	36128: 'STENCIL_ATTACHMENT',
	36160: 'FRAMEBUFFER',
	36161: 'RENDERBUFFER',
	36162: 'RENDERBUFFER_WIDTH',
	36163: 'RENDERBUFFER_HEIGHT',
	36164: 'RENDERBUFFER_INTERNAL_FORMAT',
	36168: 'STENCIL_INDEX8',
	36176: 'RENDERBUFFER_RED_SIZE',
	36177: 'RENDERBUFFER_GREEN_SIZE',
	36178: 'RENDERBUFFER_BLUE_SIZE',
	36179: 'RENDERBUFFER_ALPHA_SIZE',
	36180: 'RENDERBUFFER_DEPTH_SIZE',
	36181: 'RENDERBUFFER_STENCIL_SIZE',
	36194: 'RGB565',
	36336: 'LOW_FLOAT',
	36337: 'MEDIUM_FLOAT',
	36338: 'HIGH_FLOAT',
	36339: 'LOW_INT',
	36340: 'MEDIUM_INT',
	36341: 'HIGH_INT',
	36346: 'SHADER_COMPILER',
	36347: 'MAX_VERTEX_UNIFORM_VECTORS',
	36348: 'MAX_VARYING_VECTORS',
	36349: 'MAX_FRAGMENT_UNIFORM_VECTORS',
	37440: 'UNPACK_FLIP_Y_WEBGL',
	37441: 'UNPACK_PREMULTIPLY_ALPHA_WEBGL',
	37442: 'CONTEXT_LOST_WEBGL',
	37443: 'UNPACK_COLORSPACE_CONVERSION_WEBGL',
	37444: 'BROWSER_DEFAULT_WEBGL'
};

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = "// simpleColor.frag\n\n#define SHADER_NAME SIMPLE_COLOR\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec3 color;\nuniform float opacity;\n\nvoid main(void) {\n    gl_FragColor = vec4(color, opacity);\n}"

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Pass.js

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _FrameBuffer = __webpack_require__(18);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

var _ShaderLibs = __webpack_require__(21);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Pass = function () {
	function Pass(mSource) {
		var mWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var mHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
		var mParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

		_classCallCheck(this, Pass);

		this.shader = new _GLShader2.default(_ShaderLibs2.default.bigTriangleVert, mSource);

		this._width = mWidth;
		this._height = mHeight;
		this._uniforms = {};
		this._hasOwnFbo = this._width > 0 && this._width > 0;
		this._uniforms = {};

		if (this._hasOwnFbo) {
			this._fbo = new _FrameBuffer2.default(this._width, this.height, mParmas);
		}
	}

	_createClass(Pass, [{
		key: 'uniform',
		value: function uniform(mName, mValue) {
			this._uniforms[mName] = mValue;
		}
	}, {
		key: 'render',
		value: function render(texture) {
			this.shader.bind();
			this.shader.uniform('texture', 'uniform1i', 0);
			texture.bind(0);

			this.shader.uniform(this._uniforms);
		}
	}, {
		key: 'width',
		get: function get() {
			return this._width;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._height;
		}
	}, {
		key: 'fbo',
		get: function get() {
			return this._fbo;
		}
	}, {
		key: 'hasFbo',
		get: function get() {
			return this._hasOwnFbo;
		}
	}]);

	return Pass;
}();

exports.default = Pass;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Object3D2 = __webpack_require__(8);

var _Object3D3 = _interopRequireDefault(_Object3D2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Mesh = function (_Object3D) {
	_inherits(Mesh, _Object3D);

	function Mesh(geometry, material) {
		_classCallCheck(this, Mesh);

		var _this = _possibleConstructorReturn(this, (Mesh.__proto__ || Object.getPrototypeOf(Mesh)).call(this));

		_this.geometry = geometry;
		_this.material = material;
		return _this;
	}

	return Mesh;
}(_Object3D3.default);

exports.default = Mesh;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GLCubeTexture.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _parseDds = __webpack_require__(60);

var _parseDds2 = _interopRequireDefault(_parseDds);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var DDSD_MIPMAPCOUNT = 0x20000;
var OFF_MIPMAPCOUNT = 7;
var headerLengthInt = 31;

var GLCubeTexture = function () {
	function GLCubeTexture(mSource) {
		var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		var isCubeTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

		_classCallCheck(this, GLCubeTexture);

		gl = _GLTool2.default.gl;

		if (isCubeTexture) {
			this.texture = mSource;
			return;
		}

		var hasMipmaps = mSource.length > 6;
		if (mSource[0].mipmapCount) {
			hasMipmaps = mSource[0].mipmapCount > 1;
		}

		this.texture = gl.createTexture();
		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR_MIPMAP_LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

		if (!hasMipmaps && this.minFilter == gl.LINEAR_MIPMAP_LINEAR) {
			this.minFilter = gl.LINEAR;
		}

		gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
		var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

		var numLevels = 1;
		var index = 0;
		numLevels = mSource.length / 6;
		this.numLevels = numLevels;

		if (hasMipmaps) {
			for (var j = 0; j < 6; j++) {
				for (var i = 0; i < numLevels; i++) {
					gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

					index = j * numLevels + i;
					if (mSource[index].shape) {
						gl.texImage2D(targets[j], i, gl.RGBA, mSource[index].shape[0], mSource[index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[index].data);
					} else {
						gl.texImage2D(targets[j], i, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[index]);
					}

					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
					gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
				}
			}
		} else {
			var _index = 0;
			for (var _j = 0; _j < 6; _j++) {
				_index = _j * numLevels;
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				if (mSource[_index].shape) {
					gl.texImage2D(targets[_j], 0, gl.RGBA, mSource[_index].shape[0], mSource[_index].shape[1], 0, gl.RGBA, gl.FLOAT, mSource[_index].data);
				} else {
					gl.texImage2D(targets[_j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, mSource[_index]);
				}
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
				gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
			}

			gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
		}

		gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	}

	//	PUBLIC METHOD

	_createClass(GLCubeTexture, [{
		key: 'bind',
		value: function bind() {
			var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			if (!_GLTool2.default.shader) {
				return;
			}

			gl.activeTexture(gl.TEXTURE0 + index);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
			// gl.uniform1i(GL.shader.uniformTextures[index], index);
			this._bindIndex = index;
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		}
	}]);

	return GLCubeTexture;
}();

GLCubeTexture.parseDDS = function parseDDS(mArrayBuffer) {

	function clamp(value, min, max) {
		if (min > max) {
			return clamp(value, max, min);
		}

		if (value < min) return min;else if (value > max) return max;else return value;
	}

	//	CHECKING MIP MAP LEVELS
	var ddsInfos = (0, _parseDds2.default)(mArrayBuffer);
	var flags = ddsInfos.flags;

	var header = new Int32Array(mArrayBuffer, 0, headerLengthInt);
	var mipmapCount = 1;
	if (flags & DDSD_MIPMAPCOUNT) {
		mipmapCount = Math.max(1, header[OFF_MIPMAPCOUNT]);
	}
	var sources = ddsInfos.images.map(function (img) {
		var faceData = new Float32Array(mArrayBuffer.slice(img.offset, img.offset + img.length));
		return {
			data: faceData,
			shape: img.shape,
			mipmapCount: mipmapCount
		};
	});

	return new GLCubeTexture(sources);
};

exports.default = GLCubeTexture;

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shaderCache = []; // Shaders.js

var definesToString = function definesToString(defines) {
	var outStr = '';
	for (var def in defines) {
		if (defines[def]) {
			outStr += '#define ' + def + ' ' + defines[def] + '\n';
		}
	}
	return outStr;
};

var getUniformType = function getUniformType(mValue) {
	if (mValue.length) {
		return 'vec' + mValue.length;
	} else {
		return 'float';
	}
};

var addUniforms = function addUniforms(mShader, mObjUniforms) {

	var strUniforms = '';
	for (var uniformName in mObjUniforms) {
		var uniformValue = mObjUniforms[uniformName];
		var uniformType = getUniformType(uniformValue);

		strUniforms += 'uniform ' + uniformType + ' ' + uniformName + ';\n';
	}

	mShader = mShader.replace('{{UNIFORMS}}', strUniforms);

	return mShader;
};

var bindUniforms = function bindUniforms(mShader, mObjUniforms) {

	for (var uniformName in mObjUniforms) {
		var uniformValue = mObjUniforms[uniformName];
		var uniformType = getUniformType(uniformValue);
		mShader.uniform(uniformName, uniformType, uniformValue);
	}
};

var injectDefines = function injectDefines(mShader, mDefines) {

	return definesToString(mDefines) + '\n' + mShader;
};

var get = function get(vs, fs) {
	var defines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	var _shader = void 0;
	var _vs = injectDefines(vs, defines);
	var _fs = injectDefines(fs, defines);

	shaderCache.forEach(function (shader) {
		if (_vs === shader.vs && _fs === shader.fs) {
			_shader = shader.glShader;
		}
	});

	if (!_shader) {
		_shader = new _GLShader2.default(_vs, _fs);
		shaderCache.push({
			vs: _vs,
			fs: _fs,
			glShader: _shader
		});
	}

	return _shader;
};

exports.default = {
	get: get,
	addUniforms: addUniforms,
	bindUniforms: bindUniforms,
	injectDefines: injectDefines
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // FrameBuffer.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _WebglNumber = __webpack_require__(10);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _objectAssign = __webpack_require__(17);

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;
var webglDepthTexture = void 0;
var hasCheckedMultiRenderSupport = false;
var extDrawBuffer = void 0;

var checkMultiRender = function checkMultiRender() {
	if (_GLTool2.default.webgl2) {
		return true;
	} else {
		extDrawBuffer = _GLTool2.default.getExtension('WEBGL_draw_buffers');
		return !!extDrawBuffer;
	}

	hasCheckedMultiRenderSupport = true;
};

var FrameBuffer = function () {
	function FrameBuffer(mWidth, mHeight) {
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		var mNumTargets = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

		_classCallCheck(this, FrameBuffer);

		gl = _GLTool2.default.gl;
		webglDepthTexture = _GLTool2.default.checkExtension('WEBGL_depth_texture');

		this.width = mWidth;
		this.height = mHeight;
		this._numTargets = mNumTargets;
		this._multipleTargets = mNumTargets > 1;
		this._parameters = mParameters;

		if (!hasCheckedMultiRenderSupport) {
			checkMultiRender();
		}

		if (this._multipleTargets) {
			this._checkMaxNumRenderTarget();
		}

		this._init();
	}

	_createClass(FrameBuffer, [{
		key: '_init',
		value: function _init() {
			this._initTextures();

			this.frameBuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);

			if (_GLTool2.default.webgl2) {
				// this.renderBufferDepth = gl.createRenderbuffer();
				// gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
				// gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
				// gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);

				var buffers = [];
				for (var i = 0; i < this._numTargets; i++) {
					gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, this._textures[i].texture, 0);
					buffers.push(gl['COLOR_ATTACHMENT' + i]);
				}

				gl.drawBuffers(buffers);

				gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			} else {
				for (var _i = 0; _i < this._numTargets; _i++) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i, gl.TEXTURE_2D, this._textures[_i].texture, 0);
				}

				if (this._multipleTargets) {
					var drawBuffers = [];
					for (var _i2 = 0; _i2 < this._numTargets; _i2++) {
						drawBuffers.push(extDrawBuffer['COLOR_ATTACHMENT' + _i2 + '_WEBGL']);
					}

					extDrawBuffer.drawBuffersWEBGL(drawBuffers);
				}

				if (webglDepthTexture) {
					gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
				}
			}

			//	CHECKING FBO
			var FBOstatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			if (FBOstatus != gl.FRAMEBUFFER_COMPLETE) {
				console.error('GL_FRAMEBUFFER_COMPLETE failed, CANNOT use Framebuffer', _WebglNumber2.default[FBOstatus]);
			}

			//	UNBIND

			gl.bindTexture(gl.TEXTURE_2D, null);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			//	CLEAR FRAMEBUFFER 

			this.clear();
		}
	}, {
		key: '_checkMaxNumRenderTarget',
		value: function _checkMaxNumRenderTarget() {
			var maxNumDrawBuffers = _GLTool2.default.gl.getParameter(extDrawBuffer.MAX_DRAW_BUFFERS_WEBGL);
			if (this._numTargets > maxNumDrawBuffers) {
				console.error('Over max number of draw buffers supported : ', maxNumDrawBuffers);
				this._numTargets = maxNumDrawBuffers;
			}
		}
	}, {
		key: '_initTextures',
		value: function _initTextures() {
			this._textures = [];
			for (var i = 0; i < this._numTargets; i++) {
				var glt = this._createTexture();
				this._textures.push(glt);
			}

			if (_GLTool2.default.webgl2) {
				this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);
			} else {
				this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, { minFilter: _GLTool2.default.LINEAR });
			}
		}
	}, {
		key: '_createTexture',
		value: function _createTexture(mInternalformat, mTexelType, mFormat) {
			var mParameters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

			var parameters = (0, _objectAssign2.default)({}, this._parameters);
			if (!mFormat) {
				mFormat = mInternalformat;
			}

			parameters.internalFormat = mInternalformat || gl.RGBA;
			parameters.format = mFormat;
			parameters.type = mTexelType || parameters.type || _GLTool2.default.UNSIGNED_BYTE;
			for (var s in mParameters) {
				parameters[s] = mParameters[s];
			}

			var texture = new _GLTexture2.default(null, parameters, this.width, this.height);
			return texture;
		}

		//	PUBLIC METHODS

	}, {
		key: 'bind',
		value: function bind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, this.width, this.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			this._textures.forEach(function (texture) {
				texture.generateMipmap();
			});
		}
	}, {
		key: 'clear',
		value: function clear() {
			var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
			var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
			var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

			this.bind();
			_GLTool2.default.clear(r, g, b, a);
			this.unbind();
		}

		//	TEXTURES

	}, {
		key: 'getTexture',
		value: function getTexture() {
			var mIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			return this._textures[mIndex];
		}
	}, {
		key: 'getDepthTexture',
		value: function getDepthTexture() {
			return this.glDepthTexture;
		}

		//	TOUGHTS : Should I remove these from frame buffer ? 
		//	Shouldn't these be set individually to each texture ? 
		//	e.g. fbo.getTexture(0).minFilter = GL.NEAREST;
		//		 fbo.getTexture(1).minFilter = GL.LINEAR; ... etc ? 

		//	MIPMAP FILTER

	}, {
		key: 'showParameters',


		//	UTILS

		value: function showParameters() {
			this._textures[0].showParameters();
		}
	}, {
		key: 'minFilter',
		get: function get() {
			return this._textures[0].minFilter;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.minFilter = mValue;
			});
		}
	}, {
		key: 'magFilter',
		get: function get() {
			return this._textures[0].magFilter;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.magFilter = mValue;
			});
		}

		//	WRAPPING

	}, {
		key: 'wrapS',
		get: function get() {
			return this._textures[0].wrapS;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.wrapS = mValue;
			});
		}
	}, {
		key: 'wrapT',
		get: function get() {
			return this._textures[0].wrapT;
		},
		set: function set(mValue) {
			this._textures.forEach(function (texture) {
				texture.wrapT = mValue;
			});
		}
	}, {
		key: 'numTargets',
		get: function get() {
			return this._numTargets;
		}
	}]);

	return FrameBuffer;
}();

exports.default = FrameBuffer;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // EaseNumber.js

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EaseNumber = function () {
	function EaseNumber(mValue) {
		var _this = this;

		var mEasing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;

		_classCallCheck(this, EaseNumber);

		this.easing = mEasing;
		this._value = mValue;
		this._targetValue = mValue;
		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._update();
		});
	}

	_createClass(EaseNumber, [{
		key: '_update',
		value: function _update() {
			var MIN_DIFF = 0.0001;
			this._checkLimit();
			this._value += (this._targetValue - this._value) * this.easing;
			if (Math.abs(this._targetValue - this._value) < MIN_DIFF) {
				this._value = this._targetValue;
			}
		}
	}, {
		key: 'setTo',
		value: function setTo(mValue) {
			this._targetValue = this._value = mValue;
		}
	}, {
		key: 'add',
		value: function add(mAdd) {
			this._targetValue += mAdd;
		}
	}, {
		key: 'limit',
		value: function limit(mMin, mMax) {
			if (mMin > mMax) {
				this.limit(mMax, mMin);
				return;
			}

			this._min = mMin;
			this._max = mMax;

			this._checkLimit();
		}
	}, {
		key: '_checkLimit',
		value: function _checkLimit() {
			if (this._min !== undefined && this._targetValue < this._min) {
				this._targetValue = this._min;
			}

			if (this._max !== undefined && this._targetValue > this._max) {
				this._targetValue = this._max;
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			_scheduling2.default.removeEF(this._efIndex);
		}

		//	GETTERS / SETTERS

	}, {
		key: 'value',
		set: function set(mValue) {
			this._targetValue = mValue;
		},
		get: function get() {
			return this._value;
		}
	}, {
		key: 'targetValue',
		get: function get() {
			return this._targetValue;
		}
	}]);

	return EaseNumber;
}();

exports.default = EaseNumber;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Ray.js

var _glMatrix = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var a = _glMatrix.vec3.create();
var b = _glMatrix.vec3.create();
var c = _glMatrix.vec3.create();
var target = _glMatrix.vec3.create();
var edge1 = _glMatrix.vec3.create();
var edge2 = _glMatrix.vec3.create();
var normal = _glMatrix.vec3.create();
var diff = _glMatrix.vec3.create();

var Ray = function () {
	function Ray(mOrigin, mDirection) {
		_classCallCheck(this, Ray);

		this.origin = _glMatrix.vec3.clone(mOrigin);
		this.direction = _glMatrix.vec3.clone(mDirection);
	}

	_createClass(Ray, [{
		key: 'at',
		value: function at(t) {
			_glMatrix.vec3.copy(target, this.direction);
			_glMatrix.vec3.scale(target, target, t);
			_glMatrix.vec3.add(target, target, this.origin);

			return target;
		}
	}, {
		key: 'lookAt',
		value: function lookAt(mTarget) {
			_glMatrix.vec3.sub(this.direction, mTarget, this.origin);
			_glMatrix.vec3.normalize(this.origin, this.origin);
		}
	}, {
		key: 'closestPointToPoint',
		value: function closestPointToPoint(mPoint) {
			var result = _glMatrix.vec3.create();
			_glMatrix.vec3.sub(mPoint, this.origin);
			var directionDistance = _glMatrix.vec3.dot(result, this.direction);

			if (directionDistance < 0) {
				return _glMatrix.vec3.clone(this.origin);
			}

			_glMatrix.vec3.copy(result, this.direction);
			_glMatrix.vec3.scale(result, result, directionDistance);
			_glMatrix.vec3.add(result, result, this.origin);

			return result;
		}
	}, {
		key: 'distanceToPoint',
		value: function distanceToPoint(mPoint) {
			return Math.sqrt(this.distanceSqToPoint(mPoint));
		}
	}, {
		key: 'distanceSqToPoint',
		value: function distanceSqToPoint(mPoint) {
			var v1 = _glMatrix.vec3.create();

			_glMatrix.vec3.sub(v1, mPoint, this.origin);
			var directionDistance = _glMatrix.vec3.dot(v1, this.direction);

			if (directionDistance < 0) {
				return _glMatrix.vec3.squaredDistance(this.origin, mPoint);
			}

			_glMatrix.vec3.copy(v1, this.direction);
			_glMatrix.vec3.scale(v1, v1, directionDistance);
			_glMatrix.vec3.add(v1, v1, this.origin);
			return _glMatrix.vec3.squaredDistance(v1, mPoint);
		}
	}, {
		key: 'intersectsSphere',
		value: function intersectsSphere(mCenter, mRadius) {
			return this.distanceToPoint(mCenter) <= mRadius;
		}
	}, {
		key: 'intersectSphere',
		value: function intersectSphere(mCenter, mRadius) {
			var v1 = _glMatrix.vec3.create();
			_glMatrix.vec3.sub(v1, mCenter, this.origin);
			var tca = _glMatrix.vec3.dot(v1, this.direction);
			var d2 = _glMatrix.vec3.dot(v1, v1) - tca * tca;
			var radius2 = mRadius * mRadius;

			if (d2 > radius2) return null;

			var thc = Math.sqrt(radius2 - d2);

			var t0 = tca - thc;

			var t1 = tca + thc;

			if (t0 < 0 && t1 < 0) return null;

			if (t0 < 0) return this.at(t1);

			return this.at(t0);
		}
	}, {
		key: 'distanceToPlane',
		value: function distanceToPlane(mPlaneCenter, mNormal) {
			var denominator = _glMatrix.vec3.dot(mNormal, this.direction);

			if (denominator === 0) {}
		}
	}, {
		key: 'intersectTriangle',
		value: function intersectTriangle(mPA, mPB, mPC) {
			var backfaceCulling = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

			_glMatrix.vec3.copy(a, mPA);
			_glMatrix.vec3.copy(b, mPB);
			_glMatrix.vec3.copy(c, mPC);

			// const edge1 = vec3.create();
			// const edge2 = vec3.create();
			// const normal = vec3.create();
			// const diff = vec3.create();

			_glMatrix.vec3.sub(edge1, b, a);
			_glMatrix.vec3.sub(edge2, c, a);
			_glMatrix.vec3.cross(normal, edge1, edge2);

			var DdN = _glMatrix.vec3.dot(this.direction, normal);
			var sign = void 0;

			if (DdN > 0) {
				if (backfaceCulling) {
					return null;
				}
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_glMatrix.vec3.sub(diff, this.origin, a);

			_glMatrix.vec3.cross(edge2, diff, edge2);
			var DdQxE2 = sign * _glMatrix.vec3.dot(this.direction, edge2);
			if (DdQxE2 < 0) {
				return null;
			}

			_glMatrix.vec3.cross(edge1, edge1, diff);
			var DdE1xQ = sign * _glMatrix.vec3.dot(this.direction, edge1);
			if (DdE1xQ < 0) {
				return null;
			}

			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			}

			var Qdn = -sign * _glMatrix.vec3.dot(diff, normal);
			if (Qdn < 0) {
				return null;
			}

			return this.at(Qdn / DdN);
		}
	}]);

	return Ray;
}();

exports.default = Ray;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _simpleColor = __webpack_require__(11);

var _simpleColor2 = _interopRequireDefault(_simpleColor);

var _bigTriangle = __webpack_require__(22);

var _bigTriangle2 = _interopRequireDefault(_bigTriangle);

var _general = __webpack_require__(37);

var _general2 = _interopRequireDefault(_general);

var _copy = __webpack_require__(23);

var _copy2 = _interopRequireDefault(_copy);

var _basic = __webpack_require__(15);

var _basic2 = _interopRequireDefault(_basic);

var _skybox = __webpack_require__(38);

var _skybox2 = _interopRequireDefault(_skybox);

var _skybox3 = __webpack_require__(39);

var _skybox4 = _interopRequireDefault(_skybox3);

var _gltf = __webpack_require__(70);

var _gltf2 = _interopRequireDefault(_gltf);

var _gltf3 = __webpack_require__(71);

var _gltf4 = _interopRequireDefault(_gltf3);

var _debug = __webpack_require__(72);

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ShaderLbs.js

var ShaderLibs = {
	simpleColorFrag: _simpleColor2.default,
	bigTriangleVert: _bigTriangle2.default,
	generalVert: _general2.default,
	copyFrag: _copy2.default,
	basicVert: _basic2.default,
	skyboxVert: _skybox2.default,
	skyboxFrag: _skybox4.default,
	gltfVert: _gltf2.default,
	gltfFrag: _gltf4.default,
	debugFrag: _debug2.default
};

exports.default = ShaderLibs;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = "// bigTriangle.vert\n\n#define SHADER_NAME BIG_TRIANGLE_VERTEX\n\nprecision mediump float;\n#define GLSLIFY 1\nattribute vec2 aPosition;\nvarying vec2 vTextureCoord;\n\nvoid main(void) {\n    gl_Position = vec4(aPosition, 0.0, 1.0);\n    vTextureCoord = aPosition * .5 + .5;\n}"

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = "// copy.frag\n\n#define SHADER_NAME COPY_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = texture2D(texture, vTextureCoord);\n}"

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Camera.js

var _glMatrix = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Camera = function () {
	function Camera() {
		_classCallCheck(this, Camera);

		//	VIEW MATRIX
		this._matrix = _glMatrix.mat4.create();

		//	FOR TRANSFORM FROM ORIENTATION
		this._quat = _glMatrix.quat.create();
		this._orientation = _glMatrix.mat4.create();

		//	PROJECTION MATRIX
		this._projection = _glMatrix.mat4.create();

		//	POSITION OF CAMERA
		this.position = vec3.create();
	}

	_createClass(Camera, [{
		key: 'lookAt',
		value: function lookAt(aEye, aCenter) {
			var aUp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1, 0];

			this._eye = vec3.clone(aEye);
			this._center = vec3.clone(aCenter);

			vec3.copy(this.position, aEye);
			_glMatrix.mat4.identity(this._matrix);
			_glMatrix.mat4.lookAt(this._matrix, aEye, aCenter, aUp);
		}
	}, {
		key: 'setFromOrientation',
		value: function setFromOrientation(x, y, z, w) {
			_glMatrix.quat.set(this._quat, x, y, z, w);
			_glMatrix.mat4.fromQuat(this._orientation, this._quat);
			_glMatrix.mat4.translate(this._matrix, this._orientation, this.positionOffset);
		}
	}, {
		key: 'setProjection',
		value: function setProjection(mProj) {
			this._projection = _glMatrix.mat4.clone(mProj);
		}
	}, {
		key: 'setView',
		value: function setView(mView) {
			this._matrix = _glMatrix.mat4.clone(mView);
		}
	}, {
		key: 'setFromViewProj',
		value: function setFromViewProj(mView, mProj) {
			this.setView(mView);
			this.setProjection(mProj);
		}

		//	GETTERS 

	}, {
		key: 'matrix',
		get: function get() {
			return this._matrix;
		}
	}, {
		key: 'viewMatrix',
		get: function get() {
			return this._matrix;
		}
	}, {
		key: 'projection',
		get: function get() {
			return this._projection;
		}
	}, {
		key: 'projectionMatrix',
		get: function get() {
			return this._projection;
		}
	}, {
		key: 'eye',
		get: function get() {
			return this._eye;
		}
	}, {
		key: 'center',
		get: function get() {
			return this._center;
		}
	}]);

	return Camera;
}();

exports.default = Camera;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Camera2 = __webpack_require__(24);

var _Camera3 = _interopRequireDefault(_Camera2);

var _Ray = __webpack_require__(20);

var _Ray2 = _interopRequireDefault(_Ray);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // CameraPerspective.js

var mInverseViewProj = _glMatrix.mat4.create();
var cameraDir = _glMatrix.vec3.create();

var CameraPerspective = function (_Camera) {
	_inherits(CameraPerspective, _Camera);

	function CameraPerspective() {
		_classCallCheck(this, CameraPerspective);

		return _possibleConstructorReturn(this, (CameraPerspective.__proto__ || Object.getPrototypeOf(CameraPerspective)).apply(this, arguments));
	}

	_createClass(CameraPerspective, [{
		key: 'setPerspective',
		value: function setPerspective(mFov, mAspectRatio, mNear, mFar) {

			this._fov = mFov;
			this._near = mNear;
			this._far = mFar;
			this._aspectRatio = mAspectRatio;
			_glMatrix.mat4.perspective(this._projection, mFov, mAspectRatio, mNear, mFar);

			// this._frustumTop = this._near * Math.tan(this._fov * 0.5);
			// this._frustumButtom = -this._frustumTop;
			// this._frustumRight = this._frustumTop * this._aspectRatio;
			// this._frustumLeft = -this._frustumRight;
		}
	}, {
		key: 'setAspectRatio',
		value: function setAspectRatio(mAspectRatio) {
			this._aspectRatio = mAspectRatio;
			_glMatrix.mat4.perspective(this.projection, this._fov, mAspectRatio, this._near, this._far);
		}
	}, {
		key: 'generateRay',
		value: function generateRay(mScreenPosition, mRay) {
			var proj = this.projectionMatrix;
			var view = this.viewMatrix;

			_glMatrix.mat4.multiply(mInverseViewProj, proj, view);
			_glMatrix.mat4.invert(mInverseViewProj, mInverseViewProj);

			_glMatrix.vec3.transformMat4(cameraDir, mScreenPosition, mInverseViewProj);
			_glMatrix.vec3.sub(cameraDir, cameraDir, this.position);
			_glMatrix.vec3.normalize(cameraDir, cameraDir);

			if (!mRay) {
				mRay = new _Ray2.default(this.position, cameraDir);
			} else {
				mRay.origin = this.position;
				mRay.direction = cameraDir;
			}

			return mRay;
		}
	}]);

	return CameraPerspective;
}(_Camera3.default);

exports.default = CameraPerspective;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// BinaryLoader.js

var BinaryLoader = function () {
	function BinaryLoader() {
		var _this = this;

		var isArrayBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		_classCallCheck(this, BinaryLoader);

		this._req = new XMLHttpRequest();
		this._req.addEventListener('load', function (e) {
			return _this._onLoaded(e);
		});
		this._req.addEventListener('progress', function (e) {
			return _this._onProgress(e);
		});
		if (isArrayBuffer) {
			this._req.responseType = 'arraybuffer';
		}
	}

	_createClass(BinaryLoader, [{
		key: 'load',
		value: function load(url, callback) {
			console.log('Loading : ', url);
			this._callback = callback;

			this._req.open('GET', url);
			this._req.send();
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			this._callback(this._req.response);
		}
	}, {
		key: '_onProgress',
		value: function _onProgress() /* e*/{
			// console.log('on Progress:', (e.loaded/e.total*100).toFixed(2));
		}
	}]);

	return BinaryLoader;
}();

exports.default = BinaryLoader;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ShaderLibs = exports.Shaders = exports.View3D = exports.View = exports.Scene = exports.BatchFXAA = exports.BatchSky = exports.BatchSkybox = exports.BatchLine = exports.BatchDotsPlane = exports.BatchBall = exports.BatchAxis = exports.BatchCopy = exports.PassFxaa = exports.PassHBlur = exports.PassVBlur = exports.PassBlur = exports.PassMacro = exports.Pass = exports.EffectComposer = exports.ColladaParser = exports.loadImages = exports.GLTFLoader = exports.HDRLoader = exports.ObjLoader = exports.BinaryLoader = exports.Object3D = exports.Ray = exports.CameraCube = exports.CameraPerspective = exports.CameraOrtho = exports.Camera = exports.TouchDetector = exports.QuatRotation = exports.WebglNumber = exports.OrbitalControl = exports.TweenNumber = exports.EaseNumber = exports.EventDispatcher = exports.Scheduler = exports.TransformFeedbackObject = exports.MultisampleFrameBuffer = exports.CubeFrameBuffer = exports.FrameBuffer = exports.Batch = exports.Geom = exports.Material = exports.Geometry = exports.Mesh = exports.GLCubeTexture = exports.GLTexture = exports.GLShader = exports.GL = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // alfrid.js

//	WEBGL 2


//	TOOLS


//	SHADERS


//	CAMERAS


//	MATH


//	OBJECT


//	LOADERS


//	POST EFFECT


//	HELPERS


var _glMatrix = __webpack_require__(2);

var GLM = _interopRequireWildcard(_glMatrix);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _GLCubeTexture = __webpack_require__(14);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

var _Mesh = __webpack_require__(13);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _Material = __webpack_require__(34);

var _Material2 = _interopRequireDefault(_Material);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _Batch = __webpack_require__(5);

var _Batch2 = _interopRequireDefault(_Batch);

var _FrameBuffer = __webpack_require__(18);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

var _CubeFrameBuffer = __webpack_require__(63);

var _CubeFrameBuffer2 = _interopRequireDefault(_CubeFrameBuffer);

var _MultisampleFrameBuffer = __webpack_require__(64);

var _MultisampleFrameBuffer2 = _interopRequireDefault(_MultisampleFrameBuffer);

var _TransformFeedbackObject = __webpack_require__(65);

var _TransformFeedbackObject2 = _interopRequireDefault(_TransformFeedbackObject);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _EventDispatcher = __webpack_require__(35);

var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

var _EaseNumber = __webpack_require__(19);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _TweenNumber = __webpack_require__(66);

var _TweenNumber2 = _interopRequireDefault(_TweenNumber);

var _OrbitalControl = __webpack_require__(36);

var _OrbitalControl2 = _interopRequireDefault(_OrbitalControl);

var _QuatRotation = __webpack_require__(67);

var _QuatRotation2 = _interopRequireDefault(_QuatRotation);

var _TouchDetector = __webpack_require__(68);

var _TouchDetector2 = _interopRequireDefault(_TouchDetector);

var _WebglNumber = __webpack_require__(10);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

var _WebglConst = __webpack_require__(32);

var _WebglConst2 = _interopRequireDefault(_WebglConst);

var _Shaders = __webpack_require__(16);

var _Shaders2 = _interopRequireDefault(_Shaders);

var _ShaderLibs = __webpack_require__(21);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

var _Camera = __webpack_require__(24);

var _Camera2 = _interopRequireDefault(_Camera);

var _CameraOrtho = __webpack_require__(40);

var _CameraOrtho2 = _interopRequireDefault(_CameraOrtho);

var _CameraPerspective = __webpack_require__(25);

var _CameraPerspective2 = _interopRequireDefault(_CameraPerspective);

var _CameraCube = __webpack_require__(73);

var _CameraCube2 = _interopRequireDefault(_CameraCube);

var _Ray = __webpack_require__(20);

var _Ray2 = _interopRequireDefault(_Ray);

var _Object3D = __webpack_require__(8);

var _Object3D2 = _interopRequireDefault(_Object3D);

var _BinaryLoader = __webpack_require__(26);

var _BinaryLoader2 = _interopRequireDefault(_BinaryLoader);

var _ObjLoader = __webpack_require__(74);

var _ObjLoader2 = _interopRequireDefault(_ObjLoader);

var _HDRLoader = __webpack_require__(75);

var _HDRLoader2 = _interopRequireDefault(_HDRLoader);

var _ColladaParser = __webpack_require__(77);

var _ColladaParser2 = _interopRequireDefault(_ColladaParser);

var _GltfLoader = __webpack_require__(80);

var _GltfLoader2 = _interopRequireDefault(_GltfLoader);

var _loadImages = __webpack_require__(41);

var _loadImages2 = _interopRequireDefault(_loadImages);

var _EffectComposer = __webpack_require__(85);

var _EffectComposer2 = _interopRequireDefault(_EffectComposer);

var _Pass = __webpack_require__(12);

var _Pass2 = _interopRequireDefault(_Pass);

var _PassMacro = __webpack_require__(43);

var _PassMacro2 = _interopRequireDefault(_PassMacro);

var _PassBlur = __webpack_require__(86);

var _PassBlur2 = _interopRequireDefault(_PassBlur);

var _PassVBlur = __webpack_require__(44);

var _PassVBlur2 = _interopRequireDefault(_PassVBlur);

var _PassHBlur = __webpack_require__(46);

var _PassHBlur2 = _interopRequireDefault(_PassHBlur);

var _PassFxaa = __webpack_require__(90);

var _PassFxaa2 = _interopRequireDefault(_PassFxaa);

var _BatchCopy = __webpack_require__(91);

var _BatchCopy2 = _interopRequireDefault(_BatchCopy);

var _BatchAxis = __webpack_require__(92);

var _BatchAxis2 = _interopRequireDefault(_BatchAxis);

var _BatchBall = __webpack_require__(95);

var _BatchBall2 = _interopRequireDefault(_BatchBall);

var _BatchDotsPlane = __webpack_require__(96);

var _BatchDotsPlane2 = _interopRequireDefault(_BatchDotsPlane);

var _BatchLine = __webpack_require__(98);

var _BatchLine2 = _interopRequireDefault(_BatchLine);

var _BatchSkybox = __webpack_require__(99);

var _BatchSkybox2 = _interopRequireDefault(_BatchSkybox);

var _BatchSky = __webpack_require__(100);

var _BatchSky2 = _interopRequireDefault(_BatchSky);

var _BatchFXAA = __webpack_require__(102);

var _BatchFXAA2 = _interopRequireDefault(_BatchFXAA);

var _Scene = __webpack_require__(103);

var _Scene2 = _interopRequireDefault(_Scene);

var _View = __webpack_require__(104);

var _View2 = _interopRequireDefault(_View);

var _View3D = __webpack_require__(105);

var _View3D2 = _interopRequireDefault(_View3D);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VERSION = '0.2.0';

var Alfrid = function () {
	function Alfrid() {
		_classCallCheck(this, Alfrid);

		this.glm = GLM;
		this.GL = _GLTool2.default;
		this.GLTool = _GLTool2.default;
		this.GLShader = _GLShader2.default;
		this.GLTexture = _GLTexture2.default;
		this.GLCubeTexture = _GLCubeTexture2.default;
		this.Mesh = _Mesh2.default;
		this.Geometry = _Geometry2.default;
		this.Material = _Material2.default;
		this.Geom = _Geom2.default;
		this.Batch = _Batch2.default;
		this.FrameBuffer = _FrameBuffer2.default;
		this.CubeFrameBuffer = _CubeFrameBuffer2.default;
		this.Scheduler = _scheduling2.default;
		this.EventDispatcher = _EventDispatcher2.default;
		this.EaseNumber = _EaseNumber2.default;
		this.TweenNumber = _TweenNumber2.default;
		this.Camera = _Camera2.default;
		this.CameraOrtho = _CameraOrtho2.default;
		this.CameraPerspective = _CameraPerspective2.default;
		this.Ray = _Ray2.default;
		this.CameraCube = _CameraCube2.default;
		this.OrbitalControl = _OrbitalControl2.default;
		this.QuatRotation = _QuatRotation2.default;
		this.TouchDetector = _TouchDetector2.default;
		this.BinaryLoader = _BinaryLoader2.default;
		this.ObjLoader = _ObjLoader2.default;
		this.ColladaParser = _ColladaParser2.default;
		this.HDRLoader = _HDRLoader2.default;
		this.GLTFLoader = _GltfLoader2.default;
		this.loadImages = _loadImages2.default;
		this.BatchCopy = _BatchCopy2.default;
		this.BatchAxis = _BatchAxis2.default;
		this.BatchBall = _BatchBall2.default;
		this.BatchBall = _BatchBall2.default;
		this.BatchLine = _BatchLine2.default;
		this.BatchSkybox = _BatchSkybox2.default;
		this.BatchSky = _BatchSky2.default;
		this.BatchFXAA = _BatchFXAA2.default;
		this.BatchDotsPlane = _BatchDotsPlane2.default;
		this.Scene = _Scene2.default;
		this.View = _View2.default;
		this.View3D = _View3D2.default;
		this.Object3D = _Object3D2.default;
		this.Shaders = _Shaders2.default;
		this.ShaderLibs = _ShaderLibs2.default;
		this.WebglNumber = _WebglNumber2.default;

		this.EffectComposer = _EffectComposer2.default;
		this.Pass = _Pass2.default;
		this.PassMacro = _PassMacro2.default;
		this.PassBlur = _PassBlur2.default;
		this.PassVBlur = _PassVBlur2.default;
		this.PassHBlur = _PassHBlur2.default;
		this.PassFxaa = _PassFxaa2.default;

		this.MultisampleFrameBuffer = _MultisampleFrameBuffer2.default;
		this.TransformFeedbackObject = _TransformFeedbackObject2.default;

		//	NOT SUPER SURE I'VE DONE THIS IS A GOOD WAY

		for (var s in GLM) {
			if (GLM[s]) {
				window[s] = GLM[s];
			}
		}
	}

	_createClass(Alfrid, [{
		key: 'log',
		value: function log() {
			if (navigator.userAgent.indexOf('Chrome') > -1) {
				console.log('%clib alfrid : VERSION ' + VERSION, 'background: #193441; color: #FCFFF5');
			} else {
				console.log('lib alfrid : VERSION ', VERSION);
			}
			console.log('%cClasses : ', 'color: #193441');

			for (var s in this) {
				if (this[s]) {
					console.log('%c - ' + s, 'color: #3E606F');
				}
			}
		}
	}]);

	return Alfrid;
}();

var al = new Alfrid();

exports.default = al;
exports.GL = _GLTool2.default;
exports.GLShader = _GLShader2.default;
exports.GLTexture = _GLTexture2.default;
exports.GLCubeTexture = _GLCubeTexture2.default;
exports.Mesh = _Mesh2.default;
exports.Geometry = _Geometry2.default;
exports.Material = _Material2.default;
exports.Geom = _Geom2.default;
exports.Batch = _Batch2.default;
exports.FrameBuffer = _FrameBuffer2.default;
exports.CubeFrameBuffer = _CubeFrameBuffer2.default;
exports.MultisampleFrameBuffer = _MultisampleFrameBuffer2.default;
exports.TransformFeedbackObject = _TransformFeedbackObject2.default;
exports.Scheduler = _scheduling2.default;
exports.EventDispatcher = _EventDispatcher2.default;
exports.EaseNumber = _EaseNumber2.default;
exports.TweenNumber = _TweenNumber2.default;
exports.OrbitalControl = _OrbitalControl2.default;
exports.WebglNumber = _WebglNumber2.default;
exports.QuatRotation = _QuatRotation2.default;
exports.TouchDetector = _TouchDetector2.default;
exports.Camera = _Camera2.default;
exports.CameraOrtho = _CameraOrtho2.default;
exports.CameraPerspective = _CameraPerspective2.default;
exports.CameraCube = _CameraCube2.default;
exports.Ray = _Ray2.default;
exports.Object3D = _Object3D2.default;
exports.BinaryLoader = _BinaryLoader2.default;
exports.ObjLoader = _ObjLoader2.default;
exports.HDRLoader = _HDRLoader2.default;
exports.GLTFLoader = _GltfLoader2.default;
exports.loadImages = _loadImages2.default;
exports.ColladaParser = _ColladaParser2.default;
exports.EffectComposer = _EffectComposer2.default;
exports.Pass = _Pass2.default;
exports.PassMacro = _PassMacro2.default;
exports.PassBlur = _PassBlur2.default;
exports.PassVBlur = _PassVBlur2.default;
exports.PassHBlur = _PassHBlur2.default;
exports.PassFxaa = _PassFxaa2.default;
exports.BatchCopy = _BatchCopy2.default;
exports.BatchAxis = _BatchAxis2.default;
exports.BatchBall = _BatchBall2.default;
exports.BatchDotsPlane = _BatchDotsPlane2.default;
exports.BatchLine = _BatchLine2.default;
exports.BatchSkybox = _BatchSkybox2.default;
exports.BatchSky = _BatchSky2.default;
exports.BatchFXAA = _BatchFXAA2.default;
exports.Scene = _Scene2.default;
exports.View = _View2.default;
exports.View3D = _View3D2.default;
exports.Shaders = _Shaders2.default;
exports.ShaderLibs = _ShaderLibs2.default;

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["fromMat4"] = fromMat4;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromMat2d"] = fromMat2d;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["normalFromMat4"] = normalFromMat4;
/* harmony export (immutable) */ __webpack_exports__["projection"] = projection;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b01 = a22 * a11 - a12 * a21;
  let b11 = -a22 * a10 + a12 * a20;
  let b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  let det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  out[0] = (a11 * a22 - a12 * a21);
  out[1] = (a02 * a21 - a01 * a22);
  out[2] = (a01 * a12 - a02 * a11);
  out[3] = (a12 * a20 - a10 * a22);
  out[4] = (a00 * a22 - a02 * a20);
  out[5] = (a02 * a10 - a00 * a12);
  out[6] = (a10 * a21 - a11 * a20);
  out[7] = (a01 * a20 - a00 * a21);
  out[8] = (a00 * a11 - a01 * a10);
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2];
  let a10 = a[3], a11 = a[4], a12 = a[5];
  let a20 = a[6], a21 = a[7], a22 = a[8];

  let b00 = b[0], b01 = b[1], b02 = b[2];
  let b10 = b[3], b11 = b[4], b12 = b[5];
  let b20 = b[6], b21 = b[7], b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],
    x = v[0], y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  let a00 = a[0], a01 = a[1], a02 = a[2],
    a10 = a[3], a11 = a[4], a12 = a[5],
    a20 = a[6], a21 = a[7], a22 = a[8],

    s = Math.sin(rad),
    c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
          a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}



/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
         a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
         a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["hermite"] = hermite;
/* harmony export (immutable) */ __webpack_exports__["bezier"] = bezier;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["angle"] = angle;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return Math.sqrt(x*x + y*y + z*z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  return x*x + y*y + z*z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return x*x + y*y + z*z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len = x*x + y*y + z*z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  let factorTimes2 = t * t;
  let factor1 = factorTimes2 * (2 * t - 3) + 1;
  let factor2 = factorTimes2 * (t - 2) + t;
  let factor3 = factorTimes2 * (t - 1);
  let factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  let inverseFactor = 1 - t;
  let inverseFactorTimesTwo = inverseFactor * inverseFactor;
  let factorTimes2 = t * t;
  let factor1 = inverseFactorTimesTwo * inverseFactor;
  let factor2 = 3 * t * inverseFactorTimesTwo;
  let factor3 = 3 * factorTimes2 * inverseFactor;
  let factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  let r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  let z = (__WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0) - 1.0;
  let zScale = Math.sqrt(1.0-z*z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  let x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  r[1] = p[1];
  r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
  let p = [], r=[];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  let tempA = fromValues(a[0], a[1], a[2]);
  let tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  let cosine = dot(tempA, tempB);

  if(cosine > 1.0) {
    return 0;
  }
  else if(cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2];
  let b0 = b[0], b1 = b[1], b2 = b[2];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec3.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec3.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec3.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec3.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 3;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  let x = b[0] - a[0];
  let y = b[1] - a[1];
  let z = b[2] - a[2];
  let w = b[3] - a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return Math.sqrt(x*x + y*y + z*z + w*w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  return x*x + y*y + z*z + w*w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len = x*x + y*y + z*z + w*w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  let ax = a[0];
  let ay = a[1];
  let az = a[2];
  let aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, vectorScale) {
  vectorScale = vectorScale || 1.0;

  //TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[1] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[2] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  out[3] = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]();
  normalize(out, out);
  scale(out, out, vectorScale);
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  let x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  let x = a[0], y = a[1], z = a[2];
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];

  // calculate quat * vec
  let ix = qw * x + qy * z - qz * y;
  let iy = qw * y + qz * x - qx * z;
  let iz = qw * z + qx * y - qy * x;
  let iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec4.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec4.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec4.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 4;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// WebglConst.js

// stolen there https://github.com/mattdesl/gl-constants thanks @mattdesl ^^

module.exports = {
	ACTIVE_ATTRIBUTES: 35721,
	ACTIVE_ATTRIBUTE_MAX_LENGTH: 35722,
	ACTIVE_TEXTURE: 34016,
	ACTIVE_UNIFORMS: 35718,
	ACTIVE_UNIFORM_MAX_LENGTH: 35719,
	ALIASED_LINE_WIDTH_RANGE: 33902,
	ALIASED_POINT_SIZE_RANGE: 33901,
	ALPHA: 6406,
	ALPHA_BITS: 3413,
	ALWAYS: 519,
	ARRAY_BUFFER: 34962,
	ARRAY_BUFFER_BINDING: 34964,
	ATTACHED_SHADERS: 35717,
	BACK: 1029,
	BLEND: 3042,
	BLEND_COLOR: 32773,
	BLEND_DST_ALPHA: 32970,
	BLEND_DST_RGB: 32968,
	BLEND_EQUATION: 32777,
	BLEND_EQUATION_ALPHA: 34877,
	BLEND_EQUATION_RGB: 32777,
	BLEND_SRC_ALPHA: 32971,
	BLEND_SRC_RGB: 32969,
	BLUE_BITS: 3412,
	BOOL: 35670,
	BOOL_VEC2: 35671,
	BOOL_VEC3: 35672,
	BOOL_VEC4: 35673,
	BROWSER_DEFAULT_WEBGL: 37444,
	BUFFER_SIZE: 34660,
	BUFFER_USAGE: 34661,
	BYTE: 5120,
	CCW: 2305,
	CLAMP_TO_EDGE: 33071,
	COLOR_ATTACHMENT0: 36064,
	COLOR_BUFFER_BIT: 16384,
	COLOR_CLEAR_VALUE: 3106,
	COLOR_WRITEMASK: 3107,
	COMPILE_STATUS: 35713,
	COMPRESSED_TEXTURE_FORMATS: 34467,
	CONSTANT_ALPHA: 32771,
	CONSTANT_COLOR: 32769,
	CONTEXT_LOST_WEBGL: 37442,
	CULL_FACE: 2884,
	CULL_FACE_MODE: 2885,
	CURRENT_PROGRAM: 35725,
	CURRENT_VERTEX_ATTRIB: 34342,
	CW: 2304,
	DECR: 7683,
	DECR_WRAP: 34056,
	DELETE_STATUS: 35712,
	DEPTH_ATTACHMENT: 36096,
	DEPTH_BITS: 3414,
	DEPTH_BUFFER_BIT: 256,
	DEPTH_CLEAR_VALUE: 2931,
	DEPTH_COMPONENT: 6402,
	RED: 6403,
	DEPTH_COMPONENT16: 33189,
	DEPTH_FUNC: 2932,
	DEPTH_RANGE: 2928,
	DEPTH_STENCIL: 34041,
	DEPTH_STENCIL_ATTACHMENT: 33306,
	DEPTH_TEST: 2929,
	DEPTH_WRITEMASK: 2930,
	DITHER: 3024,
	DONT_CARE: 4352,
	DST_ALPHA: 772,
	DST_COLOR: 774,
	DYNAMIC_DRAW: 35048,
	ELEMENT_ARRAY_BUFFER: 34963,
	ELEMENT_ARRAY_BUFFER_BINDING: 34965,
	EQUAL: 514,
	FASTEST: 4353,
	FLOAT: 5126,
	FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	FRAGMENT_SHADER: 35632,
	FRAMEBUFFER: 36160,
	FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
	FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
	FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
	FRAMEBUFFER_BINDING: 36006,
	FRAMEBUFFER_COMPLETE: 36053,
	FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
	FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
	FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
	FRAMEBUFFER_UNSUPPORTED: 36061,
	FRONT: 1028,
	FRONT_AND_BACK: 1032,
	FRONT_FACE: 2886,
	FUNC_ADD: 32774,
	FUNC_REVERSE_SUBTRACT: 32779,
	FUNC_SUBTRACT: 32778,
	GENERATE_MIPMAP_HINT: 33170,
	GEQUAL: 518,
	GREATER: 516,
	GREEN_BITS: 3411,
	HIGH_FLOAT: 36338,
	HIGH_INT: 36341,
	INCR: 7682,
	INCR_WRAP: 34055,
	INFO_LOG_LENGTH: 35716,
	INT: 5124,
	INT_VEC2: 35667,
	INT_VEC3: 35668,
	INT_VEC4: 35669,
	INVALID_ENUM: 1280,
	INVALID_FRAMEBUFFER_OPERATION: 1286,
	INVALID_OPERATION: 1282,
	INVALID_VALUE: 1281,
	INVERT: 5386,
	KEEP: 7680,
	LEQUAL: 515,
	LESS: 513,
	LINEAR: 9729,
	LINEAR_MIPMAP_LINEAR: 9987,
	LINEAR_MIPMAP_NEAREST: 9985,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	LINE_WIDTH: 2849,
	LINK_STATUS: 35714,
	LOW_FLOAT: 36336,
	LOW_INT: 36339,
	LUMINANCE: 6409,
	LUMINANCE_ALPHA: 6410,
	MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
	MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
	MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
	MAX_RENDERBUFFER_SIZE: 34024,
	MAX_TEXTURE_IMAGE_UNITS: 34930,
	MAX_TEXTURE_SIZE: 3379,
	MAX_VARYING_VECTORS: 36348,
	MAX_VERTEX_ATTRIBS: 34921,
	MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
	MAX_VERTEX_UNIFORM_VECTORS: 36347,
	MAX_VIEWPORT_DIMS: 3386,
	MEDIUM_FLOAT: 36337,
	MEDIUM_INT: 36340,
	MIRRORED_REPEAT: 33648,
	NEAREST: 9728,
	NEAREST_MIPMAP_LINEAR: 9986,
	NEAREST_MIPMAP_NEAREST: 9984,
	NEVER: 512,
	NICEST: 4354,
	NONE: 0,
	NOTEQUAL: 517,
	NO_ERROR: 0,
	NUM_COMPRESSED_TEXTURE_FORMATS: 34466,
	ONE: 1,
	ONE_MINUS_CONSTANT_ALPHA: 32772,
	ONE_MINUS_CONSTANT_COLOR: 32770,
	ONE_MINUS_DST_ALPHA: 773,
	ONE_MINUS_DST_COLOR: 775,
	ONE_MINUS_SRC_ALPHA: 771,
	ONE_MINUS_SRC_COLOR: 769,
	OUT_OF_MEMORY: 1285,
	PACK_ALIGNMENT: 3333,
	POINTS: 0,
	POLYGON_OFFSET_FACTOR: 32824,
	POLYGON_OFFSET_FILL: 32823,
	POLYGON_OFFSET_UNITS: 10752,
	RED_BITS: 3410,
	RENDERBUFFER: 36161,
	RENDERBUFFER_ALPHA_SIZE: 36179,
	RENDERBUFFER_BINDING: 36007,
	RENDERBUFFER_BLUE_SIZE: 36178,
	RENDERBUFFER_DEPTH_SIZE: 36180,
	RENDERBUFFER_GREEN_SIZE: 36177,
	RENDERBUFFER_HEIGHT: 36163,
	RENDERBUFFER_INTERNAL_FORMAT: 36164,
	RENDERBUFFER_RED_SIZE: 36176,
	RENDERBUFFER_STENCIL_SIZE: 36181,
	RENDERBUFFER_WIDTH: 36162,
	RENDERER: 7937,
	REPEAT: 10497,
	REPLACE: 7681,
	RGB: 6407,
	RGB5_A1: 32855,
	RGB565: 36194,
	RGBA: 6408,
	RGBA4: 32854,
	SAMPLER_2D: 35678,
	SAMPLER_CUBE: 35680,
	SAMPLES: 32937,
	SAMPLE_ALPHA_TO_COVERAGE: 32926,
	SAMPLE_BUFFERS: 32936,
	SAMPLE_COVERAGE: 32928,
	SAMPLE_COVERAGE_INVERT: 32939,
	SAMPLE_COVERAGE_VALUE: 32938,
	SCISSOR_BOX: 3088,
	SCISSOR_TEST: 3089,
	SHADER_COMPILER: 36346,
	SHADER_SOURCE_LENGTH: 35720,
	SHADER_TYPE: 35663,
	SHADING_LANGUAGE_VERSION: 35724,
	SHORT: 5122,
	SRC_ALPHA: 770,
	SRC_ALPHA_SATURATE: 776,
	SRC_COLOR: 768,
	STATIC_DRAW: 35044,
	STENCIL_ATTACHMENT: 36128,
	STENCIL_BACK_FAIL: 34817,
	STENCIL_BACK_FUNC: 34816,
	STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
	STENCIL_BACK_PASS_DEPTH_PASS: 34819,
	STENCIL_BACK_REF: 36003,
	STENCIL_BACK_VALUE_MASK: 36004,
	STENCIL_BACK_WRITEMASK: 36005,
	STENCIL_BITS: 3415,
	STENCIL_BUFFER_BIT: 1024,
	STENCIL_CLEAR_VALUE: 2961,
	STENCIL_FAIL: 2964,
	STENCIL_FUNC: 2962,
	STENCIL_INDEX: 6401,
	STENCIL_INDEX8: 36168,
	STENCIL_PASS_DEPTH_FAIL: 2965,
	STENCIL_PASS_DEPTH_PASS: 2966,
	STENCIL_REF: 2967,
	STENCIL_TEST: 2960,
	STENCIL_VALUE_MASK: 2963,
	STENCIL_WRITEMASK: 2968,
	STREAM_DRAW: 35040,
	SUBPIXEL_BITS: 3408,
	TEXTURE: 5890,
	TEXTURE0: 33984,
	TEXTURE1: 33985,
	TEXTURE2: 33986,
	TEXTURE3: 33987,
	TEXTURE4: 33988,
	TEXTURE5: 33989,
	TEXTURE6: 33990,
	TEXTURE7: 33991,
	TEXTURE8: 33992,
	TEXTURE9: 33993,
	TEXTURE10: 33994,
	TEXTURE11: 33995,
	TEXTURE12: 33996,
	TEXTURE13: 33997,
	TEXTURE14: 33998,
	TEXTURE15: 33999,
	TEXTURE16: 34000,
	TEXTURE17: 34001,
	TEXTURE18: 34002,
	TEXTURE19: 34003,
	TEXTURE20: 34004,
	TEXTURE21: 34005,
	TEXTURE22: 34006,
	TEXTURE23: 34007,
	TEXTURE24: 34008,
	TEXTURE25: 34009,
	TEXTURE26: 34010,
	TEXTURE27: 34011,
	TEXTURE28: 34012,
	TEXTURE29: 34013,
	TEXTURE30: 34014,
	TEXTURE31: 34015,
	TEXTURE_2D: 3553,
	TEXTURE_BINDING_2D: 32873,
	TEXTURE_BINDING_CUBE_MAP: 34068,
	TEXTURE_CUBE_MAP: 34067,
	TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
	TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
	TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
	TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
	TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
	TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
	TEXTURE_MAG_FILTER: 10240,
	TEXTURE_MIN_FILTER: 10241,
	TEXTURE_WRAP_S: 10242,
	TEXTURE_WRAP_T: 10243,
	TRIANGLES: 4,
	TRIANGLE_FAN: 6,
	TRIANGLE_STRIP: 5,
	UNPACK_ALIGNMENT: 3317,
	UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
	UNPACK_FLIP_Y_WEBGL: 37440,
	UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_INT: 5125,
	UNSIGNED_SHORT: 5123,
	UNSIGNED_SHORT_4_4_4_4: 32819,
	UNSIGNED_SHORT_5_5_5_1: 32820,
	UNSIGNED_SHORT_5_6_5: 33635,
	VALIDATE_STATUS: 35715,
	VENDOR: 7936,
	VERSION: 7938,
	VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
	VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
	VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
	VERTEX_ATTRIB_ARRAY_POINTER: 34373,
	VERTEX_ATTRIB_ARRAY_SIZE: 34339,
	VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
	VERTEX_ATTRIB_ARRAY_TYPE: 34341,
	VERTEX_SHADER: 35633,
	VIEWPORT: 2978,
	ZERO: 0,
	R8: 33321
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (gl, shaderProgram, name) {
	if (shaderProgram.cacheAttribLoc === undefined) {
		shaderProgram.cacheAttribLoc = {};
	}
	if (shaderProgram.cacheAttribLoc[name] === undefined) {
		shaderProgram.cacheAttribLoc[name] = gl.getAttribLocation(shaderProgram, name);
	}

	return shaderProgram.cacheAttribLoc[name];
};

; // getAttribLoc.js

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Material.js

var _Shaders = __webpack_require__(16);

var _Shaders2 = _interopRequireDefault(_Shaders);

var _objectAssign = __webpack_require__(17);

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Material = function () {
	function Material(vs, fs) {
		var uniforms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
		var defines = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

		_classCallCheck(this, Material);

		this._shader = _Shaders2.default.get(vs, fs, defines);
		this.uniforms = (0, _objectAssign2.default)({}, uniforms);
	}

	_createClass(Material, [{
		key: 'update',
		value: function update() {
			this._shader.bind();
			this._shader.uniform(this.uniforms);
		}
	}, {
		key: 'shader',
		get: function get() {
			return this._shader;
		}
	}]);

	return Material;
}();

exports.default = Material;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// EventDispatcher.js

var supportsCustomEvents = true;
try {
	var newTestCustomEvent = document.createEvent('CustomEvent');
	newTestCustomEvent = null;
} catch (e) {
	supportsCustomEvents = false;
}

var EventDispatcher = function () {
	function EventDispatcher() {
		_classCallCheck(this, EventDispatcher);

		this._eventListeners = {};
	}

	_createClass(EventDispatcher, [{
		key: 'addEventListener',
		value: function addEventListener(aEventType, aFunction) {

			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}

			if (!this._eventListeners[aEventType]) {
				this._eventListeners[aEventType] = [];
			}
			this._eventListeners[aEventType].push(aFunction);

			return this;
		}
	}, {
		key: 'on',
		value: function on(aEventType, aFunction) {
			return this.addEventListener(aEventType, aFunction);
		}
	}, {
		key: 'removeEventListener',
		value: function removeEventListener(aEventType, aFunction) {
			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}
			var currentArray = this._eventListeners[aEventType];

			if (typeof currentArray === 'undefined') {
				return this;
			}

			var currentArrayLength = currentArray.length;
			for (var i = 0; i < currentArrayLength; i++) {
				if (currentArray[i] === aFunction) {
					currentArray.splice(i, 1);
					i--;
					currentArrayLength--;
				}
			}
			return this;
		}
	}, {
		key: 'off',
		value: function off(aEventType, aFunction) {
			return this.removeEventListener(aEventType, aFunction);
		}
	}, {
		key: 'dispatchEvent',
		value: function dispatchEvent(aEvent) {
			if (this._eventListeners === null || this._eventListeners === undefined) {
				this._eventListeners = {};
			}
			var eventType = aEvent.type;

			try {
				if (aEvent.target === null) {
					aEvent.target = this;
				}
				aEvent.currentTarget = this;
			} catch (theError) {
				var newEvent = { type: eventType, detail: aEvent.detail, dispatcher: this };
				return this.dispatchEvent(newEvent);
			}

			var currentEventListeners = this._eventListeners[eventType];
			if (currentEventListeners !== null && currentEventListeners !== undefined) {
				var currentArray = this._copyArray(currentEventListeners);
				var currentArrayLength = currentArray.length;
				for (var i = 0; i < currentArrayLength; i++) {
					var currentFunction = currentArray[i];
					currentFunction.call(this, aEvent);
				}
			}
			return this;
		}
	}, {
		key: 'dispatchCustomEvent',
		value: function dispatchCustomEvent(aEventType, aDetail) {
			var newEvent = void 0;
			if (supportsCustomEvents) {
				newEvent = document.createEvent('CustomEvent');
				newEvent.dispatcher = this;
				newEvent.initCustomEvent(aEventType, false, false, aDetail);
			} else {
				newEvent = { type: aEventType, detail: aDetail, dispatcher: this };
			}
			return this.dispatchEvent(newEvent);
		}
	}, {
		key: 'trigger',
		value: function trigger(aEventType, aDetail) {
			return this.dispatchCustomEvent(aEventType, aDetail);
		}
	}, {
		key: '_destroy',
		value: function _destroy() {
			if (this._eventListeners !== null) {
				for (var objectName in this._eventListeners) {
					if (this._eventListeners.hasOwnProperty(objectName)) {
						var currentArray = this._eventListeners[objectName];
						var currentArrayLength = currentArray.length;
						for (var i = 0; i < currentArrayLength; i++) {
							currentArray[i] = null;
						}
						delete this._eventListeners[objectName];
					}
				}
				this._eventListeners = null;
			}
		}
	}, {
		key: '_copyArray',
		value: function _copyArray(aArray) {
			var currentArray = new Array(aArray.length);
			var currentArrayLength = currentArray.length;
			for (var i = 0; i < currentArrayLength; i++) {
				currentArray[i] = aArray[i];
			}
			return currentArray;
		}
	}]);

	return EventDispatcher;
}();

exports.default = EventDispatcher;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// OrbitalControl.js


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _EaseNumber = __webpack_require__(19);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getMouse = function getMouse(mEvent, mTarget) {

	var o = mTarget || {};
	if (mEvent.touches) {
		o.x = mEvent.touches[0].pageX;
		o.y = mEvent.touches[0].pageY;
	} else {
		o.x = mEvent.clientX;
		o.y = mEvent.clientY;
	}

	return o;
};

var OrbitalControl = function () {
	function OrbitalControl(mTarget) {
		var _this = this;

		var mListenerTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
		var mRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;

		_classCallCheck(this, OrbitalControl);

		this._target = mTarget;
		this._listenerTarget = mListenerTarget;
		this._mouse = {};
		this._preMouse = {};
		this.center = _glMatrix.vec3.create();
		this._up = _glMatrix.vec3.fromValues(0, 1, 0);
		this.radius = new _EaseNumber2.default(mRadius);
		this.position = _glMatrix.vec3.fromValues(0, 0, this.radius.value);
		this.positionOffset = _glMatrix.vec3.create();
		this._rx = new _EaseNumber2.default(0);
		this._rx.limit(-Math.PI / 2, Math.PI / 2);
		this._ry = new _EaseNumber2.default(0);
		this._preRX = 0;
		this._preRY = 0;

		this._isLockZoom = false;
		this._isLockRotation = false;
		this._isInvert = false;
		this.sensitivity = 1.0;

		this._wheelBind = function (e) {
			return _this._onWheel(e);
		};
		this._downBind = function (e) {
			return _this._onDown(e);
		};
		this._moveBind = function (e) {
			return _this._onMove(e);
		};
		this._upBind = function () {
			return _this._onUp();
		};

		this.connect();
		_scheduling2.default.addEF(function () {
			return _this._loop();
		});
	}

	_createClass(OrbitalControl, [{
		key: 'connect',
		value: function connect() {
			this.disconnect();

			this._listenerTarget.addEventListener('mousewheel', this._wheelBind);
			this._listenerTarget.addEventListener('DOMMouseScroll', this._wheelBind);

			this._listenerTarget.addEventListener('mousedown', this._downBind);
			this._listenerTarget.addEventListener('touchstart', this._downBind);
			this._listenerTarget.addEventListener('mousemove', this._moveBind);
			this._listenerTarget.addEventListener('touchmove', this._moveBind);
			window.addEventListener('touchend', this._upBind);
			window.addEventListener('mouseup', this._upBind);
		}
	}, {
		key: 'disconnect',
		value: function disconnect() {
			this._listenerTarget.removeEventListener('mousewheel', this._wheelBind);
			this._listenerTarget.removeEventListener('DOMMouseScroll', this._wheelBind);

			this._listenerTarget.removeEventListener('mousedown', this._downBind);
			this._listenerTarget.removeEventListener('touchstart', this._downBind);
			this._listenerTarget.removeEventListener('mousemove', this._moveBind);
			this._listenerTarget.removeEventListener('touchmove', this._moveBind);
			window.removeEventListener('touchend', this._upBind);
			window.removeEventListener('mouseup', this._upBind);
		}

		//	PUBLIC METHODS

	}, {
		key: 'lock',
		value: function lock() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockZoom = mValue;
			this._isLockRotation = mValue;
			this._isMouseDown = false;
		}
	}, {
		key: 'lockZoom',
		value: function lockZoom() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockZoom = mValue;
		}
	}, {
		key: 'lockRotation',
		value: function lockRotation() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLockRotation = mValue;
		}
	}, {
		key: 'inverseControl',
		value: function inverseControl() {
			var isInvert = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isInvert = isInvert;
		}

		//	EVENT HANDLERES

	}, {
		key: '_onDown',
		value: function _onDown(mEvent) {
			if (this._isLockRotation) {
				return;
			}
			this._isMouseDown = true;
			getMouse(mEvent, this._mouse);
			getMouse(mEvent, this._preMouse);
			this._preRX = this._rx.targetValue;
			this._preRY = this._ry.targetValue;
		}
	}, {
		key: '_onMove',
		value: function _onMove(mEvent) {
			if (this._isLockRotation) {
				return;
			}
			getMouse(mEvent, this._mouse);
			if (mEvent.touches) {
				mEvent.preventDefault();
			}

			if (this._isMouseDown) {
				var diffX = -(this._mouse.x - this._preMouse.x);
				if (this._isInvert) {
					diffX *= -1;
				}
				this._ry.value = this._preRY - diffX * 0.01 * this.sensitivity;

				var diffY = -(this._mouse.y - this._preMouse.y);
				if (this._isInvert) {
					diffY *= -1;
				}
				this._rx.value = this._preRX - diffY * 0.01 * this.sensitivity;
			}
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			if (this._isLockRotation) {
				return;
			}
			this._isMouseDown = false;
		}
	}, {
		key: '_onWheel',
		value: function _onWheel(mEvent) {
			if (this._isLockZoom) {
				return;
			}
			var w = mEvent.wheelDelta;
			var d = mEvent.detail;
			var value = 0;
			if (d) {
				if (w) {
					value = w / d / 40 * d > 0 ? 1 : -1; // Opera
				} else {
					value = -d / 3; // Firefox;         TODO: do not /3 for OS X
				}
			} else {
				value = w / 120;
			}

			this.radius.add(-value * 2);
		}

		//	PRIVATE METHODS

	}, {
		key: '_loop',
		value: function _loop() {

			this._updatePosition();

			if (this._target) {
				this._updateCamera();
			}
		}
	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			this.position[1] = Math.sin(this._rx.value) * this.radius.value;
			var tr = Math.cos(this._rx.value) * this.radius.value;
			this.position[0] = Math.cos(this._ry.value + Math.PI * 0.5) * tr;
			this.position[2] = Math.sin(this._ry.value + Math.PI * 0.5) * tr;
			_glMatrix.vec3.add(this.position, this.position, this.positionOffset);
		}
	}, {
		key: '_updateCamera',
		value: function _updateCamera() {
			this._target.lookAt(this.position, this.center, this._up);
		}

		//	GETTER / SETTER


	}, {
		key: 'rx',
		get: function get() {
			return this._rx;
		}
	}, {
		key: 'ry',
		get: function get() {
			return this._ry;
		}
	}]);

	return OrbitalControl;
}();

exports.default = OrbitalControl;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = "// generalWithNormal.vert\n\n#define SHADER_NAME GENERAL_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform vec3 position;\nuniform vec3 scale;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tvec3 pos      = aVertexPosition * scale;\n\tpos           += position;\n\tgl_Position   = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(pos, 1.0);\n\t\n\tvTextureCoord = aTextureCoord;\n\tvNormal       = normalize(uNormalMatrix * aNormal);\n}"

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME SKYBOX_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n\tgl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvTextureCoord = aTextureCoord;\n\t\n\tvVertex = aVertexPosition;\n\tvNormal = aNormal;\n}"

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = "// basic.frag\n\n#define SHADER_NAME SKYBOX_FRAGMENT\n\nprecision mediump float;\n#define GLSLIFY 1\nuniform samplerCube texture;\nvarying vec2 vTextureCoord;\nvarying vec3 vVertex;\n\nvoid main(void) {\n    gl_FragColor = textureCube(texture, vVertex);\n}"

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Camera2 = __webpack_require__(24);

var _Camera3 = _interopRequireDefault(_Camera2);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // CameraOrtho.js

var CameraOrtho = function (_Camera) {
	_inherits(CameraOrtho, _Camera);

	function CameraOrtho() {
		_classCallCheck(this, CameraOrtho);

		var _this = _possibleConstructorReturn(this, (CameraOrtho.__proto__ || Object.getPrototypeOf(CameraOrtho)).call(this));

		var eye = _glMatrix.vec3.clone([0, 0, 15]);
		var center = _glMatrix.vec3.create();
		var up = _glMatrix.vec3.clone([0, -1, 0]);
		_this.lookAt(eye, center, up);
		_this.ortho(1, -1, 1, -1);
		return _this;
	}

	_createClass(CameraOrtho, [{
		key: 'setBoundary',
		value: function setBoundary(left, right, top, bottom) {
			var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
			var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;

			this.ortho(left, right, top, bottom, near, far);
		}
	}, {
		key: 'ortho',
		value: function ortho(left, right, top, bottom) {
			var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
			var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			mat4.ortho(this._projection, left, right, top, bottom, near, far);
		}
	}]);

	return CameraOrtho;
}(_Camera3.default);

exports.default = CameraOrtho;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _promisePolyfill = __webpack_require__(42);

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var get = function get(url) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var img = new Image();
		img.onload = function onLoad() {
			resolve(this);
		};

		img.onerror = function onError() {
			reject('Image not found : ' + url);
		};

		img.src = url;
	});
}; // loadImages.js

var loadImages = function loadImages(paths) {
	return _promisePolyfill2.default.all(paths.map(get));
};

exports.default = loadImages;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  this._state = 0;
  this._handled = false;
  this._value = undefined;
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = function(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
};

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!arr || typeof arr.length === 'undefined')
      throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(values) {
  return new Promise(function(resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  (typeof setImmediate === 'function' &&
    function(fn) {
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

module.exports = Promise;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(82).setImmediate))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// PassMacro.js

var PassMacro = function () {
	function PassMacro() {
		_classCallCheck(this, PassMacro);

		this._passes = [];
	}

	_createClass(PassMacro, [{
		key: "addPass",
		value: function addPass(pass) {
			this._passes.push(pass);
		}
	}, {
		key: "passes",
		get: function get() {
			return this._passes;
		}
	}]);

	return PassMacro;
}();

exports.default = PassMacro;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassBlurBase2 = __webpack_require__(45);

var _PassBlurBase3 = _interopRequireDefault(_PassBlurBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassVBlur.js

var PassVBlur = function (_PassBlurBase) {
	_inherits(PassVBlur, _PassBlurBase);

	function PassVBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassVBlur);

		return _possibleConstructorReturn(this, (PassVBlur.__proto__ || Object.getPrototypeOf(PassVBlur)).call(this, mQuality, [0, 1], mWidth, mHeight, mParams));
	}

	return PassVBlur;
}(_PassBlurBase3.default);

exports.default = PassVBlur;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Pass2 = __webpack_require__(12);

var _Pass3 = _interopRequireDefault(_Pass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassBlurBase.js

var fsBlur5 = __webpack_require__(87);
var fsBlur9 = __webpack_require__(88);
var fsBlur13 = __webpack_require__(89);

var PassBlurBase = function (_Pass) {
	_inherits(PassBlurBase, _Pass);

	function PassBlurBase() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mDirection = arguments[1];
		var mWidth = arguments[2];
		var mHeight = arguments[3];
		var mParams = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

		_classCallCheck(this, PassBlurBase);

		var fs = void 0;
		switch (mQuality) {
			case 5:
			default:
				fs = fsBlur5;
				break;
			case 9:
				fs = fsBlur9;
				break;
			case 13:
				fs = fsBlur13;
				break;

		}

		var _this = _possibleConstructorReturn(this, (PassBlurBase.__proto__ || Object.getPrototypeOf(PassBlurBase)).call(this, fs, mWidth, mHeight, mParams));

		_this.uniform('uDirection', mDirection);
		_this.uniform('uResolution', [_GLTool2.default.width, _GLTool2.default.height]);
		return _this;
	}

	return PassBlurBase;
}(_Pass3.default);

exports.default = PassBlurBase;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassBlurBase2 = __webpack_require__(45);

var _PassBlurBase3 = _interopRequireDefault(_PassBlurBase2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassHBlur.js

var PassHBlur = function (_PassBlurBase) {
	_inherits(PassHBlur, _PassBlurBase);

	function PassHBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassHBlur);

		return _possibleConstructorReturn(this, (PassHBlur.__proto__ || Object.getPrototypeOf(PassHBlur)).call(this, mQuality, [1, 0], mWidth, mHeight, mParams));
	}

	return PassHBlur;
}(_PassBlurBase3.default);

exports.default = PassHBlur;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = "// fxaa.frag\n\n#define SHADER_NAME FXAA\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uResolution;\n\n\nfloat FXAA_SUBPIX_SHIFT = 1.0/4.0;\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\n\n\nvec4 applyFXAA(sampler2D tex) {\n    vec4 color;\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 rgbNW = texture2D(tex, (fragCoord + vec2(-1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbNE = texture2D(tex, (fragCoord + vec2(1.0, -1.0)) * uResolution).xyz;\n    vec3 rgbSW = texture2D(tex, (fragCoord + vec2(-1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbSE = texture2D(tex, (fragCoord + vec2(1.0, 1.0)) * uResolution).xyz;\n    vec3 rgbM  = texture2D(tex, fragCoord  * uResolution).xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * uResolution;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * uResolution + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * uResolution + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * uResolution + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, 1.0);\n    else\n        color = vec4(rgbB, 1.0);\n    return color;\n}\n\nvoid main(void) {\n \tvec4 color = applyFXAA(texture);\n    gl_FragColor = color;\n}"

/***/ }),
/* 48 */,
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["LDU"] = LDU;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    let a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];

  // Calculate the determinant
  let det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] =  a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] =  a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  let a0 = a[0];
  out[0] =  a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] =  a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2]/a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  let aa = a[0], ab = a[1], ac = a[2], ad = a[3];
  let atx = a[4], aty = a[5];

  let det = aa * ad - ab * ac;
  if(!det){
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  out[0] = a0 *  c + a2 * s;
  out[1] = a1 *  c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let v0 = v[0], v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  let s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
          a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromXRotation"] = fromXRotation;
/* harmony export (immutable) */ __webpack_exports__["fromYRotation"] = fromYRotation;
/* harmony export (immutable) */ __webpack_exports__["fromZRotation"] = fromZRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslation"] = fromRotationTranslation;
/* harmony export (immutable) */ __webpack_exports__["getTranslation"] = getTranslation;
/* harmony export (immutable) */ __webpack_exports__["getScaling"] = getScaling;
/* harmony export (immutable) */ __webpack_exports__["getRotation"] = getRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScale"] = fromRotationTranslationScale;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScaleOrigin"] = fromRotationTranslationScaleOrigin;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["frustum"] = frustum;
/* harmony export (immutable) */ __webpack_exports__["perspective"] = perspective;
/* harmony export (immutable) */ __webpack_exports__["perspectiveFromFieldOfView"] = perspectiveFromFieldOfView;
/* harmony export (immutable) */ __webpack_exports__["ortho"] = ortho;
/* harmony export (immutable) */ __webpack_exports__["lookAt"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["targetTo"] = targetTo;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 4x4 Matrix
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    let a01 = a[1], a02 = a[2], a03 = a[3];
    let a12 = a[6], a13 = a[7];
    let a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
  out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
  out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
  out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
  out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
  out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

  // Cache only the current line of the second matrix
  let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
  out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
  out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

  b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
  out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
  out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
  out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
  out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  let x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  let x = v[0], y = v[1], z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;
  let a00, a01, a02, a03;
  let a10, a11, a12, a13;
  let a20, a21, a22, a23;
  let b00, b01, b02;
  let b10, b11, b12;
  let b20, b21, b22;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
  a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
  a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
  b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
  b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[0]  = a[0];
    out[1]  = a[1];
    out[2]  = a[2];
    out[3]  = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a20 = a[8];
  let a21 = a[9];
  let a22 = a[10];
  let a23 = a[11];

  if (a !== out) { // If the source and destination differ, copy the unchanged rows
    out[4]  = a[4];
    out[5]  = a[5];
    out[6]  = a[6];
    out[7]  = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);
  let a00 = a[0];
  let a01 = a[1];
  let a02 = a[2];
  let a03 = a[3];
  let a10 = a[4];
  let a11 = a[5];
  let a12 = a[6];
  let a13 = a[7];

  if (a !== out) { // If the source and destination differ, copy the unchanged last row
    out[8]  = a[8];
    out[9]  = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  let x = axis[0], y = axis[1], z = axis[2];
  let len = Math.sqrt(x * x + y * y + z * z);
  let s, c, t;

  if (Math.abs(len) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) { return null; }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = 1;
  out[1]  = 0;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = 0;
  out[2]  = -s;
  out[3]  = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  let s = Math.sin(rad);
  let c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0]  = c;
  out[1]  = s;
  out[2]  = 0;
  out[3]  = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  let m11 = mat[0];
  let m12 = mat[1];
  let m13 = mat[2];
  let m21 = mat[4];
  let m22 = mat[5];
  let m23 = mat[6];
  let m31 = mat[8];
  let m32 = mat[9];
  let m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  let trace = mat[0] + mat[5] + mat[10];
  let S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  let sx = s[0];
  let sy = s[1];
  let sz = s[2];

  let ox = o[0];
  let oy = o[1];
  let oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;

  let xx = x * x2;
  let yx = y * x2;
  let yy = y * y2;
  let zx = z * x2;
  let zy = z * y2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  let rl = 1 / (right - left);
  let tb = 1 / (top - bottom);
  let nf = 1 / (near - far);
  out[0] = (near * 2) * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = (near * 2) * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (far * near * 2) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  let f = 1.0 / Math.tan(fovy / 2);
  let nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = (2 * far * near) * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  let upTan = Math.tan(fov.upDegrees * Math.PI/180.0);
  let downTan = Math.tan(fov.downDegrees * Math.PI/180.0);
  let leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0);
  let rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0);
  let xScale = 2.0 / (leftTan + rightTan);
  let yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = ((upTan - downTan) * yScale * 0.5);
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = (far * near) / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  let lr = 1 / (left - right);
  let bt = 1 / (bottom - top);
  let nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  let eyex = eye[0];
  let eyey = eye[1];
  let eyez = eye[2];
  let upx = up[0];
  let upy = up[1];
  let upz = up[2];
  let centerx = center[0];
  let centery = center[1];
  let centerz = center[2];

  if (Math.abs(eyex - centerx) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyey - centery) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"] &&
      Math.abs(eyez - centerz) < __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]) {
    return mat4.identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  let eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  let z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  let len = z0*z0 + z1*z1 + z2*z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  let x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
          a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
          a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
          a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  out[2] = a[2] + (b[2] * scale);
  out[3] = a[3] + (b[3] * scale);
  out[4] = a[4] + (b[4] * scale);
  out[5] = a[5] + (b[5] * scale);
  out[6] = a[6] + (b[6] * scale);
  out[7] = a[7] + (b[7] * scale);
  out[8] = a[8] + (b[8] * scale);
  out[9] = a[9] + (b[9] * scale);
  out[10] = a[10] + (b[10] * scale);
  out[11] = a[11] + (b[11] * scale);
  out[12] = a[12] + (b[12] * scale);
  out[13] = a[13] + (b[13] * scale);
  out[14] = a[14] + (b[14] * scale);
  out[15] = a[15] + (b[15] * scale);
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] &&
         a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] &&
         a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
         a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  let a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3];
  let a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7];
  let a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11];
  let a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

  let b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3];
  let b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7];
  let b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11];
  let b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
          Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
          Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
          Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
          Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
          Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
          Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
          Math.abs(a9 - b9) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
          Math.abs(a10 - b10) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
          Math.abs(a11 - b11) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
          Math.abs(a12 - b12) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
          Math.abs(a13 - b13) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
          Math.abs(a14 - b14) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
          Math.abs(a15 - b15) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link mat4.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["setAxisAngle"] = setAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["getAxisAngle"] = getAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["calculateW"] = calculateW;
/* harmony export (immutable) */ __webpack_exports__["slerp"] = slerp;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["conjugate"] = conjugate;
/* harmony export (immutable) */ __webpack_exports__["fromMat3"] = fromMat3;
/* harmony export (immutable) */ __webpack_exports__["fromEuler"] = fromEuler;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mat3__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vec3__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vec4__ = __webpack_require__(31);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */






/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](4);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  let rad = Math.acos(q[3]) * 2.0;
  let s = Math.sin(rad / 2.0);
  if (s != 0.0) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let by = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bz = Math.sin(rad), bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  let x = a[0], y = a[1], z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];

  let omega, cosom, sinom, scale0, scale1;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if ( cosom < 0.0 ) {
    cosom = -cosom;
    bx = - bx;
    by = - by;
    bz = - bz;
    bw = - bw;
  }
  // calculate coefficients
  if ( (1.0 - cosom) > 0.000001 ) {
    // standard case (slerp)
    omega  = Math.acos(cosom);
    sinom  = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
  let invDot = dot ? 1.0/dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0*invDot;
  out[1] = -a1*invDot;
  out[2] = -a2*invDot;
  out[3] = a3*invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;

  if ( fTrace > 0.0 ) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0);  // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5/fRoot;  // 1/(4w)
    out[0] = (m[5]-m[7])*fRoot;
    out[1] = (m[6]-m[2])*fRoot;
    out[2] = (m[1]-m[3])*fRoot;
  } else {
    // |w| <= 1/2
    let i = 0;
    if ( m[4] > m[0] )
      i = 1;
    if ( m[8] > m[i*3+i] )
      i = 2;
    let j = (i+1)%3;
    let k = (i+2)%3;

    fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
    out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
    out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
    let halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;

    let sx = Math.sin(x);
    let cx = Math.cos(x);
    let sy = Math.sin(y);
    let cy = Math.cos(y);
    let sz = Math.sin(z);
    let cz = Math.cos(z);

    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;

    return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
const clone = __WEBPACK_IMPORTED_MODULE_3__vec4__["clone"];
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;


/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
const fromValues = __WEBPACK_IMPORTED_MODULE_3__vec4__["fromValues"];
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;


/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
const copy = __WEBPACK_IMPORTED_MODULE_3__vec4__["copy"];
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;


/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
const set = __WEBPACK_IMPORTED_MODULE_3__vec4__["set"];
/* harmony export (immutable) */ __webpack_exports__["set"] = set;


/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
const add = __WEBPACK_IMPORTED_MODULE_3__vec4__["add"];
/* harmony export (immutable) */ __webpack_exports__["add"] = add;


/**
 * Alias for {@link quat.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
const scale = __WEBPACK_IMPORTED_MODULE_3__vec4__["scale"];
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;


/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
const dot = __WEBPACK_IMPORTED_MODULE_3__vec4__["dot"];
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;


/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
const lerp = __WEBPACK_IMPORTED_MODULE_3__vec4__["lerp"];
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;


/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
const length = __WEBPACK_IMPORTED_MODULE_3__vec4__["length"];
/* harmony export (immutable) */ __webpack_exports__["length"] = length;


/**
 * Alias for {@link quat.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
const squaredLength = __WEBPACK_IMPORTED_MODULE_3__vec4__["squaredLength"];
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;


/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
const normalize = __WEBPACK_IMPORTED_MODULE_3__vec4__["normalize"];
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;


/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const exactEquals = __WEBPACK_IMPORTED_MODULE_3__vec4__["exactEquals"];
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;


/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
const equals = __WEBPACK_IMPORTED_MODULE_3__vec4__["equals"];
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;


/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
const rotationTo = (function() {
  let tmpvec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["create"]();
  let xUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](1,0,0);
  let yUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3__["fromValues"](0,1,0);

  return function(out, a, b) {
    let dot = __WEBPACK_IMPORTED_MODULE_2__vec3__["dot"](a, b);
    if (dot < -0.999999) {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, xUnitVec3, a);
      if (__WEBPACK_IMPORTED_MODULE_2__vec3__["len"](tmpvec3) < 0.000001)
        __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, yUnitVec3, a);
      __WEBPACK_IMPORTED_MODULE_2__vec3__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      __WEBPACK_IMPORTED_MODULE_2__vec3__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
})();
/* harmony export (immutable) */ __webpack_exports__["rotationTo"] = rotationTo;


/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
const sqlerp = (function () {
  let temp1 = create();
  let temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}());
/* harmony export (immutable) */ __webpack_exports__["sqlerp"] = sqlerp;


/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
const setAxes = (function() {
  let matr = __WEBPACK_IMPORTED_MODULE_1__mat3__["create"]();

  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
})();
/* harmony export (immutable) */ __webpack_exports__["setAxes"] = setAxes;



/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat2"] = transformMat2;
/* harmony export (immutable) */ __webpack_exports__["transformMat2d"] = transformMat2d;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common__ = __webpack_require__(4);
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */



/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  let out = new __WEBPACK_IMPORTED_MODULE_0__common__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
};

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round (out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale);
  out[1] = a[1] + (b[1] * scale);
  return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1];
  return x*x + y*y;
};

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
    y = a[1];
  return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1];
  return x*x + y*y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
    y = a[1];
  var len = x*x + y*y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
    ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = __WEBPACK_IMPORTED_MODULE_0__common__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
    y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  let x = a[0];
  let y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  let a0 = a[0], a1 = a[1];
  let b0 = b[0], b1 = b[1];
  return (Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common__["EPSILON"]*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
const len = length;
/* harmony export (immutable) */ __webpack_exports__["len"] = len;


/**
 * Alias for {@link vec2.subtract}
 * @function
 */
const sub = subtract;
/* harmony export (immutable) */ __webpack_exports__["sub"] = sub;


/**
 * Alias for {@link vec2.multiply}
 * @function
 */
const mul = multiply;
/* harmony export (immutable) */ __webpack_exports__["mul"] = mul;


/**
 * Alias for {@link vec2.divide}
 * @function
 */
const div = divide;
/* harmony export (immutable) */ __webpack_exports__["div"] = div;


/**
 * Alias for {@link vec2.distance}
 * @function
 */
const dist = distance;
/* harmony export (immutable) */ __webpack_exports__["dist"] = dist;


/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
const sqrDist = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["sqrDist"] = sqrDist;


/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
const sqrLen = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["sqrLen"] = sqrLen;


/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
const forEach = (function() {
  let vec = create();

  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if(!stride) {
      stride = 2;
    }

    if(!offset) {
      offset = 0;
    }

    if(count) {
      l = Math.min((count * stride) + offset, a.length);
    } else {
      l = a.length;
    }

    for(i = offset; i < l; i += stride) {
      vec[0] = a[i]; vec[1] = a[i+1];
      fn(vec, vec, arg);
      a[i] = vec[0]; a[i+1] = vec[1];
    }

    return a;
  };
})();
/* harmony export (immutable) */ __webpack_exports__["forEach"] = forEach;



/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = getAndApplyExtension;
// VertexArrayObject.js

function getAndApplyExtension(gl, name) {
	var ext = gl.getExtension(name);
	if (!ext) {
		return false;
	}
	var suffix = name.split('_')[0];
	var suffixRE = new RegExp(suffix + '$');

	for (var key in ext) {
		var val = ext[key];
		if (typeof val === 'function') {
			var unsuffixedKey = key.replace(suffixRE, '');
			if (key.substring) {
				gl[unsuffixedKey] = ext[key].bind(ext);
				// console.log('Replacing :', key, '=>', unsuffixedKey);
			}
		}
	}

	return true;
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _WebglConst = __webpack_require__(32);

var _WebglConst2 = _interopRequireDefault(_WebglConst);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// exposeAttributes.js

var exposeAttributes = function exposeAttributes() {
	// GL.VERTEX_SHADER         = GL.gl.VERTEX_SHADER;
	// GL.FRAGMENT_SHADER       = GL.gl.FRAGMENT_SHADER;
	// GL.COMPILE_STATUS        = GL.gl.COMPILE_STATUS;
	// GL.DEPTH_TEST            = GL.gl.DEPTH_TEST;
	// GL.CULL_FACE             = GL.gl.CULL_FACE;
	// GL.BLEND                 = GL.gl.BLEND;
	// GL.POINTS                = GL.gl.POINTS;
	// GL.LINES                 = GL.gl.LINES;
	// GL.TRIANGLES             = GL.gl.TRIANGLES;

	// GL.LINEAR                	= GL.gl.LINEAR;
	// GL.NEAREST               	= GL.gl.NEAREST;
	// GL.LINEAR_MIPMAP_NEAREST 	= GL.gl.LINEAR_MIPMAP_NEAREST;
	// GL.NEAREST_MIPMAP_LINEAR 	= GL.gl.NEAREST_MIPMAP_LINEAR;
	// GL.LINEAR_MIPMAP_LINEAR 	= GL.gl.LINEAR_MIPMAP_LINEAR;
	// GL.NEAREST_MIPMAP_NEAREST 	= GL.gl.NEAREST_MIPMAP_NEAREST;
	// GL.MIRRORED_REPEAT       	= GL.gl.MIRRORED_REPEAT;
	// GL.CLAMP_TO_EDGE         	= GL.gl.CLAMP_TO_EDGE;
	// GL.SCISSOR_TEST		   	 	= GL.gl.SCISSOR_TEST;
	// GL.UNSIGNED_BYTE		 	= GL.gl.UNSIGNED_BYTE;
	for (var s in _WebglConst2.default) {
		if (!_GLTool2.default[s]) {
			_GLTool2.default[s] = _WebglConst2.default[s];
		} else {
			console.log('already exist : ', s);
		}
	}
};

exports.default = exposeAttributes;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	if (!hasChecked) {
		_float = checkFloat();
	}

	return _float;
};

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasChecked = false; // getFloat.js

var _float = void 0;

function checkFloat() {
	if (_GLTool2.default.webgl2) {
		return _GLTool2.default.gl.FLOAT;
	} else {
		var extFloat = _GLTool2.default.getExtension('OES_texture_float');
		if (extFloat) {
			return _GLTool2.default.gl.FLOAT;
		} else {
			console.warn('USING FLOAT BUT OES_texture_float NOT SUPPORTED');
			return _GLTool2.default.gl.UNSIGNED_BYTE;
		}
	}

	hasChecked = true;
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	if (!hasChecked) {
		halfFloat = checkHalfFloat();
	}

	return halfFloat;
};

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasChecked = false; // getHalfFloat.js

var halfFloat = void 0;

function checkHalfFloat() {
	if (_GLTool2.default.webgl2) {
		return _GLTool2.default.gl.HALF_FLOAT;
	} else {
		var extHalfFloat = _GLTool2.default.getExtension('OES_texture_half_float');
		if (extHalfFloat) {
			return extHalfFloat.HALF_FLOAT_OES;
		} else {
			console.warn('USING HALF FLOAT BUT OES_texture_half_float NOT SUPPORTED');
			return _GLTool2.default.gl.UNSIGNED_BYTE;
		}
	}

	hasChecked = true;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// ExtensionsList.js

exports.default = ['EXT_shader_texture_lod', 'EXT_sRGB', 'EXT_frag_depth', 'OES_texture_float', 'OES_texture_half_float', 'OES_texture_float_linear', 'OES_texture_half_float_linear', 'OES_standard_derivatives', 'WEBGL_depth_texture', 'EXT_texture_filter_anisotropic', 'OES_vertex_array_object', 'ANGLE_instanced_arrays', 'WEBGL_draw_buffers'];

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
} // getTextureParameters.js

;

var getTextureParameters = function getTextureParameters(mParams, mSource, mWidth, mHeight) {
	if (!mParams.minFilter) {
		var minFilter = _GLTool2.default.LINEAR;
		if (mWidth && mWidth) {
			if (isPowerOfTwo(mWidth) && isPowerOfTwo(mHeight)) {
				minFilter = _GLTool2.default.LINEAR_MIPMAP_NEAREST;
			}
		}

		mParams.minFilter = minFilter;
	}

	mParams.mipmap = mParams.mipmap || true;
	mParams.magFilter = mParams.magFilter || _GLTool2.default.LINEAR;
	mParams.wrapS = mParams.wrapS || _GLTool2.default.CLAMP_TO_EDGE;
	mParams.wrapT = mParams.wrapT || _GLTool2.default.CLAMP_TO_EDGE;
	mParams.internalFormat = mParams.internalFormat || _GLTool2.default.RGBA;
	mParams.format = mParams.format || _GLTool2.default.RGBA;
	mParams.premultiplyAlpha = mParams.premultiplyAlpha || false;
	mParams.level = mParams.level || 0;
	mParams.anisotropy = mParams.anisotropy || 0;

	return mParams;
};

exports.default = getTextureParameters;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/
//
// DX10 Cubemap support based on
// https://github.com/dariomanesku/cmft/issues/7#issuecomment-69516844
// https://msdn.microsoft.com/en-us/library/windows/desktop/bb943983(v=vs.85).aspx
// https://github.com/playcanvas/engine/blob/master/src/resources/resources_texture.js

var DDS_MAGIC = 0x20534444
var DDSD_MIPMAPCOUNT = 0x20000
var DDPF_FOURCC = 0x4

var FOURCC_DXT1 = fourCCToInt32('DXT1')
var FOURCC_DXT3 = fourCCToInt32('DXT3')
var FOURCC_DXT5 = fourCCToInt32('DXT5')
var FOURCC_DX10 = fourCCToInt32('DX10')
var FOURCC_FP32F = 116 // DXGI_FORMAT_R32G32B32A32_FLOAT

var DDSCAPS2_CUBEMAP = 0x200
var D3D10_RESOURCE_DIMENSION_TEXTURE2D = 3
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2

// The header length in 32 bit ints
var headerLengthInt = 31

// Offsets into the header array
var off_magic = 0
var off_size = 1
var off_flags = 2
var off_height = 3
var off_width = 4
var off_mipmapCount = 7
var off_pfFlags = 20
var off_pfFourCC = 21
var off_caps2 = 28

module.exports = parseHeaders

function parseHeaders (arrayBuffer) {
  var header = new Int32Array(arrayBuffer, 0, headerLengthInt)

  if (header[off_magic] !== DDS_MAGIC) {
    throw new Error('Invalid magic number in DDS header')
  }

  if (!header[off_pfFlags] & DDPF_FOURCC) {
    throw new Error('Unsupported format, must contain a FourCC code')
  }

  var blockBytes
  var format
  var fourCC = header[off_pfFourCC]
  switch (fourCC) {
    case FOURCC_DXT1:
      blockBytes = 8
      format = 'dxt1'
      break
    case FOURCC_DXT3:
      blockBytes = 16
      format = 'dxt3'
      break
    case FOURCC_DXT5:
      blockBytes = 16
      format = 'dxt5'
      break
    case FOURCC_FP32F:
      format = 'rgba32f'
      break
    case FOURCC_DX10:
      var dx10Header = new Uint32Array(arrayBuffer.slice(128, 128 + 20))
      format = dx10Header[0]
      var resourceDimension = dx10Header[1]
      var miscFlag = dx10Header[2]
      var arraySize = dx10Header[3]
      var miscFlags2 = dx10Header[4]

      if (resourceDimension === D3D10_RESOURCE_DIMENSION_TEXTURE2D && format === DXGI_FORMAT_R32G32B32A32_FLOAT) {
        format = 'rgba32f'
      } else {
        throw new Error('Unsupported DX10 texture format ' + format)
      }
      break
    default:
      throw new Error('Unsupported FourCC code: ' + int32ToFourCC(fourCC))
  }

  var flags = header[off_flags]
  var mipmapCount = 1

  if (flags & DDSD_MIPMAPCOUNT) {
    mipmapCount = Math.max(1, header[off_mipmapCount])
  }

  var cubemap = false
  var caps2 = header[off_caps2]
  if (caps2 & DDSCAPS2_CUBEMAP) {
    cubemap = true
  }

  var width = header[off_width]
  var height = header[off_height]
  var dataOffset = header[off_size] + 4
  var texWidth = width
  var texHeight = height
  var images = []
  var dataLength

  if (fourCC === FOURCC_DX10) {
    dataOffset += 20
  }

  if (cubemap) {
    for (var f = 0; f < 6; f++) {
      if (format !== 'rgba32f') {
        throw new Error('Only RGBA32f cubemaps are supported')
      }
      var bpp = 4 * 32 / 8

      width = texWidth
      height = texHeight

      // cubemap should have all mipmap levels defined
      // Math.log2(width) + 1
      var requiredMipLevels = Math.log(width) / Math.log(2) + 1

      for (var i = 0; i < requiredMipLevels; i++) {
        dataLength = width * height * bpp
        images.push({
          offset: dataOffset,
          length: dataLength,
          shape: [ width, height ]
        })
        // Reuse data from the previous level if we are beyond mipmapCount
        // This is hack for CMFT not publishing full mipmap chain https://github.com/dariomanesku/cmft/issues/10
        if (i < mipmapCount) {
          dataOffset += dataLength
        }
        width = Math.floor(width / 2)
        height = Math.floor(height / 2)
      }
    }
  } else {
    for (var i = 0; i < mipmapCount; i++) {
      dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes

      images.push({
        offset: dataOffset,
        length: dataLength,
        shape: [ width, height ]
      })
      dataOffset += dataLength
      width = Math.floor(width / 2)
      height = Math.floor(height / 2)
    }
  }

  return {
    shape: [ texWidth, texHeight ],
    images: images,
    format: format,
    flags: flags,
    cubemap: cubemap
  }
}

function fourCCToInt32 (value) {
  return value.charCodeAt(0) +
    (value.charCodeAt(1) << 8) +
    (value.charCodeAt(2) << 16) +
    (value.charCodeAt(3) << 24)
}

function int32ToFourCC (value) {
  return String.fromCharCode(
    value & 0xff,
    (value >> 8) & 0xff,
    (value >> 16) & 0xff,
    (value >> 24) & 0xff
  )
}


/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}


/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = "// basic.frag\n\n#define SHADER_NAME BASIC_FRAGMENT\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform float time;\n// uniform sampler2D texture;\n\nvoid main(void) {\n    gl_FragColor = vec4(vTextureCoord, sin(time) * .5 + .5, 1.0);\n}"

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// CubeFrameBuffer.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLCubeTexture = __webpack_require__(14);

var _GLCubeTexture2 = _interopRequireDefault(_GLCubeTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var CubeFrameBuffer = function () {
	function CubeFrameBuffer(size) {
		var mParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, CubeFrameBuffer);

		gl = _GLTool2.default.gl;
		this._size = size;
		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;

		this._init();
	}

	_createClass(CubeFrameBuffer, [{
		key: '_init',
		value: function _init() {
			this.texture = gl.createTexture();
			this.glTexture = new _GLCubeTexture2.default(this.texture, {}, true);

			gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, this.magFilter);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, this.minFilter);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this.wrapS);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this.wrapT);

			var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

			for (var i = 0; i < targets.length; i++) {
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
				gl.texImage2D(targets[i], 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.FLOAT, null);
			}

			this._frameBuffers = [];
			for (var _i = 0; _i < targets.length; _i++) {
				var frameBuffer = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, targets[_i], this.texture, 0);

				var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
				if (status !== gl.FRAMEBUFFER_COMPLETE) {
					console.log('\'gl.checkFramebufferStatus() returned \'' + status);
				}

				this._frameBuffers.push(frameBuffer);
			}

			// gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		}
	}, {
		key: 'bind',
		value: function bind(mTargetIndex) {

			// if(Math.random() > .99) console.log('bind :', mTargetIndex, this._frameBuffers[mTargetIndex]);
			_GLTool2.default.viewport(0, 0, this.width, this.height);
			gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffers[mTargetIndex]);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
		}

		//	TEXTURES

	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this.glTexture;
		}

		//	GETTERS AND SETTERS

	}, {
		key: 'width',
		get: function get() {
			return this._size;
		}
	}, {
		key: 'height',
		get: function get() {
			return this._size;
		}
	}]);

	return CubeFrameBuffer;
}();

exports.default = CubeFrameBuffer;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // MultisampleFrameBuffer.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

function isPowerOfTwo(x) {
	return x !== 0 && !(x & x - 1);
};

var MultisampleFrameBuffer = function () {
	function MultisampleFrameBuffer(mWidth, mHeight) {
		var mParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, MultisampleFrameBuffer);

		gl = _GLTool2.default.gl;

		this.width = mWidth;
		this.height = mHeight;

		this.magFilter = mParameters.magFilter || gl.LINEAR;
		this.minFilter = mParameters.minFilter || gl.LINEAR;
		this.wrapS = mParameters.wrapS || gl.CLAMP_TO_EDGE;
		this.wrapT = mParameters.wrapT || gl.CLAMP_TO_EDGE;
		this.useDepth = mParameters.useDepth || true;
		this.useStencil = mParameters.useStencil || false;
		this.texelType = mParameters.type;
		this._numSample = mParameters.numSample || 8;

		if (!isPowerOfTwo(this.width) || !isPowerOfTwo(this.height)) {
			this.wrapS = this.wrapT = gl.CLAMP_TO_EDGE;

			if (this.minFilter === gl.LINEAR_MIPMAP_NEAREST) {
				this.minFilter = gl.LINEAR;
			}
		}

		this._init();
	}

	_createClass(MultisampleFrameBuffer, [{
		key: '_init',
		value: function _init() {
			var texelType = gl.UNSIGNED_BYTE;
			if (this.texelType) {
				texelType = this.texelType;
			}

			this.texelType = texelType;

			this.frameBuffer = gl.createFramebuffer();
			this.frameBufferColor = gl.createFramebuffer();
			this.renderBufferColor = gl.createRenderbuffer();
			this.renderBufferDepth = gl.createRenderbuffer();
			this.glTexture = this._createTexture();
			this.glDepthTexture = this._createTexture(gl.DEPTH_COMPONENT16, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, true);

			gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferColor);
			gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.RGBA8, this.width, this.height);

			gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBufferDepth);
			gl.renderbufferStorageMultisample(gl.RENDERBUFFER, this._numSample, gl.DEPTH_COMPONENT16, this.width, this.height);

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.renderBufferColor);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBufferDepth);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferColor);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.glTexture.texture, 0);
			// gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			// gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBufferDepth);
			// gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.glDepthTexture.texture, 0);
			// gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: '_createTexture',
		value: function _createTexture(mInternalformat, mTexelType, mFormat) {
			var forceNearest = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

			if (mInternalformat === undefined) {
				mInternalformat = gl.RGBA;
			}
			if (mTexelType === undefined) {
				mTexelType = this.texelType;
			}
			if (!mFormat) {
				mFormat = mInternalformat;
			}

			var t = gl.createTexture();
			var glt = new _GLTexture2.default(t, true);
			var magFilter = forceNearest ? _GLTool2.default.NEAREST : this.magFilter;
			var minFilter = forceNearest ? _GLTool2.default.NEAREST : this.minFilter;

			gl.bindTexture(gl.TEXTURE_2D, t);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.wrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.wrapT);
			gl.texImage2D(gl.TEXTURE_2D, 0, mInternalformat, this.width, this.height, 0, mFormat, mTexelType, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			return glt;
		}
	}, {
		key: 'bind',
		value: function bind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, this.width, this.height);
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
		}
	}, {
		key: 'unbind',
		value: function unbind() {
			var mAutoSetViewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			if (mAutoSetViewport) {
				_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);
			}

			var width = this.width,
			    height = this.height;


			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
			gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferColor);
			gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 0.0]);
			gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, gl.COLOR_BUFFER_BIT, _GLTool2.default.NEAREST);
			// gl.blitFramebuffer(
			// 	0, 0, width, height,
			// 	0, 0, width, height,
			// 	gl.COLOR_BUFFER_BIT|gl.DEPTH_STENCIL, GL.NEAREST
			// );

			// gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.frameBuffer);
			// gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.frameBufferDepth);
			// gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1.0, 0);
			// gl.blitFramebuffer(
			// 	0, 0, width, height,
			// 	0, 0, width, height,
			// 	gl.DEPTH_BUFFER_BIT, gl.NEAREST
			// );

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			var mIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

			return this.glTexture;
		}
	}, {
		key: 'getDepthTexture',
		value: function getDepthTexture() {
			return this.glDepthTexture;
		}
	}]);

	return MultisampleFrameBuffer;
}();

exports.default = MultisampleFrameBuffer;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // TransformFeedbackObject.js

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var gl = void 0;

var TransformFeedbackObject = function () {
	function TransformFeedbackObject(strVertexShader, strFragmentShader) {
		_classCallCheck(this, TransformFeedbackObject);

		gl = _GLTool2.default.gl;
		this._vs = strVertexShader;
		this._fs = strFragmentShader;

		this._init();
	}

	_createClass(TransformFeedbackObject, [{
		key: '_init',
		value: function _init() {
			this._geoCurrent = new _Geometry2.default();
			this._geoTarget = new _Geometry2.default();
			this._numPoints = -1;

			this._varyings = [];
			this.transformFeedback = gl.createTransformFeedback();
		}
	}, {
		key: 'bufferData',
		value: function bufferData(mData, mName, mVaryingName) {
			var isTransformFeedback = !!mVaryingName;
			console.log('is Transform feedback ?', mName, isTransformFeedback);
			this._geoCurrent.bufferData(mData, mName, null, gl.STREAM_COPY, false);
			this._geoTarget.bufferData(mData, mName, null, gl.STREAM_COPY, false);

			if (isTransformFeedback) {
				this._varyings.push(mVaryingName);

				if (this._numPoints < 0) {
					this._numPoints = mData.length;
				}
			}
		}
	}, {
		key: 'bufferIndex',
		value: function bufferIndex(mArrayIndices) {
			this._geoCurrent.bufferIndex(mArrayIndices);
			this._geoTarget.bufferIndex(mArrayIndices);
		}
	}, {
		key: 'uniform',
		value: function uniform(mName, mType, mValue) {
			if (this.shader) {
				this.shader.uniform(mName, mType, mValue);
			}
		}
	}, {
		key: 'generate',
		value: function generate() {
			this.shader = new _GLShader2.default(this._vs, this._fs, this._varyings);
		}
	}, {
		key: 'render',
		value: function render() {
			if (!this.shader) {
				this.generate();
			}

			this.shader.bind();
			_GLTool2.default.drawTransformFeedback(this);

			this._swap();
		}
	}, {
		key: '_swap',
		value: function _swap() {
			var tmp = this._geoCurrent;
			this._geoCurrent = this._geoTarget;
			this._geoTarget = tmp;
		}
	}, {
		key: 'numPoints',
		get: function get() {
			return this._numPoints;
		}
	}, {
		key: 'geoCurrent',
		get: function get() {
			return this._geoCurrent;
		}
	}, {
		key: 'geoTarget',
		get: function get() {
			return this._geoTarget;
		}
	}, {
		key: 'geoSource',
		get: function get() {
			return this._geoCurrent;
		}
	}, {
		key: 'geoDestination',
		get: function get() {
			return this._geoTarget;
		}
	}]);

	return TransformFeedbackObject;
}();

exports.default = TransformFeedbackObject;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// TweenNumber.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Easing = {
	Linear: {
		None: function None(k) {
			return k;
		}
	},
	Quadratic: {
		In: function In(k) {
			return k * k;
		},
		Out: function Out(k) {
			return k * (2 - k);
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}
			return -0.5 * (--k * (k - 2) - 1);
		}
	},
	Cubic: {
		In: function In(k) {
			return k * k * k;
		},
		Out: function Out(k) {
			return --k * k * k + 1;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}
			return 0.5 * ((k -= 2) * k * k + 2);
		}
	},
	Quartic: {
		In: function In(k) {
			return k * k * k * k;
		},
		Out: function Out(k) {
			return 1 - --k * k * k * k;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}
			return -0.5 * ((k -= 2) * k * k * k - 2);
		}
	},
	Quintic: {
		In: function In(k) {
			return k * k * k * k * k;
		},
		Out: function Out(k) {
			return --k * k * k * k * k + 1;
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}
			return 0.5 * ((k -= 2) * k * k * k * k + 2);
		}
	},
	Sinusoidal: {
		In: function In(k) {
			return 1 - Math.cos(k * Math.PI / 2);
		},
		Out: function Out(k) {
			return Math.sin(k * Math.PI / 2);
		},
		InOut: function InOut(k) {
			return 0.5 * (1 - Math.cos(Math.PI * k));
		}
	},
	Exponential: {
		In: function In(k) {
			return k === 0 ? 0 : Math.pow(1024, k - 1);
		},
		Out: function Out(k) {
			return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
		},
		InOut: function InOut(k) {
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}
			return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
		}
	},
	Circular: {
		In: function In(k) {
			return 1 - Math.sqrt(1 - k * k);
		},
		Out: function Out(k) {
			return Math.sqrt(1 - --k * k);
		},
		InOut: function InOut(k) {
			if ((k *= 2) < 1) {
				return -0.5 * (Math.sqrt(1 - k * k) - 1);
			}
			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
		}
	},
	Elastic: {
		In: function In(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
		},
		Out: function Out(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
		},
		InOut: function InOut(k) {
			var s = void 0;
			var a = 0.1;
			var p = 0.4;
			if (k === 0) {
				return 0;
			}
			if (k === 1) {
				return 1;
			}
			if (!a || a < 1) {
				a = 1;
				s = p / 4;
			} else {
				s = p * Math.asin(1 / a) / (2 * Math.PI);
			}
			if ((k *= 2) < 1) {
				return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
			}
			return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
		}
	},
	Back: {
		In: function In(k) {
			var s = 1.70158;
			return k * k * ((s + 1) * k - s);
		},
		Out: function Out(k) {
			var s = 1.70158;
			return --k * k * ((s + 1) * k + s) + 1;
		},
		InOut: function InOut(k) {
			var s = 1.70158 * 1.525;
			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}
			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
		}
	},
	Bounce: {
		in: function _in(k) {
			return 1 - Easing.Bounce.out(1 - k);
		},
		out: function out(k) {
			if (k < 1 / 2.75) {
				return 7.5625 * k * k;
			} else if (k < 2 / 2.75) {
				return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
			} else if (k < 2.5 / 2.75) {
				return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
			} else {
				return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
			}
		},
		inOut: function inOut(k) {
			if (k < 0.5) {
				return Easing.Bounce.in(k * 2) * 0.5;
			}
			return Easing.Bounce.out(k * 2 - 1) * 0.5 + 0.5;
		}
	}
};

function getFunc(mEasing) {
	switch (mEasing) {
		default:
		case 'linear':
			return Easing.Linear.None;
		case 'expIn':
			return Easing.Exponential.In;
		case 'expOut':
			return Easing.Exponential.Out;
		case 'expInOut':
			return Easing.Exponential.InOut;

		case 'cubicIn':
			return Easing.Cubic.In;
		case 'cubicOut':
			return Easing.Cubic.Out;
		case 'cubicInOut':
			return Easing.Cubic.InOut;

		case 'quarticIn':
			return Easing.Quartic.In;
		case 'quarticOut':
			return Easing.Quartic.Out;
		case 'quarticInOut':
			return Easing.Quartic.InOut;

		case 'quinticIn':
			return Easing.Quintic.In;
		case 'quinticOut':
			return Easing.Quintic.Out;
		case 'quinticInOut':
			return Easing.Quintic.InOut;

		case 'sinusoidalIn':
			return Easing.Sinusoidal.In;
		case 'sinusoidalOut':
			return Easing.Sinusoidal.Out;
		case 'sinusoidalInOut':
			return Easing.Sinusoidal.InOut;

		case 'circularIn':
			return Easing.Circular.In;
		case 'circularOut':
			return Easing.Circular.Out;
		case 'circularInOut':
			return Easing.Circular.InOut;

		case 'elasticIn':
			return Easing.Elastic.In;
		case 'elasticOut':
			return Easing.Elastic.Out;
		case 'elasticInOut':
			return Easing.Elastic.InOut;

		case 'backIn':
			return Easing.Back.In;
		case 'backOut':
			return Easing.Back.Out;
		case 'backInOut':
			return Easing.Back.InOut;

		case 'bounceIn':
			return Easing.Bounce.in;
		case 'bounceOut':
			return Easing.Bounce.out;
		case 'bounceInOut':
			return Easing.Bounce.inOut;
	}
}

var TweenNumber = function () {
	function TweenNumber(mValue) {
		var _this = this;

		var mEasing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'expOut';
		var mSpeed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.01;

		_classCallCheck(this, TweenNumber);

		this._value = mValue;
		this._startValue = mValue;
		this._targetValue = mValue;
		this._counter = 1;
		this.speed = mSpeed;
		this.easing = mEasing;
		this._needUpdate = true;

		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._update();
		});
	}

	_createClass(TweenNumber, [{
		key: '_update',
		value: function _update() {
			var newCounter = this._counter + this.speed;
			if (newCounter > 1) {
				newCounter = 1;
			}
			if (this._counter === newCounter) {
				this._needUpdate = false;
				return;
			}

			this._counter = newCounter;
			this._needUpdate = true;
		}
	}, {
		key: 'limit',
		value: function limit(mMin, mMax) {
			if (mMin > mMax) {
				this.limit(mMax, mMin);
				return;
			}

			this._min = mMin;
			this._max = mMax;

			this._checkLimit();
		}
	}, {
		key: 'setTo',
		value: function setTo(mValue) {
			this._value = mValue;
			this._targetValue = mValue;
			this._counter = 1;
		}
	}, {
		key: '_checkLimit',
		value: function _checkLimit() {
			if (this._min !== undefined && this._targetValue < this._min) {
				this._targetValue = this._min;
			}

			if (this._max !== undefined && this._targetValue > this._max) {
				this._targetValue = this._max;
			}
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			_scheduling2.default.removeEF(this._efIndex);
		}

		//	GETTERS / SETTERS

	}, {
		key: 'value',
		set: function set(mValue) {
			this._startValue = this._value;
			this._targetValue = mValue;
			this._checkLimit();
			this._counter = 0;
		},
		get: function get() {
			if (this._needUpdate) {
				var f = getFunc(this.easing);
				var p = f(this._counter);
				this._value = this._startValue + p * (this._targetValue - this._startValue);
				this._needUpdate = false;
			}
			return this._value;
		}
	}, {
		key: 'targetValue',
		get: function get() {
			return this._targetValue;
		}
	}]);

	return TweenNumber;
}();

exports.default = TweenNumber;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// QuatRotation.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _glMatrix = __webpack_require__(2);

var _glMatrix2 = _interopRequireDefault(_glMatrix);

var _EaseNumber = __webpack_require__(19);

var _EaseNumber2 = _interopRequireDefault(_EaseNumber);

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getMouse = function getMouse(mEvent, mTarget) {

	var o = mTarget || {};
	if (mEvent.touches) {
		o.x = mEvent.touches[0].pageX;
		o.y = mEvent.touches[0].pageY;
	} else {
		o.x = mEvent.clientX;
		o.y = mEvent.clientY;
	}

	return o;
};

var QuatRotation = function () {
	function QuatRotation(mTarget) {
		var _this = this;

		var mListenerTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
		var mEasing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;

		_classCallCheck(this, QuatRotation);

		this._target = mTarget;
		this._listenerTarget = mListenerTarget;

		this.matrix = _glMatrix2.default.mat4.create();
		this.m = _glMatrix2.default.mat4.create();
		this._vZaxis = _glMatrix2.default.vec3.clone([0, 0, 0]);
		this._zAxis = _glMatrix2.default.vec3.clone([0, 0, 1]);
		this.preMouse = { x: 0, y: 0 };
		this.mouse = { x: 0, y: 0 };
		this._isMouseDown = false;
		this._rotation = _glMatrix2.default.quat.create();
		this.tempRotation = _glMatrix2.default.quat.create();
		this._rotateZMargin = 0;
		this._offset = 0.004;
		this._slerp = -1;
		this._isLocked = false;

		this._diffX = new _EaseNumber2.default(0, mEasing);
		this._diffY = new _EaseNumber2.default(0, mEasing);

		this._listenerTarget.addEventListener('mousedown', function (e) {
			return _this._onDown(e);
		});
		this._listenerTarget.addEventListener('touchstart', function (e) {
			return _this._onDown(e);
		});
		this._listenerTarget.addEventListener('mousemove', function (e) {
			return _this._onMove(e);
		});
		this._listenerTarget.addEventListener('touchmove', function (e) {
			return _this._onMove(e);
		});
		window.addEventListener('touchend', function () {
			return _this._onUp();
		});
		window.addEventListener('mouseup', function () {
			return _this._onUp();
		});

		_scheduling2.default.addEF(function () {
			return _this._loop();
		});
	}

	// 	PUBLIC METHODS

	_createClass(QuatRotation, [{
		key: 'inverseControl',
		value: function inverseControl() {
			var isInvert = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isInvert = isInvert;
		}
	}, {
		key: 'lock',
		value: function lock() {
			var mValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			this._isLocked = mValue;
		}
	}, {
		key: 'setCameraPos',
		value: function setCameraPos(mQuat) {
			var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;

			this.easing = speed;
			if (this._slerp > 0) {
				return;
			}

			var tempRotation = _glMatrix2.default.quat.clone(this._rotation);
			this._updateRotation(tempRotation);
			this._rotation = _glMatrix2.default.quat.clone(tempRotation);
			this._currDiffX = this.diffX = 0;
			this._currDiffY = this.diffY = 0;

			this._isMouseDown = false;
			this._isRotateZ = 0;

			this._targetQuat = _glMatrix2.default.quat.clone(mQuat);
			this._slerp = 1;
		}
	}, {
		key: 'resetQuat',
		value: function resetQuat() {
			this._rotation = _glMatrix2.default.quat.clone([0, 0, 1, 0]);
			this.tempRotation = _glMatrix2.default.quat.clone([0, 0, 0, 0]);
			this._targetQuat = undefined;
			this._slerp = -1;
		}

		//	EVENT HANDLER

	}, {
		key: '_onDown',
		value: function _onDown(mEvent) {
			if (this._isLocked) {
				return;
			}

			var mouse = getMouse(mEvent);
			var tempRotation = _glMatrix2.default.quat.clone(this._rotation);
			this._updateRotation(tempRotation);
			this._rotation = tempRotation;

			this._isMouseDown = true;
			this._isRotateZ = 0;
			this.preMouse = { x: mouse.x, y: mouse.y };

			if (mouse.y < this._rotateZMargin || mouse.y > window.innerHeight - this._rotateZMargin) {
				this._isRotateZ = 1;
			} else if (mouse.x < this._rotateZMargin || mouse.x > window.innerWidth - this._rotateZMargin) {
				this._isRotateZ = 2;
			}

			this._diffX.setTo(0);
			this._diffY.setTo(0);
		}
	}, {
		key: '_onMove',
		value: function _onMove(mEvent) {
			if (this._isLocked) {
				return;
			}
			getMouse(mEvent, this.mouse);
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			if (this._isLocked) {
				return;
			}
			this._isMouseDown = false;
		}

		//	PRIVATE METHODS

	}, {
		key: '_updateRotation',
		value: function _updateRotation(mTempRotation) {
			if (this._isMouseDown && !this._isLocked) {
				this._diffX.value = -(this.mouse.x - this.preMouse.x);
				this._diffY.value = this.mouse.y - this.preMouse.y;

				if (this._isInvert) {
					this._diffX.value = -this._diffX.targetValue;
					this._diffY.value = -this._diffY.targetValue;
				}
			}

			var angle = void 0,
			    _quat = void 0;

			if (this._isRotateZ > 0) {
				if (this._isRotateZ === 1) {
					angle = -this._diffX.value * this._offset;
					angle *= this.preMouse.y < this._rotateZMargin ? -1 : 1;
					_quat = _glMatrix2.default.quat.clone([0, 0, Math.sin(angle), Math.cos(angle)]);
					_glMatrix2.default.quat.multiply(_quat, mTempRotation, _quat);
				} else {
					angle = -this._diffY.value * this._offset;
					angle *= this.preMouse.x < this._rotateZMargin ? 1 : -1;
					_quat = _glMatrix2.default.quat.clone([0, 0, Math.sin(angle), Math.cos(angle)]);
					_glMatrix2.default.quat.multiply(_quat, mTempRotation, _quat);
				}
			} else {
				var v = _glMatrix2.default.vec3.clone([this._diffX.value, this._diffY.value, 0]);
				var axis = _glMatrix2.default.vec3.create();
				_glMatrix2.default.vec3.cross(axis, v, this._zAxis);
				_glMatrix2.default.vec3.normalize(axis, axis);
				angle = _glMatrix2.default.vec3.length(v) * this._offset;
				_quat = _glMatrix2.default.quat.clone([Math.sin(angle) * axis[0], Math.sin(angle) * axis[1], Math.sin(angle) * axis[2], Math.cos(angle)]);
				_glMatrix2.default.quat.multiply(mTempRotation, _quat, mTempRotation);
			}
		}
	}, {
		key: '_loop',
		value: function _loop() {
			_glMatrix2.default.mat4.identity(this.m);

			if (this._targetQuat === undefined) {
				_glMatrix2.default.quat.set(this.tempRotation, this._rotation[0], this._rotation[1], this._rotation[2], this._rotation[3]);
				this._updateRotation(this.tempRotation);
			} else {
				this._slerp += (0 - this._slerp) * 0.1;

				if (this._slerp < 0.0005) {
					_glMatrix2.default.quat.copy(this._rotation, this._targetQuat);
					_glMatrix2.default.quat.copy(this.tempRotation, this._targetQuat);
					this._targetQuat = undefined;
					this._diffX.setTo(0);
					this._diffY.setTo(0);
					this._slerp = -1;
				} else {
					_glMatrix2.default.quat.set(this.tempRotation, 0, 0, 0, 0);
					_glMatrix2.default.quat.slerp(this.tempRotation, this._targetQuat, this._rotation, this._slerp);
				}
			}

			_glMatrix2.default.vec3.transformQuat(this._vZaxis, this._vZaxis, this.tempRotation);

			_glMatrix2.default.mat4.fromQuat(this.matrix, this.tempRotation);
		}

		//	GETTER AND SETTER

	}, {
		key: 'easing',
		set: function set(mValue) {
			this._diffX.easing = mValue;
			this._diffY.easing = mValue;
		},
		get: function get() {
			return this._diffX.easing;
		}
	}]);

	return QuatRotation;
}();

exports.default = QuatRotation;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _EventDispatcher2 = __webpack_require__(35);

var _EventDispatcher3 = _interopRequireDefault(_EventDispatcher2);

var _Ray = __webpack_require__(20);

var _Ray2 = _interopRequireDefault(_Ray);

var _getMouse = __webpack_require__(69);

var _getMouse2 = _interopRequireDefault(_getMouse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // TouchDetector.js


function distance(a, b) {
	var dx = a.x - b.x;
	var dy = a.y - b.y;
	return Math.sqrt(dx * dx + dy * dy);
}

var TouchDetector = function (_EventDispatcher) {
	_inherits(TouchDetector, _EventDispatcher);

	function TouchDetector(mGeometry, mCamera) {
		var mSkipMoveCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
		var mListenerTarget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;

		_classCallCheck(this, TouchDetector);

		var _this = _possibleConstructorReturn(this, (TouchDetector.__proto__ || Object.getPrototypeOf(TouchDetector)).call(this));

		_this._geometry = mGeometry;
		_this._geometry.generateFaces();
		_this._camera = mCamera;
		_this.faceVertices = mGeometry.faces.map(function (face) {
			return face.vertices;
		});
		_this.clickTolerance = 8;

		_this._ray = new _Ray2.default([0, 0, 0], [0, 0, -1]);
		_this._hit = vec3.fromValues(-999, -999, -999);
		_this._lastPos;
		_this._firstPos;
		_this.mtxModel = mat4.create();

		_this._listenerTarget = mListenerTarget;
		_this._skippingMove = mSkipMoveCheck;

		_this._onMoveBind = function (e) {
			return _this._onMove(e);
		};
		_this._onDownBind = function (e) {
			return _this._onDown(e);
		};
		_this._onUpBind = function () {
			return _this._onUp();
		};

		_this.connect();
		return _this;
	}

	_createClass(TouchDetector, [{
		key: 'connect',
		value: function connect() {
			this._listenerTarget.addEventListener('mousedown', this._onDownBind);
			this._listenerTarget.addEventListener('mousemove', this._onMoveBind);
			this._listenerTarget.addEventListener('mouseup', this._onUpBind);
		}
	}, {
		key: 'disconnect',
		value: function disconnect() {
			this._listenerTarget.removeEventListener('mousedown', this._onDownBind);
			this._listenerTarget.removeEventListener('mousemove', this._onMoveBind);
			this._listenerTarget.removeEventListener('mouseup', this._onUpBind);
		}
	}, {
		key: '_checkHit',
		value: function _checkHit() {
			var _this2 = this;

			var mType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'onHit';

			var camera = this._camera;
			if (!camera) {
				return;
			}

			var mx = this._lastPos.x / _GLTool2.default.width * 2.0 - 1.0;
			var my = -(this._lastPos.y / _GLTool2.default.height) * 2.0 + 1.0;

			camera.generateRay([mx, my, 0], this._ray);

			var hit = void 0;
			var v0 = vec3.create();
			var v1 = vec3.create();
			var v2 = vec3.create();
			var dist = 0;

			var getVector = function getVector(v, target) {
				vec3.transformMat4(target, v, _this2.mtxModel);
			};

			for (var i = 0; i < this.faceVertices.length; i++) {
				var vertices = this.faceVertices[i];
				getVector(vertices[0], v0);
				getVector(vertices[1], v1);
				getVector(vertices[2], v2);
				var t = this._ray.intersectTriangle(v0, v1, v2);

				if (t) {
					if (hit) {
						var distToCam = vec3.dist(t, camera.position);
						if (distToCam < dist) {
							hit = vec3.clone(t);
							dist = distToCam;
						}
					} else {
						hit = vec3.clone(t);
						dist = vec3.dist(hit, camera.position);
					}
				}
			}

			if (hit) {
				this._hit = vec3.clone(hit);
				this.dispatchCustomEvent(mType, { hit: hit });
			} else {
				this.dispatchCustomEvent('onUp');
			}
		}
	}, {
		key: '_onDown',
		value: function _onDown(e) {
			this._firstPos = (0, _getMouse2.default)(e);
			this._lastPos = (0, _getMouse2.default)(e);
			this._checkHit('onDown');
		}
	}, {
		key: '_onMove',
		value: function _onMove(e) {
			this._lastPos = (0, _getMouse2.default)(e);
			if (!this._skippingMove) {
				this._checkHit();
			}
		}
	}, {
		key: '_onUp',
		value: function _onUp() {
			var dist = distance(this._firstPos, this._lastPos);
			if (dist < this.clickTolerance) {
				this._checkHit();
			}
		}
	}]);

	return TouchDetector;
}(_EventDispatcher3.default);

exports.default = TouchDetector;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (e) {
	var x = void 0,
	    y = void 0;

	if (e.touches) {
		x = e.touches[0].pageX;
		y = e.touches[0].pageY;
	} else {
		x = e.clientX;
		y = e.clientY;
	}

	return {
		x: x, y: y
	};
};

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = "#define SHADER_NAME gltf_vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\n\n#ifdef HAS_UV\nattribute vec2 aTextureCoord;\n#endif\n\n#ifdef HAS_NORMALS\nattribute vec3 aNormal;\n#endif\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\nuniform mat3 uModelViewMatrixInverse;\n\n\nvarying vec3 vPosition;\nvarying vec2 vTextureCoord;\n\n#ifdef HAS_NORMALS\nvarying vec3 vNormal;\n#endif\n\n\nvoid main(void) {\n\tvec4 position = uModelMatrix * vec4(aVertexPosition, 1.0);\n\tvPosition     = position.xyz / position.w;\n\t\n\t#ifdef HAS_UV\n\tvTextureCoord = vec2(aTextureCoord.x, 1.0 - aTextureCoord.y);\n\t#else\n\tvTextureCoord = vec2(0.,0.);\n\t#endif\n\n\t#ifdef HAS_NORMALS\n\tvNormal       = normalize(vec3(uModelMatrix * vec4(aNormal, 0.0)));\n\t#endif\n\t\n\tgl_Position   = uProjectionMatrix * uViewMatrix * position;\n}\n"

/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = "#define SHADER_NAME gltf_frag\n\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D \tuBRDFMap;\nuniform samplerCube uRadianceMap;\nuniform samplerCube uIrradianceMap;\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D uColorMap;\n#endif\n\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D uMetallicRoughnessMap;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D uAoMap;\nuniform float uOcclusionStrength;\n#endif\n\n#ifdef HAS_NORMALMAP\nuniform sampler2D uNormalMap;\nuniform float uNormalScale;\n#endif\n\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D uEmissiveMap;\nuniform vec3 uEmissiveFactor;\n#endif\n\nuniform vec3 uLightDirection;\nuniform vec3 uLightColor;\nuniform vec3 uCameraPos;\n\nuniform vec4 uScaleDiffBaseMR;\nuniform vec4 uScaleFGDSpec;\nuniform vec4 uScaleIBLAmbient;\n\nuniform vec3 uBaseColor;\nuniform float uRoughness;\nuniform float uMetallic;\nuniform float uGamma;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vPosition;\n\n#ifdef HAS_NORMALS\nvarying vec3 vNormal;\n#endif\n\n\n//\tFrom GLTF WebGL PBR :\n//\thttps://github.com/KhronosGroup/glTF-WebGL-PBR\n\n// Encapsulate the various inputs used by the various functions in the shading equation\n// We store values in this struct to simplify the integration of alternative implementations\n// of the shading terms, outlined in the Readme.MD Appendix.\nstruct PBRInfo\n{\n\tfloat NdotL;                  // cos angle between normal and light direction\n\tfloat NdotV;                  // cos angle between normal and view direction\n\tfloat NdotH;                  // cos angle between normal and half vector\n\tfloat LdotH;                  // cos angle between light direction and half vector\n\tfloat VdotH;                  // cos angle between view direction and half vector\n\tfloat perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)\n\tfloat metalness;              // metallic value at the surface\n\tvec3 reflectance0;            // full reflectance color (normal incidence angle)\n\tvec3 reflectance90;           // reflectance color at grazing angle\n\tfloat alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])\n\tvec3 diffuseColor;            // color contribution from diffuse lighting\n\tvec3 specularColor;           // color contribution from specular lighting\n};\n\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n\t#ifdef MANUAL_SRGB\n\t#ifdef SRGB_FAST_APPROXIMATION\n\tvec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n\t#else //SRGB_FAST_APPROXIMATION\n\tvec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n\tvec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n\t#endif //SRGB_FAST_APPROXIMATION\n\treturn vec4(linOut,srgbIn.w);;\n\t#else //MANUAL_SRGB\n\treturn srgbIn;\n\t#endif //MANUAL_SRGB\n}\n\n\nvec3 getNormal() {\n\tvec3 pos_dx = dFdx(vPosition);\n\tvec3 pos_dy = dFdy(vPosition);\n\tvec3 tex_dx = dFdx(vec3(vTextureCoord, 0.0));\n\tvec3 tex_dy = dFdy(vec3(vTextureCoord, 0.0));\n\tvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n\t\n#ifdef HAS_NORMALS\n\tvec3 ng = normalize(vNormal);\n#else\n\tvec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n\tt = normalize(t - ng * dot(ng, t));\n\tvec3 b = normalize(cross(ng, t));\n\tmat3 tbn = mat3(t, b, ng);\n\n#ifdef HAS_NORMALMAP\n\tvec3 n = texture2D(uNormalMap, vTextureCoord).rgb;\n\tn = normalize(tbn * ((2.0 * n - 1.0) * vec3(uNormalScale, uNormalScale, 1.0)));\n#else\n\t// The tbn matrix is linearly interpolated, so we need to re-normalize\n\tvec3 n = normalize(tbn[2].xyz);\n#endif\n\n\treturn n;\n}\n\n\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n\tfloat mipCount = 7.0; // resolution of 512x512\n\tfloat lod = (pbrInputs.perceptualRoughness * mipCount);\n\t// retrieve a scale and bias to F0. See [1], Figure 3\n\tvec3 brdf = SRGBtoLINEAR(texture2D(uBRDFMap, vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n\tvec3 diffuseLight = SRGBtoLINEAR(textureCube(uIrradianceMap, n)).rgb;\n\n\tvec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(uRadianceMap, reflection, lod)).rgb;\n\n\tvec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n\tvec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n\n\t// For presentation, this allows us to disable IBL terms\n\tdiffuse *= uScaleIBLAmbient.x;\n\tspecular *= uScaleIBLAmbient.y;\n\n\treturn diffuse + specular;\n}\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.diffuseColor / M_PI;\n}\n\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n\treturn pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n\tfloat NdotL = pbrInputs.NdotL;\n\tfloat NdotV = pbrInputs.NdotV;\n\tfloat r = pbrInputs.alphaRoughness;\n\n\tfloat attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n\tfloat attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n\treturn attenuationL * attenuationV;\n}\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n\tfloat roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n\tfloat f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n\treturn roughnessSq / (M_PI * f * f);\n}\n\nvoid main() {\n\n\tfloat perceptualRoughness   = uRoughness;\n\tfloat metallic              = uMetallic;\n#ifdef HAS_METALROUGHNESSMAP\n\t// Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.\n\t// This layout intentionally reserves the 'r' channel for (optional) occlusion map data\n\tvec4 mrSample = texture2D(uMetallicRoughnessMap, vTextureCoord);\n\tperceptualRoughness = mrSample.g * perceptualRoughness;\n\tmetallic = mrSample.b * metallic;\n#endif\t\n\tperceptualRoughness         = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n\tmetallic                    = clamp(metallic, 0.0, 1.0);\n\tfloat alphaRoughness        = perceptualRoughness * perceptualRoughness;\n\n#ifdef HAS_BASECOLORMAP\t\n\tvec4 baseColor = SRGBtoLINEAR(texture2D(uColorMap, vTextureCoord));\n#else\n\tvec4 baseColor              = vec4(uBaseColor, 1.0);\n#endif\t\n\t\n\tvec3 f0                     = vec3(0.04);\n\tvec3 diffuseColor           = baseColor.rgb * (vec3(1.0) - f0);\n\tdiffuseColor                *= 1.0 - metallic;\n\tvec3 specularColor          = mix(f0, baseColor.rgb, metallic);\n\t\n\t// Compute reflectance.\n\tfloat reflectance           = max(max(specularColor.r, specularColor.g), specularColor.b);\n\t\n\t// For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.\n\t// For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.\n\tfloat reflectance90         = clamp(reflectance * 25.0, 0.0, 1.0);\n\tvec3 specularEnvironmentR0  = specularColor.rgb;\n\tvec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\t\n\tvec3 n                      = getNormal();                             // normal at surface point\n\tvec3 v                      = normalize(uCameraPos - vPosition);        // Vector from surface point to camera\n\tvec3 l                      = normalize(uLightDirection);             // Vector from surface point to light\n\tvec3 h                      = normalize(l+v);                          // Half vector between both l and v\n\tvec3 reflection             = -normalize(reflect(v, n));\n\t\n\tfloat NdotL                 = clamp(dot(n, l), 0.001, 1.0);\n\tfloat NdotV                 = abs(dot(n, v)) + 0.001;\n\tfloat NdotH                 = clamp(dot(n, h), 0.0, 1.0);\n\tfloat LdotH                 = clamp(dot(l, h), 0.0, 1.0);\n\tfloat VdotH                 = clamp(dot(v, h), 0.0, 1.0);\n\n\tPBRInfo pbrInputs = PBRInfo(\n\t\tNdotL,\n\t\tNdotV,\n\t\tNdotH,\n\t\tLdotH,\n\t\tVdotH,\n\t\tperceptualRoughness,\n\t\tmetallic,\n\t\tspecularEnvironmentR0,\n\t\tspecularEnvironmentR90,\n\t\talphaRoughness,\n\t\tdiffuseColor,\n\t\tspecularColor\n\t);\n\n\t// Calculate the shading terms for the microfacet specular shading model\n\tvec3 F              = specularReflection(pbrInputs);\n\tfloat G             = geometricOcclusion(pbrInputs);\n\tfloat D             = microfacetDistribution(pbrInputs);\n\t\n\t// Calculation of analytical lighting contribution\n\tvec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n\tvec3 specContrib    = F * G * D / (4.0 * NdotL * NdotV);\n\t// Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)\n\tvec3 color          = NdotL * uLightColor * (diffuseContrib + specContrib);\n\t\n#ifdef USE_IBL\n\tcolor += getIBLContribution(pbrInputs, n, reflection);\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\t\n\tfloat ao            = texture2D(uAoMap, vTextureCoord).r;\n\tcolor               = mix(color, color * ao, uOcclusionStrength);\n#endif\t\n\n#ifdef HAS_EMISSIVEMAP\n\tvec3 emissive = SRGBtoLINEAR(texture2D(uEmissiveMap, vTextureCoord)).rgb * uEmissiveFactor;\n\tcolor += emissive;\n#endif\n\t\n\t// This section uses mix to override final color for reference app visualization\n\t// of various parameters in the lighting equation.\n\tcolor               = mix(color, F, uScaleFGDSpec.x);\n\tcolor               = mix(color, vec3(G), uScaleFGDSpec.y);\n\tcolor               = mix(color, vec3(D), uScaleFGDSpec.z);\n\tcolor               = mix(color, specContrib, uScaleFGDSpec.w);\n\t\n\tcolor               = mix(color, diffuseContrib, uScaleDiffBaseMR.x);\n\tcolor               = mix(color, baseColor.rgb, uScaleDiffBaseMR.y);\n\tcolor               = mix(color, vec3(metallic), uScaleDiffBaseMR.z);\n\tcolor               = mix(color, vec3(perceptualRoughness), uScaleDiffBaseMR.w);\n\t\n\t// output the fragment color\n\tgl_FragColor        = vec4(pow(color,vec3(1.0/uGamma)), baseColor.a);\n\t// gl_FragColor        = vec4(vec3(metallic), 1.0);\n\n}"

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = "// debug.frag\n\n#define SHADER_NAME debug_frag\n#extension GL_EXT_shader_texture_lod: enable\n#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec3 uEmissiveFactor;\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D uColorMap;\n#endif\n\n#ifdef HAS_NORMALMAP\nuniform sampler2D uNormalMap;\nuniform float uNormalScale;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D uAoMap;\nuniform float uOcclusionStrength;\n#endif\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\n\nvec3 getNormal() {\n\tvec3 pos_dx = dFdx(vPosition);\n\tvec3 pos_dy = dFdy(vPosition);\n\tvec3 tex_dx = dFdx(vec3(vTextureCoord, 0.0));\n\tvec3 tex_dy = dFdy(vec3(vTextureCoord, 0.0));\n\tvec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n\tvec3 ng = normalize(vNormal);\n\n\tt = normalize(t - ng * dot(ng, t));\n\tvec3 b = normalize(cross(ng, t));\n\tmat3 tbn = mat3(t, b, ng);\n\n#ifdef HAS_NORMALMAP\n\tvec3 n = texture2D(uNormalMap, vTextureCoord).rgb;\n\tn = normalize(tbn * ((2.0 * n - 1.0) * vec3(uNormalScale, uNormalScale, 1.0)));\n#else\n\t// The tbn matrix is linearly interpolated, so we need to re-normalize\n\tvec3 n = normalize(tbn[2].xyz);\n#endif\n\n\treturn n;\n}\n\n\nvoid main(void) {\n    // gl_FragColor = vec4(vNormal * .5 + .5, 1.0);\n\n    vec3 color = getNormal() * .5 + .5;\n\n#ifdef HAS_BASECOLORMAP\n\tcolor = texture2D(uColorMap, vTextureCoord).rgb;\n#endif\n\n#ifdef HAS_OCCLUSIONMAP\t\n\tfloat ao            = texture2D(uAoMap, vTextureCoord).r;\n\tcolor               = mix(color, color * ao, uOcclusionStrength);\n#endif\t\n\n    gl_FragColor = vec4(color, 1.0);\n}"

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// CameraCube.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _CameraPerspective2 = __webpack_require__(25);

var _CameraPerspective3 = _interopRequireDefault(_CameraPerspective2);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CAMERA_SETTINGS = [[_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(1, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(-1, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 1, 0), _glMatrix.vec3.fromValues(0, 0, 1)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, -1, 0), _glMatrix.vec3.fromValues(0, 0, -1)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 0, 1), _glMatrix.vec3.fromValues(0, -1, 0)], [_glMatrix.vec3.fromValues(0, 0, 0), _glMatrix.vec3.fromValues(0, 0, -1), _glMatrix.vec3.fromValues(0, -1, 0)]];

var CameraCube = function (_CameraPerspective) {
	_inherits(CameraCube, _CameraPerspective);

	function CameraCube() {
		_classCallCheck(this, CameraCube);

		var _this = _possibleConstructorReturn(this, (CameraCube.__proto__ || Object.getPrototypeOf(CameraCube)).call(this));

		_this.setPerspective(Math.PI / 2, 1, 0.1, 1000);
		return _this;
	}

	_createClass(CameraCube, [{
		key: 'face',
		value: function face(mIndex) {
			var o = CAMERA_SETTINGS[mIndex];
			this.lookAt(o[0], o[1], o[2]);
		}
	}]);

	return CameraCube;
}(_CameraPerspective3.default);

exports.default = CameraCube;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ObjLoader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _BinaryLoader2 = __webpack_require__(26);

var _BinaryLoader3 = _interopRequireDefault(_BinaryLoader2);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ObjLoader = function (_BinaryLoader) {
	_inherits(ObjLoader, _BinaryLoader);

	function ObjLoader() {
		_classCallCheck(this, ObjLoader);

		return _possibleConstructorReturn(this, (ObjLoader.__proto__ || Object.getPrototypeOf(ObjLoader)).apply(this, arguments));
	}

	_createClass(ObjLoader, [{
		key: 'load',
		value: function load(url, callback) {
			var drawType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;

			this._drawType = drawType;
			_get(ObjLoader.prototype.__proto__ || Object.getPrototypeOf(ObjLoader.prototype), 'load', this).call(this, url, callback);
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			this.parseObj(this._req.response);
		}
	}, {
		key: 'parseObj',
		value: function parseObj(objStr) {
			var lines = objStr.split('\n');

			var positions = [];
			var coords = [];
			var finalNormals = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];
			var count = 0;
			var result = void 0;

			// v float float float
			var vertexPattern = /v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// vn float float float
			var normalPattern = /vn( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// vt float float
			var uvPattern = /vt( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

			// f vertex vertex vertex ...
			var facePattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/;

			// f vertex/uv vertex/uv vertex/uv ...
			var facePattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/;

			// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...
			var facePattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/;

			// f vertex//normal vertex//normal vertex//normal ... 
			var facePattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/;

			function parseVertexIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + vertices.length / 3) * 3;
			}

			function parseNormalIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + normals.length / 3) * 3;
			}

			function parseUVIndex(value) {
				var index = parseInt(value);
				return (index >= 0 ? index - 1 : index + uvs.length / 2) * 2;
			}

			function addVertex(a, b, c) {
				positions.push([vertices[a], vertices[a + 1], vertices[a + 2]]);
				positions.push([vertices[b], vertices[b + 1], vertices[b + 2]]);
				positions.push([vertices[c], vertices[c + 1], vertices[c + 2]]);

				indices.push(count * 3 + 0);
				indices.push(count * 3 + 1);
				indices.push(count * 3 + 2);

				count++;
			}

			function addUV(a, b, c) {
				coords.push([uvs[a], uvs[a + 1]]);
				coords.push([uvs[b], uvs[b + 1]]);
				coords.push([uvs[c], uvs[c + 1]]);
			}

			function addNormal(a, b, c) {
				finalNormals.push([normals[a], normals[a + 1], normals[a + 2]]);
				finalNormals.push([normals[b], normals[b + 1], normals[b + 2]]);
				finalNormals.push([normals[c], normals[c + 1], normals[c + 2]]);
			}

			function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {
				var ia = parseVertexIndex(a);
				var ib = parseVertexIndex(b);
				var ic = parseVertexIndex(c);
				var id = void 0;

				if (d === undefined) {

					addVertex(ia, ib, ic);
				} else {

					id = parseVertexIndex(d);

					addVertex(ia, ib, id);
					addVertex(ib, ic, id);
				}

				if (ua !== undefined) {

					ia = parseUVIndex(ua);
					ib = parseUVIndex(ub);
					ic = parseUVIndex(uc);

					if (d === undefined) {

						addUV(ia, ib, ic);
					} else {

						id = parseUVIndex(ud);

						addUV(ia, ib, id);
						addUV(ib, ic, id);
					}
				}

				if (na !== undefined) {

					ia = parseNormalIndex(na);
					ib = parseNormalIndex(nb);
					ic = parseNormalIndex(nc);

					if (d === undefined) {

						addNormal(ia, ib, ic);
					} else {

						id = parseNormalIndex(nd);

						addNormal(ia, ib, id);
						addNormal(ib, ic, id);
					}
				}
			}

			for (var i = 0; i < lines.length; i++) {
				var line = lines[i];
				line = line.trim();

				if (line.length === 0 || line.charAt(0) === '#') {

					continue;
				} else if ((result = vertexPattern.exec(line)) !== null) {

					vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
				} else if ((result = normalPattern.exec(line)) !== null) {

					normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));
				} else if ((result = uvPattern.exec(line)) !== null) {

					uvs.push(parseFloat(result[1]), parseFloat(result[2]));
				} else if ((result = facePattern1.exec(line)) !== null) {

					addFace(result[1], result[2], result[3], result[4]);
				} else if ((result = facePattern2.exec(line)) !== null) {

					addFace(result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);
				} else if ((result = facePattern3.exec(line)) !== null) {
					addFace(result[2], result[6], result[10], result[14], result[3], result[7], result[11], result[15], result[4], result[8], result[12], result[16]);
				} else if ((result = facePattern4.exec(line)) !== null) {
					addFace(result[2], result[5], result[8], result[11], undefined, undefined, undefined, undefined, result[3], result[6], result[9], result[12]);
				}
			}

			return this._generateGeometry({
				positions: positions,
				coords: coords,
				normals: finalNormals,
				indices: indices
			});
		}
	}, {
		key: '_generateGeometry',
		value: function _generateGeometry(o) {
			var maxNumVertices = 65535;
			var hasNormals = o.normals.length > 0;
			var hasUVs = o.coords.length > 0;
			var geometry = void 0;

			if (o.positions.length > maxNumVertices) {
				var geometries = [];
				var lastIndex = 0;

				var oCopy = {};
				oCopy.positions = o.positions.concat();
				oCopy.coords = o.coords.concat();
				oCopy.indices = o.indices.concat();
				oCopy.normals = o.normals.concat();

				while (o.indices.length > 0) {

					var sliceNum = Math.min(maxNumVertices, o.positions.length);
					var indices = o.indices.splice(0, sliceNum);
					var positions = [];
					var coords = [];
					var normals = [];
					var index = void 0,
					    tmpIndex = 0;

					for (var i = 0; i < indices.length; i++) {
						if (indices[i] > tmpIndex) {
							tmpIndex = indices[i];
						}

						index = indices[i];

						positions.push(oCopy.positions[index]);
						if (hasUVs) {
							coords.push(oCopy.coords[index]);
						}
						if (hasNormals) {
							normals.push(oCopy.normals[index]);
						}

						indices[i] -= lastIndex;
					}

					lastIndex = tmpIndex + 1;

					geometry = new _Geometry2.default(this._drawType);
					geometry.bufferVertex(positions);
					if (hasUVs) {
						geometry.bufferTexCoord(coords);
					}

					geometry.bufferIndex(indices);
					if (hasNormals) {
						geometry.bufferNormal(normals);
					}

					geometries.push(geometry);
				}

				if (this._callback) {
					this._callback(geometries, oCopy);
				}

				return geometries;
			} else {
				geometry = new _Geometry2.default(this._drawType);
				geometry.bufferVertex(o.positions);
				if (hasUVs) {
					geometry.bufferTexCoord(o.coords);
				}
				geometry.bufferIndex(o.indices);
				if (hasNormals) {
					geometry.bufferNormal(o.normals);
				}

				if (this._callback) {
					this._callback(geometry, o);
				}

				return geometry;
			}

			return null;
		}
	}]);

	return ObjLoader;
}(_BinaryLoader3.default);

ObjLoader.parse = function (objStr) {
	var loader = new ObjLoader();
	return loader.parseObj(objStr);
};

exports.default = ObjLoader;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HDRLoader.js



Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _BinaryLoader2 = __webpack_require__(26);

var _BinaryLoader3 = _interopRequireDefault(_BinaryLoader2);

var _HDRParser = __webpack_require__(76);

var _HDRParser2 = _interopRequireDefault(_HDRParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HDRLoader = function (_BinaryLoader) {
	_inherits(HDRLoader, _BinaryLoader);

	function HDRLoader() {
		_classCallCheck(this, HDRLoader);

		return _possibleConstructorReturn(this, (HDRLoader.__proto__ || Object.getPrototypeOf(HDRLoader)).call(this, true));
	}

	_createClass(HDRLoader, [{
		key: 'parse',
		value: function parse(mArrayBuffer) {
			return (0, _HDRParser2.default)(mArrayBuffer);
		}
	}, {
		key: '_onLoaded',
		value: function _onLoaded() {
			var o = this.parse(this._req.response);
			if (this._callback) {
				this._callback(o);
			}
		}
	}]);

	return HDRLoader;
}(_BinaryLoader3.default);

HDRLoader.parse = function (mArrayBuffer) {
	return (0, _HDRParser2.default)(mArrayBuffer);
};

exports.default = HDRLoader;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HDRParser.js



// Code ported by Marcin Ignac (2014)
// Based on Java implementation from
// https://code.google.com/r/cys12345-research/source/browse/hdr/image_processor/RGBE.java?r=7d84e9fd866b24079dbe61fa0a966ce8365f5726

Object.defineProperty(exports, "__esModule", {
	value: true
});
var radiancePattern = '#\\?RADIANCE';
var commentPattern = '#.*';
// let gammaPattern = 'GAMMA=';
var exposurePattern = 'EXPOSURE=\\s*([0-9]*[.][0-9]*)';
var formatPattern = 'FORMAT=32-bit_rle_rgbe';
var widthHeightPattern = '-Y ([0-9]+) \\+X ([0-9]+)';

// http://croquetweak.blogspot.co.uk/2014/08/deconstructing-floats-frexp-and-ldexp.html
// function ldexp(mantissa, exponent) {
//     return exponent > 1023 ? mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023) : exponent < -1074 ? mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074) : mantissa * Math.pow(2, exponent);
// }

function readPixelsRawRLE(buffer, data, offset, fileOffset, scanlineWidth, numScanlines) {
	var rgbe = new Array(4);
	var scanlineBuffer = null;
	var ptr = void 0;
	var ptrEnd = void 0;
	var count = void 0;
	var buf = new Array(2);
	var bufferLength = buffer.length;

	function readBuf(buf) {
		var bytesRead = 0;
		do {
			buf[bytesRead++] = buffer[fileOffset];
		} while (++fileOffset < bufferLength && bytesRead < buf.length);
		return bytesRead;
	}

	function readBufOffset(buf, offset, length) {
		var bytesRead = 0;
		do {
			buf[offset + bytesRead++] = buffer[fileOffset];
		} while (++fileOffset < bufferLength && bytesRead < length);
		return bytesRead;
	}

	function readPixelsRaw(buffer, data, offset, numpixels) {
		var numExpected = 4 * numpixels;
		var numRead = readBufOffset(data, offset, numExpected);
		if (numRead < numExpected) {
			throw new Error('Error reading raw pixels: got ' + numRead + ' bytes, expected ' + numExpected);
		}
	}

	while (numScanlines > 0) {
		if (readBuf(rgbe) < rgbe.length) {
			throw new Error('Error reading bytes: expected ' + rgbe.length);
		}

		if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
			// this file is not run length encoded
			data[offset++] = rgbe[0];
			data[offset++] = rgbe[1];
			data[offset++] = rgbe[2];
			data[offset++] = rgbe[3];
			readPixelsRaw(buffer, data, offset, scanlineWidth * numScanlines - 1);
			return;
		}

		if (((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) !== scanlineWidth) {
			throw new Error('Wrong scanline width ' + ((rgbe[2] & 0xFF) << 8 | rgbe[3] & 0xFF) + ', expected ' + scanlineWidth);
		}

		if (scanlineBuffer === null) {
			scanlineBuffer = new Array(4 * scanlineWidth);
		}

		ptr = 0;
		/* read each of the four channels for the scanline into the buffer */
		for (var i = 0; i < 4; i++) {
			ptrEnd = (i + 1) * scanlineWidth;
			while (ptr < ptrEnd) {
				if (readBuf(buf) < buf.length) {
					throw new Error('Error reading 2-byte buffer');
				}
				if ((buf[0] & 0xFF) > 128) {
					/* a run of the same value */
					count = (buf[0] & 0xFF) - 128;
					if (count === 0 || count > ptrEnd - ptr) {
						throw new Error('Bad scanline data');
					}
					while (count-- > 0) {
						scanlineBuffer[ptr++] = buf[1];
					}
				} else {
					/* a non-run */
					count = buf[0] & 0xFF;
					if (count === 0 || count > ptrEnd - ptr) {
						throw new Error('Bad scanline data');
					}
					scanlineBuffer[ptr++] = buf[1];
					if (--count > 0) {
						if (readBufOffset(scanlineBuffer, ptr, count) < count) {
							throw new Error('Error reading non-run data');
						}
						ptr += count;
					}
				}
			}
		}

		/* copy byte data to output */
		for (var _i = 0; _i < scanlineWidth; _i++) {
			data[offset + 0] = scanlineBuffer[_i];
			data[offset + 1] = scanlineBuffer[_i + scanlineWidth];
			data[offset + 2] = scanlineBuffer[_i + 2 * scanlineWidth];
			data[offset + 3] = scanlineBuffer[_i + 3 * scanlineWidth];
			offset += 4;
		}

		numScanlines--;
	}
}

// Returns data as floats and flipped along Y by default
function parseHdr(buffer) {
	if (buffer instanceof ArrayBuffer) {
		buffer = new Uint8Array(buffer);
	}

	var fileOffset = 0;
	var bufferLength = buffer.length;

	var NEW_LINE = 10;

	function readLine() {
		var buf = '';
		do {
			var b = buffer[fileOffset];
			if (b === NEW_LINE) {
				++fileOffset;
				break;
			}
			buf += String.fromCharCode(b);
		} while (++fileOffset < bufferLength);
		return buf;
	}

	var width = 0;
	var height = 0;
	var exposure = 1;
	var gamma = 1;
	var rle = false;

	for (var i = 0; i < 20; i++) {
		var line = readLine();
		var match = void 0;
		if (match = line.match(radiancePattern)) {} else if (match = line.match(formatPattern)) {
			rle = true;
		} else if (match = line.match(exposurePattern)) {
			exposure = Number(match[1]);
		} else if (match = line.match(commentPattern)) {} else if (match = line.match(widthHeightPattern)) {
			height = Number(match[1]);
			width = Number(match[2]);
			break;
		}
	}

	if (!rle) {
		throw new Error('File is not run length encoded!');
	}

	var data = new Uint8Array(width * height * 4);
	var scanlineWidth = width;
	var numScanlines = height;

	readPixelsRawRLE(buffer, data, 0, fileOffset, scanlineWidth, numScanlines);

	// TODO: Should be Float16
	var floatData = new Float32Array(width * height * 4);
	for (var offset = 0; offset < data.length; offset += 4) {
		var r = data[offset + 0] / 255;
		var g = data[offset + 1] / 255;
		var b = data[offset + 2] / 255;
		var e = data[offset + 3];
		var f = Math.pow(2.0, e - 128.0);

		r *= f;
		g *= f;
		b *= f;

		var floatOffset = offset;

		floatData[floatOffset + 0] = r;
		floatData[floatOffset + 1] = g;
		floatData[floatOffset + 2] = b;
		floatData[floatOffset + 3] = 1.0;
	}

	return {
		shape: [width, height],
		exposure: exposure,
		gamma: gamma,
		data: floatData
	};
}

exports.default = parseHdr;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _colladaParser = __webpack_require__(78);

var _colladaParser2 = _interopRequireDefault(_colladaParser);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ColladaParser.js

var generateGeometry = function generateGeometry(meshes) {
	var caches = {};

	meshes.forEach(function (mesh) {
		var _mesh$mesh = mesh.mesh,
		    vertices = _mesh$mesh.vertices,
		    normals = _mesh$mesh.normals,
		    coords = _mesh$mesh.coords,
		    triangles = _mesh$mesh.triangles,
		    name = _mesh$mesh.name;

		if (!caches[name]) {
			var glGeometry = new _Geometry2.default().bufferFlattenData(vertices, 'aVertexPosition', 3).bufferFlattenData(coords, 'aTextureCoord', 2).bufferFlattenData(normals, 'aNormal', 3).bufferIndex(triangles);

			caches[name] = glGeometry;
		}

		mesh.glGeometry = caches[name];
	});
};

var parse = function parse(mData) {
	var meshes = _colladaParser2.default.parse(mData);
	generateGeometry(meshes);

	return meshes;
};

var load = function load(mPath, mCallback) {
	_colladaParser2.default.load(mPath, function (meshes) {
		generateGeometry(meshes);
		mCallback(meshes);
	});
};

var ColladaParser = {
	parse: parse,
	load: load
};

exports.default = ColladaParser;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Collada = __webpack_require__(79);

var _Collada2 = _interopRequireDefault(_Collada);

var _glMatrix = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ColladaParser.js

var parseData = function parseData(mData) {
	var materials = mData.materials,
	    meshes = mData.meshes;


	var finalMeshes = [];
	var meshObjs = [];
	var allMeshes = [];

	//	getting all meshes' buffers
	for (var s in meshes) {
		var oMesh = meshes[s];
		var vertices = oMesh.vertices,
		    normals = oMesh.normals,
		    coords = oMesh.coords,
		    triangles = oMesh.triangles;

		var buffers = {
			vertices: vertices, normals: normals, coords: coords, triangles: triangles
		};
		allMeshes.push({
			id: s,
			buffers: buffers
		});
	}

	function getMaterial(id) {
		var mat = void 0;
		for (var _s in materials) {
			if (_s === id) {
				mat = materials[_s];
			}
		}

		var oMaterial = {};
		if (mat.diffuse) {
			oMaterial.diffuseColor = mat.diffuse;
		}

		oMaterial.diffuseColor = mat.diffuse || [0, 0, 0];
		oMaterial.shininess = mat.shininess || 0;
		if (mat.textures) {
			if (mat.textures.diffuse) {
				oMaterial.diffuseMapID = mat.textures.diffuse.map_id;
			}

			if (mat.textures.normal) {
				oMaterial.normalMapID = mat.textures.normal.map_id;
			}
		}

		return oMaterial;
	}

	function walk(node, mtxParent) {
		var m = _glMatrix.mat4.create();
		if (node.model) {
			_glMatrix.mat4.multiply(m, mtxParent, node.model);
		} else {
			_glMatrix.mat4.copy(m, mtxParent);
		}

		if (node.children.length > 0) {
			node.children.forEach(function (child) {
				walk(child, m);
			});
		}

		if (node.mesh) {
			var _oMesh = {};
			_oMesh.modelMatrix = m;
			_oMesh.mesh = meshes[node.mesh];
			_oMesh.id = node.id;
			_oMesh.name = node.name;
			_oMesh.material = getMaterial(node.material);
			meshObjs.push(_oMesh);
		}
	}

	var mtx = _glMatrix.mat4.create();
	walk(mData.root, mtx);

	return meshObjs;
};

var parse = function parse(mFile) {
	var o = _Collada2.default.parse(mFile);
	return parseData(o);
};

var load = function load(mPath, mCallBack) {
	_Collada2.default.load(mPath, function (mData) {
		mCallBack(parseData(mData));
	});
};

var ColladaParser = {
	load: load,
	parse: parse
};

exports.default = ColladaParser;
module.exports = exports['default'];
//# sourceMappingURL=ColladaParser.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _glMatrix = __webpack_require__(2);

var isWorker = global.document === undefined; // Collada.js

var DEG2RAD = Math.PI * 2 / 360;

//global temporal variables
var temp_mat4 = null;
var temp_vec2 = null;
var temp_vec3 = null;
var temp_vec4 = null;
var temp_quat = null;

function request(url, callback) {
	var req = new XMLHttpRequest();
	req.onload = function () {
		var response = this.response;
		if (this.status != 200) return;
		if (callback) callback(this.response);
	};
	req.open("get", url, true);
	req.send();
}

var Collada = {

	libsPath: "./",
	workerPath: "./",
	no_flip: true,
	use_transferables: true, //for workers
	onerror: null,
	verbose: false,
	config: { forceParser: false },

	init: function init(config) {
		config = config || {};
		for (var i in config) {
			this[i] = config[i];
		}this.config = config;

		if (isWorker) {
			try {
				importScripts(this.libsPath + "gl-matrix-min.js", this.libsPath + "tinyxml.js");
			} catch (err) {
				Collada.throwException(Collada.LIBMISSING_ERROR);
			}
		}

		//init glMatrix
		temp_mat4 = _glMatrix.mat4.create();
		temp_vec2 = vec3.create();
		temp_vec3 = vec3.create();
		temp_vec4 = vec3.create();
		temp_quat = _glMatrix.quat.create();

		if (isWorker) console.log("Collada worker ready");
	},

	load: function load(url, callback) {
		request(url, function (data) {
			if (!data) callback(null);else callback(Collada.parse(data));
		});
	},

	_xmlroot: null,
	_nodes_by_id: null,
	_transferables: null,
	_controllers_found: null,
	_geometries_found: null,

	safeString: function safeString(str) {
		if (!str) return "";

		if (this.convertID) return this.convertID(str);

		return str.replace(/ /g, "_");
	},

	LIBMISSING_ERROR: "Libraries loading error, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath",
	NOXMLPARSER_ERROR: "TinyXML not found, when using workers remember to pass the URL to the tinyxml.js in the options.libsPath (Workers do not allow to access the native XML DOMParser)",
	throwException: function throwException(msg) {
		if (isWorker) self.postMessage({ action: "exception", msg: msg });else if (Collada.onerror) Collada.onerror(msg);
		throw msg;
	},

	getFilename: function getFilename(filename) {
		var pos = filename.lastIndexOf("\\");
		if (pos != -1) filename = filename.substr(pos + 1);
		//strip unix slashes
		pos = filename.lastIndexOf("/");
		if (pos != -1) filename = filename.substr(pos + 1);
		return filename;
	},

	last_name: 0,

	generateName: function generateName(v) {
		v = v || "name_";
		var name = v + this.last_name;
		this.last_name++;
		return name;
	},

	parse: function parse(data, options, filename) {
		options = options || {};
		filename = filename || "_dae_" + Date.now() + ".dae";

		//console.log("Parsing collada");
		var flip = false;

		var xmlparser = null;
		var root = null;
		this._transferables = [];

		if (this.verbose) console.log(" - XML parsing...");

		if (global["DOMParser"] && !this.config.forceParser) {
			xmlparser = new DOMParser();
			root = xmlparser.parseFromString(data, "text/xml");
			if (this.verbose) console.log(" - XML parsed");
		} else //USING JS XML PARSER IMPLEMENTATION (much slower)
			{
				if (!global["DOMImplementation"]) return Collada.throwException(Collada.NOXMLPARSER_ERROR);
				//use tinyxmlparser
				try {
					xmlparser = new DOMImplementation();
				} catch (err) {
					return Collada.throwException(Collada.NOXMLPARSER_ERROR);
				}

				root = xmlparser.loadXML(data);
				if (this.verbose) console.log(" - XML parsed");

				//for every node...
				var by_ids = root._nodes_by_id = {};
				for (var i = 0, l = root.all.length; i < l; ++i) {
					var node = root.all[i];
					by_ids[node.id] = node;
					if (node.getAttribute("sid")) by_ids[node.getAttribute("sid")] = node;
				}

				if (!this.extra_functions) {
					this.extra_functions = true;
					//these methods are missing so here is a lousy implementation
					DOMDocument.prototype.querySelector = DOMElement.prototype.querySelector = function (selector) {
						var tags = selector.split(" ");
						var current_element = this;

						while (tags.length) {
							var current = tags.shift();
							var tokens = current.split("#");
							var tagname = tokens[0];
							var id = tokens[1];
							var elements = tagname ? current_element.getElementsByTagName(tagname) : current_element.childNodes;
							if (!id) //no id filter
								{
									if (tags.length == 0) return elements.item(0);
									current_element = elements.item(0);
									continue;
								}

							//has id? check for all to see if one matches the id
							for (var i = 0; i < elements.length; i++) {
								if (elements.item(i).getAttribute("id") == id) {
									if (tags.length == 0) return elements.item(i);
									current_element = elements.item(i);
									break;
								}
							}
						}
						return null;
					};

					DOMDocument.prototype.querySelectorAll = DOMElement.prototype.querySelectorAll = function (selector) {
						var tags = selector.split(" ");
						if (tags.length == 1) return this.getElementsByTagName(selector);

						var current_element = this;
						var result = [];

						inner(this, tags);

						function inner(root, tags) {
							if (!tags) return;

							var current = tags.shift();
							var elements = root.getElementsByTagName(current);
							if (tags.length == 0) {
								for (var i = 0; i < elements.length; i++) {
									result.push(elements.item(i));
								}return;
							}

							for (var i = 0; i < elements.length; i++) {
								inner(elements.item(i), tags.concat());
							}
						}

						var list = new DOMNodeList(this.documentElement);
						list._nodes = result;
						list.length = result.length;

						return list;
					};

					Object.defineProperty(DOMElement.prototype, "textContent", {
						get: function get() {
							var nodes = this.getChildNodes();
							return nodes.item(0).toString();
						},
						set: function set() {}
					});
				}
			}
		this._xmlroot = root;
		var xmlcollada = root.querySelector("COLLADA");
		if (xmlcollada) {
			this._current_DAE_version = xmlcollada.getAttribute("version");
			console.log("DAE Version:" + this._current_DAE_version);
		}

		//var xmlvisual_scene = root.querySelector("visual_scene");
		var xmlvisual_scene = root.getElementsByTagName("visual_scene").item(0);
		if (!xmlvisual_scene) throw "visual_scene XML node not found in DAE";

		//hack to avoid problems with bones with spaces in names
		this._nodes_by_id = {}; //clear
		this._controllers_found = {}; //we need to check what controllers had been found, in case we miss one at the end
		this._geometries_found = {};

		//Create a scene tree
		var scene = {
			object_type: "SceneTree",
			light: null,
			materials: {},
			meshes: {},
			resources: {}, //used to store animation tracks
			root: { children: [] },
			external_files: {} //store info about external files mentioned in this 
		};

		//scene metadata (like author, tool, up vector, dates, etc)
		var xmlasset = root.getElementsByTagName("asset")[0];
		if (xmlasset) scene.metadata = this.readAsset(xmlasset);

		//parse nodes tree to extract names and ierarchy only
		var xmlnodes = xmlvisual_scene.childNodes;
		for (var i = 0; i < xmlnodes.length; i++) {
			if (xmlnodes.item(i).localName != "node") continue;

			var node = this.readNodeTree(xmlnodes.item(i), scene, 0, flip);
			if (node) scene.root.children.push(node);
		}

		//parse nodes content (two steps so we have first all the scene tree info)
		for (var i = 0; i < xmlnodes.length; i++) {
			if (xmlnodes.item(i).localName != "node") continue;
			this.readNodeInfo(xmlnodes.item(i), scene, 0, flip);
		}

		//read remaining controllers (in some cases some controllers are not linked from the nodes or the geometries)
		this.readLibraryControllers(scene);

		//read animations
		var animations = this.readAnimations(root, scene);
		if (animations) {
			var animations_name = "#animations_" + filename.substr(0, filename.indexOf("."));
			scene.resources[animations_name] = animations;
			scene.root.animations = animations_name;
		}

		//read external files (images)
		scene.images = this.readImages(root);

		//clear memory
		this._nodes_by_id = {};
		this._controllers_found = {};
		this._geometries_found = {};
		this._xmlroot = null;

		//console.log(scene);
		return scene;
	},

	/* Collect node ids, in case there is bones (with spaces in name) I need to know the nodenames in advance */
	/*
 readAllNodeNames: function(xmlnode)
 {
 	var node_id = this.safeString( xmlnode.getAttribute("id") );
 	if(node_id)
 		this._nodes_by_id[node_id] = true; //node found
 	//nodes seem to have to possible ids, id and sid, I guess one is unique, the other user-defined
 	var node_sid = this.safeString( xmlnode.getAttribute("sid") );
 	if(node_sid)
 		this._nodes_by_id[node_sid] = true; //node found
 
 	for( var i = 0; i < xmlnode.childNodes.length; i++ )
 	{
 		var xmlchild = xmlnode.childNodes.item(i);
 			//children
 		if(xmlchild.localName != "node")
 			continue;
 		this.readAllNodeNames(xmlchild);
 	}
 },
 	*/

	readAsset: function readAsset(xmlasset) {
		var metadata = {};

		for (var i = 0; i < xmlasset.childNodes.length; i++) {
			var xmlchild = xmlasset.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;
			switch (xmlchild.localName) {
				case "contributor":
					var tool = xmlchild.querySelector("authoring_tool");
					if (tool) metadata["authoring_tool"] = tool.textContext;
					break;
				case "unit":
					metadata["unit"] = xmlchild.getAttribute("name");break;
				default:
					metadata[xmlchild.localName] = xmlchild.textContent;break;
			}
		}

		return metadata;
	},

	readNodeTree: function readNodeTree(xmlnode, scene, level, flip) {
		var node_id = this.safeString(xmlnode.getAttribute("id"));
		var node_sid = this.safeString(xmlnode.getAttribute("sid"));

		if (!node_id && !node_sid) return null;

		//here we create the node
		var node = {
			id: node_sid || node_id,
			children: [],
			_depth: level
		};

		var node_type = xmlnode.getAttribute("type");
		if (node_type) node.type = node_type;

		var node_name = xmlnode.getAttribute("name");
		if (node_name) node.name = node_name;
		this._nodes_by_id[node.id] = node;
		if (node_id) this._nodes_by_id[node_id] = node;
		if (node_sid) this._nodes_by_id[node_sid] = node;

		//transform
		node.model = this.readTransform(xmlnode, level, flip);

		//node elements
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xmlchild = xmlnode.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;

			//children
			if (xmlchild.localName == "node") {
				var child_node = this.readNodeTree(xmlchild, scene, level + 1, flip);
				if (child_node) node.children.push(child_node);
				continue;
			}
		}

		return node;
	},

	readNodeInfo: function readNodeInfo(xmlnode, scene, level, flip, parent) {
		var node_id = this.safeString(xmlnode.getAttribute("id"));
		var node_sid = this.safeString(xmlnode.getAttribute("sid"));

		/*
  if(!node_id && !node_sid)
  {
  	console.warn("Collada: node without id, creating a random one");
  	node_id = this.generateName("node_");
  	return null;
  }
  */

		var node;
		if (!node_id && !node_sid) {
			//if there is no id, then either all of this node's properties 
			//should be assigned directly to its parent node, or the node doesn't
			//have a parent node, in which case its a light or something. 
			//So we get the parent by its id, and if there is no parent, we return null
			if (parent) node = this._nodes_by_id[parent.id || parent.sid];else return null;
		} else node = this._nodes_by_id[node_id || node_sid];

		if (!node) {
			console.warn("Collada: Node not found by id: " + (node_id || node_sid));
			return null;
		}

		//node elements
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xmlchild = xmlnode.childNodes.item(i);
			if (xmlchild.nodeType != 1) //not tag
				continue;

			//children
			if (xmlchild.localName == "node") {
				//pass parent node in case child node is a 'dead' node (has no id or sid)
				this.readNodeInfo(xmlchild, scene, level + 1, flip, xmlnode);
				continue;
			}

			//geometry
			if (xmlchild.localName == "instance_geometry") {
				var url = xmlchild.getAttribute("url");
				var mesh_id = url.toString().substr(1);
				node.mesh = mesh_id;

				if (!scene.meshes[url]) {
					var mesh_data = this.readGeometry(url, flip);
					if (mesh_data) {
						mesh_data.name = mesh_id;
						scene.meshes[mesh_id] = mesh_data;
					}
				}

				//binded material
				var xmlmaterials = xmlchild.querySelectorAll("instance_material");
				if (xmlmaterials) {
					for (var iMat = 0; iMat < xmlmaterials.length; ++iMat) {
						var xmlmaterial = xmlmaterials.item(iMat);
						if (!xmlmaterial) {
							console.warn("instance_material not found: " + i);
							continue;
						}

						var matname = xmlmaterial.getAttribute("target").toString().substr(1);
						//matname = matname.replace(/ /g,"_"); //names cannot have spaces
						if (!scene.materials[matname]) {

							var material = this.readMaterial(matname);
							if (material) {
								material.id = matname;
								scene.materials[material.id] = material;
							}
						}
						if (iMat == 0) node.material = matname;else {
							if (!node.materials) node.materials = [];
							node.materials.push(matname);
						}
					}
				}
			}

			//this node has a controller: skinning, morph targets or even multimaterial are controllers
			//warning: I detected that some nodes could have a controller but they are not referenced here.  ??
			if (xmlchild.localName == "instance_controller") {
				var url = xmlchild.getAttribute("url");
				var xmlcontroller = this._xmlroot.querySelector("controller" + url);

				if (xmlcontroller) {

					var mesh_data = this.readController(xmlcontroller, flip, scene);

					//binded materials
					var xmlbind_material = xmlchild.querySelector("bind_material");
					if (xmlbind_material) {
						//removed readBindMaterials up here for consistency
						var xmltechniques = xmlbind_material.querySelectorAll("technique_common");
						for (var iTec = 0; iTec < xmltechniques.length; iTec++) {
							var xmltechnique = xmltechniques.item(iTec);
							var xmlinstance_materials = xmltechnique.querySelectorAll("instance_material");
							for (var iMat = 0; iMat < xmlinstance_materials.length; iMat++) {
								var xmlinstance_material = xmlinstance_materials.item(iMat);
								if (!xmlinstance_material) {
									console.warn("instance_material for controller not found: " + xmlinstance_material);
									continue;
								}
								var matname = xmlinstance_material.getAttribute("target").toString().substr(1);
								if (!scene.materials[matname]) {

									var material = this.readMaterial(matname);
									if (material) {
										material.id = matname;
										scene.materials[material.id] = material;
									}
								}
								if (iMat == 0) node.material = matname;else {
									if (!node.materials) node.materials = [];
									node.materials.push(matname);
								}
							}
						}
					}

					if (mesh_data) {
						var mesh = mesh_data;
						if (mesh_data.type == "morph") {
							mesh = mesh_data.mesh;
							node.morph_targets = mesh_data.morph_targets;
						}

						mesh.name = url.toString();
						node.mesh = url.toString();
						scene.meshes[url] = mesh;
					}
				}
			}

			//light
			if (xmlchild.localName == "instance_light") {
				var url = xmlchild.getAttribute("url");
				this.readLight(node, url);
			}

			//camera
			if (xmlchild.localName == "instance_camera") {
				var url = xmlchild.getAttribute("url");
				this.readCamera(node, url);
			}

			//other possible tags?
		}
	},

	//if you want to rename some material names
	material_translate_table: {
		/*
  transparency: "opacity",
  reflectivity: "reflection_factor",
  specular: "specular_factor",
  shininess: "specular_gloss",
  emission: "emissive",
  diffuse: "color"
  */
	},

	light_translate_table: {

		point: "omni",
		directional: "directional",
		spot: "spot"
	},

	camera_translate_table: {
		xfov: "fov",
		aspect_ratio: "aspect",
		znear: "near",
		zfar: "far"
	},

	//used when id have spaces (regular selector do not support spaces)
	querySelectorAndId: function querySelectorAndId(root, selector, id) {
		var nodes = root.querySelectorAll(selector);
		for (var i = 0; i < nodes.length; i++) {
			var attr_id = nodes.item(i).getAttribute("id");
			if (!attr_id) continue;
			attr_id = attr_id.toString();
			if (attr_id == id) return nodes.item(i);
		}
		return null;
	},

	//returns the first element that matches a tag name, if not tagname is specified then the first tag element
	getFirstChildElement: function getFirstChildElement(root, localName) {
		var c = root.childNodes;
		for (var i = 0; i < c.length; ++i) {
			var item = c.item(i);
			if (item.localName && !localName || localName && localName == item.localName) return item;
		}
		return null;
	},

	readMaterial: function readMaterial(url) {
		var xmlmaterial = this.querySelectorAndId(this._xmlroot, "library_materials material", url);

		if (!xmlmaterial) return null;

		//get effect name
		var xmleffect = xmlmaterial.querySelector("instance_effect");
		if (!xmleffect) return null;

		var effect_url = xmleffect.getAttribute("url").substr(1);

		//get effect
		var xmleffects = this.querySelectorAndId(this._xmlroot, "library_effects effect", effect_url);

		if (!xmleffects) return null;

		//get common
		var xmltechnique = xmleffects.querySelector("technique");
		if (!xmltechnique) return null;

		//get newparams and convert to js object
		var xmlnewparams = xmleffects.querySelectorAll("newparam");
		var newparams = {};
		for (var i = 0; i < xmlnewparams.length; i++) {

			var init_from = xmlnewparams[i].querySelector("init_from");
			var parent;
			if (init_from) parent = init_from.innerHTML;else {
				var source = xmlnewparams[i].querySelector("source");
				parent = source.innerHTML;
			}

			newparams[xmlnewparams[i].getAttribute("sid")] = {
				parent: parent
			};
		}

		var material = {};

		//read the images here because we need to access them to assign texture names
		var images = this.readImages(this._xmlroot);

		var xmlphong = xmltechnique.querySelector("phong");
		if (!xmlphong) xmlphong = xmltechnique.querySelector("blinn");
		if (!xmlphong) xmlphong = xmltechnique.querySelector("lambert");
		if (!xmlphong) return null;

		//for every tag of properties
		for (var i = 0; i < xmlphong.childNodes.length; ++i) {
			var xmlparam = xmlphong.childNodes.item(i);

			if (!xmlparam.localName) //text tag
				continue;

			//translate name
			var param_name = xmlparam.localName.toString();
			if (this.material_translate_table[param_name]) param_name = this.material_translate_table[param_name];

			//value
			var xmlparam_value = this.getFirstChildElement(xmlparam);
			if (!xmlparam_value) continue;

			if (xmlparam_value.localName.toString() == "color") {
				var value = this.readContentAsFloats(xmlparam_value);
				if (xmlparam.getAttribute("opaque") == "RGB_ZERO") material[param_name] = value.subarray(0, 4);else material[param_name] = value.subarray(0, 3);
				continue;
			} else if (xmlparam_value.localName.toString() == "float") {
				material[param_name] = this.readContentAsFloats(xmlparam_value)[0];
				continue;
			} else if (xmlparam_value.localName.toString() == "texture") {
				if (!material.textures) material.textures = {};
				var map_id = xmlparam_value.getAttribute("texture");
				if (!map_id) continue;

				// if map_id is not a filename, lets go and look for it.
				if (map_id.indexOf('.') === -1) {
					//check effect parents
					map_id = this.getParentParam(newparams, map_id);

					if (images[map_id]) map_id = images[map_id].path;
				}

				//now get the texture filename from images

				var map_info = { map_id: map_id };
				var uvs = xmlparam_value.getAttribute("texcoord");
				map_info.uvs = uvs;
				material.textures[param_name] = map_info;
			}
		}

		material.object_type = "Material";
		return material;
	},

	getParentParam: function getParentParam(newparams, param) {
		if (!newparams[param]) return param;

		if (newparams[param].parent) return this.getParentParam(newparams, newparams[param].parent);else return param;
	},

	readLight: function readLight(node, url) {
		var light = {};

		var xmlnode = null;

		if (url.length > 1) //weird cases with id == #
			xmlnode = this._xmlroot.querySelector("library_lights " + url);else {
			var xmlliblights = this._xmlroot.querySelector("library_lights");
			xmlnode = this.getFirstChildElement(xmlliblights, "light");
		}

		if (!xmlnode) return null;

		//pack
		var children = [];
		var xml = xmlnode.querySelector("technique_common");
		if (xml) for (var i = 0; i < xml.childNodes.length; i++) {
			if (xml.childNodes.item(i).nodeType == 1) //tag
				children.push(xml.childNodes.item(i));
		}var xmls = xmlnode.querySelectorAll("technique");
		for (var i = 0; i < xmls.length; i++) {
			var xml2 = xmls.item(i);
			for (var j = 0; j < xml2.childNodes.length; j++) {
				if (xml2.childNodes.item(j).nodeType == 1) //tag
					children.push(xml2.childNodes.item(j));
			}
		}

		//get
		for (var i = 0; i < children.length; i++) {
			var xml = children[i];
			switch (xml.localName) {
				case "point":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;
				case "directional":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;
				case "spot":
					light.type = this.light_translate_table[xml.localName];
					parse_params(light, xml);
					break;

				case "intensity":
					light.intensity = this.readContentAsFloats(xml)[0];
					break;
			}
		}

		function parse_params(light, xml) {
			for (var i = 0; i < xml.childNodes.length; i++) {
				var child = xml.childNodes.item(i);
				if (!child || child.nodeType != 1) //tag
					continue;

				switch (child.localName) {
					case "color":
						light.color = Collada.readContentAsFloats(child);break;
					case "falloff_angle":
						light.angle_end = Collada.readContentAsFloats(child)[0];
						light.angle = light.angle_end - 10;
						break;
				}
			}
		}

		if (node.model) {
			//light position is final column of model
			light.position = [node.model[12], node.model[13], node.model[14]];
			//light forward vector is reverse of third column of model
			var forward = [-node.model[8], -node.model[9], -node.model[10]];
			//so light target is position + forward
			light.target = [light.position[0] + forward[0], light.position[1] + forward[1], light.position[2] + forward[2]];
		} else {
			console.warn("Could not read light position for light: " + node.name + ". Setting defaults.");
			light.position = [0, 0, 0];
			light.target = [0, -1, 0];
		}

		node.light = light;
	},

	readCamera: function readCamera(node, url) {
		var camera = {};

		var xmlnode = this._xmlroot.querySelector("library_cameras " + url);
		if (!xmlnode) return null;

		//pack
		var children = [];
		var xml = xmlnode.querySelector("technique_common");
		if (xml) //grab all internal stuff
			for (var i = 0; i < xml.childNodes.length; i++) {
				if (xml.childNodes.item(i).nodeType == 1) //tag
					children.push(xml.childNodes.item(i));
			} //
		for (var i = 0; i < children.length; i++) {
			var tag = children[i];
			parse_params(camera, tag);
		}

		function parse_params(camera, xml) {
			for (var i = 0; i < xml.childNodes.length; i++) {
				var child = xml.childNodes.item(i);
				if (!child || child.nodeType != 1) //tag
					continue;
				var translated = Collada.camera_translate_table[child.localName] || child.localName;
				camera[translated] = parseFloat(child.textContent);
			}
		}

		//parse to convert yfov to standard (x) fov
		if (camera.yfov && !camera.fov) {
			if (camera.aspect) {
				camera.fov = camera.yfov * camera.aspect;
			} else console.warn("Could not convert camera yfov to xfov because aspect ratio not set");
		}

		node.camera = camera;
	},

	readTransform: function readTransform(xmlnode, level, flip) {
		//identity
		var matrix = _glMatrix.mat4.create();
		var temp = _glMatrix.mat4.create();
		var tmpq = _glMatrix.quat.create();

		var flip_fix = false;

		//search for the matrix
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xml = xmlnode.childNodes.item(i);
			if (!xml || xml.nodeType != 1) //tag
				continue;

			if (xml.localName == "matrix") {
				var matrix = this.readContentAsFloats(xml);
				//console.log("Nodename: " + xmlnode.getAttribute("id"));
				//console.log(matrix);
				this.transformMatrix(matrix, level == 0);
				//console.log(matrix);
				return matrix;
			}

			if (xml.localName == "translate") {
				var values = this.readContentAsFloats(xml);
				if (flip && level > 0) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}

				_glMatrix.mat4.translate(matrix, matrix, values);
				continue;
			}

			//rotate
			if (xml.localName == "rotate") {
				var values = this.readContentAsFloats(xml);
				if (values.length == 4) //x,y,z, angle
					{
						var id = xml.getAttribute("sid");
						if (id == "jointOrientX") {
							values[3] += 90;
							flip_fix = true;
						}
						//rotateX & rotateY & rotateZ done below

						if (flip) {
							var tmp = values[1];
							values[1] = values[2];
							values[2] = -tmp; //swap coords
						}

						if (values[3] != 0.0) {
							_glMatrix.quat.setAxisAngle(tmpq, values.subarray(0, 3), values[3] * DEG2RAD);
							_glMatrix.mat4.fromQuat(temp, tmpq);
							_glMatrix.mat4.multiply(matrix, matrix, temp);
						}
					}
				continue;
			}

			//scale
			if (xml.localName == "scale") {
				var values = this.readContentAsFloats(xml);
				if (flip) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}
				_glMatrix.mat4.scale(matrix, matrix, values);
			}
		}

		return matrix;
	},

	readTransform2: function readTransform2(xmlnode, level, flip) {
		//identity
		var matrix = _glMatrix.mat4.create();
		var rotation = _glMatrix.quat.create();
		var tmpmatrix = _glMatrix.mat4.create();
		var tmpq = _glMatrix.quat.create();
		var translate = vec3.create();
		var scale = vec3.fromValues(1, 1, 1);

		var flip_fix = false;

		//search for the matrix
		for (var i = 0; i < xmlnode.childNodes.length; i++) {
			var xml = xmlnode.childNodes.item(i);

			if (xml.localName == "matrix") {
				var matrix = this.readContentAsFloats(xml);
				//console.log("Nodename: " + xmlnode.getAttribute("id"));
				//console.log(matrix);
				this.transformMatrix(matrix, level == 0);
				//console.log(matrix);
				return matrix;
			}

			if (xml.localName == "translate") {
				var values = this.readContentAsFloats(xml);
				translate.set(values);
				continue;
			}

			//rotate
			if (xml.localName == "rotate") {
				var values = this.readContentAsFloats(xml);
				if (values.length == 4) //x,y,z, angle
					{
						var id = xml.getAttribute("sid");
						if (id == "jointOrientX") {
							values[3] += 90;
							flip_fix = true;
						}
						//rotateX & rotateY & rotateZ done below

						if (flip) {
							var tmp = values[1];
							values[1] = values[2];
							values[2] = -tmp; //swap coords
						}

						if (values[3] != 0.0) {
							_glMatrix.quat.setAxisAngle(tmpq, values.subarray(0, 3), values[3] * DEG2RAD);
							_glMatrix.quat.multiply(rotation, rotation, tmpq);
						}
					}
				continue;
			}

			//scale
			if (xml.localName == "scale") {
				var values = this.readContentAsFloats(xml);
				if (flip) {
					var tmp = values[1];
					values[1] = values[2];
					values[2] = -tmp; //swap coords
				}
				scale.set(values);
			}
		}

		if (flip && level > 0) {
			var tmp = translate[1];
			translate[1] = translate[2];
			translate[2] = -tmp; //swap coords
		}
		_glMatrix.mat4.translate(matrix, matrix, translate);

		_glMatrix.mat4.fromQuat(tmpmatrix, rotation);
		//mat4.rotateX(tmpmatrix, tmpmatrix, Math.PI * 0.5);
		_glMatrix.mat4.multiply(matrix, matrix, tmpmatrix);
		_glMatrix.mat4.scale(matrix, matrix, scale);

		return matrix;
	},

	//for help read this: https://www.khronos.org/collada/wiki/Using_accessors
	readGeometry: function readGeometry(id, flip, scene) {
		//already read, could happend if several controllers point to the same mesh
		if (this._geometries_found[id] !== undefined) return this._geometries_found[id];

		//var xmlgeometry = this._xmlroot.querySelector("geometry" + id);
		var xmlgeometry = this._xmlroot.getElementById(id.substr(1));
		if (!xmlgeometry) {
			console.warn("readGeometry: geometry not found: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//if the geometry has morph targets then instead of storing it in a geometry, it is in a controller
		if (xmlgeometry.localName == "controller") {
			var geometry = this.readController(xmlgeometry, flip, scene);
			this._geometries_found[id] = geometry;
			return geometry;
		}

		if (xmlgeometry.localName != "geometry") {
			console.warn("readGeometry: tag should be geometry, instead it was found: " + xmlgeometry.localName);
			this._geometries_found[id] = null;
			return null;
		}

		var xmlmesh = xmlgeometry.querySelector("mesh");
		if (!xmlmesh) {
			console.warn("readGeometry: mesh not found in geometry: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//get data sources
		var sources = {};
		var xmlsources = xmlmesh.querySelectorAll("source");
		for (var i = 0; i < xmlsources.length; i++) {
			var xmlsource = xmlsources.item(i);
			if (!xmlsource.querySelector) continue;
			var float_array = xmlsource.querySelector("float_array");
			if (!float_array) continue;
			var floats = this.readContentAsFloats(float_array);

			var xmlaccessor = xmlsource.querySelector("accessor");
			var stride = parseInt(xmlaccessor.getAttribute("stride"));

			sources[xmlsource.getAttribute("id")] = { stride: stride, data: floats };
		}

		//get streams
		var xmlvertices = xmlmesh.querySelector("vertices input");
		var vertices_source = sources[xmlvertices.getAttribute("source").substr(1)];
		sources[xmlmesh.querySelector("vertices").getAttribute("id")] = vertices_source;

		var mesh = null;
		var xmlpolygons = xmlmesh.querySelector("polygons");
		if (xmlpolygons) mesh = this.readTriangles(xmlpolygons, sources);

		if (!mesh) {
			var xmltriangles = xmlmesh.querySelectorAll("triangles");
			if (xmltriangles && xmltriangles.length) mesh = this.readTriangles(xmltriangles, sources);
		}

		if (!mesh) {
			//polylist = true;
			//var vcount = null;
			//var xmlvcount = xmlpolygons.querySelector("vcount");
			//var vcount = this.readContentAsUInt32( xmlvcount );
			var xmlpolylist = xmlmesh.querySelector("polylist");
			if (xmlpolylist) mesh = this.readPolylist(xmlpolylist, sources);
		}

		if (!mesh) {
			var xmllinestrip = xmlmesh.querySelector("linestrips");
			if (xmllinestrip) mesh = this.readLineStrip(sources, xmllinestrip);
		}

		if (!mesh) {
			console.log("no polygons or triangles in mesh: " + id);
			this._geometries_found[id] = null;
			return null;
		}

		//swap coords (X,Y,Z) -> (X,Z,-Y)
		if (flip && !this.no_flip) {
			var tmp = 0;
			var array = mesh.vertices;
			for (var i = 0, l = array.length; i < l; i += 3) {
				tmp = array[i + 1];
				array[i + 1] = array[i + 2];
				array[i + 2] = -tmp;
			}

			array = mesh.normals;
			for (var i = 0, l = array.length; i < l; i += 3) {
				tmp = array[i + 1];
				array[i + 1] = array[i + 2];
				array[i + 2] = -tmp;
			}
		}

		//transferables for worker
		if (isWorker && this.use_transferables) {
			for (var i in mesh) {
				var data = mesh[i];
				if (data && data.buffer && data.length > 100) {
					this._transferables.push(data.buffer);
				}
			}
		}

		//extra info
		mesh.filename = id;
		mesh.object_type = "Mesh";

		this._geometries_found[id] = mesh;
		return mesh;
	},

	readTriangles: function readTriangles(xmltriangles, sources) {
		var use_indices = false;

		var groups = [];
		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = []; //maps DAE vertex index to Mesh vertex index (because when meshes are triangulated indices are changed
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		//for every triangles set (warning, some times they are repeated...)
		for (var tris = 0; tris < xmltriangles.length; tris++) {
			var xml_shape_root = xmltriangles.item(tris);
			var triangles = xml_shape_root.localName == "triangles";

			material_name = xml_shape_root.getAttribute("material");

			//for each buffer (input) build the structure info
			if (tris == 0) buffers = this.readShapeInputs(xml_shape_root, sources);

			//assuming buffers are ordered by offset

			//iterate data
			var xmlps = xml_shape_root.querySelectorAll("p");
			var num_data_vertex = buffers.length; //one value per input buffer

			//for every polygon (could be one with all the indices, could be several, depends on the program)
			for (var i = 0; i < xmlps.length; i++) {
				var xmlp = xmlps.item(i);
				if (!xmlp || !xmlp.textContent) break;

				var data = xmlp.textContent.trim().split(" ");

				//used for triangulate polys
				var first_index = -1;
				var current_index = -1;
				var prev_index = -1;

				//discomment to force 16bits indices
				//if(use_indices && last_index >= 256*256)
				//	break;

				var num_values_per_vertex = 1;
				for (var b in buffers) {
					num_values_per_vertex = Math.max(num_values_per_vertex, buffers[b][4] + 1);
				} //for every pack of indices in the polygon (vertex, normal, uv, ... )
				var current_data_pos = 0;
				for (var k = 0, l = data.length; k < l; k += num_values_per_vertex) {
					var vertex_id = data.slice(k, k + num_values_per_vertex).join(" "); //generate unique id

					prev_index = current_index;
					if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
						current_index = facemap[vertex_id];else {
						//for every data buffer associated to this vertex
						for (var j = 0; j < buffers.length; ++j) {
							var buffer = buffers[j];
							var array = buffer[1]; //array where we accumulate the final data as we extract if from sources
							var source = buffer[3]; //where to read the data from

							//compute the index inside the data source array
							//var index = parseInt(data[k + j]);
							var index = parseInt(data[k + buffer[4]]);
							//current_data_pos += buffer[4];

							//remember this index in case we need to remap
							if (j == 0) vertex_remap[array.length / buffer[2]] = index; //not sure if buffer[2], it should be number of floats per vertex (usually 3)
							//vertex_remap[ array.length / num_data_vertex ] = index;

							//compute the position inside the source buffer where the final data is located
							index *= buffer[2]; //this works in most DAEs (not all)
							//index = index * buffer[2] + buffer[4]; //stride(2) offset(4)
							//index += buffer[4]; //stride(2) offset(4)
							//extract every value of this element and store it in its final array (every x,y,z, etc)
							for (var x = 0; x < buffer[2]; ++x) {
								if (source[index + x] === undefined) throw "UNDEFINED!"; //DEBUG
								array.push(source[index + x]);
							}
						}

						current_index = last_index;
						last_index += 1;
						facemap[vertex_id] = current_index;
					}

					if (!triangles) //the xml element is not triangles? then split polygons in triangles
						{
							if (k == 0) first_index = current_index;
							//if(k > 2 * num_data_vertex) //not sure if use this or the next line, the next one works in some DAEs but not sure if it works in all
							if (k > 2) //triangulate polygons: ensure this works
								{
									indicesArray.push(first_index);
									indicesArray.push(prev_index);
								}
						}

					indicesArray.push(current_index);
				} //per vertex
			} //per polygon

			var group = {
				name: group_name || "group" + tris,
				start: last_start,
				length: indicesArray.length - last_start,
				material: material_name || ""
			};
			last_start = indicesArray.length;
			groups.push(group);
		} //per triangles group

		var mesh = {
			vertices: new Float32Array(buffers[0][1]),
			info: { groups: groups },
			_remap: new Uint32Array(vertex_remap)
		};

		this.transformMeshInfo(mesh, buffers, indicesArray);

		return mesh;
	},

	readPolylist: function readPolylist(xml_shape_root, sources) {
		var use_indices = false;

		var groups = [];
		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = [];
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		material_name = xml_shape_root.getAttribute("material");
		buffers = this.readShapeInputs(xml_shape_root, sources);

		var xmlvcount = xml_shape_root.querySelector("vcount");
		var vcount = this.readContentAsUInt32(xmlvcount);

		var xmlp = xml_shape_root.querySelector("p");
		var data = this.readContentAsUInt32(xmlp);

		var num_data_vertex = buffers.length;

		var pos = 0;
		for (var i = 0, l = vcount.length; i < l; ++i) {
			var num_vertices = vcount[i];

			var first_index = -1;
			var current_index = -1;
			var prev_index = -1;

			//iterate vertices of this polygon
			for (var k = 0; k < num_vertices; ++k) {
				var vertex_id = data.subarray(pos, pos + num_data_vertex).join(" ");

				prev_index = current_index;
				if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
					current_index = facemap[vertex_id];else {
					for (var j = 0; j < buffers.length; ++j) {
						var buffer = buffers[j];
						var index = parseInt(data[pos + j]); //p
						var array = buffer[1]; //array with all the data
						var source = buffer[3]; //where to read the data from
						if (j == 0) vertex_remap[array.length / num_data_vertex] = index;
						index *= buffer[2]; //stride
						for (var x = 0; x < buffer[2]; ++x) {
							array.push(source[index + x]);
						}
					}

					current_index = last_index;
					last_index += 1;
					facemap[vertex_id] = current_index;
				}

				if (num_vertices > 3) //split polygons then
					{
						if (k == 0) first_index = current_index;
						//if(k > 2 * num_data_vertex) //not sure if use this or the next line, the next one works in some DAEs but not sure if it works in all
						if (k > 2) //triangulate polygons: tested, this works
							{
								indicesArray.push(first_index);
								indicesArray.push(prev_index);
							}
					}

				indicesArray.push(current_index);
				pos += num_data_vertex;
			} //per vertex
		} //per polygon

		var mesh = {
			vertices: new Float32Array(buffers[0][1]),
			info: {},
			_remap: new Uint32Array(vertex_remap)
		};

		this.transformMeshInfo(mesh, buffers, indicesArray);

		return mesh;
	},

	readShapeInputs: function readShapeInputs(xml_shape_root, sources) {
		var buffers = [];

		var xmlinputs = xml_shape_root.querySelectorAll("input");
		for (var i = 0; i < xmlinputs.length; i++) {
			var xmlinput = xmlinputs.item(i);
			if (!xmlinput.getAttribute) continue;
			var semantic = xmlinput.getAttribute("semantic").toUpperCase();
			var stream_source = sources[xmlinput.getAttribute("source").substr(1)];
			var offset = parseInt(xmlinput.getAttribute("offset"));
			var data_set = 0;
			if (xmlinput.getAttribute("set")) data_set = parseInt(xmlinput.getAttribute("set"));
			buffers.push([semantic, [], stream_source.stride, stream_source.data, offset, data_set]);
		}

		return buffers;
	},

	transformMeshInfo: function transformMeshInfo(mesh, buffers, indicesArray) {
		//rename buffers (DAE has other names)
		var translator = {
			"normal": "normals",
			"texcoord": "coords"
		};
		for (var i = 1; i < buffers.length; ++i) {
			var name = buffers[i][0].toLowerCase();
			var data = buffers[i][1];
			if (!data.length) continue;

			if (translator[name]) name = translator[name];
			if (mesh[name]) name = name + buffers[i][5];
			mesh[name] = new Float32Array(data); //are they always float32? I think so
		}

		if (indicesArray && indicesArray.length) {
			if (mesh.vertices.length > 256 * 256) mesh.triangles = new Uint32Array(indicesArray);else mesh.triangles = new Uint16Array(indicesArray);
		}

		return mesh;
	},

	readLineStrip: function readLineStrip(sources, xmllinestrip) {
		var use_indices = false;

		var buffers = [];
		var last_index = 0;
		var facemap = {};
		var vertex_remap = [];
		var indicesArray = [];
		var last_start = 0;
		var group_name = "";
		var material_name = "";

		var tris = 0; //used in case there are several strips

		//for each buffer (input) build the structure info
		var xmlinputs = xmllinestrip.querySelectorAll("input");
		if (tris == 0) //first iteration, create buffers
			for (var i = 0; i < xmlinputs.length; i++) {
				var xmlinput = xmlinputs.item(i);
				if (!xmlinput.getAttribute) continue;
				var semantic = xmlinput.getAttribute("semantic").toUpperCase();
				var stream_source = sources[xmlinput.getAttribute("source").substr(1)];
				var offset = parseInt(xmlinput.getAttribute("offset"));
				var data_set = 0;
				if (xmlinput.getAttribute("set")) data_set = parseInt(xmlinput.getAttribute("set"));

				buffers.push([semantic, [], stream_source.stride, stream_source.data, offset, data_set]);
			}
		//assuming buffers are ordered by offset

		//iterate data
		var xmlps = xmllinestrip.querySelectorAll("p");
		var num_data_vertex = buffers.length; //one value per input buffer

		//for every polygon (could be one with all the indices, could be several, depends on the program)
		for (var i = 0; i < xmlps.length; i++) {
			var xmlp = xmlps.item(i);
			if (!xmlp || !xmlp.textContent) break;

			var data = xmlp.textContent.trim().split(" ");

			//used for triangulate polys
			var first_index = -1;
			var current_index = -1;
			var prev_index = -1;

			//if(use_indices && last_index >= 256*256)
			//	break;

			//for every pack of indices in the polygon (vertex, normal, uv, ... )
			for (var k = 0, l = data.length; k < l; k += num_data_vertex) {
				var vertex_id = data.slice(k, k + num_data_vertex).join(" "); //generate unique id

				prev_index = current_index;
				if (facemap.hasOwnProperty(vertex_id)) //add to arrays, keep the index
					current_index = facemap[vertex_id];else {
					for (var j = 0; j < buffers.length; ++j) {
						var buffer = buffers[j];
						var index = parseInt(data[k + j]);
						var array = buffer[1]; //array with all the data
						var source = buffer[3]; //where to read the data from
						if (j == 0) vertex_remap[array.length / num_data_vertex] = index;
						index *= buffer[2]; //stride
						for (var x = 0; x < buffer[2]; ++x) {
							array.push(source[index + x]);
						}
					}

					current_index = last_index;
					last_index += 1;
					facemap[vertex_id] = current_index;
				}

				indicesArray.push(current_index);
			} //per vertex
		} //per polygon

		var mesh = {
			primitive: "line_strip",
			vertices: new Float32Array(buffers[0][1]),
			info: {}
		};

		return this.transformMeshInfo(mesh, buffers, indicesArray);
	},

	//like querySelector but allows spaces in names because COLLADA allows space in names
	findXMLNodeById: function findXMLNodeById(root, nodename, id) {
		//precomputed
		if (this._xmlroot._nodes_by_id) {
			var n = this._xmlroot._nodes_by_id[id];
			if (n && n.localName == nodename) return n;
		} else //for the native parser
			{
				var n = this._xmlroot.getElementById(id);
				if (n) return n;
			}

		//recursive: slow
		var childs = root.childNodes;
		for (var i = 0; i < childs.length; ++i) {
			var xmlnode = childs.item(i);
			if (xmlnode.nodeType != 1) //no tag
				continue;
			if (xmlnode.localName != nodename) continue;
			var node_id = xmlnode.getAttribute("id");
			if (node_id == id) return xmlnode;
		}
		return null;
	},

	readImages: function readImages(root) {
		var xmlimages = root.querySelector("library_images");
		if (!xmlimages) return null;

		var images = {};

		var xmlimages_childs = xmlimages.childNodes;
		for (var i = 0; i < xmlimages_childs.length; ++i) {
			var xmlimage = xmlimages_childs.item(i);
			if (xmlimage.nodeType != 1) //no tag
				continue;

			var xmlinitfrom = xmlimage.querySelector("init_from");
			if (!xmlinitfrom) continue;
			if (xmlinitfrom.textContent) {
				var filename = this.getFilename(xmlinitfrom.textContent);
				var id = xmlimage.getAttribute("id");
				images[id] = { filename: filename, map: id, name: xmlimage.getAttribute("name"), path: xmlinitfrom.textContent };
			}
		}

		return images;
	},

	readAnimations: function readAnimations(root, scene) {
		var xmlanimations = root.querySelector("library_animations");
		if (!xmlanimations) return null;

		var xmlanimation_childs = xmlanimations.childNodes;

		var animations = {
			object_type: "Animation",
			takes: {}
		};

		var default_take = { tracks: [] };
		var tracks = default_take.tracks;

		for (var i = 0; i < xmlanimation_childs.length; ++i) {
			var xmlanimation = xmlanimation_childs.item(i);
			if (xmlanimation.nodeType != 1 || xmlanimation.localName != "animation") //no tag
				continue;

			var anim_id = xmlanimation.getAttribute("id");
			if (!anim_id) //nested animation (DAE 1.5)
				{
					var xmlanimation2_childs = xmlanimation.querySelectorAll("animation");
					if (xmlanimation2_childs.length) {
						for (var j = 0; j < xmlanimation2_childs.length; ++j) {
							var xmlanimation2 = xmlanimation2_childs.item(j);
							this.readAnimation(xmlanimation2, tracks);
						}
					} else //source tracks?
						this.readAnimation(xmlanimation, tracks);
				} else //no nested (DAE 1.4)
				this.readAnimation(xmlanimation, tracks);
		}

		if (!tracks.length) return null; //empty animation

		//compute animation duration
		var max_time = 0;
		for (var i = 0; i < tracks.length; ++i) {
			if (max_time < tracks[i].duration) max_time = tracks[i].duration;
		}default_take.name = "default";
		default_take.duration = max_time;
		animations.takes[default_take.name] = default_take;
		return animations;
	},

	//animation xml
	readAnimation: function readAnimation(xmlanimation, result) {
		if (xmlanimation.localName != "animation") return null;

		//this could be missing when there are lots of anims packed in one <animation>
		var anim_id = xmlanimation.getAttribute("id");

		//channels are like animated properties
		var xmlchannel_list = xmlanimation.querySelectorAll("channel");
		if (!xmlchannel_list.length) return null;

		var tracks = result || [];

		for (var i = 0; i < xmlchannel_list.length; ++i) {
			var anim = this.readChannel(xmlchannel_list.item(i), xmlanimation);
			if (anim) tracks.push(anim);
		}

		return tracks;
	},

	readChannel: function readChannel(xmlchannel, xmlanimation) {
		if (xmlchannel.localName != "channel" || xmlanimation.localName != "animation") return null;

		var source = xmlchannel.getAttribute("source");
		var target = xmlchannel.getAttribute("target");

		//sampler, is in charge of the interpolation
		//var xmlsampler = xmlanimation.querySelector("sampler" + source);
		var xmlsampler = this.findXMLNodeById(xmlanimation, "sampler", source.substr(1));
		if (!xmlsampler) {
			console.error("Error DAE: Sampler not found in " + source);
			return null;
		}

		var inputs = {};
		var params = {};
		var sources = {};
		var xmlinputs = xmlsampler.querySelectorAll("input");

		var time_data = null;

		//iterate inputs: collada separates the keyframe info in independent streams, like time, interpolation method, value )
		for (var j = 0; j < xmlinputs.length; j++) {
			var xmlinput = xmlinputs.item(j);
			var source_name = xmlinput.getAttribute("source");

			//there are three 
			var semantic = xmlinput.getAttribute("semantic");

			//Search for source
			var xmlsource = this.findXMLNodeById(xmlanimation, "source", source_name.substr(1));
			if (!xmlsource) continue;

			var xmlparam = xmlsource.querySelector("param");
			if (!xmlparam) continue;

			var type = xmlparam.getAttribute("type");
			inputs[semantic] = { source: source_name, type: type };

			var data_array = null;

			if (type == "float" || type == "float4x4") {
				var xmlfloatarray = xmlsource.querySelector("float_array");
				var floats = this.readContentAsFloats(xmlfloatarray);
				sources[source_name] = floats;
				data_array = floats;
			} else //only floats and matrices are supported in animation
				continue;

			var param_name = xmlparam.getAttribute("name");
			if (param_name == "TIME") time_data = data_array;
			if (semantic == "OUTPUT") param_name = semantic;
			if (param_name) params[param_name] = type;else console.warn("Collada: <param> without name attribute in <animation>");
		}

		if (!time_data) {
			console.error("Error DAE: no TIME info found in <channel>: " + xmlchannel.getAttribute("source"));
			return null;
		}

		//construct animation
		var path = target.split("/");

		var anim = {};
		var nodename = path[0]; //safeString ?
		var node = this._nodes_by_id[nodename];
		var locator = node.id + "/" + path[1];
		//anim.nodename = this.safeString( path[0] ); //where it goes
		anim.name = path[1];
		anim.property = locator;
		var type = "number";
		var element_size = 1;
		var param_type = params["OUTPUT"];
		switch (param_type) {
			case "float":
				element_size = 1;break;
			case "float3x3":
				element_size = 9;type = "mat3";break;
			case "float4x4":
				element_size = 16;type = "mat4";break;
			default:
				break;
		}

		anim.type = type;
		anim.value_size = element_size;
		anim.duration = time_data[time_data.length - 1]; //last sample

		var value_data = sources[inputs["OUTPUT"].source];
		if (!value_data) return null;

		//Pack data ****************
		var num_samples = time_data.length;
		var sample_size = element_size + 1;
		var anim_data = new Float32Array(num_samples * sample_size);
		//for every sample
		for (var j = 0; j < time_data.length; ++j) {
			anim_data[j * sample_size] = time_data[j]; //set time
			var value = value_data.subarray(j * element_size, (j + 1) * element_size);
			if (param_type == "float4x4") {
				this.transformMatrix(value, node ? node._depth == 0 : 0);
				//mat4.transpose(value, value);
			}
			anim_data.set(value, j * sample_size + 1); //set data
		}

		if (isWorker && this.use_transferables) {
			var data = anim_data;
			if (data && data.buffer && data.length > 100) this._transferables.push(data.buffer);
		}

		anim.data = anim_data;
		return anim;
	},

	findNode: function findNode(root, id) {
		if (root.id == id) return root;
		if (root.children) for (var i in root.children) {
			var ret = this.findNode(root.children[i], id);
			if (ret) return ret;
		}
		return null;
	},

	//reads controllers and stores them in 
	readLibraryControllers: function readLibraryControllers(scene) {
		var xmllibrarycontrollers = this._xmlroot.querySelector("library_controllers");
		if (!xmllibrarycontrollers) return null;

		var xmllibrarycontrollers_childs = xmllibrarycontrollers.childNodes;

		for (var i = 0; i < xmllibrarycontrollers_childs.length; ++i) {
			var xmlcontroller = xmllibrarycontrollers_childs.item(i);
			if (xmlcontroller.nodeType != 1 || xmlcontroller.localName != "controller") //no tag
				continue;
			var id = xmlcontroller.getAttribute("id");
			//we have already processed this controller
			if (this._controllers_found[id]) continue;

			//read it (we wont use the returns, we will get it from this._controllers_found
			this.readController(xmlcontroller, null, scene);
		}
	},

	//used for skinning and morphing
	readController: function readController(xmlcontroller, flip, scene) {
		if (!xmlcontroller.localName == "controller") {
			console.warn("readController: not a controller: " + xmlcontroller.localName);
			return null;
		}

		var id = xmlcontroller.getAttribute("id");
		//use cached
		if (this._controllers_found[id]) return this._controllers_found[id];

		//AGUILA
		//TODO: does this work?
		// if (this._controllers_found[ id ])
		// 	return this._controllers_found[ id ];

		var use_indices = false;
		var mesh = null;
		var xmlskin = xmlcontroller.querySelector("skin");
		if (xmlskin) {
			mesh = this.readSkinController(xmlskin, flip, scene);
		}

		var xmlmorph = xmlcontroller.querySelector("morph");
		if (xmlmorph) mesh = this.readMorphController(xmlmorph, flip, scene, mesh);

		//cache and return
		if (this._controllers_found[id]) {
			id += "_1blah"; //??? this doesnt do anything
		} else this._controllers_found[id] = mesh;

		return mesh;
	},

	//read this to more info about DAE and skinning https://collada.org/mediawiki/index.php/Skinning
	readSkinController: function readSkinController(xmlskin, flip, scene) {
		//base geometry
		var id_geometry = xmlskin.getAttribute("source");

		var mesh = this.readGeometry(id_geometry, flip, scene);
		if (!mesh) return null;

		var sources = this.readSources(xmlskin, flip);
		if (!sources) return null;

		//matrix
		var bind_matrix = null;
		var xmlbindmatrix = xmlskin.querySelector("bind_shape_matrix");
		if (xmlbindmatrix) {
			bind_matrix = this.readContentAsFloats(xmlbindmatrix);
			this.transformMatrix(bind_matrix, true, true);
		} else bind_matrix = _glMatrix.mat4.create(); //identity

		//joints
		var joints = [];
		var xmljoints = xmlskin.querySelector("joints");
		if (xmljoints) {
			var joints_source = null; //which bones
			var inv_bind_source = null; //bind matrices
			var xmlinputs = xmljoints.querySelectorAll("input");
			for (var i = 0; i < xmlinputs.length; i++) {
				var xmlinput = xmlinputs[i];
				var sem = xmlinput.getAttribute("semantic").toUpperCase();
				var src = xmlinput.getAttribute("source");
				var source = sources[src.substr(1)];
				if (sem == "JOINT") joints_source = source;else if (sem == "INV_BIND_MATRIX") inv_bind_source = source;
			}

			//save bone names and inv matrix
			if (!inv_bind_source || !joints_source) {
				console.error("Error DAE: no joints or inv_bind sources found");
				return null;
			}

			for (var i in joints_source) {
				//get the inverse of the bind pose
				var inv_mat = inv_bind_source.subarray(i * 16, i * 16 + 16);
				var nodename = joints_source[i];
				var node = this._nodes_by_id[nodename];
				if (!node) {
					console.warn("Node " + nodename + " not found");
					continue;
				}
				this.transformMatrix(inv_mat, node._depth == 0, true);
				joints.push([nodename, inv_mat]);
			}
		}

		//weights
		var xmlvertexweights = xmlskin.querySelector("vertex_weights");
		if (xmlvertexweights) {

			//here we see the order 
			var weights_indexed_array = null;
			var xmlinputs = xmlvertexweights.querySelectorAll("input");
			for (var i = 0; i < xmlinputs.length; i++) {
				if (xmlinputs[i].getAttribute("semantic").toUpperCase() == "WEIGHT") weights_indexed_array = sources[xmlinputs.item(i).getAttribute("source").substr(1)];
			}

			if (!weights_indexed_array) throw "no weights found";

			var xmlvcount = xmlvertexweights.querySelector("vcount");
			var vcount = this.readContentAsUInt32(xmlvcount);

			var xmlv = xmlvertexweights.querySelector("v");
			var v = this.readContentAsUInt32(xmlv);

			var num_vertices = mesh.vertices.length / 3; //3 components per vertex
			var weights_array = new Float32Array(4 * num_vertices); //4 bones per vertex
			var bone_index_array = new Uint8Array(4 * num_vertices); //4 bones per vertex

			var pos = 0;
			var remap = mesh._remap;
			var max_bone = 0; //max bone affected

			for (var i = 0, l = vcount.length; i < l; ++i) {
				var num_bones = vcount[i]; //num bones influencing this vertex

				//find 4 with more influence
				//var v_tuplets = v.subarray(offset, offset + num_bones*2);

				var offset = pos;
				var b = bone_index_array.subarray(i * 4, i * 4 + 4);
				var w = weights_array.subarray(i * 4, i * 4 + 4);

				var sum = 0;
				for (var j = 0; j < num_bones && j < 4; ++j) {
					b[j] = v[offset + j * 2];
					if (b[j] > max_bone) max_bone = b[j];

					w[j] = weights_indexed_array[v[offset + j * 2 + 1]];
					sum += w[j];
				}

				//normalize weights
				if (num_bones > 4 && sum < 1.0) {
					var inv_sum = 1 / sum;
					for (var j = 0; j < 4; ++j) {
						w[j] *= inv_sum;
					}
				}

				pos += num_bones * 2;
			}

			//remap: because vertices order is now changed after parsing the mesh
			var final_weights = new Float32Array(4 * num_vertices); //4 bones per vertex
			var final_bone_indices = new Uint8Array(4 * num_vertices); //4 bones per vertex
			var used_joints = [];

			//for every vertex in the mesh, process bone indices and weights
			for (var i = 0; i < num_vertices; ++i) {
				var p = remap[i] * 4;
				var w = weights_array.subarray(p, p + 4);
				var b = bone_index_array.subarray(p, p + 4);

				//sort by weight so relevant ones goes first
				for (var k = 0; k < 3; ++k) {
					var max_pos = k;
					var max_value = w[k];
					for (var j = k + 1; j < 4; ++j) {
						if (w[j] <= max_value) continue;
						max_pos = j;
						max_value = w[j];
					}
					if (max_pos != k) {
						var tmp = w[k];
						w[k] = w[max_pos];
						w[max_pos] = tmp;
						tmp = b[k];
						b[k] = b[max_pos];
						b[max_pos] = tmp;
					}
				}

				//store
				final_weights.set(w, i * 4);
				final_bone_indices.set(b, i * 4);

				//mark bones used
				if (w[0]) used_joints[b[0]] = true;
				if (w[1]) used_joints[b[1]] = true;
				if (w[2]) used_joints[b[2]] = true;
				if (w[3]) used_joints[b[3]] = true;
			}

			if (max_bone >= joints.length) console.warn("Mesh uses higher bone index than bones found");

			//trim unused bones (collada could give you 100 bones for an object that only uses a fraction of them)
			if (1) {
				var new_bones = [];
				var bones_translation = {};
				for (var i = 0; i < used_joints.length; ++i) {
					if (used_joints[i]) {
						bones_translation[i] = new_bones.length;
						new_bones.push(joints[i]);
					}
				} //in case there are less bones in use...
				if (new_bones.length < joints.length) {
					//remap
					for (var i = 0; i < final_bone_indices.length; i++) {
						final_bone_indices[i] = bones_translation[final_bone_indices[i]];
					}joints = new_bones;
				}
				//console.log("Bones: ", joints.length, " used:", num_used_joints );
			}

			//console.log("Bones: ", joints.length, "Max bone: ", max_bone);

			mesh.weights = final_weights;
			mesh.bone_indices = final_bone_indices;
			mesh.bones = joints;
			mesh.bind_matrix = bind_matrix;

			//delete mesh["_remap"];
		}

		return mesh;
	},

	//NOT TESTED
	readMorphController: function readMorphController(xmlmorph, flip, scene, mesh) {
		var id_geometry = xmlmorph.getAttribute("source");
		var base_mesh = this.readGeometry(id_geometry, flip, scene);
		if (!base_mesh) return null;

		//read sources with blend shapes info (which ones, and the weight)
		var sources = this.readSources(xmlmorph, flip);

		var morphs = [];

		//targets
		var xmltargets = xmlmorph.querySelector("targets");
		if (!xmltargets) return null;

		var xmlinputs = xmltargets.querySelectorAll("input");
		var targets = null;
		var weights = null;

		for (var i = 0; i < xmlinputs.length; i++) {
			var xmlinput = xmlinputs.item(i);
			var semantic = xmlinput.getAttribute("semantic").toUpperCase();
			var data = sources[xmlinput.getAttribute("source").substr(1)];
			if (semantic == "MORPH_TARGET") targets = data;else if (semantic == "MORPH_WEIGHT") weights = data;
		}

		if (!targets || !weights) {
			console.warn("Morph controller without targets or weights. Skipping it.");
			return null;
		}

		//get targets
		for (var i in targets) {
			var id = "#" + targets[i];
			var geometry = this.readGeometry(id, flip, scene);
			scene.meshes[id] = geometry;
			morphs.push({ mesh: id, weight: weights[i] });
		}

		base_mesh.morph_targets = morphs;
		return base_mesh;
	},

	readBindMaterials: function readBindMaterials(xmlbind_material, mesh) {
		var materials = [];

		var xmltechniques = xmlbind_material.querySelectorAll("technique_common");
		for (var i = 0; i < xmltechniques.length; i++) {
			var xmltechnique = xmltechniques.item(i);
			var xmlinstance_materials = xmltechnique.querySelectorAll("instance_material");
			for (var j = 0; j < xmlinstance_materials.length; j++) {
				var xmlinstance_material = xmlinstance_materials.item(j);
				if (xmlinstance_material) materials.push(xmlinstance_material.getAttribute("symbol"));
			}
		}

		return materials;
	},

	readSources: function readSources(xmlnode, flip) {
		//for data sources
		var sources = {};
		var xmlsources = xmlnode.querySelectorAll("source");
		for (var i = 0; i < xmlsources.length; i++) {
			var xmlsource = xmlsources.item(i);
			if (!xmlsource.querySelector) //??
				continue;

			var float_array = xmlsource.querySelector("float_array");
			if (float_array) {
				var floats = this.readContentAsFloats(xmlsource);
				sources[xmlsource.getAttribute("id")] = floats;
				continue;
			}

			var name_array = xmlsource.querySelector("Name_array");
			if (name_array) {
				var names = this.readContentAsStringsArray(name_array);
				if (!names) continue;
				sources[xmlsource.getAttribute("id")] = names;
				continue;
			}

			var ref_array = xmlsource.querySelector("IDREF_array");
			if (ref_array) {
				var names = this.readContentAsStringsArray(ref_array);
				if (!names) continue;
				sources[xmlsource.getAttribute("id")] = names;
				continue;
			}
		}

		return sources;
	},

	readContentAsUInt32: function readContentAsUInt32(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.trim(); //remove empty spaces
		if (text.length == 0) return null;
		var numbers = text.split(" "); //create array
		var floats = new Uint32Array(numbers.length);
		for (var k = 0; k < numbers.length; k++) {
			floats[k] = parseInt(numbers[k]);
		}return floats;
	},

	readContentAsFloats: function readContentAsFloats(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.replace(/\s\s+/gi, " ");
		text = text.replace(/\t/gi, "");
		text = text.trim(); //remove empty spaces
		var numbers = text.split(" "); //create array
		var count = xmlnode.getAttribute("count");
		var length = count ? parseInt(count) : numbers.length;
		var floats = new Float32Array(length);
		for (var k = 0; k < numbers.length; k++) {
			floats[k] = parseFloat(numbers[k]);
		}return floats;
	},

	readContentAsStringsArray: function readContentAsStringsArray(xmlnode) {
		if (!xmlnode) return null;
		var text = xmlnode.textContent;
		text = text.replace(/\n/gi, " "); //remove line breaks
		text = text.replace(/\s\s/gi, " ");
		text = text.trim(); //remove empty spaces
		var words = text.split(" "); //create array
		for (var k = 0; k < words.length; k++) {
			words[k] = words[k].trim();
		}if (xmlnode.getAttribute("count") && parseInt(xmlnode.getAttribute("count")) != words.length) {
			var merged_words = [];
			var name = "";
			for (var i in words) {
				if (!name) name = words[i];else name += " " + words[i];
				if (!this._nodes_by_id[this.safeString(name)]) continue;
				merged_words.push(this.safeString(name));
				name = "";
			}

			var count = parseInt(xmlnode.getAttribute("count"));
			if (merged_words.length == count) return merged_words;

			console.error("Error: bone names have spaces, avoid using spaces in names");
			return null;
		}
		return words;
	},

	max3d_matrix_0: new Float32Array([0, -1, 0, 0, 0, 0, -1, 0, 1, 0, 0, -0, 0, 0, 0, 1]),
	//max3d_matrix_other: new Float32Array([0, -1, 0, 0, 0, 0, -1, 0, 1, 0, 0, -0, 0, 0, 0, 1]),

	transformMatrix: function transformMatrix(matrix, first_level, inverted) {
		_glMatrix.mat4.transpose(matrix, matrix);

		if (this.no_flip) return matrix;

		//WARNING: DO NOT CHANGE THIS FUNCTION, THE SKY WILL FALL
		if (first_level) {

			//flip row two and tree
			var temp = new Float32Array(matrix.subarray(4, 8)); //swap rows
			matrix.set(matrix.subarray(8, 12), 4);
			matrix.set(temp, 8);

			//reverse Z
			temp = matrix.subarray(8, 12);
			vec4.scale(temp, temp, -1);
		} else {
			var M = _glMatrix.mat4.create();
			var m = matrix;

			//if(inverted) mat4.invert(m,m);

			/* non trasposed
   M.set([m[0],m[8],-m[4]], 0);
   M.set([m[2],m[10],-m[6]], 4);
   M.set([-m[1],-m[9],m[5]], 8);
   M.set([m[3],m[11],-m[7]], 12);
   */

			M.set([m[0], m[2], -m[1]], 0);
			M.set([m[8], m[10], -m[9]], 4);
			M.set([-m[4], -m[6], m[5]], 8);
			M.set([m[12], m[14], -m[13]], 12);

			m.set(M);

			//if(inverted) mat4.invert(m,m);
		}
		return matrix;
	}
};

exports.default = Collada;
module.exports = exports['default'];
//# sourceMappingURL=Collada.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27)))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _xhr = __webpack_require__(81);

var _xhr2 = _interopRequireDefault(_xhr);

var _loadImages = __webpack_require__(41);

var _loadImages2 = _interopRequireDefault(_loadImages);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _Material = __webpack_require__(34);

var _Material2 = _interopRequireDefault(_Material);

var _Mesh = __webpack_require__(13);

var _Mesh2 = _interopRequireDefault(_Mesh);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _ShaderLibs = __webpack_require__(21);

var _ShaderLibs2 = _interopRequireDefault(_ShaderLibs);

var _Shaders = __webpack_require__(16);

var _Shaders2 = _interopRequireDefault(_Shaders);

var _GLTexture = __webpack_require__(9);

var _GLTexture2 = _interopRequireDefault(_GLTexture);

var _Object3D = __webpack_require__(8);

var _Object3D2 = _interopRequireDefault(_Object3D);

var _promisePolyfill = __webpack_require__(42);

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

var _objectAssign = __webpack_require__(17);

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _WebglNumber = __webpack_require__(10);

var _WebglNumber2 = _interopRequireDefault(_WebglNumber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ARRAY_CTOR_MAP = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
}; // GltfLoader.js

var SIZE_MAP = {
	SCALAR: 1,
	VEC2: 2,
	VEC3: 3,
	VEC4: 4,
	MAT2: 4,
	MAT3: 9,
	MAT4: 16
};

var semanticAttributeMap = {
	NORMAL: 'aNormal',
	POSITION: 'aVertexPosition',
	// 'TANGENT': 'aTangent',
	TEXCOORD_0: 'aTextureCoord',
	// TEXCOORD_1: 'aTextureCoord1',
	WEIGHTS_0: 'aWeight',
	JOINTS_0: 'aJoint',
	COLOR: 'aColor'
};

var base = void 0;

var load = function load(mSource) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		if (typeof mSource === 'string') {
			base = mSource.substring(0, mSource.lastIndexOf('/') + 1);
		} else {
			base = '';
		}

		_loadGltf(mSource).then(_loadBin).then(_loadTextures).then(_getBufferViewData).then(_parseMaterials).then(_parseMesh).then(_parseNodes).then(function (gltfInfo) {
			resolve(gltfInfo);
		}).catch(function (e) {
			console.log('Error:', e);
		});
	});
};

var _parseNodes = function _parseNodes(gltf) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var nodes = gltf.nodes,
		    scenes = gltf.scenes;


		var getTree = function getTree(nodeIndex) {
			var node = nodes[nodeIndex];
			var obj3D = node.mesh === undefined ? new _Object3D2.default() : gltf.output.meshes[node.mesh];

			if (node.scale) {
				obj3D.scaleX = node.scale[0];
				obj3D.scaleY = node.scale[1];
				obj3D.scaleZ = node.scale[2];
			}

			if (node.rotation) {
				obj3D.setRotationFromQuaternion(node.rotation);
			}

			if (node.translation) {
				obj3D.x = node.translation[0];
				obj3D.y = node.translation[1];
				obj3D.z = node.translation[2];
			}

			if (node.children) {
				node.children.forEach(function (child) {
					var _child = getTree(child);
					obj3D.addChild(_child);
				});
			}

			return obj3D;
		};

		gltf.output.scenes = scenes.map(function (scene) {
			var container = new _Object3D2.default();
			scene.nodes.forEach(function (nodeIndex) {
				var childTree = getTree(nodeIndex);
				container.addChild(childTree);
			});

			return container;
		});

		resolve(gltf);
	});
};

var _parseMesh = function _parseMesh(gltf) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var meshes = gltf.meshes;


		meshes.forEach(function (mesh) {
			var primitives = mesh.primitives;


			var geometryInfo = {};

			primitives.forEach(function (primitiveInfo) {
				var semantics = Object.keys(primitiveInfo.attributes);
				var defines = {};

				semantics.forEach(function (semantic) {
					var accessorIdx = primitiveInfo.attributes[semantic];
					var attributeInfo = gltf.accessors[accessorIdx];
					var attributeName = semanticAttributeMap[semantic];
					if (!attributeName) {
						return;
					}
					if (semantic === 'NORMAL') {
						defines.HAS_NORMALS = 1;
					}
					if (semantic.indexOf('TEXCOORD') > -1) {
						defines.HAS_UV = 1;
					}

					var size = SIZE_MAP[attributeInfo.type];
					var attributeArray = _getAccessorData(gltf, accessorIdx);
					if (attributeArray instanceof Uint32Array) {
						attributeArray = new Float32Array(attributeArray);
					}

					if (semantic === 'TEXCOORD_1') {
						console.log(size, attributeArray);
					}

					geometryInfo[attributeName] = {
						value: attributeArray,
						size: size
					};
					// console.log('attribute', attributeName, geometry[attributeName]);
				});

				//	parse index
				if (primitiveInfo.indices != null) {
					var attributeArray = _getAccessorData(gltf, primitiveInfo.indices, true);
					geometryInfo.indices = {
						value: attributeArray,
						size: 1
					};
				}

				var geometry = new _Geometry2.default();

				for (var s in geometryInfo) {
					var data = geometryInfo[s];
					if (s !== 'indices') {
						geometry.bufferFlattenData(data.value, s, data.size);
					} else {
						geometry.bufferIndex(data.value);
					}
				}

				var materialInfo = gltf.output.materialInfo[primitiveInfo.material];
				defines = (0, _objectAssign2.default)(defines, materialInfo.defines);

				var emissiveFacotr = materialInfo.emissiveFacotr,
				    normalTexture = materialInfo.normalTexture,
				    occlusionTexture = materialInfo.occlusionTexture,
				    pbrMetallicRoughness = materialInfo.pbrMetallicRoughness;
				var baseColorTexture = pbrMetallicRoughness.baseColorTexture,
				    metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;


				var uniforms = {
					uEmissiveFactor: emissiveFacotr || [0, 0, 0],
					uBaseColor: pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1],
					uRoughness: pbrMetallicRoughness.roughnessFactor || 1,
					uMetallic: pbrMetallicRoughness.metallicFactor || 1,
					uScaleDiffBaseMR: [0, 0, 0, 0],
					uScaleFGDSpec: [0, 0, 0, 0],
					uScaleIBLAmbient: [1, 1, 1, 1],
					uLightDirection: [1, 1, 1],
					uLightColor: [1, 1, 1],
					uGamma: 1
				};

				if (baseColorTexture) {
					uniforms.uColorMap = baseColorTexture.glTexture;
				}

				if (metallicRoughnessTexture) {
					uniforms.uMetallicRoughnessMap = metallicRoughnessTexture.glTexture;
				}

				if (normalTexture) {
					uniforms.uNormalScale = normalTexture.scale || 1;
					uniforms.uNormalMap = normalTexture.glTexture;
				}

				if (occlusionTexture) {
					uniforms.uAoMap = occlusionTexture.glTexture;
					uniforms.uOcclusionStrength = occlusionTexture.strength || 1;
				}

				var material = new _Material2.default(_ShaderLibs2.default.gltfVert, _ShaderLibs2.default.gltfFrag, uniforms, defines);
				var mesh = new _Mesh2.default(geometry, material);
				gltf.output.meshes.push(mesh);
			});
		});

		resolve(gltf);
	});
};

var _getBufferViewData = function _getBufferViewData(gltfInfo) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var bufferViews = gltfInfo.bufferViews,
		    buffers = gltfInfo.buffers;


		bufferViews.forEach(function (bufferViewInfo, i) {
			var buffer = buffers[bufferViewInfo.buffer].data;
			bufferViewInfo.data = buffer.slice(bufferViewInfo.byteOffset || 0, (bufferViewInfo.byteOffset || 0) + (bufferViewInfo.byteLength || 0));
		});
		resolve(gltfInfo);
	});
};

var _loadGltf = function _loadGltf(mSource) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		if (typeof mSource !== 'string') {
			resolve(mSource);
		} else {
			(0, _xhr2.default)(mSource).then(function (o) {
				var gltfInfo = JSON.parse(o);
				gltfInfo.output = {
					meshes: [],
					scenes: [],
					textures: [],
					material: [],
					materialInfo: []
				};

				resolve(gltfInfo);
			}, function (e) {
				reject(e);
			});
		}
	});
};

var _loadBin = function _loadBin(gltfInfo) {
	return new _promisePolyfill2.default(function (resolve, reject) {

		if (gltfInfo.buffers) {
			var count = gltfInfo.buffers.length;

			gltfInfo.buffers.forEach(function (buffer) {

				var urlBin = '' + base + gltfInfo.buffers[0].uri;
				(0, _xhr2.default)(urlBin, true).then(function (o) {
					buffer.data = o;

					count--;
					if (count === 0) {
						resolve(gltfInfo);
					}
				}, function (e) {
					reject(e);
				});
			});
		} else {
			resolve(gltfInfo);
		}
	});
};

var _loadTextures = function _loadTextures(gltfInfo) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var textures = gltfInfo.textures,
		    images = gltfInfo.images,
		    samplers = gltfInfo.samplers;

		if (!images) {
			resolve(gltfInfo);
		}

		var imagesToLoad = images.map(function (img) {
			return '' + base + img.uri;
		});

		(0, _loadImages2.default)(imagesToLoad).then(function (o) {
			gltfInfo.output.textures = o.map(function (img, i) {
				var settings = (0, _objectAssign2.default)({}, samplers ? samplers[textures[i].sampler] : {});
				return new _GLTexture2.default(img, settings);
			});
			resolve(gltfInfo);
		}, function (e) {
			reject(e);
		});
	});
};

var _parseMaterials = function _parseMaterials(gltfInfo) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		var materials = gltfInfo.materials;
		var textures = gltfInfo.output.textures;


		gltfInfo.output.materialInfo = materials.map(function (material) {
			material.defines = {
				USE_IBL: 1
			};

			if (material.normalTexture) {
				material.defines.HAS_NORMALMAP = 1;
				material.normalTexture.glTexture = textures[material.normalTexture.index];
			}

			if (material.occlusionTexture) {
				material.defines.HAS_OCCLUSIONMAP = 1;
				material.occlusionTexture.glTexture = textures[material.occlusionTexture.index];
			}

			// if(material.pbrMetallicRoughness) {
			if (material.pbrMetallicRoughness.baseColorTexture) {
				material.defines.HAS_BASECOLORMAP = 1;
				material.pbrMetallicRoughness.baseColorTexture.glTexture = textures[material.pbrMetallicRoughness.baseColorTexture.index];
			}

			if (material.pbrMetallicRoughness.metallicRoughnessTexture) {
				material.defines.HAS_METALROUGHNESSMAP = 1;
				material.pbrMetallicRoughness.metallicRoughnessTexture.glTexture = textures[material.pbrMetallicRoughness.metallicRoughnessTexture.index];
			}

			// }

			return material;
		});

		resolve(gltfInfo);
	});
};

var parse = function parse(mGltfInfo, mBin) {
	return new _promisePolyfill2.default(function (resolve, reject) {
		resolve(mSource);
	});
};

var _getAccessorData = function _getAccessorData(gltf, accessorIdx) {
	var isIndices = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	var accessorInfo = gltf.accessors[accessorIdx];
	var buffer = gltf.bufferViews[accessorInfo.bufferView].data;
	var byteOffset = accessorInfo.byteOffset || 0;
	var ArrayCtor = ARRAY_CTOR_MAP[accessorInfo.componentType] || Float32Array;
	var size = SIZE_MAP[accessorInfo.type];
	if (size == null && isIndices) {
		size = 1;
	}
	var arr = new ArrayCtor(buffer, byteOffset, size * accessorInfo.count);
	var quantizeExtension = accessorInfo.extensions && accessorInfo.extensions['WEB3D_quantized_attributes'];
	if (quantizeExtension) {
		var decodedArr = new Float32Array(size * accessorInfo.count);
		var decodeMatrix = quantizeExtension.decodeMatrix;
		var decodeOffset = new Array(size);
		var decodeScale = new Array(size);
		for (var k = 0; k < size; k++) {
			decodeOffset[k] = decodeMatrix[size * (size + 1) + k];
			decodeScale[k] = decodeMatrix[k * (size + 1) + k];
		}
		for (var i = 0; i < accessorInfo.count; i++) {
			for (var _k = 0; _k < size; _k++) {
				decodedArr[i * size + _k] = arr[i * size + _k] * decodeScale[_k] + decodeOffset[_k];
			}
		}

		arr = decodedArr;
	}

	// console.log({buffer, byteOffset, ArrayCtor, size, arr});

	return arr;
};

exports.default = {
	load: load,
	parse: parse
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
// xhr.js

var load = function load(mPath, isArrayBuffer) {
	return new Promise(function (resolve, reject) {
		var req = new XMLHttpRequest();
		req.addEventListener('load', function (e) {
			resolve(req.response);
		});

		req.addEventListener('error', function (e) {
			reject(e);
		});

		if (isArrayBuffer) {
			req.responseType = 'arraybuffer';
		}

		req.open('GET', mPath);
		req.send();
	});
};

exports.default = load;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(83);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27), __webpack_require__(84)))

/***/ }),
/* 84 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // EffectComposer.js

var _Pass = __webpack_require__(12);

var _Pass2 = _interopRequireDefault(_Pass);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _FrameBuffer = __webpack_require__(18);

var _FrameBuffer2 = _interopRequireDefault(_FrameBuffer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EffectComposer = function () {
	function EffectComposer(mWidth, mHeight) {
		var mParmas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		_classCallCheck(this, EffectComposer);

		this._width = mWidth || _GLTool2.default.width;
		this._height = mHeight || _GLTool2.default.height;

		this._params = {};
		this.setSize(mWidth, mHeight);
		this._geometry = _Geom2.default.bigTriangle();
		this._passes = [];
		this._returnTexture;
	}

	_createClass(EffectComposer, [{
		key: 'addPass',
		value: function addPass(pass) {
			if (pass.passes) {
				this.addPass(pass.passes);
				return;
			}

			if (pass.length) {
				for (var i = 0; i < pass.length; i++) {
					this._passes.push(pass[i]);
				}
			} else {
				this._passes.push(pass);
			}
		}
	}, {
		key: 'render',
		value: function render(mSource) {
			var _this = this;

			var source = mSource;
			var fboTarget = void 0;

			this._passes.forEach(function (pass) {

				//	get target
				if (pass.hasFbo) {
					fboTarget = pass.fbo;
				} else {
					fboTarget = _this._fboTarget;
				}

				//	render
				fboTarget.bind();
				_GLTool2.default.clear(0, 0, 0, 0);
				pass.render(source);
				_GLTool2.default.draw(_this._geometry);
				fboTarget.unbind();

				//	reset source
				if (pass.hasFbo) {
					source = pass.fbo.getTexture();
				} else {
					_this._swap();
					source = _this._fboCurrent.getTexture();
				}
			});

			this._returnTexture = source;

			return source;
		}
	}, {
		key: '_swap',
		value: function _swap() {
			var tmp = this._fboCurrent;
			this._fboCurrent = this._fboTarget;
			this._fboTarget = tmp;

			this._current = this._fboCurrent;
			this._target = this._fboTarget;
		}
	}, {
		key: 'setSize',
		value: function setSize(mWidth, mHeight) {
			this._width = mWidth;
			this._height = mHeight;
			this._fboCurrent = new _FrameBuffer2.default(this._width, this._height, this._params);
			this._fboTarget = new _FrameBuffer2.default(this._width, this._height, this._params);
		}
	}, {
		key: 'getTexture',
		value: function getTexture() {
			return this._returnTexture;
		}
	}, {
		key: 'passes',
		get: function get() {
			return this._passes;
		}
	}]);

	return EffectComposer;
}();

exports.default = EffectComposer;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _PassVBlur = __webpack_require__(44);

var _PassVBlur2 = _interopRequireDefault(_PassVBlur);

var _PassHBlur = __webpack_require__(46);

var _PassHBlur2 = _interopRequireDefault(_PassHBlur);

var _PassMacro2 = __webpack_require__(43);

var _PassMacro3 = _interopRequireDefault(_PassMacro2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassBlur.js

var PassBlur = function (_PassMacro) {
	_inherits(PassBlur, _PassMacro);

	function PassBlur() {
		var mQuality = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;
		var mWidth = arguments[1];
		var mHeight = arguments[2];
		var mParams = arguments[3];

		_classCallCheck(this, PassBlur);

		var _this = _possibleConstructorReturn(this, (PassBlur.__proto__ || Object.getPrototypeOf(PassBlur)).call(this));

		var vBlur = new _PassVBlur2.default(mQuality, mWidth, mHeight, mParams);
		var hBlur = new _PassHBlur2.default(mQuality, mWidth, mHeight, mParams);

		_this.addPass(vBlur);
		_this.addPass(hBlur);
		return _this;
	}

	return PassBlur;
}(_PassMacro3.default);

exports.default = PassBlur;

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = "// blur5.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_5\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3333333333333333) * direction;\n\tcolor += texture2D(image, uv) * 0.29411764705882354;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;\n\treturn color; \n}\n\n\nvoid main(void) {\n    gl_FragColor = blur5(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = "// blur9.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_9\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.3846153846) * direction;\n\tvec2 off2 = vec2(3.2307692308) * direction;\n\tcolor += texture2D(image, uv) * 0.2270270270;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur9(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = "// blur13.frag\n// source  : https://github.com/Jam3/glsl-fast-gaussian-blur\n\n#define SHADER_NAME BLUR_13\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vTextureCoord;\nuniform sampler2D texture;\nuniform vec2 uDirection;\nuniform vec2 uResolution;\n\nvec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n\tvec4 color = vec4(0.0);\n\tvec2 off1 = vec2(1.411764705882353) * direction;\n\tvec2 off2 = vec2(3.2941176470588234) * direction;\n\tvec2 off3 = vec2(5.176470588235294) * direction;\n\tcolor += texture2D(image, uv) * 0.1964825501511404;\n\tcolor += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;\n\tcolor += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;\n\tcolor += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;\n\tcolor += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;\n\treturn color;\n}\n\n\nvoid main(void) {\n    gl_FragColor = blur13(texture, vTextureCoord, uResolution, uDirection);\n}"

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Pass2 = __webpack_require__(12);

var _Pass3 = _interopRequireDefault(_Pass2);

var _fxaa = __webpack_require__(47);

var _fxaa2 = _interopRequireDefault(_fxaa);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // PassFxaa.js

var PassFxaa = function (_Pass) {
	_inherits(PassFxaa, _Pass);

	function PassFxaa() {
		_classCallCheck(this, PassFxaa);

		var _this = _possibleConstructorReturn(this, (PassFxaa.__proto__ || Object.getPrototypeOf(PassFxaa)).call(this, _fxaa2.default));

		_this.uniform('uResolution', [1 / _GLTool2.default.width, 1 / _GLTool2.default.height]);
		return _this;
	}

	return PassFxaa;
}(_Pass3.default);

exports.default = PassFxaa;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchCopy.js

var vs = __webpack_require__(22);
var fs = __webpack_require__(23);

var BatchCopy = function (_Batch) {
	_inherits(BatchCopy, _Batch);

	function BatchCopy() {
		_classCallCheck(this, BatchCopy);

		var mesh = _Geom2.default.bigTriangle();
		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchCopy.__proto__ || Object.getPrototypeOf(BatchCopy)).call(this, mesh, shader));

		shader.bind();
		shader.uniform('texture', 'uniform1i', 0);
		return _this;
	}

	_createClass(BatchCopy, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchCopy.prototype.__proto__ || Object.getPrototypeOf(BatchCopy.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchCopy;
}(_Batch3.default);

exports.default = BatchCopy;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchAxis.js

var vs = __webpack_require__(93);
var fs = __webpack_require__(94);

var BatchAxis = function (_Batch) {
	_inherits(BatchAxis, _Batch);

	function BatchAxis() {
		_classCallCheck(this, BatchAxis);

		var positions = [];
		var colors = [];
		var indices = [0, 1, 2, 3, 4, 5];
		var r = 9999;

		positions.push([-r, 0, 0]);
		positions.push([r, 0, 0]);
		positions.push([0, -r, 0]);
		positions.push([0, r, 0]);
		positions.push([0, 0, -r]);
		positions.push([0, 0, r]);

		colors.push([1, 0, 0]);
		colors.push([1, 0, 0]);
		colors.push([0, 1, 0]);
		colors.push([0, 1, 0]);
		colors.push([0, 0, 1]);
		colors.push([0, 0, 1]);

		var mesh = new _Geometry2.default(_GLTool2.default.LINES);
		mesh.bufferVertex(positions);
		mesh.bufferIndex(indices);
		mesh.bufferData(colors, 'aColor', 3);

		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchAxis.__proto__ || Object.getPrototypeOf(BatchAxis)).call(this, mesh, shader));
	}

	return BatchAxis;
}(_Batch3.default);

exports.default = BatchAxis;

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = "// axis.vert\n\n#define SHADER_NAME BASIC_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aColor;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vColor = aColor;\n    vNormal = aNormal;\n}"

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = "// axis.frag\n\n#define SHADER_NAME SIMPLE_TEXTURE\n\nprecision lowp float;\n#define GLSLIFY 1\nvarying vec3 vColor;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\t// vec3 color = vNormal;\n\tvec3 color = vColor + vNormal * 0.0001;\n    gl_FragColor = vec4(color, 1.0);\n}"

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchBall.js

var vs = __webpack_require__(37);
var fs = __webpack_require__(11);

var BatchBall = function (_Batch) {
	_inherits(BatchBall, _Batch);

	function BatchBall() {
		_classCallCheck(this, BatchBall);

		var geometry = _Geom2.default.sphere(1, 24);
		var shader = new _GLShader2.default(vs, fs);
		return _possibleConstructorReturn(this, (BatchBall.__proto__ || Object.getPrototypeOf(BatchBall)).call(this, geometry, shader));
	}

	_createClass(BatchBall, [{
		key: 'draw',
		value: function draw() {
			var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
			var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 1, 1];
			var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1];
			var opacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

			this.shader.bind();
			this.shader.uniform('position', 'uniform3fv', position);
			this.shader.uniform('scale', 'uniform3fv', scale);
			this.shader.uniform('color', 'uniform3fv', color);
			this.shader.uniform('opacity', 'uniform1f', opacity);
			_get(BatchBall.prototype.__proto__ || Object.getPrototypeOf(BatchBall.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchBall;
}(_Batch3.default);

exports.default = BatchBall;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchDotsPlane.js

var vs = __webpack_require__(97);
var fs = __webpack_require__(11);

var BatchDotsPlane = function (_Batch) {
	_inherits(BatchDotsPlane, _Batch);

	function BatchDotsPlane() {
		_classCallCheck(this, BatchDotsPlane);

		var positions = [];
		var indices = [];
		var index = 0;
		var size = 100;
		var i = void 0,
		    j = void 0;

		for (i = -size; i < size; i += 1) {
			for (j = -size; j < size; j += 1) {
				positions.push([i, j, 0]);
				indices.push(index);
				index++;

				positions.push([i, 0, j]);
				indices.push(index);
				index++;
			}
		}

		var geometry = new _Geometry2.default(_GLTool2.default.POINTS);
		geometry.bufferVertex(positions);
		geometry.bufferIndex(indices);

		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchDotsPlane.__proto__ || Object.getPrototypeOf(BatchDotsPlane)).call(this, geometry, shader));

		_this.color = [1, 1, 1];
		_this.opacity = 0.5;
		return _this;
	}

	_createClass(BatchDotsPlane, [{
		key: 'draw',
		value: function draw() {
			this.shader.bind();
			this.shader.uniform('color', 'uniform3fv', this.color);
			this.shader.uniform('opacity', 'uniform1f', this.opacity);
			_get(BatchDotsPlane.prototype.__proto__ || Object.getPrototypeOf(BatchDotsPlane.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchDotsPlane;
}(_Batch3.default);

exports.default = BatchDotsPlane;

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "// basic.vert\n\n#define SHADER_NAME DOTS_PLANE_VERTEX\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec3 vNormal;\n\nvoid main(void) {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition + aNormal * 0.000001, 1.0);\n    gl_PointSize = 1.0;\n    vNormal = aNormal;\n}"

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geometry = __webpack_require__(3);

var _Geometry2 = _interopRequireDefault(_Geometry);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchLine.js


var vs = __webpack_require__(15);
var fs = __webpack_require__(11);

var BatchAxis = function (_Batch) {
	_inherits(BatchAxis, _Batch);

	function BatchAxis() {
		_classCallCheck(this, BatchAxis);

		var positions = [];
		var indices = [0, 1];
		var coords = [[0, 0], [1, 1]];
		positions.push([0, 0, 0]);
		positions.push([0, 0, 0]);

		var geometry = new _Geometry2.default(_GLTool2.default.LINES);
		geometry.bufferVertex(positions);
		geometry.bufferTexCoord(coords);
		geometry.bufferIndex(indices);

		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchAxis.__proto__ || Object.getPrototypeOf(BatchAxis)).call(this, geometry, shader));
	}

	_createClass(BatchAxis, [{
		key: 'draw',
		value: function draw(mPositionA, mPositionB) {
			var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [1, 1, 1];
			var opacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;

			this._geometry.bufferVertex([mPositionA, mPositionB]);

			this._shader.bind();
			this._shader.uniform('color', 'vec3', color);
			this._shader.uniform('opacity', 'float', opacity);
			_get(BatchAxis.prototype.__proto__ || Object.getPrototypeOf(BatchAxis.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchAxis;
}(_Batch3.default);

exports.default = BatchAxis;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchSkybox.js

var vs = __webpack_require__(38);
var fs = __webpack_require__(39);

var BatchSkybox = function (_Batch) {
	_inherits(BatchSkybox, _Batch);

	function BatchSkybox() {
		var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;

		_classCallCheck(this, BatchSkybox);

		var geometry = _Geom2.default.skybox(size);
		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchSkybox.__proto__ || Object.getPrototypeOf(BatchSkybox)).call(this, geometry, shader));
	}

	_createClass(BatchSkybox, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchSkybox.prototype.__proto__ || Object.getPrototypeOf(BatchSkybox.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchSkybox;
}(_Batch3.default);

exports.default = BatchSkybox;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchSky.js

var vs = __webpack_require__(101);
var fs = __webpack_require__(23);

var BatchSky = function (_Batch) {
	_inherits(BatchSky, _Batch);

	function BatchSky() {
		var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
		var seg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;

		_classCallCheck(this, BatchSky);

		var geometry = _Geom2.default.sphere(size, seg, true);
		var shader = new _GLShader2.default(vs, fs);

		return _possibleConstructorReturn(this, (BatchSky.__proto__ || Object.getPrototypeOf(BatchSky)).call(this, geometry, shader));
	}

	_createClass(BatchSky, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			_get(BatchSky.prototype.__proto__ || Object.getPrototypeOf(BatchSky.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchSky;
}(_Batch3.default);

exports.default = BatchSky;

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = "// sky.vert\n\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec3 aNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec3 vNormal;\n\nvoid main(void) {\n\tmat4 matView = uViewMatrix;\n\tmatView[3][0] = 0.0;\n\tmatView[3][1] = 0.0;\n\tmatView[3][2] = 0.0;\n\t\n    gl_Position = uProjectionMatrix * matView * uModelMatrix * vec4(aVertexPosition, 1.0);\n    vTextureCoord = aTextureCoord;\n    vNormal = aNormal;\n}"

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _Geom = __webpack_require__(7);

var _Geom2 = _interopRequireDefault(_Geom);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _Batch2 = __webpack_require__(5);

var _Batch3 = _interopRequireDefault(_Batch2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // BatchFXAA.js


var vs = __webpack_require__(22);
var fs = __webpack_require__(47);

var BatchFXAA = function (_Batch) {
	_inherits(BatchFXAA, _Batch);

	function BatchFXAA() {
		_classCallCheck(this, BatchFXAA);

		var geometry = _Geom2.default.bigTriangle();
		var shader = new _GLShader2.default(vs, fs);

		var _this = _possibleConstructorReturn(this, (BatchFXAA.__proto__ || Object.getPrototypeOf(BatchFXAA)).call(this, geometry, shader));

		shader.bind();
		shader.uniform('texture', 'uniform1i', 0);
		return _this;
	}

	_createClass(BatchFXAA, [{
		key: 'draw',
		value: function draw(texture) {
			this.shader.bind();
			texture.bind(0);
			this.shader.uniform('uResolution', 'vec2', [1 / _GLTool2.default.width, 1 / _GLTool2.default.height]);
			_get(BatchFXAA.prototype.__proto__ || Object.getPrototypeOf(BatchFXAA.prototype), 'draw', this).call(this);
		}
	}]);

	return BatchFXAA;
}(_Batch3.default);

exports.default = BatchFXAA;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Scene.js

var _scheduling = __webpack_require__(6);

var _scheduling2 = _interopRequireDefault(_scheduling);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

var _CameraPerspective = __webpack_require__(25);

var _CameraPerspective2 = _interopRequireDefault(_CameraPerspective);

var _CameraOrtho = __webpack_require__(40);

var _CameraOrtho2 = _interopRequireDefault(_CameraOrtho);

var _OrbitalControl = __webpack_require__(36);

var _OrbitalControl2 = _interopRequireDefault(_OrbitalControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scene = function () {
	function Scene() {
		var _this = this;

		_classCallCheck(this, Scene);

		this._children = [];
		this._matrixIdentity = mat4.create();
		_GLTool2.default.enableAlphaBlending();

		this._init();
		this._initTextures();
		this._initViews();

		this._efIndex = _scheduling2.default.addEF(function () {
			return _this._loop();
		});
		window.addEventListener('resize', function () {
			return _this.resize();
		});
	}

	//	PUBLIC METHODS

	_createClass(Scene, [{
		key: 'update',
		value: function update() {}
	}, {
		key: 'render',
		value: function render() {}
	}, {
		key: 'stop',
		value: function stop() {
			if (this._efIndex === -1) {
				return;
			}
			this._efIndex = _scheduling2.default.removeEF(this._efIndex);
		}
	}, {
		key: 'start',
		value: function start() {
			var _this2 = this;

			if (this._efIndex !== -1) {
				return;
			}

			this._efIndex = _scheduling2.default.addEF(function () {
				return _this2._loop();
			});
		}
	}, {
		key: 'resize',
		value: function resize() {
			_GLTool2.default.setSize(window.innerWidth, window.innerHeight);
			this.camera.setAspectRatio(_GLTool2.default.aspectRatio);
		}
	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}

		//	PROTECTED METHODS TO BE OVERRIDEN BY CHILDREN

	}, {
		key: '_initTextures',
		value: function _initTextures() {}
	}, {
		key: '_initViews',
		value: function _initViews() {}
	}, {
		key: '_renderChildren',
		value: function _renderChildren() {
			var child = void 0;
			for (var i = 0; i < this._children.length; i++) {
				child = this._children[i];
				child.toRender();
			}

			_GLTool2.default.rotate(this._matrixIdentity);
		}

		//	PRIVATE METHODS

	}, {
		key: '_init',
		value: function _init() {
			this.camera = new _CameraPerspective2.default();
			this.camera.setPerspective(45 * Math.PI / 180, _GLTool2.default.aspectRatio, 0.1, 100);
			this.orbitalControl = new _OrbitalControl2.default(this.camera, window, 15);
			this.orbitalControl.radius.value = 10;

			this.cameraOrtho = new _CameraOrtho2.default();
		}
	}, {
		key: '_loop',
		value: function _loop() {

			//	RESET VIEWPORT
			_GLTool2.default.viewport(0, 0, _GLTool2.default.width, _GLTool2.default.height);

			//	RESET CAMERA
			_GLTool2.default.setMatrices(this.camera);

			this.update();
			this._renderChildren();
			this.render();
		}
	}]);

	return Scene;
}();

exports.default = Scene;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // View.js

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var View = function () {
	function View(mStrVertex, mStrFrag) {
		_classCallCheck(this, View);

		this.shader = new _GLShader2.default(mStrVertex, mStrFrag);

		this._init();
	}

	//	PROTECTED METHODS

	_createClass(View, [{
		key: '_init',
		value: function _init() {}

		// 	PUBLIC METHODS

	}, {
		key: 'render',
		value: function render() {}
	}]);

	return View;
}();

exports.default = View;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Object3D2 = __webpack_require__(8);

var _Object3D3 = _interopRequireDefault(_Object3D2);

var _GLShader = __webpack_require__(1);

var _GLShader2 = _interopRequireDefault(_GLShader);

var _GLTool = __webpack_require__(0);

var _GLTool2 = _interopRequireDefault(_GLTool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // View3D.js

var View3D = function (_Object3D) {
	_inherits(View3D, _Object3D);

	function View3D(mStrVertex, mStrFrag) {
		_classCallCheck(this, View3D);

		var _this = _possibleConstructorReturn(this, (View3D.__proto__ || Object.getPrototypeOf(View3D)).call(this));

		_this._children = [];
		_this.shader = new _GLShader2.default(mStrVertex, mStrFrag);
		_this._init();
		_this._matrixTemp = mat4.create();
		return _this;
	}

	//	PROTECTED METHODS

	_createClass(View3D, [{
		key: '_init',
		value: function _init() {}

		// 	PUBLIC METHODS

	}, {
		key: 'addChild',
		value: function addChild(mChild) {
			this._children.push(mChild);
		}
	}, {
		key: 'removeChild',
		value: function removeChild(mChild) {
			var index = this._children.indexOf(mChild);
			if (index == -1) {
				console.warn('Child no exist');return;
			}

			this._children.splice(index, 1);
		}
	}, {
		key: 'toRender',
		value: function toRender(matrix) {
			if (matrix === undefined) {
				matrix = mat4.create();
			}
			mat4.mul(this._matrixTemp, matrix, this.matrix);
			_GLTool2.default.rotate(this._matrixTemp);
			this.render();

			for (var i = 0; i < this._children.length; i++) {
				var child = this._children[i];
				child.toRender(this.matrix);
			}
		}
	}, {
		key: 'render',
		value: function render() {}
	}]);

	return View3D;
}(_Object3D3.default);

exports.default = View3D;

/***/ }),
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _datGui = __webpack_require__(133);

var _datGui2 = _interopRequireDefault(_datGui);

var _stats = __webpack_require__(136);

var _stats2 = _interopRequireDefault(_stats);

var _alfrid = __webpack_require__(28);

var _alfrid2 = _interopRequireDefault(_alfrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//	INIT DAT-GUI
window.gui = new _datGui2.default.GUI({ width: 300 }); // debug.js

var div = document.body.querySelector('.dg.ac');
div.style.zIndex = '999';

//	STATS
var stats = new _stats2.default();
document.body.appendChild(stats.domElement);
_alfrid2.default.Scheduler.addEF(function () {
  return stats.update();
});

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(134)
module.exports.color = __webpack_require__(135)

/***/ }),
/* 134 */
/***/ (function(module, exports) {

/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.gui = dat.gui || {};

/** @namespace */
dat.utils = dat.utils || {};

/** @namespace */
dat.controllers = dat.controllers || {};

/** @namespace */
dat.dom = dat.dom || {};

/** @namespace */
dat.color = dat.color || {};

dat.utils.css = (function () {
  return {
    load: function (url, doc) {
      doc = doc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function(css, doc) {
      doc = doc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = css;
      doc.getElementsByTagName('head')[0].appendChild(injected);
    }
  }
})();


dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.controllers.Controller = (function (common) {

  /**
   * @class An "abstract" class that represents a given property of an object.
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var Controller = function(object, property) {

    this.initialValue = object[property];

    /**
     * Those who extend this class will put their DOM elements in here.
     * @type {DOMElement}
     */
    this.domElement = document.createElement('div');

    /**
     * The object to manipulate
     * @type {Object}
     */
    this.object = object;

    /**
     * The name of the property to manipulate
     * @type {String}
     */
    this.property = property;

    /**
     * The function to be called on change.
     * @type {Function}
     * @ignore
     */
    this.__onChange = undefined;

    /**
     * The function to be called on finishing change.
     * @type {Function}
     * @ignore
     */
    this.__onFinishChange = undefined;

  };

  common.extend(

      Controller.prototype,

      /** @lends dat.controllers.Controller.prototype */
      {

        /**
         * Specify that a function fire every time someone changes the value with
         * this Controller.
         *
         * @param {Function} fnc This function will be called whenever the value
         * is modified via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onChange: function(fnc) {
          this.__onChange = fnc;
          return this;
        },

        /**
         * Specify that a function fire every time someone "finishes" changing
         * the value wih this Controller. Useful for values that change
         * incrementally like numbers or strings.
         *
         * @param {Function} fnc This function will be called whenever
         * someone "finishes" changing the value via this Controller.
         * @returns {dat.controllers.Controller} this
         */
        onFinishChange: function(fnc) {
          this.__onFinishChange = fnc;
          return this;
        },

        /**
         * Change the value of <code>object[property]</code>
         *
         * @param {Object} newValue The new value of <code>object[property]</code>
         */
        setValue: function(newValue) {
          this.object[this.property] = newValue;
          if (this.__onChange) {
            this.__onChange.call(this, newValue);
          }
          this.updateDisplay();
          return this;
        },

        /**
         * Gets the value of <code>object[property]</code>
         *
         * @returns {Object} The current value of <code>object[property]</code>
         */
        getValue: function() {
          return this.object[this.property];
        },

        /**
         * Refreshes the visual display of a Controller in order to keep sync
         * with the object's current value.
         * @returns {dat.controllers.Controller} this
         */
        updateDisplay: function() {
          return this;
        },

        /**
         * @returns {Boolean} true if the value has deviated from initialValue
         */
        isModified: function() {
          return this.initialValue !== this.getValue()
        }

      }

  );

  return Controller;


})(dat.utils.common);


dat.dom.dom = (function (common) {

  var EVENT_MAP = {
    'HTMLEvents': ['change'],
    'MouseEvents': ['click','mousemove','mousedown','mouseup', 'mouseover'],
    'KeyboardEvents': ['keydown']
  };

  var EVENT_MAP_INV = {};
  common.each(EVENT_MAP, function(v, k) {
    common.each(v, function(e) {
      EVENT_MAP_INV[e] = k;
    });
  });

  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {

    if (val === '0' || common.isUndefined(val)) return 0;

    var match = val.match(CSS_VALUE_PIXELS);

    if (!common.isNull(match)) {
      return parseFloat(match[1]);
    }

    // TODO ...ems? %?

    return 0;

  }

  /**
   * @namespace
   * @member dat.dom
   */
  var dom = {

    /**
     * 
     * @param elem
     * @param selectable
     */
    makeSelectable: function(elem, selectable) {

      if (elem === undefined || elem.style === undefined) return;

      elem.onselectstart = selectable ? function() {
        return false;
      } : function() {
      };

      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';

    },

    /**
     *
     * @param elem
     * @param horizontal
     * @param vertical
     */
    makeFullscreen: function(elem, horizontal, vertical) {

      if (common.isUndefined(horizontal)) horizontal = true;
      if (common.isUndefined(vertical)) vertical = true;

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }
      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }

    },

    /**
     *
     * @param elem
     * @param eventType
     * @param params
     */
    fakeEvent: function(elem, eventType, params, aux) {
      params = params || {};
      var className = EVENT_MAP_INV[eventType];
      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }
      var evt = document.createEvent(className);
      switch (className) {
        case 'MouseEvents':
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false,
              params.cancelable || true, window, params.clickCount || 1,
              0, //screen X
              0, //screen Y
              clientX, //client X
              clientY, //client Y
              false, false, false, false, 0, null);
          break;
        case 'KeyboardEvents':
          var init = evt.initKeyboardEvent || evt.initKeyEvent; // webkit || moz
          common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false,
              params.cancelable, window,
              params.ctrlKey, params.altKey,
              params.shiftKey, params.metaKey,
              params.keyCode, params.charCode);
          break;
        default:
          evt.initEvent(eventType, params.bubbles || false,
              params.cancelable || true);
          break;
      }
      common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    bind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.addEventListener)
        elem.addEventListener(event, func, bool);
      else if (elem.attachEvent)
        elem.attachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param event
     * @param func
     * @param bool
     */
    unbind: function(elem, event, func, bool) {
      bool = bool || false;
      if (elem.removeEventListener)
        elem.removeEventListener(event, func, bool);
      else if (elem.detachEvent)
        elem.detachEvent('on' + event, func);
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    addClass: function(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);
        if (classes.indexOf(className) == -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }
      return dom;
    },

    /**
     *
     * @param elem
     * @param className
     */
    removeClass: function(elem, className) {
      if (className) {
        if (elem.className === undefined) {
          // elem.className = className;
        } else if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);
          if (index != -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }
      return dom;
    },

    hasClass: function(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },

    /**
     *
     * @param elem
     */
    getWidth: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-left-width']) +
          cssValueToPixels(style['border-right-width']) +
          cssValueToPixels(style['padding-left']) +
          cssValueToPixels(style['padding-right']) +
          cssValueToPixels(style['width']);
    },

    /**
     *
     * @param elem
     */
    getHeight: function(elem) {

      var style = getComputedStyle(elem);

      return cssValueToPixels(style['border-top-width']) +
          cssValueToPixels(style['border-bottom-width']) +
          cssValueToPixels(style['padding-top']) +
          cssValueToPixels(style['padding-bottom']) +
          cssValueToPixels(style['height']);
    },

    /**
     *
     * @param elem
     */
    getOffset: function(elem) {
      var offset = {left: 0, top:0};
      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
        } while (elem = elem.offsetParent);
      }
      return offset;
    },

    // http://stackoverflow.com/posts/2684561/revisions
    /**
     * 
     * @param elem
     */
    isActive: function(elem) {
      return elem === document.activeElement && ( elem.type || elem.href );
    }

  };

  return dom;

})(dat.utils.common);


dat.controllers.OptionController = (function (Controller, dom, common) {

  /**
   * @class Provides a select input to alter the property of an object, using a
   * list of accepted values.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object|string[]} options A map of labels to acceptable values, or
   * a list of acceptable string values.
   *
   * @member dat.controllers
   */
  var OptionController = function(object, property, options) {

    OptionController.superclass.call(this, object, property);

    var _this = this;

    /**
     * The drop down menu
     * @ignore
     */
    this.__select = document.createElement('select');

    if (common.isArray(options)) {
      var map = {};
      common.each(options, function(element) {
        map[element] = element;
      });
      options = map;
    }

    common.each(options, function(value, key) {

      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);

    });

    // Acknowledge original value
    this.updateDisplay();

    dom.bind(this.__select, 'change', function() {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });

    this.domElement.appendChild(this.__select);

  };

  OptionController.superclass = Controller;

  common.extend(

      OptionController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = OptionController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          return toReturn;
        },

        updateDisplay: function() {
          this.__select.value = this.getValue();
          return OptionController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return OptionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberController = (function (Controller, common) {

  /**
   * @class Represents a given property of an object that is a number.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberController = function(object, property, params) {

    NumberController.superclass.call(this, object, property);

    params = params || {};

    this.__min = params.min;
    this.__max = params.max;
    this.__step = params.step;

    if (common.isUndefined(this.__step)) {

      if (this.initialValue == 0) {
        this.__impliedStep = 1; // What are we, psychics?
      } else {
        // Hey Doug, check this out.
        this.__impliedStep = Math.pow(10, Math.floor(Math.log(this.initialValue)/Math.LN10))/10;
      }

    } else {

      this.__impliedStep = this.__step;

    }

    this.__precision = numDecimals(this.__impliedStep);


  };

  NumberController.superclass = Controller;

  common.extend(

      NumberController.prototype,
      Controller.prototype,

      /** @lends dat.controllers.NumberController.prototype */
      {

        setValue: function(v) {

          if (this.__min !== undefined && v < this.__min) {
            v = this.__min;
          } else if (this.__max !== undefined && v > this.__max) {
            v = this.__max;
          }

          if (this.__step !== undefined && v % this.__step != 0) {
            v = Math.round(v / this.__step) * this.__step;
          }

          return NumberController.superclass.prototype.setValue.call(this, v);

        },

        /**
         * Specify a minimum value for <code>object[property]</code>.
         *
         * @param {Number} minValue The minimum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        min: function(v) {
          this.__min = v;
          return this;
        },

        /**
         * Specify a maximum value for <code>object[property]</code>.
         *
         * @param {Number} maxValue The maximum value for
         * <code>object[property]</code>
         * @returns {dat.controllers.NumberController} this
         */
        max: function(v) {
          this.__max = v;
          return this;
        },

        /**
         * Specify a step value that dat.controllers.NumberController
         * increments by.
         *
         * @param {Number} stepValue The step value for
         * dat.controllers.NumberController
         * @default if minimum and maximum specified increment is 1% of the
         * difference otherwise stepValue is 1
         * @returns {dat.controllers.NumberController} this
         */
        step: function(v) {
          this.__step = v;
          return this;
        }

      }

  );

  function numDecimals(x) {
    x = x.toString();
    if (x.indexOf('.') > -1) {
      return x.length - x.indexOf('.') - 1;
    } else {
      return 0;
    }
  }

  return NumberController;

})(dat.controllers.Controller,
dat.utils.common);


dat.controllers.NumberControllerBox = (function (NumberController, dom, common) {

  /**
   * @class Represents a given property of an object that is a number and
   * provides an input element with which to manipulate it.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Object} [params] Optional parameters
   * @param {Number} [params.min] Minimum allowed value
   * @param {Number} [params.max] Maximum allowed value
   * @param {Number} [params.step] Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerBox = function(object, property, params) {

    this.__truncationSuspended = false;

    NumberControllerBox.superclass.call(this, object, property, params);

    var _this = this;

    /**
     * {Number} Previous mouse y position
     * @ignore
     */
    var prev_y;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    // Makes it so manually specified values are not truncated.

    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'mousedown', onMouseDown);
    dom.bind(this.__input, 'keydown', function(e) {

      // When pressing entire, you can be as precise as you want.
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
      }

    });

    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!common.isNaN(attempted)) _this.setValue(attempted);
    }

    function onBlur() {
      onChange();
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prev_y = e.clientY;
    }

    function onMouseDrag(e) {

      var diff = prev_y - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);

      prev_y = e.clientY;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  NumberControllerBox.superclass = NumberController;

  common.extend(

      NumberControllerBox.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {

          this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
          return NumberControllerBox.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  return NumberControllerBox;

})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.common);


dat.controllers.NumberControllerSlider = (function (NumberController, dom, css, common, styleSheet) {

  /**
   * @class Represents a given property of an object that is a number, contains
   * a minimum and maximum, and provides a slider element with which to
   * manipulate it. It should be noted that the slider element is made up of
   * <code>&lt;div&gt;</code> tags, <strong>not</strong> the html5
   * <code>&lt;slider&gt;</code> element.
   *
   * @extends dat.controllers.Controller
   * @extends dat.controllers.NumberController
   * 
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   * @param {Number} minValue Minimum allowed value
   * @param {Number} maxValue Maximum allowed value
   * @param {Number} stepValue Increment by which to change value
   *
   * @member dat.controllers
   */
  var NumberControllerSlider = function(object, property, min, max, step) {

    NumberControllerSlider.superclass.call(this, object, property, { min: min, max: max, step: step });

    var _this = this;

    this.__background = document.createElement('div');
    this.__foreground = document.createElement('div');
    


    dom.bind(this.__background, 'mousedown', onMouseDown);
    
    dom.addClass(this.__background, 'slider');
    dom.addClass(this.__foreground, 'slider-fg');

    function onMouseDown(e) {

      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);

      onMouseDrag(e);
    }

    function onMouseDrag(e) {

      e.preventDefault();

      var offset = dom.getOffset(_this.__background);
      var width = dom.getWidth(_this.__background);
      
      _this.setValue(
        map(e.clientX, offset.left, offset.left + width, _this.__min, _this.__max)
      );

      return false;

    }

    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.__background.appendChild(this.__foreground);
    this.domElement.appendChild(this.__background);

  };

  NumberControllerSlider.superclass = NumberController;

  /**
   * Injects default stylesheet for slider elements.
   */
  NumberControllerSlider.useDefaultStyles = function() {
    css.inject(styleSheet);
  };

  common.extend(

      NumberControllerSlider.prototype,
      NumberController.prototype,

      {

        updateDisplay: function() {
          var pct = (this.getValue() - this.__min)/(this.__max - this.__min);
          this.__foreground.style.width = pct*100+'%';
          return NumberControllerSlider.superclass.prototype.updateDisplay.call(this);
        }

      }



  );

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  return NumberControllerSlider;
  
})(dat.controllers.NumberController,
dat.dom.dom,
dat.utils.css,
dat.utils.common,
".slider {\n  box-shadow: inset 0 2px 4px rgba(0,0,0,0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden;\n}\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em;\n}\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border:  1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em;\n}");


dat.controllers.FunctionController = (function (Controller, dom, common) {

  /**
   * @class Provides a GUI interface to fire a specified method, a property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var FunctionController = function(object, property, text) {

    FunctionController.superclass.call(this, object, property);

    var _this = this;

    this.__button = document.createElement('div');
    this.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(this.__button, 'click', function(e) {
      e.preventDefault();
      _this.fire();
      return false;
    });

    dom.addClass(this.__button, 'button');

    this.domElement.appendChild(this.__button);


  };

  FunctionController.superclass = Controller;

  common.extend(

      FunctionController.prototype,
      Controller.prototype,
      {
        
        fire: function() {
          if (this.__onChange) {
            this.__onChange.call(this);
          }
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.getValue().call(this.object);
        }
      }

  );

  return FunctionController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.controllers.BooleanController = (function (Controller, dom, common) {

  /**
   * @class Provides a checkbox input to alter the boolean property of an object.
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var BooleanController = function(object, property) {

    BooleanController.superclass.call(this, object, property);

    var _this = this;
    this.__prev = this.getValue();

    this.__checkbox = document.createElement('input');
    this.__checkbox.setAttribute('type', 'checkbox');


    dom.bind(this.__checkbox, 'change', onChange, false);

    this.domElement.appendChild(this.__checkbox);

    // Match original value
    this.updateDisplay();

    function onChange() {
      _this.setValue(!_this.__prev);
    }

  };

  BooleanController.superclass = Controller;

  common.extend(

      BooleanController.prototype,
      Controller.prototype,

      {

        setValue: function(v) {
          var toReturn = BooleanController.superclass.prototype.setValue.call(this, v);
          if (this.__onFinishChange) {
            this.__onFinishChange.call(this, this.getValue());
          }
          this.__prev = this.getValue();
          return toReturn;
        },

        updateDisplay: function() {
          
          if (this.getValue() === true) {
            this.__checkbox.setAttribute('checked', 'checked');
            this.__checkbox.checked = true;    
          } else {
              this.__checkbox.checked = false;
          }

          return BooleanController.superclass.prototype.updateDisplay.call(this);

        }


      }

  );

  return BooleanController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common);


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common);


dat.GUI = dat.gui.GUI = (function (css, saveDialogueContents, styleSheet, controllerFactory, Controller, BooleanController, FunctionController, NumberControllerBox, NumberControllerSlider, OptionController, ColorController, requestAnimationFrame, CenteredDiv, dom, common) {

  css.inject(styleSheet);

  /** Outer-most className for GUI's */
  var CSS_NAMESPACE = 'dg';

  var HIDE_KEY_CODE = 72;

  /** The only value shared between the JS and SCSS. Use caution. */
  var CLOSE_BUTTON_HEIGHT = 20;

  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = (function() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  })();

  var SAVE_DIALOGUE;

  /** Have we yet to create an autoPlace GUI? */
  var auto_place_virgin = true;

  /** Fixed position div that auto place GUI's go inside */
  var auto_place_container;

  /** Are we hiding the GUI's ? */
  var hide = false;

  /** GUI's which should be hidden */
  var hideable_guis = [];

  /**
   * A lightweight controller library for JavaScript. It allows you to easily
   * manipulate variables and fire functions on the fly.
   * @class
   *
   * @member dat.gui
   *
   * @param {Object} [params]
   * @param {String} [params.name] The name of this GUI.
   * @param {Object} [params.load] JSON object representing the saved state of
   * this GUI.
   * @param {Boolean} [params.auto=true]
   * @param {dat.gui.GUI} [params.parent] The GUI I'm nested in.
   * @param {Boolean} [params.closed] If true, starts closed
   */
  var GUI = function(params) {

    var _this = this;

    /**
     * Outermost DOM Element
     * @type DOMElement
     */
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);

    dom.addClass(this.domElement, CSS_NAMESPACE);

    /**
     * Nested GUI's by name
     * @ignore
     */
    this.__folders = {};

    this.__controllers = [];

    /**
     * List of objects I'm remembering for save, only used in top level GUI
     * @ignore
     */
    this.__rememberedObjects = [];

    /**
     * Maps the index of remembered objects to a map of controllers, only used
     * in top level GUI.
     *
     * @private
     * @ignore
     *
     * @example
     * [
     *  {
     *    propertyName: Controller,
     *    anotherPropertyName: Controller
     *  },
     *  {
     *    propertyName: Controller
     *  }
     * ]
     */
    this.__rememberedObjectIndecesToControllers = [];

    this.__listening = [];

    params = params || {};

    // Default parameters
    params = common.defaults(params, {
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });

    params = common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });


    if (!common.isUndefined(params.load)) {

      // Explicit preset
      if (params.preset) params.load.preset = params.preset;

    } else {

      params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };

    }

    if (common.isUndefined(params.parent) && params.hideable) {
      hideable_guis.push(this);
    }

    // Only root level GUI's are resizable.
    params.resizable = common.isUndefined(params.parent) && params.resizable;


    if (params.autoPlace && common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }
//    params.scrollable = common.isUndefined(params.parent) && params.scrollable === true;

    // Not part of params because I don't want people passing this in via
    // constructor. Should be a 'remembered' value.
    var use_local_storage =
        SUPPORTS_LOCAL_STORAGE &&
            localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';

    Object.defineProperties(this,

        /** @lends dat.gui.GUI.prototype */
        {

          /**
           * The parent <code>GUI</code>
           * @type dat.gui.GUI
           */
          parent: {
            get: function() {
              return params.parent;
            }
          },

          scrollable: {
            get: function() {
              return params.scrollable;
            }
          },

          /**
           * Handles <code>GUI</code>'s element placement for you
           * @type Boolean
           */
          autoPlace: {
            get: function() {
              return params.autoPlace;
            }
          },

          /**
           * The identifier for a set of saved values
           * @type String
           */
          preset: {

            get: function() {
              if (_this.parent) {
                return _this.getRoot().preset;
              } else {
                return params.load.preset;
              }
            },

            set: function(v) {
              if (_this.parent) {
                _this.getRoot().preset = v;
              } else {
                params.load.preset = v;
              }
              setPresetSelectIndex(this);
              _this.revert();
            }

          },

          /**
           * The width of <code>GUI</code> element
           * @type Number
           */
          width: {
            get: function() {
              return params.width;
            },
            set: function(v) {
              params.width = v;
              setWidth(_this, v);
            }
          },

          /**
           * The name of <code>GUI</code>. Used for folders. i.e
           * a folder's name
           * @type String
           */
          name: {
            get: function() {
              return params.name;
            },
            set: function(v) {
              // TODO Check for collisions among sibling folders
              params.name = v;
              if (title_row_name) {
                title_row_name.innerHTML = params.name;
              }
            }
          },

          /**
           * Whether the <code>GUI</code> is collapsed or not
           * @type Boolean
           */
          closed: {
            get: function() {
              return params.closed;
            },
            set: function(v) {
              params.closed = v;
              if (params.closed) {
                dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
              } else {
                dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
              }
              // For browsers that aren't going to respect the CSS transition,
              // Lets just check our height against the window height right off
              // the bat.
              this.onResize();

              if (_this.__closeButton) {
                _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
              }
            }
          },

          /**
           * Contains all presets
           * @type Object
           */
          load: {
            get: function() {
              return params.load;
            }
          },

          /**
           * Determines whether or not to use <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage">localStorage</a> as the means for
           * <code>remember</code>ing
           * @type Boolean
           */
          useLocalStorage: {

            get: function() {
              return use_local_storage;
            },
            set: function(bool) {
              if (SUPPORTS_LOCAL_STORAGE) {
                use_local_storage = bool;
                if (bool) {
                  dom.bind(window, 'unload', saveToLocalStorage);
                } else {
                  dom.unbind(window, 'unload', saveToLocalStorage);
                }
                localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
              }
            }

          }

        });

    // Are we a root level GUI?
    if (common.isUndefined(params.parent)) {

      params.closed = false;

      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      // Are we supposed to be loading locally?
      if (SUPPORTS_LOCAL_STORAGE) {

        if (use_local_storage) {

          _this.useLocalStorage = true;

          var saved_gui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (saved_gui) {
            params.load = JSON.parse(saved_gui);
          }

        }

      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
      this.domElement.appendChild(this.__closeButton);

      dom.bind(this.__closeButton, 'click', function() {

        _this.closed = !_this.closed;


      });


      // Oh, you're a nested GUI!
    } else {

      if (params.closed === undefined) {
        params.closed = true;
      }

      var title_row_name = document.createTextNode(params.name);
      dom.addClass(title_row_name, 'controller-name');

      var title_row = addRow(_this, title_row_name);

      var on_click_title = function(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);

      dom.addClass(title_row, 'title');
      dom.bind(title_row, 'click', on_click_title);

      if (!params.closed) {
        this.closed = false;
      }

    }

    if (params.autoPlace) {

      if (common.isUndefined(params.parent)) {

        if (auto_place_virgin) {
          auto_place_container = document.createElement('div');
          dom.addClass(auto_place_container, CSS_NAMESPACE);
          dom.addClass(auto_place_container, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(auto_place_container);
          auto_place_virgin = false;
        }

        // Put it in the dom for you.
        auto_place_container.appendChild(this.domElement);

        // Apply the auto styles
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);

      }


      // Make it not elastic.
      if (!this.parent) setWidth(_this, params.width);

    }

    dom.bind(window, 'resize', function() { _this.onResize() });
    dom.bind(this.__ul, 'webkitTransitionEnd', function() { _this.onResize(); });
    dom.bind(this.__ul, 'transitionend', function() { _this.onResize() });
    dom.bind(this.__ul, 'oTransitionEnd', function() { _this.onResize() });
    this.onResize();


    if (params.resizable) {
      addResizeHandle(this);
    }

    function saveToLocalStorage() {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }

    var root = _this.getRoot();
    function resetWidth() {
        var root = _this.getRoot();
        root.width += 1;
        common.defer(function() {
          root.width -= 1;
        });
      }

      if (!params.parent) {
        resetWidth();
      }

  };

  GUI.toggleHide = function() {

    hide = !hide;
    common.each(hideable_guis, function(gui) {
      gui.domElement.style.zIndex = hide ? -999 : 999;
      gui.domElement.style.opacity = hide ? 0 : 1;
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_DRAG = 'drag';

  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  dom.bind(window, 'keydown', function(e) {

    if (document.activeElement.type !== 'text' &&
        (e.which === HIDE_KEY_CODE || e.keyCode == HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }

  }, false);

  common.extend(

      GUI.prototype,

      /** @lends dat.gui.GUI */
      {

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.Controller} The new controller that was added.
         * @instance
         */
        add: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
              }
          );

        },

        /**
         * @param object
         * @param property
         * @returns {dat.controllers.ColorController} The new controller that was added.
         * @instance
         */
        addColor: function(object, property) {

          return add(
              this,
              object,
              property,
              {
                color: true
              }
          );

        },

        /**
         * @param controller
         * @instance
         */
        remove: function(controller) {

          // TODO listening?
          this.__ul.removeChild(controller.__li);
          this.__controllers.slice(this.__controllers.indexOf(controller), 1);
          var _this = this;
          common.defer(function() {
            _this.onResize();
          });

        },

        destroy: function() {

          if (this.autoPlace) {
            auto_place_container.removeChild(this.domElement);
          }

        },

        /**
         * @param name
         * @returns {dat.gui.GUI} The new folder.
         * @throws {Error} if this GUI already has a folder by the specified
         * name
         * @instance
         */
        addFolder: function(name) {

          // We have to prevent collisions on names in order to have a key
          // by which to remember saved values
          if (this.__folders[name] !== undefined) {
            throw new Error('You already have a folder in this GUI by the' +
                ' name "' + name + '"');
          }

          var new_gui_params = { name: name, parent: this };

          // We need to pass down the autoPlace trait so that we can
          // attach event listeners to open/close folder actions to
          // ensure that a scrollbar appears if the window is too short.
          new_gui_params.autoPlace = this.autoPlace;

          // Do we have saved appearance data for this folder?

          if (this.load && // Anything loaded?
              this.load.folders && // Was my parent a dead-end?
              this.load.folders[name]) { // Did daddy remember me?

            // Start me closed if I was closed
            new_gui_params.closed = this.load.folders[name].closed;

            // Pass down the loaded data
            new_gui_params.load = this.load.folders[name];

          }

          var gui = new GUI(new_gui_params);
          this.__folders[name] = gui;

          var li = addRow(this, gui.domElement);
          dom.addClass(li, 'folder');
          return gui;

        },

        open: function() {
          this.closed = false;
        },

        close: function() {
          this.closed = true;
        },

        onResize: function() {

          var root = this.getRoot();

          if (root.scrollable) {

            var top = dom.getOffset(root.__ul).top;
            var h = 0;

            common.each(root.__ul.childNodes, function(node) {
              if (! (root.autoPlace && node === root.__save_row))
                h += dom.getHeight(node);
            });

            if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
              dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
            } else {
              dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
              root.__ul.style.height = 'auto';
            }

          }

          if (root.__resize_handle) {
            common.defer(function() {
              root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
            });
          }

          if (root.__closeButton) {
            root.__closeButton.style.width = root.width + 'px';
          }

        },

        /**
         * Mark objects for saving. The order of these objects cannot change as
         * the GUI grows. When remembering new objects, append them to the end
         * of the list.
         *
         * @param {Object...} objects
         * @throws {Error} if not called on a top level GUI.
         * @instance
         */
        remember: function() {

          if (common.isUndefined(SAVE_DIALOGUE)) {
            SAVE_DIALOGUE = new CenteredDiv();
            SAVE_DIALOGUE.domElement.innerHTML = saveDialogueContents;
          }

          if (this.parent) {
            throw new Error("You can only call remember on a top level GUI.");
          }

          var _this = this;

          common.each(Array.prototype.slice.call(arguments), function(object) {
            if (_this.__rememberedObjects.length == 0) {
              addSaveMenu(_this);
            }
            if (_this.__rememberedObjects.indexOf(object) == -1) {
              _this.__rememberedObjects.push(object);
            }
          });

          if (this.autoPlace) {
            // Set save row width
            setWidth(this, this.width);
          }

        },

        /**
         * @returns {dat.gui.GUI} the topmost parent GUI of a nested GUI.
         * @instance
         */
        getRoot: function() {
          var gui = this;
          while (gui.parent) {
            gui = gui.parent;
          }
          return gui;
        },

        /**
         * @returns {Object} a JSON object representing the current state of
         * this GUI as well as its remembered properties.
         * @instance
         */
        getSaveObject: function() {

          var toReturn = this.load;

          toReturn.closed = this.closed;

          // Am I remembering any values?
          if (this.__rememberedObjects.length > 0) {

            toReturn.preset = this.preset;

            if (!toReturn.remembered) {
              toReturn.remembered = {};
            }

            toReturn.remembered[this.preset] = getCurrentPreset(this);

          }

          toReturn.folders = {};
          common.each(this.__folders, function(element, key) {
            toReturn.folders[key] = element.getSaveObject();
          });

          return toReturn;

        },

        save: function() {

          if (!this.load.remembered) {
            this.load.remembered = {};
          }

          this.load.remembered[this.preset] = getCurrentPreset(this);
          markPresetModified(this, false);

        },

        saveAs: function(presetName) {

          if (!this.load.remembered) {

            // Retain default values upon first save
            this.load.remembered = {};
            this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);

          }

          this.load.remembered[presetName] = getCurrentPreset(this);
          this.preset = presetName;
          addPresetOption(this, presetName, true);

        },

        revert: function(gui) {

          common.each(this.__controllers, function(controller) {
            // Make revert work on Default.
            if (!this.getRoot().load.remembered) {
              controller.setValue(controller.initialValue);
            } else {
              recallSavedValue(gui || this.getRoot(), controller);
            }
          }, this);

          common.each(this.__folders, function(folder) {
            folder.revert(folder);
          });

          if (!gui) {
            markPresetModified(this.getRoot(), false);
          }


        },

        listen: function(controller) {

          var init = this.__listening.length == 0;
          this.__listening.push(controller);
          if (init) updateDisplays(this.__listening);

        }

      }

  );

  function add(gui, object, property, params) {

    if (object[property] === undefined) {
      throw new Error("Object " + object + " has no property \"" + property + "\"");
    }

    var controller;

    if (params.color) {

      controller = new ColorController(object, property);

    } else {

      var factoryArgs = [object,property].concat(params.factoryArgs);
      controller = controllerFactory.apply(gui, factoryArgs);

    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);

    dom.addClass(controller.domElement, 'c');

    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;

    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);

    var li = addRow(gui, container, params.before);

    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
    dom.addClass(li, typeof controller.getValue());

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;

  }

  /**
   * Add a row to the end of the GUI or before another row.
   *
   * @param gui
   * @param [dom] If specified, inserts the dom content in the new row
   * @param [liBefore] If specified, places the new row before another row
   */
  function addRow(gui, dom, liBefore) {
    var li = document.createElement('li');
    if (dom) li.appendChild(dom);
    if (liBefore) {
      gui.__ul.insertBefore(li, params.before);
    } else {
      gui.__ul.appendChild(li);
    }
    gui.onResize();
    return li;
  }

  function augmentController(gui, li, controller) {

    controller.__li = li;
    controller.__gui = gui;

    common.extend(controller, {

      options: function(options) {

        if (arguments.length > 1) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [common.toArray(arguments)]
              }
          );

        }

        if (common.isArray(options) || common.isObject(options)) {
          controller.remove();

          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [options]
              }
          );

        }

      },

      name: function(v) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = v;
        return controller;
      },

      listen: function() {
        controller.__gui.listen(controller);
        return controller;
      },

      remove: function() {
        controller.__gui.remove(controller);
        return controller;
      }

    });

    // All sliders should be accompanied by a box.
    if (controller instanceof NumberControllerSlider) {

      var box = new NumberControllerBox(controller.object, controller.property,
          { min: controller.__min, max: controller.__max, step: controller.__step });

      common.each(['updateDisplay', 'onChange', 'onFinishChange'], function(method) {
        var pc = controller[method];
        var pb = box[method];
        controller[method] = box[method] = function() {
          var args = Array.prototype.slice.call(arguments);
          pc.apply(controller, args);
          return pb.apply(box, args);
        }
      });

      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);

    }
    else if (controller instanceof NumberControllerBox) {

      var r = function(returned) {

        // Have we defined both boundaries?
        if (common.isNumber(controller.__min) && common.isNumber(controller.__max)) {

          // Well, then lets just replace this with a slider.
          controller.remove();
          return add(
              gui,
              controller.object,
              controller.property,
              {
                before: controller.__li.nextElementSibling,
                factoryArgs: [controller.__min, controller.__max, controller.__step]
              });

        }

        return returned;

      };

      controller.min = common.compose(r, controller.min);
      controller.max = common.compose(r, controller.max);

    }
    else if (controller instanceof BooleanController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__checkbox, 'click');
      });

      dom.bind(controller.__checkbox, 'click', function(e) {
        e.stopPropagation(); // Prevents double-toggle
      })

    }
    else if (controller instanceof FunctionController) {

      dom.bind(li, 'click', function() {
        dom.fakeEvent(controller.__button, 'click');
      });

      dom.bind(li, 'mouseover', function() {
        dom.addClass(controller.__button, 'hover');
      });

      dom.bind(li, 'mouseout', function() {
        dom.removeClass(controller.__button, 'hover');
      });

    }
    else if (controller instanceof ColorController) {

      dom.addClass(li, 'color');
      controller.updateDisplay = common.compose(function(r) {
        li.style.borderLeftColor = controller.__color.toString();
        return r;
      }, controller.updateDisplay);

      controller.updateDisplay();

    }

    controller.setValue = common.compose(function(r) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }
      return r;
    }, controller.setValue);

  }

  function recallSavedValue(gui, controller) {

    // Find the topmost GUI, that's where remembered objects live.
    var root = gui.getRoot();

    // Does the object we're controlling match anything we've been told to
    // remember?
    var matched_index = root.__rememberedObjects.indexOf(controller.object);

    // Why yes, it does!
    if (matched_index != -1) {

      // Let me fetch a map of controllers for thcommon.isObject.
      var controller_map =
          root.__rememberedObjectIndecesToControllers[matched_index];

      // Ohp, I believe this is the first controller we've created for this
      // object. Lets make the map fresh.
      if (controller_map === undefined) {
        controller_map = {};
        root.__rememberedObjectIndecesToControllers[matched_index] =
            controller_map;
      }

      // Keep track of this controller
      controller_map[controller.property] = controller;

      // Okay, now have we saved any values for this controller?
      if (root.load && root.load.remembered) {

        var preset_map = root.load.remembered;

        // Which preset are we trying to load?
        var preset;

        if (preset_map[gui.preset]) {

          preset = preset_map[gui.preset];

        } else if (preset_map[DEFAULT_DEFAULT_PRESET_NAME]) {

          // Uhh, you can have the default instead?
          preset = preset_map[DEFAULT_DEFAULT_PRESET_NAME];

        } else {

          // Nada.

          return;

        }


        // Did the loaded object remember thcommon.isObject?
        if (preset[matched_index] &&

          // Did we remember this particular property?
            preset[matched_index][controller.property] !== undefined) {

          // We did remember something for this guy ...
          var value = preset[matched_index][controller.property];

          // And that's what it is.
          controller.initialValue = value;
          controller.setValue(value);

        }

      }

    }

  }

  function getLocalStorageHash(gui, key) {
    // TODO how does this deal with multiple GUI's?
    return document.location.href + '.' + key;

  }

  function addSaveMenu(gui) {

    var div = gui.__save_row = document.createElement('li');

    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');

    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');

    // TODO replace with FunctionController
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');

    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');

    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');

    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {

      common.each(gui.load.remembered, function(value, key) {
        addPresetOption(gui, key, key == gui.preset);
      });

    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function() {


      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;

    });

    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {

      var saveLocally = document.getElementById('dg-save-locally');
      var explain = document.getElementById('dg-local-explain');

      saveLocally.style.display = 'block';

      var localStorageCheckBox = document.getElementById('dg-local-storage');

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      function showHideExplain() {
        explain.style.display = gui.useLocalStorage ? 'block' : 'none';
      }

      showHideExplain();

      // TODO: Use a boolean controller, fool!
      dom.bind(localStorageCheckBox, 'change', function() {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain();
      });

    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');

    dom.bind(newConstructorTextArea, 'keydown', function(e) {
      if (e.metaKey && (e.which === 67 || e.keyCode == 67)) {
        SAVE_DIALOGUE.hide();
      }
    });

    dom.bind(gears, 'click', function() {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });

    dom.bind(button, 'click', function() {
      gui.save();
    });

    dom.bind(button2, 'click', function() {
      var presetName = prompt('Enter a new preset name.');
      if (presetName) gui.saveAs(presetName);
    });

    dom.bind(button3, 'click', function() {
      gui.revert();
    });

//    div.appendChild(button2);

  }

  function addResizeHandle(gui) {

    gui.__resize_handle = document.createElement('div');

    common.extend(gui.__resize_handle.style, {

      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
//      border: '1px solid blue'

    });

    var pmouseX;

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);

    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);

    function dragStart(e) {

      e.preventDefault();

      pmouseX = e.clientX;

      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);

      return false;

    }

    function drag(e) {

      e.preventDefault();

      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;

      return false;

    }

    function dragStop() {

      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);

    }

  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';
    // Auto placed save-rows are position fixed, so we have to
    // set the width manually if we want it to bleed to the edge
    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {

    var toReturn = {};

    // For each object I'm remembering
    common.each(gui.__rememberedObjects, function(val, index) {

      var saved_values = {};

      // The controllers I've made for thcommon.isObject by property
      var controller_map =
          gui.__rememberedObjectIndecesToControllers[index];

      // Remember each value for each property
      common.each(controller_map, function(controller, property) {
        saved_values[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });

      // Save the values for thcommon.isObject
      toReturn[index] = saved_values;

    });

    return toReturn;

  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;
    gui.__preset_select.appendChild(opt);
    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value == gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
//    console.log('mark', modified, opt);
    if (modified) {
      opt.innerHTML = opt.value + "*";
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function updateDisplays(controllerArray) {


    if (controllerArray.length != 0) {

      requestAnimationFrame(function() {
        updateDisplays(controllerArray);
      });

    }

    common.each(controllerArray, function(c) {
      c.updateDisplay();
    });

  }

  return GUI;

})(dat.utils.css,
"<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n      \n    </div>\n    \n  </div>\n\n</div>",
".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity 0.1s linear;-o-transition:opacity 0.1s linear;-moz-transition:opacity 0.1s linear;transition:opacity 0.1s linear;border:0;position:absolute;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-x:hidden}.dg.a.has-save ul{margin-top:27px}.dg.a.has-save ul.closed{margin-top:0}.dg.a .save-row{position:fixed;top:0;z-index:1002}.dg li{-webkit-transition:height 0.1s ease-out;-o-transition:height 0.1s ease-out;-moz-transition:height 0.1s ease-out;transition:height 0.1s ease-out}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;overflow:hidden;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li > *{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:9px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2fa1d6}.dg .cr.number input[type=text]{color:#2fa1d6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2fa1d6}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
dat.controllers.factory = (function (OptionController, NumberControllerBox, NumberControllerSlider, StringController, FunctionController, BooleanController, common) {

      return function(object, property) {

        var initialValue = object[property];

        // Providing options?
        if (common.isArray(arguments[2]) || common.isObject(arguments[2])) {
          return new OptionController(object, property, arguments[2]);
        }

        // Providing a map?

        if (common.isNumber(initialValue)) {

          if (common.isNumber(arguments[2]) && common.isNumber(arguments[3])) {

            // Has min and max.
            return new NumberControllerSlider(object, property, arguments[2], arguments[3]);

          } else {

            return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });

          }

        }

        if (common.isString(initialValue)) {
          return new StringController(object, property);
        }

        if (common.isFunction(initialValue)) {
          return new FunctionController(object, property, '');
        }

        if (common.isBoolean(initialValue)) {
          return new BooleanController(object, property);
        }

      }

    })(dat.controllers.OptionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.StringController = (function (Controller, dom, common) {

  /**
   * @class Provides a text input to alter the string property of an object.
   *
   * @extends dat.controllers.Controller
   *
   * @param {Object} object The object to be manipulated
   * @param {string} property The name of the property to be manipulated
   *
   * @member dat.controllers
   */
  var StringController = function(object, property) {

    StringController.superclass.call(this, object, property);

    var _this = this;

    this.__input = document.createElement('input');
    this.__input.setAttribute('type', 'text');

    dom.bind(this.__input, 'keyup', onChange);
    dom.bind(this.__input, 'change', onChange);
    dom.bind(this.__input, 'blur', onBlur);
    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    

    function onChange() {
      _this.setValue(_this.__input.value);
    }

    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }

    this.updateDisplay();

    this.domElement.appendChild(this.__input);

  };

  StringController.superclass = Controller;

  common.extend(

      StringController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {
          // Stops the caret from moving on account of:
          // keyup -> setValue -> updateDisplay
          if (!dom.isActive(this.__input)) {
            this.__input.value = this.getValue();
          }
          return StringController.superclass.prototype.updateDisplay.call(this);
        }

      }

  );

  return StringController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.utils.common),
dat.controllers.FunctionController,
dat.controllers.BooleanController,
dat.utils.common),
dat.controllers.Controller,
dat.controllers.BooleanController,
dat.controllers.FunctionController,
dat.controllers.NumberControllerBox,
dat.controllers.NumberControllerSlider,
dat.controllers.OptionController,
dat.controllers.ColorController = (function (Controller, dom, Color, interpret, common) {

  var ColorController = function(object, property) {

    ColorController.superclass.call(this, object, property);

    this.__color = new Color(this.getValue());
    this.__temp = new Color(0);

    var _this = this;

    this.domElement = document.createElement('div');

    dom.makeSelectable(this.domElement, false);

    this.__selector = document.createElement('div');
    this.__selector.className = 'selector';

    this.__saturation_field = document.createElement('div');
    this.__saturation_field.className = 'saturation-field';

    this.__field_knob = document.createElement('div');
    this.__field_knob.className = 'field-knob';
    this.__field_knob_border = '2px solid ';

    this.__hue_knob = document.createElement('div');
    this.__hue_knob.className = 'hue-knob';

    this.__hue_field = document.createElement('div');
    this.__hue_field.className = 'hue-field';

    this.__input = document.createElement('input');
    this.__input.type = 'text';
    this.__input_textShadow = '0 1px 1px ';

    dom.bind(this.__input, 'keydown', function(e) {
      if (e.keyCode === 13) { // on enter
        onBlur.call(this);
      }
    });

    dom.bind(this.__input, 'blur', onBlur);

    dom.bind(this.__selector, 'mousedown', function(e) {

      dom
        .addClass(this, 'drag')
        .bind(window, 'mouseup', function(e) {
          dom.removeClass(_this.__selector, 'drag');
        });

    });

    var value_field = document.createElement('div');

    common.extend(this.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });

    common.extend(this.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: this.__field_knob_border + (this.__color.v < .5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    
    common.extend(this.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });

    common.extend(this.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });

    common.extend(value_field.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    
    linearGradient(value_field, 'top', 'rgba(0,0,0,0)', '#000');

    common.extend(this.__hue_field.style, {
      width: '15px',
      height: '100px',
      display: 'inline-block',
      border: '1px solid #555',
      cursor: 'ns-resize'
    });

    hueGradient(this.__hue_field);

    common.extend(this.__input.style, {
      outline: 'none',
//      width: '120px',
      textAlign: 'center',
//      padding: '4px',
//      marginBottom: '6px',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: this.__input_textShadow + 'rgba(0,0,0,0.7)'
    });

    dom.bind(this.__saturation_field, 'mousedown', fieldDown);
    dom.bind(this.__field_knob, 'mousedown', fieldDown);

    dom.bind(this.__hue_field, 'mousedown', function(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'mouseup', unbindH);
    });

    function fieldDown(e) {
      setSV(e);
      // document.body.style.cursor = 'none';
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'mouseup', unbindSV);
    }

    function unbindSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'mouseup', unbindSV);
      // document.body.style.cursor = 'default';
    }

    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }

    function unbindH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'mouseup', unbindH);
    }

    this.__saturation_field.appendChild(value_field);
    this.__selector.appendChild(this.__field_knob);
    this.__selector.appendChild(this.__saturation_field);
    this.__selector.appendChild(this.__hue_field);
    this.__hue_field.appendChild(this.__hue_knob);

    this.domElement.appendChild(this.__input);
    this.domElement.appendChild(this.__selector);

    this.updateDisplay();

    function setSV(e) {

      e.preventDefault();

      var w = dom.getWidth(_this.__saturation_field);
      var o = dom.getOffset(_this.__saturation_field);
      var s = (e.clientX - o.left + document.body.scrollLeft) / w;
      var v = 1 - (e.clientY - o.top + document.body.scrollTop) / w;

      if (v > 1) v = 1;
      else if (v < 0) v = 0;

      if (s > 1) s = 1;
      else if (s < 0) s = 0;

      _this.__color.v = v;
      _this.__color.s = s;

      _this.setValue(_this.__color.toOriginal());


      return false;

    }

    function setH(e) {

      e.preventDefault();

      var s = dom.getHeight(_this.__hue_field);
      var o = dom.getOffset(_this.__hue_field);
      var h = 1 - (e.clientY - o.top + document.body.scrollTop) / s;

      if (h > 1) h = 1;
      else if (h < 0) h = 0;

      _this.__color.h = h * 360;

      _this.setValue(_this.__color.toOriginal());

      return false;

    }

  };

  ColorController.superclass = Controller;

  common.extend(

      ColorController.prototype,
      Controller.prototype,

      {

        updateDisplay: function() {

          var i = interpret(this.getValue());

          if (i !== false) {

            var mismatch = false;

            // Check for mismatch on the interpreted value.

            common.each(Color.COMPONENTS, function(component) {
              if (!common.isUndefined(i[component]) &&
                  !common.isUndefined(this.__color.__state[component]) &&
                  i[component] !== this.__color.__state[component]) {
                mismatch = true;
                return {}; // break
              }
            }, this);

            // If nothing diverges, we keep our previous values
            // for statefulness, otherwise we recalculate fresh
            if (mismatch) {
              common.extend(this.__color.__state, i);
            }

          }

          common.extend(this.__temp.__state, this.__color.__state);

          this.__temp.a = 1;

          var flip = (this.__color.v < .5 || this.__color.s > .5) ? 255 : 0;
          var _flip = 255 - flip;

          common.extend(this.__field_knob.style, {
            marginLeft: 100 * this.__color.s - 7 + 'px',
            marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
            backgroundColor: this.__temp.toString(),
            border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip +')'
          });

          this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px'

          this.__temp.s = 1;
          this.__temp.v = 1;

          linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toString());

          common.extend(this.__input.style, {
            backgroundColor: this.__input.value = this.__color.toString(),
            color: 'rgb(' + flip + ',' + flip + ',' + flip +')',
            textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip +',.7)'
          });

        }

      }

  );
  
  var vendors = ['-moz-','-o-','-webkit-','-ms-',''];
  
  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    common.each(vendors, function(vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient('+x+', '+a+' 0%, ' + b + ' 100%); ';
    });
  }
  
  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  }


  return ColorController;

})(dat.controllers.Controller,
dat.dom.dom,
dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret,
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common),
dat.color.interpret,
dat.utils.common),
dat.utils.requestAnimationFrame = (function () {

  /**
   * requirejs version of Paul Irish's RequestAnimationFrame
   * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   */

  return window.webkitRequestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.oRequestAnimationFrame ||
      window.msRequestAnimationFrame ||
      function(callback, element) {

        window.setTimeout(callback, 1000 / 60);

      };
})(),
dat.dom.CenteredDiv = (function (dom, common) {


  var CenteredDiv = function() {

    this.backgroundElement = document.createElement('div');
    common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear'
    });

    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';

    this.domElement = document.createElement('div');
    common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear'
    });


    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);

    var _this = this;
    dom.bind(this.backgroundElement, 'click', function() {
      _this.hide();
    });


  };

  CenteredDiv.prototype.show = function() {

    var _this = this;
    


    this.backgroundElement.style.display = 'block';

    this.domElement.style.display = 'block';
    this.domElement.style.opacity = 0;
//    this.domElement.style.top = '52%';
    this.domElement.style.webkitTransform = 'scale(1.1)';

    this.layout();

    common.defer(function() {
      _this.backgroundElement.style.opacity = 1;
      _this.domElement.style.opacity = 1;
      _this.domElement.style.webkitTransform = 'scale(1)';
    });

  };

  CenteredDiv.prototype.hide = function() {

    var _this = this;

    var hide = function() {

      _this.domElement.style.display = 'none';
      _this.backgroundElement.style.display = 'none';

      dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
      dom.unbind(_this.domElement, 'transitionend', hide);
      dom.unbind(_this.domElement, 'oTransitionEnd', hide);

    };

    dom.bind(this.domElement, 'webkitTransitionEnd', hide);
    dom.bind(this.domElement, 'transitionend', hide);
    dom.bind(this.domElement, 'oTransitionEnd', hide);

    this.backgroundElement.style.opacity = 0;
//    this.domElement.style.top = '48%';
    this.domElement.style.opacity = 0;
    this.domElement.style.webkitTransform = 'scale(1.1)';

  };

  CenteredDiv.prototype.layout = function() {
    this.domElement.style.left = window.innerWidth/2 - dom.getWidth(this.domElement) / 2 + 'px';
    this.domElement.style.top = window.innerHeight/2 - dom.getHeight(this.domElement) / 2 + 'px';
  };
  
  function lockScroll(e) {
    console.log(e);
  }

  return CenteredDiv;

})(dat.dom.dom,
dat.utils.common),
dat.dom.dom,
dat.utils.common);

/***/ }),
/* 135 */
/***/ (function(module, exports) {

/**
 * dat-gui JavaScript Controller Library
 * http://code.google.com/p/dat-gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

/** @namespace */
var dat = module.exports = dat || {};

/** @namespace */
dat.color = dat.color || {};

/** @namespace */
dat.utils = dat.utils || {};

dat.utils.common = (function () {
  
  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;

  /**
   * Band-aid methods for things that should be a lot easier in JavaScript.
   * Implementation and structure inspired by underscore.js
   * http://documentcloud.github.com/underscore/
   */

  return { 
    
    BREAK: {},
  
    extend: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (!this.isUndefined(obj[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
      
    },
    
    defaults: function(target) {
      
      this.each(ARR_SLICE.call(arguments, 1), function(obj) {
        
        for (var key in obj)
          if (this.isUndefined(target[key])) 
            target[key] = obj[key];
        
      }, this);
      
      return target;
    
    },
    
    compose: function() {
      var toCall = ARR_SLICE.call(arguments);
            return function() {
              var args = ARR_SLICE.call(arguments);
              for (var i = toCall.length -1; i >= 0; i--) {
                args = [toCall[i].apply(this, args)];
              }
              return args[0];
            }
    },
    
    each: function(obj, itr, scope) {

      
      if (ARR_EACH && obj.forEach === ARR_EACH) { 
        
        obj.forEach(itr, scope);
        
      } else if (obj.length === obj.length + 0) { // Is number but not NaN
        
        for (var key = 0, l = obj.length; key < l; key++)
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) 
            return;
            
      } else {

        for (var key in obj) 
          if (itr.call(scope, obj[key], key) === this.BREAK)
            return;
            
      }
            
    },
    
    defer: function(fnc) {
      setTimeout(fnc, 0);
    },
    
    toArray: function(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },

    isUndefined: function(obj) {
      return obj === undefined;
    },
    
    isNull: function(obj) {
      return obj === null;
    },
    
    isNaN: function(obj) {
      return obj !== obj;
    },
    
    isArray: Array.isArray || function(obj) {
      return obj.constructor === Array;
    },
    
    isObject: function(obj) {
      return obj === Object(obj);
    },
    
    isNumber: function(obj) {
      return obj === obj+0;
    },
    
    isString: function(obj) {
      return obj === obj+'';
    },
    
    isBoolean: function(obj) {
      return obj === false || obj === true;
    },
    
    isFunction: function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    }
  
  };
    
})();


dat.color.toString = (function (common) {

  return function(color) {

    if (color.a == 1 || common.isUndefined(color.a)) {

      var s = color.hex.toString(16);
      while (s.length < 6) {
        s = '0' + s;
      }

      return '#' + s;

    } else {

      return 'rgba(' + Math.round(color.r) + ',' + Math.round(color.g) + ',' + Math.round(color.b) + ',' + color.a + ')';

    }

  }

})(dat.utils.common);


dat.Color = dat.color.Color = (function (interpret, math, toString, common) {

  var Color = function() {

    this.__state = interpret.apply(this, arguments);

    if (this.__state === false) {
      throw 'Failed to interpret color arguments';
    }

    this.__state.a = this.__state.a || 1;


  };

  Color.COMPONENTS = ['r','g','b','h','s','v','hex','a'];

  common.extend(Color.prototype, {

    toString: function() {
      return toString(this);
    },

    toOriginal: function() {
      return this.__state.conversion.write(this);
    }

  });

  defineRGBComponent(Color.prototype, 'r', 2);
  defineRGBComponent(Color.prototype, 'g', 1);
  defineRGBComponent(Color.prototype, 'b', 0);

  defineHSVComponent(Color.prototype, 'h');
  defineHSVComponent(Color.prototype, 's');
  defineHSVComponent(Color.prototype, 'v');

  Object.defineProperty(Color.prototype, 'a', {

    get: function() {
      return this.__state.a;
    },

    set: function(v) {
      this.__state.a = v;
    }

  });

  Object.defineProperty(Color.prototype, 'hex', {

    get: function() {

      if (!this.__state.space !== 'HEX') {
        this.__state.hex = math.rgb_to_hex(this.r, this.g, this.b);
      }

      return this.__state.hex;

    },

    set: function(v) {

      this.__state.space = 'HEX';
      this.__state.hex = v;

    }

  });

  function defineRGBComponent(target, component, componentHexIndex) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        recalculateRGB(this, component, componentHexIndex);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'RGB') {
          recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;

      }

    });

  }

  function defineHSVComponent(target, component) {

    Object.defineProperty(target, component, {

      get: function() {

        if (this.__state.space === 'HSV')
          return this.__state[component];

        recalculateHSV(this);

        return this.__state[component];

      },

      set: function(v) {

        if (this.__state.space !== 'HSV') {
          recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;

      }

    });

  }

  function recalculateRGB(color, component, componentHexIndex) {

    if (color.__state.space === 'HEX') {

      color.__state[component] = math.component_from_hex(color.__state.hex, componentHexIndex);

    } else if (color.__state.space === 'HSV') {

      common.extend(color.__state, math.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));

    } else {

      throw 'Corrupted color state';

    }

  }

  function recalculateHSV(color) {

    var result = math.rgb_to_hsv(color.r, color.g, color.b);

    common.extend(color.__state,
        {
          s: result.s,
          v: result.v
        }
    );

    if (!common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }

  }

  return Color;

})(dat.color.interpret = (function (toString, common) {

  var result, toReturn;

  var interpret = function() {

    toReturn = false;

    var original = arguments.length > 1 ? common.toArray(arguments) : arguments[0];

    common.each(INTERPRETATIONS, function(family) {

      if (family.litmus(original)) {

        common.each(family.conversions, function(conversion, conversionName) {

          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return common.BREAK;

          }

        });

        return common.BREAK;

      }

    });

    return toReturn;

  };

  var INTERPRETATIONS = [

    // Strings
    {

      litmus: common.isString,

      conversions: {

        THREE_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt(
                  '0x' +
                      test[1].toString() + test[1].toString() +
                      test[2].toString() + test[2].toString() +
                      test[3].toString() + test[3].toString())
            };

          },

          write: toString

        },

        SIX_CHAR_HEX: {

          read: function(original) {

            var test = original.match(/^#([A-F0-9]{6})$/i);
            if (test === null) return false;

            return {
              space: 'HEX',
              hex: parseInt('0x' + test[1].toString())
            };

          },

          write: toString

        },

        CSS_RGB: {

          read: function(original) {

            var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3])
            };

          },

          write: toString

        },

        CSS_RGBA: {

          read: function(original) {

            var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
            if (test === null) return false;

            return {
              space: 'RGB',
              r: parseFloat(test[1]),
              g: parseFloat(test[2]),
              b: parseFloat(test[3]),
              a: parseFloat(test[4])
            };

          },

          write: toString

        }

      }

    },

    // Numbers
    {

      litmus: common.isNumber,

      conversions: {

        HEX: {
          read: function(original) {
            return {
              space: 'HEX',
              hex: original,
              conversionName: 'HEX'
            }
          },

          write: function(color) {
            return color.hex;
          }
        }

      }

    },

    // Arrays
    {

      litmus: common.isArray,

      conversions: {

        RGB_ARRAY: {
          read: function(original) {
            if (original.length != 3) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b];
          }

        },

        RGBA_ARRAY: {
          read: function(original) {
            if (original.length != 4) return false;
            return {
              space: 'RGB',
              r: original[0],
              g: original[1],
              b: original[2],
              a: original[3]
            };
          },

          write: function(color) {
            return [color.r, color.g, color.b, color.a];
          }

        }

      }

    },

    // Objects
    {

      litmus: common.isObject,

      conversions: {

        RGBA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b) &&
                common.isNumber(original.a)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b,
              a: color.a
            }
          }
        },

        RGB_OBJ: {
          read: function(original) {
            if (common.isNumber(original.r) &&
                common.isNumber(original.g) &&
                common.isNumber(original.b)) {
              return {
                space: 'RGB',
                r: original.r,
                g: original.g,
                b: original.b
              }
            }
            return false;
          },

          write: function(color) {
            return {
              r: color.r,
              g: color.g,
              b: color.b
            }
          }
        },

        HSVA_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v) &&
                common.isNumber(original.a)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v,
                a: original.a
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v,
              a: color.a
            }
          }
        },

        HSV_OBJ: {
          read: function(original) {
            if (common.isNumber(original.h) &&
                common.isNumber(original.s) &&
                common.isNumber(original.v)) {
              return {
                space: 'HSV',
                h: original.h,
                s: original.s,
                v: original.v
              }
            }
            return false;
          },

          write: function(color) {
            return {
              h: color.h,
              s: color.s,
              v: color.v
            }
          }

        }

      }

    }


  ];

  return interpret;


})(dat.color.toString,
dat.utils.common),
dat.color.math = (function () {

  var tmpComponent;

  return {

    hsv_to_rgb: function(h, s, v) {

      var hi = Math.floor(h / 60) % 6;

      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - (f * s));
      var t = v * (1.0 - ((1.0 - f) * s));
      var c = [
        [v, t, p],
        [q, v, p],
        [p, v, t],
        [p, q, v],
        [t, p, v],
        [v, p, q]
      ][hi];

      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };

    },

    rgb_to_hsv: function(r, g, b) {

      var min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h, s;

      if (max != 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h /= 6;
      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },

    rgb_to_hex: function(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },

    component_from_hex: function(hex, componentIndex) {
      return (hex >> (componentIndex * 8)) & 0xFF;
    },

    hex_with_component: function(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | (hex & ~ (0xFF << tmpComponent));
    }

  }

})(),
dat.color.toString,
dat.utils.common);

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

// stats.js - http://github.com/mrdoob/stats.js
(function(f,e){ true?module.exports=e():"function"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
u(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNjBjMTg3YTVmNTNjMTA5ZGZkY2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUb29sLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0dMU2hhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9HZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0JhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY2hlZHVsaW5nL3NyYy9zY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR2VvbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9vYmplY3RzL09iamVjdDNELmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0dMVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9XZWJnbE51bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL3NpbXBsZUNvbG9yLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL01lc2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvR0xDdWJlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2Jhc2ljLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9TaGFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL0ZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0Vhc2VOdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbWF0aC9SYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvc2hhZGVycy9TaGFkZXJMaWJzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYmlnVHJpYW5nbGUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2NvcHkuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYVBlcnNwZWN0aXZlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvQmluYXJ5TG9hZGVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvV2ViZ2xDb25zdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRBdHRyaWJMb2MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvTWF0ZXJpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL09yYml0YWxDb250cm9sLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvZ2VuZXJhbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvc2t5Ym94LnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9za3lib3guZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYU9ydGhvLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvbG9hZEltYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzTWFjcm8uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzVkJsdXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzQmx1ckJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzSEJsdXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9meGFhLmZyYWciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldEFuZEFwcGx5RXh0ZW5zaW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2V4cG9zZUF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0RmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0SGFsZkZsb2F0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0V4dGVuc2lvbnNMaXN0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldFRleHR1cmVQYXJhbWV0ZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXJzZS1kZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsc2xpZnkvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2Jhc2ljLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvVHdlZW5OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0TW91c2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9nbHRmLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9nbHRmLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9kZWJ1Zy5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2NhbWVyYXMvQ2FtZXJhQ3ViZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL09iakxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0hEUkxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9IRFJQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9Db2xsYWRhUGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb2xsYWRhLXBhcnNlci9saWIvQ29sbGFkYVBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29sbGFkYS1wYXJzZXIvbGliL0NvbGxhZGEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9HbHRmTG9hZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMveGhyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9FZmZlY3RDb21wb3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NCbHVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYmx1cjUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2JsdXI5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9ibHVyMTMuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NGeGFhLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hDb3B5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hBeGlzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYXhpcy52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYXhpcy5mcmFnIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hCYWxsLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hEb3RzUGxhbmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9kb3RzUGxhbmUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoU2t5Ym94LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3kuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9za3kudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoRlhBQS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1NjZW5lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL1ZpZXczRC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZGVidWcvZGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdC1ndWkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5ndWkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdC1ndWkvdmVuZG9yL2RhdC5jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhdHMuanMvYnVpbGQvc3RhdHMubWluLmpzIl0sIm5hbWVzIjpbImdsIiwiR0xUb29sIiwiY2FudmFzIiwiX3ZpZXdwb3J0IiwiX2VuYWJsZWRWZXJ0ZXhBdHRyaWJ1dGUiLCJpZGVudGl0eU1hdHJpeCIsImNyZWF0ZSIsIl9ub3JtYWxNYXRyaXgiLCJfaW52ZXJzZU1vZGVsVmlld01hdHJpeCIsIl9tb2RlbE1hdHJpeCIsIl9tYXRyaXgiLCJfbWF0cml4U3RhY2tzIiwiX2xhc3RNZXNoIiwiX3VzZVdlYkdMMiIsIl9oYXNBcnJheUluc3RhbmNlIiwiX2V4dEFycmF5SW5zdGFuY2UiLCJfaGFzQ2hlY2tlZEV4dCIsImlkZW50aXR5IiwiaXNNb2JpbGUiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibUNhbnZhcyIsIm1QYXJhbWV0ZXJzIiwidW5kZWZpbmVkIiwiY29uc29sZSIsImVycm9yIiwiZGVzdHJveSIsInNldFNpemUiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJ1c2VXZWJnbDIiLCJjdHgiLCJnZXRDb250ZXh0IiwibG9nIiwid2ViZ2wyIiwiaW5pdFdpdGhHTCIsImV4dGVuc2lvbnMiLCJpIiwibGVuZ3RoIiwiZ2V0RXh0ZW5zaW9uIiwiZW5hYmxlIiwiREVQVEhfVEVTVCIsIkNVTExfRkFDRSIsIkJMRU5EIiwiZW5hYmxlQWxwaGFCbGVuZGluZyIsIngiLCJ5IiwidyIsImgiLCJoYXNDaGFuZ2VkIiwidmlld3BvcnQiLCJzY2lzc29yIiwiciIsImciLCJiIiwiYSIsImNsZWFyQ29sb3IiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwibVZhbHVlIiwiY3VsbEZhY2UiLCJtQ2FtZXJhIiwiY2FtZXJhIiwicm90YXRlIiwibVNoYWRlciIsInNoYWRlciIsInNoYWRlclByb2dyYW0iLCJtUm90YXRpb24iLCJjb3B5IiwibXVsdGlwbHkiLCJtYXRyaXgiLCJmcm9tTWF0NCIsImludmVydCIsInRyYW5zcG9zZSIsIm1HZW9tZXRyeSIsIm1vZGVsTWF0cml4IiwiZHJhdyIsImJpbmQiLCJ1bmlmb3JtIiwicHJvamVjdGlvbiIsInBvc2l0aW9uIiwiZHJhd1R5cGUiLCJpc0luc3RhbmNlZCIsImRyYXdFbGVtZW50c0luc3RhbmNlZCIsImlCdWZmZXIiLCJudW1JdGVtcyIsIlVOU0lHTkVEX1NIT1JUIiwibnVtSW5zdGFuY2UiLCJQT0lOVFMiLCJkcmF3QXJyYXlzIiwidmVydGV4U2l6ZSIsImRyYXdFbGVtZW50cyIsInVuYmluZCIsIm1NZXNoIiwibWF0ZXJpYWwiLCJnZW9tZXRyeSIsImRvdWJsZVNpZGVkIiwiZGlzYWJsZSIsIkdMIiwidXBkYXRlIiwiZHJhd0dlb21ldHJ5IiwibU9iaiIsImRyYXdNZXNoIiwidXBkYXRlTWF0cml4IiwiY2hpbGRyZW4iLCJmb3JFYWNoIiwiY2hpbGQiLCJtVHJhbnNmb3JtT2JqZWN0IiwibWVzaFNvdXJjZSIsIm1lc2hEZXN0aW5hdGlvbiIsIm51bVBvaW50cyIsInRyYW5zZm9ybUZlZWRiYWNrIiwiZ2VuZXJhdGVCdWZmZXJzIiwiYmluZFRyYW5zZm9ybUZlZWRiYWNrIiwiVFJBTlNGT1JNX0ZFRURCQUNLIiwiYXR0cmlidXRlcyIsImF0dHIiLCJiaW5kQnVmZmVyQmFzZSIsIlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVIiLCJidWZmZXIiLCJSQVNURVJJWkVSX0RJU0NBUkQiLCJiZWdpblRyYW5zZm9ybUZlZWRiYWNrIiwiZW5kVHJhbnNmb3JtRmVlZGJhY2siLCJ1c2VQcm9ncmFtIiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsIm1XaWR0aCIsIm1IZWlnaHQiLCJfd2lkdGgiLCJfaGVpZ2h0Iiwid2lkdGgiLCJoZWlnaHQiLCJfYXNwZWN0UmF0aW8iLCJleHQiLCJtRXh0ZW5zaW9uIiwiYmxlbmRGdW5jIiwiU1JDX0FMUEhBIiwiT05FX01JTlVTX1NSQ19BTFBIQSIsIk9ORSIsIm10eCIsImNsb25lIiwicHVzaCIsInBvcCIsIm1QYXJhbWV0ZXIiLCJzZXRWaWV3cG9ydCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImUiLCJnbHNsaWZ5IiwicmVxdWlyZSIsImlzU2FtZSIsImFycmF5MSIsImFycmF5MiIsImFkZExpbmVOdW1iZXJzIiwic3RyaW5nIiwibGluZXMiLCJzcGxpdCIsImpvaW4iLCJjbG9uZUFycmF5IiwibUFycmF5Iiwic2xpY2UiLCJGbG9hdDMyQXJyYXkiLCJkZWZhdWx0VmVydGV4U2hhZGVyIiwiZGVmYXVsdEZyYWdtZW50U2hhZGVyIiwidW5pZm9ybU1hcHBpbmciLCJmbG9hdCIsInZlYzIiLCJ2ZWMzIiwidmVjNCIsImludCIsIm1hdDMiLCJtYXQ0IiwiR0xTaGFkZXIiLCJzdHJWZXJ0ZXhTaGFkZXIiLCJzdHJGcmFnbWVudFNoYWRlciIsIm1WYXJ5aW5ncyIsInBhcmFtZXRlcnMiLCJfdW5pZm9ybVRleHR1cmVzIiwiX3ZhcnlpbmdzIiwidnNTaGFkZXIiLCJfY3JlYXRlU2hhZGVyUHJvZ3JhbSIsImZzU2hhZGVyIiwiX2F0dGFjaFNoYWRlclByb2dyYW0iLCJ1c2VTaGFkZXIiLCJtTmFtZSIsIm1UeXBlIiwidW5pZm9ybU9iamVjdCIsInVuaWZvcm1UeXBlIiwiaGFzVW5pZm9ybSIsIm9Vbmlmb3JtIiwicGFyYW1ldGVySW5kZXgiLCJuYW1lIiwiaXNOdW1iZXIiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ0eXBlIiwidmFsdWUiLCJ1bmlmb3JtTG9jIiwiaW5kZXhPZiIsIm5lZWRVcGRhdGUiLCJtVW5pZm9ybU9iaiIsInVuaWZvcm1OYW1lIiwidGV4dHVyZSIsInRleHR1cmVJbmRleCIsInV0IiwidW5pZm9ybVZhbHVlIiwiZ2V0VW5pZm9ybVR5cGUiLCJjb25jYXQiLCJ0bXAiLCJtU2hhZGVyU3RyIiwiaXNWZXJ0ZXhTaGFkZXIiLCJzaGFkZXJUeXBlIiwiVkVSVEVYX1NIQURFUiIsIkZSQUdNRU5UX1NIQURFUiIsImNyZWF0ZVNoYWRlciIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsIndhcm4iLCJnZXRTaGFkZXJJbmZvTG9nIiwibVZlcnRleFNoYWRlciIsIm1GcmFnbWVudFNoYWRlciIsImNyZWF0ZVByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJkZWxldGVTaGFkZXIiLCJ0cmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdzIiwiU0VQQVJBVEVfQVRUUklCUyIsImxpbmtQcm9ncmFtIiwiaXNBcnJheSIsImdldEFycmF5VW5pZm9ybVR5cGUiLCJTVEFUSUNfRFJBVyIsImdldEJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImZvcm1CdWZmZXIiLCJtRGF0YSIsIm1OdW0iLCJhcnkiLCJvIiwiaiIsIkdlb21ldHJ5IiwibURyYXdpbmdUeXBlIiwibVVzZVZhbyIsIl9hdHRyaWJ1dGVzIiwiX251bUluc3RhbmNlIiwiX2luZGljZXMiLCJfZmFjZXMiLCJfYnVmZmVyQ2hhbmdlZCIsIl9oYXNJbmRleEJ1ZmZlckNoYW5nZWQiLCJfaGFzVkFPIiwiX2lzSW5zdGFuY2VkIiwiX2V4dFZBTyIsImNyZWF0ZVZlcnRleEFycmF5IiwiX3VzZVZBTyIsIm1BcnJheVZlcnRpY2VzIiwibURyYXdUeXBlIiwiYnVmZmVyRGF0YSIsIm5vcm1hbHMiLCJ2ZXJ0aWNlcyIsImJ1ZmZlck5vcm1hbCIsIm1BcnJheVRleENvb3JkcyIsIm1Ob3JtYWxzIiwibUFycmF5SW5kaWNlcyIsImlzRHluYW1pYyIsIl9kcmF3VHlwZSIsIkRZTkFNSUNfRFJBVyIsIkFycmF5IiwiVWludDE2QXJyYXkiLCJfbnVtSXRlbXMiLCJtSXRlbVNpemUiLCJkYXRhIiwiZGF0YUFycmF5IiwiYXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiaXRlbVNpemUiLCJzb3VyY2UiLCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yIiwibVNoYWRlclByb2dyYW0iLCJoYXNWQU8iLCJiaW5kVmVydGV4QXJyYXkiLCJ2YW8iLCJhdHRyUG9zaXRpb24iLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsIl92YW8iLCJhdHRyT2JqIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJfdXBkYXRlSW5kZXhCdWZmZXIiLCJ1c2luZ0ZhY2VOb3JtYWxzIiwiZ2VuZXJhdGVGYWNlcyIsIl9jb21wdXRlRmFjZU5vcm1hbHMiLCJfY29tcHV0ZVZlcnRleE5vcm1hbHMiLCJmYWNlSW5kZXgiLCJmYWNlIiwiTiIsIm5vcm1hbCIsImluZGljZXMiLCJzdW1Ob3JtYWwiLCJzZXQiLCJub3JtYWxpemUiLCJpYSIsImliIiwiaWMiLCJjIiwidmJhIiwidmNhIiwidk5vcm1hbCIsImZpbmQiLCJnZXRTb3VyY2UiLCJCYXRjaCIsIl9nZW9tZXRyeSIsIl9zaGFkZXIiLCJHZW9tIiwibWVzaFRyaSIsInBsYW5lIiwibnVtU2VnbWVudHMiLCJheGlzIiwicG9zaXRpb25zIiwiY29vcmRzIiwiZ2FwWCIsImdhcFkiLCJnYXBVViIsInN4Iiwic3kiLCJpbmRleCIsInR4IiwidHkiLCJ1IiwidiIsIm1lc2giLCJidWZmZXJWZXJ0ZXgiLCJidWZmZXJUZXhDb29yZCIsImJ1ZmZlckluZGV4Iiwic3BoZXJlIiwic2l6ZSIsImlzSW52ZXJ0IiwiZ2V0UG9zaXRpb24iLCJpc05vcm1hbCIsInJ4IiwiTWF0aCIsIlBJIiwicnkiLCJwb3MiLCJzaW4iLCJ0IiwiY29zIiwicHJlY2lzaW9uIiwiZmxvb3IiLCJyZXZlcnNlIiwiY3ViZSIsImQiLCJ6IiwiY291bnQiLCJza3lib3giLCJiaWdUcmlhbmdsZSIsIk9iamVjdDNEIiwiX25lZWRVcGRhdGUiLCJfeCIsIl95IiwiX3oiLCJfc3giLCJfc3kiLCJfc3oiLCJfcngiLCJfcnkiLCJfcnoiLCJfcG9zaXRpb24iLCJfc2NhbGUiLCJmcm9tVmFsdWVzIiwiX3JvdGF0aW9uIiwiX21hdHJpeFBhcmVudCIsIl9tYXRyaXhSb3RhdGlvbiIsIl9tYXRyaXhTY2FsZSIsIl9tYXRyaXhUcmFuc2xhdGlvbiIsIl9tYXRyaXhRdWF0ZXJuaW9uIiwiX3F1YXQiLCJfY2hpbGRyZW4iLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJmcm9tUXVhdCIsIm11bCIsInNjYWxlIiwidHJhbnNsYXRlIiwidXBkYXRlUGFyZW50TWF0cml4IiwibVBhcmVudE1hdHJpeCIsIm1RdWF0IiwibUNoaWxkIiwic3BsaWNlIiwiR0xUZXh0dXJlIiwibVNvdXJjZSIsIm1QYXJhbSIsIl9zb3VyY2UiLCJfZ2V0RGltZW5zaW9uIiwiX3NvdXJjZVR5cGUiLCJnZXRTb3VyY2VUeXBlIiwiX2NoZWNrU291cmNlIiwiX3RleGVsVHlwZSIsIl9nZXRUZXhlbFR5cGUiLCJfaXNUZXh0dXJlUmVhZHkiLCJfcGFyYW1zIiwiX2NoZWNrTWlwbWFwIiwiX2NoZWNrV3JhcHBpbmciLCJfdGV4dHVyZSIsImNyZWF0ZVRleHR1cmUiLCJhZGRFRiIsIl9sb29wIiwiX3VwbG9hZFRleHR1cmUiLCJyZWFkeVN0YXRlIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwicGl4ZWxTdG9yZWkiLCJVTlBBQ0tfRkxJUF9ZX1dFQkdMIiwiX2lzU291cmNlSHRtbEVsZW1lbnQiLCJ0ZXhJbWFnZTJEIiwiaW50ZXJuYWxGb3JtYXQiLCJmb3JtYXQiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwibWFnRmlsdGVyIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwibWluRmlsdGVyIiwiVEVYVFVSRV9XUkFQX1MiLCJ3cmFwUyIsIlRFWFRVUkVfV1JBUF9UIiwid3JhcFQiLCJVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wiLCJwcmVtdWx0aXBseUFscGhhIiwiYW5pc290cm9weSIsIm1heCIsImdldFBhcmFtZXRlciIsIk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCIsImxldmVsIiwibWluIiwidGV4UGFyYW1ldGVyZiIsIlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUIiwiX2dlbmVyYXRlTWlwbWFwIiwiZ2VuZXJhdGVNaXBtYXAiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJibGFja1RleHR1cmUiLCJfYmluZEluZGV4IiwidGV4ZWxUeXBlIiwicyIsInZpZGVvV2lkdGgiLCJzcXJ0IiwiVU5TSUdORURfQllURSIsIlVpbnQ4QXJyYXkiLCJtaXBtYXAiLCJpc1Bvd2VyT2ZUd28iLCJDTEFNUF9UT19FREdFIiwiSFRNTEltYWdlRWxlbWVudCIsIkhUTUxDYW52YXNFbGVtZW50IiwiSFRNTFZpZGVvRWxlbWVudCIsIl93aGl0ZVRleHR1cmUiLCJfZ3JleVRleHR1cmUiLCJfYmxhY2tUZXh0dXJlIiwid2hpdGVUZXh0dXJlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJncmV5VGV4dHVyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJQYXNzIiwibVBhcmFtcyIsImJpZ1RyaWFuZ2xlVmVydCIsIl91bmlmb3JtcyIsIl9oYXNPd25GYm8iLCJfZmJvIiwibVBhcm1hcyIsIk1lc2giLCJERFNEX01JUE1BUENPVU5UIiwiT0ZGX01JUE1BUENPVU5UIiwiaGVhZGVyTGVuZ3RoSW50IiwiR0xDdWJlVGV4dHVyZSIsImlzQ3ViZVRleHR1cmUiLCJoYXNNaXBtYXBzIiwibWlwbWFwQ291bnQiLCJMSU5FQVIiLCJMSU5FQVJfTUlQTUFQX0xJTkVBUiIsIlRFWFRVUkVfQ1VCRV9NQVAiLCJ0YXJnZXRzIiwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YIiwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YIiwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZIiwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZIiwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aIiwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aIiwibnVtTGV2ZWxzIiwic2hhcGUiLCJSR0JBIiwicGFyc2VERFMiLCJtQXJyYXlCdWZmZXIiLCJjbGFtcCIsImRkc0luZm9zIiwiZmxhZ3MiLCJoZWFkZXIiLCJJbnQzMkFycmF5Iiwic291cmNlcyIsImltYWdlcyIsIm1hcCIsImltZyIsImZhY2VEYXRhIiwib2Zmc2V0Iiwic2hhZGVyQ2FjaGUiLCJkZWZpbmVzVG9TdHJpbmciLCJkZWZpbmVzIiwib3V0U3RyIiwiZGVmIiwiYWRkVW5pZm9ybXMiLCJtT2JqVW5pZm9ybXMiLCJzdHJVbmlmb3JtcyIsInJlcGxhY2UiLCJiaW5kVW5pZm9ybXMiLCJpbmplY3REZWZpbmVzIiwibURlZmluZXMiLCJnZXQiLCJ2cyIsImZzIiwiX3ZzIiwiX2ZzIiwiZ2xTaGFkZXIiLCJ3ZWJnbERlcHRoVGV4dHVyZSIsImhhc0NoZWNrZWRNdWx0aVJlbmRlclN1cHBvcnQiLCJleHREcmF3QnVmZmVyIiwiY2hlY2tNdWx0aVJlbmRlciIsIkZyYW1lQnVmZmVyIiwibU51bVRhcmdldHMiLCJjaGVja0V4dGVuc2lvbiIsIl9udW1UYXJnZXRzIiwiX211bHRpcGxlVGFyZ2V0cyIsIl9wYXJhbWV0ZXJzIiwiX2NoZWNrTWF4TnVtUmVuZGVyVGFyZ2V0IiwiX2luaXQiLCJfaW5pdFRleHR1cmVzIiwiZnJhbWVCdWZmZXIiLCJjcmVhdGVGcmFtZWJ1ZmZlciIsImJpbmRGcmFtZWJ1ZmZlciIsIkZSQU1FQlVGRkVSIiwiYnVmZmVycyIsImZyYW1lYnVmZmVyVGV4dHVyZTJEIiwiRFJBV19GUkFNRUJVRkZFUiIsIkNPTE9SX0FUVEFDSE1FTlQwIiwiX3RleHR1cmVzIiwiZHJhd0J1ZmZlcnMiLCJERVBUSF9BVFRBQ0hNRU5UIiwiZ2xEZXB0aFRleHR1cmUiLCJkcmF3QnVmZmVyc1dFQkdMIiwiRkJPc3RhdHVzIiwiY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyIsIkZSQU1FQlVGRkVSX0NPTVBMRVRFIiwiYmluZFJlbmRlcmJ1ZmZlciIsIlJFTkRFUkJVRkZFUiIsIm1heE51bURyYXdCdWZmZXJzIiwiTUFYX0RSQVdfQlVGRkVSU19XRUJHTCIsImdsdCIsIl9jcmVhdGVUZXh0dXJlIiwiREVQVEhfQ09NUE9ORU5UMTYiLCJERVBUSF9DT01QT05FTlQiLCJtSW50ZXJuYWxmb3JtYXQiLCJtVGV4ZWxUeXBlIiwibUZvcm1hdCIsIm1BdXRvU2V0Vmlld3BvcnQiLCJtSW5kZXgiLCJzaG93UGFyYW1ldGVycyIsIkVhc2VOdW1iZXIiLCJtRWFzaW5nIiwiZWFzaW5nIiwiX3ZhbHVlIiwiX3RhcmdldFZhbHVlIiwiX2VmSW5kZXgiLCJfdXBkYXRlIiwiTUlOX0RJRkYiLCJfY2hlY2tMaW1pdCIsImFicyIsIm1BZGQiLCJtTWluIiwibU1heCIsImxpbWl0IiwiX21pbiIsIl9tYXgiLCJyZW1vdmVFRiIsInRhcmdldCIsImVkZ2UxIiwiZWRnZTIiLCJkaWZmIiwiUmF5IiwibU9yaWdpbiIsIm1EaXJlY3Rpb24iLCJvcmlnaW4iLCJkaXJlY3Rpb24iLCJhZGQiLCJtVGFyZ2V0Iiwic3ViIiwibVBvaW50IiwicmVzdWx0IiwiZGlyZWN0aW9uRGlzdGFuY2UiLCJkb3QiLCJkaXN0YW5jZVNxVG9Qb2ludCIsInYxIiwic3F1YXJlZERpc3RhbmNlIiwibUNlbnRlciIsIm1SYWRpdXMiLCJkaXN0YW5jZVRvUG9pbnQiLCJ0Y2EiLCJkMiIsInJhZGl1czIiLCJ0aGMiLCJ0MCIsInQxIiwiYXQiLCJtUGxhbmVDZW50ZXIiLCJtTm9ybWFsIiwiZGVub21pbmF0b3IiLCJtUEEiLCJtUEIiLCJtUEMiLCJiYWNrZmFjZUN1bGxpbmciLCJjcm9zcyIsIkRkTiIsInNpZ24iLCJEZFF4RTIiLCJEZEUxeFEiLCJRZG4iLCJTaGFkZXJMaWJzIiwic2ltcGxlQ29sb3JGcmFnIiwiZ2VuZXJhbFZlcnQiLCJjb3B5RnJhZyIsImJhc2ljVmVydCIsInNreWJveFZlcnQiLCJza3lib3hGcmFnIiwiZ2x0ZlZlcnQiLCJnbHRmRnJhZyIsImRlYnVnRnJhZyIsIkNhbWVyYSIsIl9vcmllbnRhdGlvbiIsIl9wcm9qZWN0aW9uIiwiYUV5ZSIsImFDZW50ZXIiLCJhVXAiLCJfZXllIiwiX2NlbnRlciIsImxvb2tBdCIsInBvc2l0aW9uT2Zmc2V0IiwibVByb2oiLCJtVmlldyIsInNldFZpZXciLCJzZXRQcm9qZWN0aW9uIiwibUludmVyc2VWaWV3UHJvaiIsImNhbWVyYURpciIsIkNhbWVyYVBlcnNwZWN0aXZlIiwibUZvdiIsIm1Bc3BlY3RSYXRpbyIsIm1OZWFyIiwibUZhciIsIl9mb3YiLCJfbmVhciIsIl9mYXIiLCJwZXJzcGVjdGl2ZSIsIm1TY3JlZW5Qb3NpdGlvbiIsIm1SYXkiLCJwcm9qIiwicHJvamVjdGlvbk1hdHJpeCIsInZpZXciLCJ2aWV3TWF0cml4IiwidHJhbnNmb3JtTWF0NCIsIkJpbmFyeUxvYWRlciIsImlzQXJyYXlCdWZmZXIiLCJfcmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJhZGRFdmVudExpc3RlbmVyIiwiX29uTG9hZGVkIiwiX29uUHJvZ3Jlc3MiLCJyZXNwb25zZVR5cGUiLCJ1cmwiLCJjYWxsYmFjayIsIl9jYWxsYmFjayIsIm9wZW4iLCJzZW5kIiwicmVzcG9uc2UiLCJHTE0iLCJWRVJTSU9OIiwiQWxmcmlkIiwiZ2xtIiwiTWF0ZXJpYWwiLCJDdWJlRnJhbWVCdWZmZXIiLCJTY2hlZHVsZXIiLCJFdmVudERpc3BhdGNoZXIiLCJUd2Vlbk51bWJlciIsIkNhbWVyYU9ydGhvIiwiQ2FtZXJhQ3ViZSIsIk9yYml0YWxDb250cm9sIiwiUXVhdFJvdGF0aW9uIiwiVG91Y2hEZXRlY3RvciIsIk9iakxvYWRlciIsIkNvbGxhZGFQYXJzZXIiLCJIRFJMb2FkZXIiLCJHTFRGTG9hZGVyIiwibG9hZEltYWdlcyIsIkJhdGNoQ29weSIsIkJhdGNoQXhpcyIsIkJhdGNoQmFsbCIsIkJhdGNoTGluZSIsIkJhdGNoU2t5Ym94IiwiQmF0Y2hTa3kiLCJCYXRjaEZYQUEiLCJCYXRjaERvdHNQbGFuZSIsIlNjZW5lIiwiVmlldyIsIlZpZXczRCIsIlNoYWRlcnMiLCJXZWJnbE51bWJlciIsIkVmZmVjdENvbXBvc2VyIiwiUGFzc01hY3JvIiwiUGFzc0JsdXIiLCJQYXNzVkJsdXIiLCJQYXNzSEJsdXIiLCJQYXNzRnhhYSIsIk11bHRpc2FtcGxlRnJhbWVCdWZmZXIiLCJUcmFuc2Zvcm1GZWVkYmFja09iamVjdCIsImFsIiwiQUNUSVZFX0FUVFJJQlVURVMiLCJBQ1RJVkVfQVRUUklCVVRFX01BWF9MRU5HVEgiLCJBQ1RJVkVfVEVYVFVSRSIsIkFDVElWRV9VTklGT1JNUyIsIkFDVElWRV9VTklGT1JNX01BWF9MRU5HVEgiLCJBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UiLCJBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UiLCJBTFBIQSIsIkFMUEhBX0JJVFMiLCJBTFdBWVMiLCJBUlJBWV9CVUZGRVJfQklORElORyIsIkFUVEFDSEVEX1NIQURFUlMiLCJCQUNLIiwiQkxFTkRfQ09MT1IiLCJCTEVORF9EU1RfQUxQSEEiLCJCTEVORF9EU1RfUkdCIiwiQkxFTkRfRVFVQVRJT04iLCJCTEVORF9FUVVBVElPTl9BTFBIQSIsIkJMRU5EX0VRVUFUSU9OX1JHQiIsIkJMRU5EX1NSQ19BTFBIQSIsIkJMRU5EX1NSQ19SR0IiLCJCTFVFX0JJVFMiLCJCT09MIiwiQk9PTF9WRUMyIiwiQk9PTF9WRUMzIiwiQk9PTF9WRUM0IiwiQlJPV1NFUl9ERUZBVUxUX1dFQkdMIiwiQlVGRkVSX1NJWkUiLCJCVUZGRVJfVVNBR0UiLCJCWVRFIiwiQ0NXIiwiQ09MT1JfQ0xFQVJfVkFMVUUiLCJDT0xPUl9XUklURU1BU0siLCJDT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyIsIkNPTlNUQU5UX0FMUEhBIiwiQ09OU1RBTlRfQ09MT1IiLCJDT05URVhUX0xPU1RfV0VCR0wiLCJDVUxMX0ZBQ0VfTU9ERSIsIkNVUlJFTlRfUFJPR1JBTSIsIkNVUlJFTlRfVkVSVEVYX0FUVFJJQiIsIkNXIiwiREVDUiIsIkRFQ1JfV1JBUCIsIkRFTEVURV9TVEFUVVMiLCJERVBUSF9CSVRTIiwiREVQVEhfQ0xFQVJfVkFMVUUiLCJSRUQiLCJERVBUSF9GVU5DIiwiREVQVEhfUkFOR0UiLCJERVBUSF9TVEVOQ0lMIiwiREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UIiwiREVQVEhfV1JJVEVNQVNLIiwiRElUSEVSIiwiRE9OVF9DQVJFIiwiRFNUX0FMUEhBIiwiRFNUX0NPTE9SIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElORyIsIkVRVUFMIiwiRkFTVEVTVCIsIkZMT0FUX01BVDIiLCJGTE9BVF9NQVQzIiwiRkxPQVRfTUFUNCIsIkZMT0FUX1ZFQzIiLCJGTE9BVF9WRUMzIiwiRkxPQVRfVkVDNCIsIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX05BTUUiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFIiwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9URVhUVVJFX0NVQkVfTUFQX0ZBQ0UiLCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfTEVWRUwiLCJGUkFNRUJVRkZFUl9CSU5ESU5HIiwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UIiwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TIiwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQiLCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRCIsIkZST05UIiwiRlJPTlRfQU5EX0JBQ0siLCJGUk9OVF9GQUNFIiwiRlVOQ19BREQiLCJGVU5DX1JFVkVSU0VfU1VCVFJBQ1QiLCJGVU5DX1NVQlRSQUNUIiwiR0VORVJBVEVfTUlQTUFQX0hJTlQiLCJHRVFVQUwiLCJHUkVBVEVSIiwiR1JFRU5fQklUUyIsIkhJR0hfRkxPQVQiLCJISUdIX0lOVCIsIklOQ1IiLCJJTkNSX1dSQVAiLCJJTkZPX0xPR19MRU5HVEgiLCJJTlQiLCJJTlRfVkVDMiIsIklOVF9WRUMzIiwiSU5UX1ZFQzQiLCJJTlZBTElEX0VOVU0iLCJJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTiIsIklOVkFMSURfT1BFUkFUSU9OIiwiSU5WQUxJRF9WQUxVRSIsIklOVkVSVCIsIktFRVAiLCJMRVFVQUwiLCJMRVNTIiwiTElORUFSX01JUE1BUF9ORUFSRVNUIiwiTElORVMiLCJMSU5FX0xPT1AiLCJMSU5FX1NUUklQIiwiTElORV9XSURUSCIsIkxJTktfU1RBVFVTIiwiTE9XX0ZMT0FUIiwiTE9XX0lOVCIsIkxVTUlOQU5DRSIsIkxVTUlOQU5DRV9BTFBIQSIsIk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSIsIk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMiLCJNQVhfUkVOREVSQlVGRkVSX1NJWkUiLCJNQVhfVEVYVFVSRV9JTUFHRV9VTklUUyIsIk1BWF9URVhUVVJFX1NJWkUiLCJNQVhfVkFSWUlOR19WRUNUT1JTIiwiTUFYX1ZFUlRFWF9BVFRSSUJTIiwiTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMiLCJNQVhfVklFV1BPUlRfRElNUyIsIk1FRElVTV9GTE9BVCIsIk1FRElVTV9JTlQiLCJNSVJST1JFRF9SRVBFQVQiLCJORUFSRVNUIiwiTkVBUkVTVF9NSVBNQVBfTElORUFSIiwiTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCIsIk5FVkVSIiwiTklDRVNUIiwiTk9ORSIsIk5PVEVRVUFMIiwiTk9fRVJST1IiLCJOVU1fQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMiLCJPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEEiLCJPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1IiLCJPTkVfTUlOVVNfRFNUX0FMUEhBIiwiT05FX01JTlVTX0RTVF9DT0xPUiIsIk9ORV9NSU5VU19TUkNfQ09MT1IiLCJPVVRfT0ZfTUVNT1JZIiwiUEFDS19BTElHTk1FTlQiLCJQT0xZR09OX09GRlNFVF9GQUNUT1IiLCJQT0xZR09OX09GRlNFVF9GSUxMIiwiUE9MWUdPTl9PRkZTRVRfVU5JVFMiLCJSRURfQklUUyIsIlJFTkRFUkJVRkZFUl9BTFBIQV9TSVpFIiwiUkVOREVSQlVGRkVSX0JJTkRJTkciLCJSRU5ERVJCVUZGRVJfQkxVRV9TSVpFIiwiUkVOREVSQlVGRkVSX0RFUFRIX1NJWkUiLCJSRU5ERVJCVUZGRVJfR1JFRU5fU0laRSIsIlJFTkRFUkJVRkZFUl9IRUlHSFQiLCJSRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUIiwiUkVOREVSQlVGRkVSX1JFRF9TSVpFIiwiUkVOREVSQlVGRkVSX1NURU5DSUxfU0laRSIsIlJFTkRFUkJVRkZFUl9XSURUSCIsIlJFTkRFUkVSIiwiUkVQRUFUIiwiUkVQTEFDRSIsIlJHQiIsIlJHQjVfQTEiLCJSR0I1NjUiLCJSR0JBNCIsIlNBTVBMRVJfMkQiLCJTQU1QTEVSX0NVQkUiLCJTQU1QTEVTIiwiU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFIiwiU0FNUExFX0JVRkZFUlMiLCJTQU1QTEVfQ09WRVJBR0UiLCJTQU1QTEVfQ09WRVJBR0VfSU5WRVJUIiwiU0FNUExFX0NPVkVSQUdFX1ZBTFVFIiwiU0NJU1NPUl9CT1giLCJTQ0lTU09SX1RFU1QiLCJTSEFERVJfQ09NUElMRVIiLCJTSEFERVJfU09VUkNFX0xFTkdUSCIsIlNIQURFUl9UWVBFIiwiU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OIiwiU0hPUlQiLCJTUkNfQUxQSEFfU0FUVVJBVEUiLCJTUkNfQ09MT1IiLCJTVEVOQ0lMX0FUVEFDSE1FTlQiLCJTVEVOQ0lMX0JBQ0tfRkFJTCIsIlNURU5DSUxfQkFDS19GVU5DIiwiU1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfRkFJTCIsIlNURU5DSUxfQkFDS19QQVNTX0RFUFRIX1BBU1MiLCJTVEVOQ0lMX0JBQ0tfUkVGIiwiU1RFTkNJTF9CQUNLX1ZBTFVFX01BU0siLCJTVEVOQ0lMX0JBQ0tfV1JJVEVNQVNLIiwiU1RFTkNJTF9CSVRTIiwiU1RFTkNJTF9CVUZGRVJfQklUIiwiU1RFTkNJTF9DTEVBUl9WQUxVRSIsIlNURU5DSUxfRkFJTCIsIlNURU5DSUxfRlVOQyIsIlNURU5DSUxfSU5ERVgiLCJTVEVOQ0lMX0lOREVYOCIsIlNURU5DSUxfUEFTU19ERVBUSF9GQUlMIiwiU1RFTkNJTF9QQVNTX0RFUFRIX1BBU1MiLCJTVEVOQ0lMX1JFRiIsIlNURU5DSUxfVEVTVCIsIlNURU5DSUxfVkFMVUVfTUFTSyIsIlNURU5DSUxfV1JJVEVNQVNLIiwiU1RSRUFNX0RSQVciLCJTVUJQSVhFTF9CSVRTIiwiVEVYVFVSRSIsIlRFWFRVUkUxIiwiVEVYVFVSRTIiLCJURVhUVVJFMyIsIlRFWFRVUkU0IiwiVEVYVFVSRTUiLCJURVhUVVJFNiIsIlRFWFRVUkU3IiwiVEVYVFVSRTgiLCJURVhUVVJFOSIsIlRFWFRVUkUxMCIsIlRFWFRVUkUxMSIsIlRFWFRVUkUxMiIsIlRFWFRVUkUxMyIsIlRFWFRVUkUxNCIsIlRFWFRVUkUxNSIsIlRFWFRVUkUxNiIsIlRFWFRVUkUxNyIsIlRFWFRVUkUxOCIsIlRFWFRVUkUxOSIsIlRFWFRVUkUyMCIsIlRFWFRVUkUyMSIsIlRFWFRVUkUyMiIsIlRFWFRVUkUyMyIsIlRFWFRVUkUyNCIsIlRFWFRVUkUyNSIsIlRFWFRVUkUyNiIsIlRFWFRVUkUyNyIsIlRFWFRVUkUyOCIsIlRFWFRVUkUyOSIsIlRFWFRVUkUzMCIsIlRFWFRVUkUzMSIsIlRFWFRVUkVfQklORElOR18yRCIsIlRFWFRVUkVfQklORElOR19DVUJFX01BUCIsIlRSSUFOR0xFUyIsIlRSSUFOR0xFX0ZBTiIsIlRSSUFOR0xFX1NUUklQIiwiVU5QQUNLX0FMSUdOTUVOVCIsIlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wiLCJVTlNJR05FRF9JTlQiLCJVTlNJR05FRF9TSE9SVF80XzRfNF80IiwiVU5TSUdORURfU0hPUlRfNV81XzVfMSIsIlVOU0lHTkVEX1NIT1JUXzVfNl81IiwiVkFMSURBVEVfU1RBVFVTIiwiVkVORE9SIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElORyIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRCIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRCIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfUE9JTlRFUiIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfU0laRSIsIlZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFIiwiVkVSVEVYX0FUVFJJQl9BUlJBWV9UWVBFIiwiVklFV1BPUlQiLCJaRVJPIiwiUjgiLCJjYWNoZUF0dHJpYkxvYyIsImdldEF0dHJpYkxvY2F0aW9uIiwidW5pZm9ybXMiLCJzdXBwb3J0c0N1c3RvbUV2ZW50cyIsIm5ld1Rlc3RDdXN0b21FdmVudCIsImNyZWF0ZUV2ZW50IiwiX2V2ZW50TGlzdGVuZXJzIiwiYUV2ZW50VHlwZSIsImFGdW5jdGlvbiIsImN1cnJlbnRBcnJheSIsImN1cnJlbnRBcnJheUxlbmd0aCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhRXZlbnQiLCJldmVudFR5cGUiLCJjdXJyZW50VGFyZ2V0IiwidGhlRXJyb3IiLCJuZXdFdmVudCIsImRldGFpbCIsImRpc3BhdGNoZXIiLCJkaXNwYXRjaEV2ZW50IiwiY3VycmVudEV2ZW50TGlzdGVuZXJzIiwiX2NvcHlBcnJheSIsImN1cnJlbnRGdW5jdGlvbiIsImNhbGwiLCJhRGV0YWlsIiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hDdXN0b21FdmVudCIsIm9iamVjdE5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImFBcnJheSIsImdldE1vdXNlIiwibUV2ZW50IiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJjbGllbnRYIiwiY2xpZW50WSIsIm1MaXN0ZW5lclRhcmdldCIsIl90YXJnZXQiLCJfbGlzdGVuZXJUYXJnZXQiLCJfbW91c2UiLCJfcHJlTW91c2UiLCJjZW50ZXIiLCJfdXAiLCJyYWRpdXMiLCJfcHJlUlgiLCJfcHJlUlkiLCJfaXNMb2NrWm9vbSIsIl9pc0xvY2tSb3RhdGlvbiIsIl9pc0ludmVydCIsInNlbnNpdGl2aXR5IiwiX3doZWVsQmluZCIsIl9vbldoZWVsIiwiX2Rvd25CaW5kIiwiX29uRG93biIsIl9tb3ZlQmluZCIsIl9vbk1vdmUiLCJfdXBCaW5kIiwiX29uVXAiLCJjb25uZWN0IiwiZGlzY29ubmVjdCIsIl9pc01vdXNlRG93biIsInRhcmdldFZhbHVlIiwicHJldmVudERlZmF1bHQiLCJkaWZmWCIsImRpZmZZIiwid2hlZWxEZWx0YSIsIl91cGRhdGVQb3NpdGlvbiIsIl91cGRhdGVDYW1lcmEiLCJ0ciIsImV5ZSIsInVwIiwib3J0aG8iLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJuZWFyIiwiZmFyIiwicmVzb2x2ZSIsInJlamVjdCIsIkltYWdlIiwib25sb2FkIiwib25Mb2FkIiwib25lcnJvciIsIm9uRXJyb3IiLCJzcmMiLCJwYXRocyIsImFsbCIsIl9wYXNzZXMiLCJwYXNzIiwibVF1YWxpdHkiLCJmc0JsdXI1IiwiZnNCbHVyOSIsImZzQmx1cjEzIiwiUGFzc0JsdXJCYXNlIiwiZ2V0QW5kQXBwbHlFeHRlbnNpb24iLCJzdWZmaXgiLCJzdWZmaXhSRSIsIlJlZ0V4cCIsImtleSIsInZhbCIsInVuc3VmZml4ZWRLZXkiLCJzdWJzdHJpbmciLCJleHBvc2VBdHRyaWJ1dGVzIiwiaGFzQ2hlY2tlZCIsIl9mbG9hdCIsImNoZWNrRmxvYXQiLCJleHRGbG9hdCIsImhhbGZGbG9hdCIsImNoZWNrSGFsZkZsb2F0IiwiSEFMRl9GTE9BVCIsImV4dEhhbGZGbG9hdCIsIkhBTEZfRkxPQVRfT0VTIiwiZ2V0VGV4dHVyZVBhcmFtZXRlcnMiLCJfc2l6ZSIsImdsVGV4dHVyZSIsIl9mcmFtZUJ1ZmZlcnMiLCJzdGF0dXMiLCJtVGFyZ2V0SW5kZXgiLCJ1c2VEZXB0aCIsInVzZVN0ZW5jaWwiLCJfbnVtU2FtcGxlIiwibnVtU2FtcGxlIiwiZnJhbWVCdWZmZXJDb2xvciIsInJlbmRlckJ1ZmZlckNvbG9yIiwiY3JlYXRlUmVuZGVyYnVmZmVyIiwicmVuZGVyQnVmZmVyRGVwdGgiLCJyZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUiLCJSR0JBOCIsImZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyIiwiZm9yY2VOZWFyZXN0IiwiUkVBRF9GUkFNRUJVRkZFUiIsImNsZWFyQnVmZmVyZnYiLCJDT0xPUiIsImJsaXRGcmFtZWJ1ZmZlciIsIl9nZW9DdXJyZW50IiwiX2dlb1RhcmdldCIsIl9udW1Qb2ludHMiLCJjcmVhdGVUcmFuc2Zvcm1GZWVkYmFjayIsIm1WYXJ5aW5nTmFtZSIsImlzVHJhbnNmb3JtRmVlZGJhY2siLCJTVFJFQU1fQ09QWSIsImdlbmVyYXRlIiwiZHJhd1RyYW5zZm9ybUZlZWRiYWNrIiwiX3N3YXAiLCJFYXNpbmciLCJMaW5lYXIiLCJOb25lIiwiayIsIlF1YWRyYXRpYyIsIkluIiwiT3V0IiwiSW5PdXQiLCJDdWJpYyIsIlF1YXJ0aWMiLCJRdWludGljIiwiU2ludXNvaWRhbCIsIkV4cG9uZW50aWFsIiwicG93IiwiQ2lyY3VsYXIiLCJFbGFzdGljIiwicCIsImFzaW4iLCJCYWNrIiwiQm91bmNlIiwiaW4iLCJvdXQiLCJpbk91dCIsImdldEZ1bmMiLCJtU3BlZWQiLCJfc3RhcnRWYWx1ZSIsIl9jb3VudGVyIiwic3BlZWQiLCJuZXdDb3VudGVyIiwiZiIsIm0iLCJfdlpheGlzIiwiX3pBeGlzIiwicHJlTW91c2UiLCJtb3VzZSIsInF1YXQiLCJ0ZW1wUm90YXRpb24iLCJfcm90YXRlWk1hcmdpbiIsIl9vZmZzZXQiLCJfc2xlcnAiLCJfaXNMb2NrZWQiLCJfZGlmZlgiLCJfZGlmZlkiLCJfdXBkYXRlUm90YXRpb24iLCJfY3VyckRpZmZYIiwiX2N1cnJEaWZmWSIsIl9pc1JvdGF0ZVoiLCJfdGFyZ2V0UXVhdCIsInNldFRvIiwibVRlbXBSb3RhdGlvbiIsImFuZ2xlIiwic2xlcnAiLCJ0cmFuc2Zvcm1RdWF0IiwiZGlzdGFuY2UiLCJkeCIsImR5IiwibVNraXBNb3ZlQ2hlY2siLCJfY2FtZXJhIiwiZmFjZVZlcnRpY2VzIiwiZmFjZXMiLCJjbGlja1RvbGVyYW5jZSIsIl9yYXkiLCJfaGl0IiwiX2xhc3RQb3MiLCJfZmlyc3RQb3MiLCJtdHhNb2RlbCIsIl9za2lwcGluZ01vdmUiLCJfb25Nb3ZlQmluZCIsIl9vbkRvd25CaW5kIiwiX29uVXBCaW5kIiwibXgiLCJteSIsImdlbmVyYXRlUmF5IiwiaGl0IiwidjAiLCJ2MiIsImRpc3QiLCJnZXRWZWN0b3IiLCJpbnRlcnNlY3RUcmlhbmdsZSIsImRpc3RUb0NhbSIsIl9jaGVja0hpdCIsIkNBTUVSQV9TRVRUSU5HUyIsInNldFBlcnNwZWN0aXZlIiwicGFyc2VPYmoiLCJvYmpTdHIiLCJmaW5hbE5vcm1hbHMiLCJ1dnMiLCJ2ZXJ0ZXhQYXR0ZXJuIiwibm9ybWFsUGF0dGVybiIsInV2UGF0dGVybiIsImZhY2VQYXR0ZXJuMSIsImZhY2VQYXR0ZXJuMiIsImZhY2VQYXR0ZXJuMyIsImZhY2VQYXR0ZXJuNCIsInBhcnNlVmVydGV4SW5kZXgiLCJwYXJzZUludCIsInBhcnNlTm9ybWFsSW5kZXgiLCJwYXJzZVVWSW5kZXgiLCJhZGRWZXJ0ZXgiLCJhZGRVViIsImFkZE5vcm1hbCIsImFkZEZhY2UiLCJ1YSIsInViIiwidWMiLCJ1ZCIsIm5hIiwibmIiLCJuYyIsIm5kIiwiaWQiLCJsaW5lIiwidHJpbSIsImNoYXJBdCIsImV4ZWMiLCJwYXJzZUZsb2F0IiwiX2dlbmVyYXRlR2VvbWV0cnkiLCJtYXhOdW1WZXJ0aWNlcyIsImhhc05vcm1hbHMiLCJoYXNVVnMiLCJnZW9tZXRyaWVzIiwibGFzdEluZGV4Iiwib0NvcHkiLCJzbGljZU51bSIsInRtcEluZGV4IiwicGFyc2UiLCJsb2FkZXIiLCJyYWRpYW5jZVBhdHRlcm4iLCJjb21tZW50UGF0dGVybiIsImV4cG9zdXJlUGF0dGVybiIsImZvcm1hdFBhdHRlcm4iLCJ3aWR0aEhlaWdodFBhdHRlcm4iLCJyZWFkUGl4ZWxzUmF3UkxFIiwiZmlsZU9mZnNldCIsInNjYW5saW5lV2lkdGgiLCJudW1TY2FubGluZXMiLCJyZ2JlIiwic2NhbmxpbmVCdWZmZXIiLCJwdHIiLCJwdHJFbmQiLCJidWYiLCJidWZmZXJMZW5ndGgiLCJyZWFkQnVmIiwiYnl0ZXNSZWFkIiwicmVhZEJ1Zk9mZnNldCIsInJlYWRQaXhlbHNSYXciLCJudW1waXhlbHMiLCJudW1FeHBlY3RlZCIsIm51bVJlYWQiLCJFcnJvciIsInBhcnNlSGRyIiwiQXJyYXlCdWZmZXIiLCJORVdfTElORSIsInJlYWRMaW5lIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZXhwb3N1cmUiLCJnYW1tYSIsInJsZSIsIm1hdGNoIiwiTnVtYmVyIiwiZmxvYXREYXRhIiwiZmxvYXRPZmZzZXQiLCJnZW5lcmF0ZUdlb21ldHJ5IiwibWVzaGVzIiwiY2FjaGVzIiwidHJpYW5nbGVzIiwiZ2xHZW9tZXRyeSIsImJ1ZmZlckZsYXR0ZW5EYXRhIiwibG9hZCIsIm1QYXRoIiwibUNhbGxiYWNrIiwiQVJSQVlfQ1RPUl9NQVAiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJTSVpFX01BUCIsIlNDQUxBUiIsIlZFQzIiLCJWRUMzIiwiVkVDNCIsIk1BVDIiLCJNQVQzIiwiTUFUNCIsInNlbWFudGljQXR0cmlidXRlTWFwIiwiTk9STUFMIiwiUE9TSVRJT04iLCJURVhDT09SRF8wIiwiV0VJR0hUU18wIiwiSk9JTlRTXzAiLCJiYXNlIiwibGFzdEluZGV4T2YiLCJfbG9hZEdsdGYiLCJ0aGVuIiwiX2xvYWRCaW4iLCJfbG9hZFRleHR1cmVzIiwiX2dldEJ1ZmZlclZpZXdEYXRhIiwiX3BhcnNlTWF0ZXJpYWxzIiwiX3BhcnNlTWVzaCIsIl9wYXJzZU5vZGVzIiwiZ2x0ZkluZm8iLCJjYXRjaCIsImdsdGYiLCJub2RlcyIsInNjZW5lcyIsImdldFRyZWUiLCJub2RlSW5kZXgiLCJub2RlIiwib2JqM0QiLCJvdXRwdXQiLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZVoiLCJyb3RhdGlvbiIsInNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24iLCJ0cmFuc2xhdGlvbiIsIl9jaGlsZCIsImFkZENoaWxkIiwiY29udGFpbmVyIiwic2NlbmUiLCJjaGlsZFRyZWUiLCJwcmltaXRpdmVzIiwiZ2VvbWV0cnlJbmZvIiwic2VtYW50aWNzIiwiT2JqZWN0Iiwia2V5cyIsInByaW1pdGl2ZUluZm8iLCJhY2Nlc3NvcklkeCIsInNlbWFudGljIiwiYXR0cmlidXRlSW5mbyIsImFjY2Vzc29ycyIsImF0dHJpYnV0ZU5hbWUiLCJIQVNfTk9STUFMUyIsIkhBU19VViIsImF0dHJpYnV0ZUFycmF5IiwiX2dldEFjY2Vzc29yRGF0YSIsIm1hdGVyaWFsSW5mbyIsImVtaXNzaXZlRmFjb3RyIiwibm9ybWFsVGV4dHVyZSIsIm9jY2x1c2lvblRleHR1cmUiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyIsImJhc2VDb2xvclRleHR1cmUiLCJtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUiLCJ1RW1pc3NpdmVGYWN0b3IiLCJ1QmFzZUNvbG9yIiwiYmFzZUNvbG9yRmFjdG9yIiwidVJvdWdobmVzcyIsInJvdWdobmVzc0ZhY3RvciIsInVNZXRhbGxpYyIsIm1ldGFsbGljRmFjdG9yIiwidVNjYWxlRGlmZkJhc2VNUiIsInVTY2FsZUZHRFNwZWMiLCJ1U2NhbGVJQkxBbWJpZW50IiwidUxpZ2h0RGlyZWN0aW9uIiwidUxpZ2h0Q29sb3IiLCJ1R2FtbWEiLCJ1Q29sb3JNYXAiLCJ1TWV0YWxsaWNSb3VnaG5lc3NNYXAiLCJ1Tm9ybWFsU2NhbGUiLCJ1Tm9ybWFsTWFwIiwidUFvTWFwIiwidU9jY2x1c2lvblN0cmVuZ3RoIiwic3RyZW5ndGgiLCJidWZmZXJWaWV3cyIsImJ1ZmZlclZpZXdJbmZvIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJKU09OIiwidGV4dHVyZXMiLCJ1cmxCaW4iLCJ1cmkiLCJzYW1wbGVycyIsImltYWdlc1RvTG9hZCIsInNldHRpbmdzIiwic2FtcGxlciIsIm1hdGVyaWFscyIsIlVTRV9JQkwiLCJIQVNfTk9STUFMTUFQIiwiSEFTX09DQ0xVU0lPTk1BUCIsIkhBU19CQVNFQ09MT1JNQVAiLCJIQVNfTUVUQUxST1VHSE5FU1NNQVAiLCJtR2x0ZkluZm8iLCJtQmluIiwiaXNJbmRpY2VzIiwiYWNjZXNzb3JJbmZvIiwiYnVmZmVyVmlldyIsIkFycmF5Q3RvciIsImNvbXBvbmVudFR5cGUiLCJhcnIiLCJxdWFudGl6ZUV4dGVuc2lvbiIsImRlY29kZWRBcnIiLCJkZWNvZGVNYXRyaXgiLCJkZWNvZGVPZmZzZXQiLCJkZWNvZGVTY2FsZSIsIlByb21pc2UiLCJyZXEiLCJfcmV0dXJuVGV4dHVyZSIsInBhc3NlcyIsImFkZFBhc3MiLCJmYm9UYXJnZXQiLCJoYXNGYm8iLCJmYm8iLCJfZmJvVGFyZ2V0IiwicmVuZGVyIiwiZ2V0VGV4dHVyZSIsIl9mYm9DdXJyZW50IiwiX2N1cnJlbnQiLCJ2Qmx1ciIsImhCbHVyIiwiY29sb3JzIiwiY29sb3IiLCJvcGFjaXR5IiwibVBvc2l0aW9uQSIsIm1Qb3NpdGlvbkIiLCJzZWciLCJfbWF0cml4SWRlbnRpdHkiLCJfaW5pdFZpZXdzIiwicmVzaXplIiwic2V0QXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsInRvUmVuZGVyIiwib3JiaXRhbENvbnRyb2wiLCJjYW1lcmFPcnRobyIsInNldE1hdHJpY2VzIiwiX3JlbmRlckNoaWxkcmVuIiwibVN0clZlcnRleCIsIm1TdHJGcmFnIiwiX21hdHJpeFRlbXAiLCJndWkiLCJHVUkiLCJkaXYiLCJib2R5IiwicXVlcnlTZWxlY3RvciIsInN0eWxlIiwiekluZGV4Iiwic3RhdHMiLCJhcHBlbmRDaGlsZCIsImRvbUVsZW1lbnQiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQTJEO0FBQzNEO0FBQ0E7QUFDQSxXQUFHOztBQUVILG9EQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7OztBQUlBO0FBQ0Esc0RBQThDO0FBQzlDO0FBQ0E7QUFDQSxvQ0FBNEI7QUFDNUIscUNBQTZCO0FBQzdCLHlDQUFpQzs7QUFFakMsK0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUFzQztBQUN0QztBQUNBO0FBQ0EscUNBQTZCO0FBQzdCLHFDQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQSw0REFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQWMsNEJBQTRC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YSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE1BQU07QUFDakIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3Z3QkQ7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FB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O0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlFQUF5QyxhQUFhOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE1BQU07QUFDakIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEI7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7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Q0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FB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QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQyx3RUFBd0U7O0FBRXhFO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0EsNkJBQTZCO0FBQzdCLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0U7QUFDbEU7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsK0NBQStDO0FBQy9DLDRCQUE0QjtBQUM1QjtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBLDBDQUEwQztBQUMxQyw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQSx3RkFBd0Y7QUFDeEY7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQyxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QjtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIseUNBQXlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixHQUFHOztBQUVIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0Q0FBNEM7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QjtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0MsMERBQTBEO0FBQzFELDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEIscUNBQXFDLE9BQU87QUFDNUMsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQsNkRBQTZEO0FBQzdEOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMscUJBQXFCO0FBQ3JCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5QixpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7Ozs7Ozs7QUMzaUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFJQSxJQUFNeWxCLGlCQUFpQjtBQUN0QixPQUFNQyxTQURnQjtBQUV0QixPQUFNcDFCLFVBRmdCO0FBR3RCLE9BQU1xMUIsVUFIZ0I7QUFJdEIsT0FBTTFnQyxXQUpnQjtBQUt0QixPQUFNMmdDLFdBTGdCO0FBTXRCLE9BQU1wbkM7QUFOZ0IsQ0FBdkIsQyxDQW5CQTs7QUE0QkEsSUFBTXFuQyxXQUFXO0FBQ2hCQyxTQUFRLENBRFE7QUFFaEJDLE9BQU0sQ0FGVTtBQUdoQkMsT0FBTSxDQUhVO0FBSWhCQyxPQUFNLENBSlU7QUFLaEJDLE9BQU0sQ0FMVTtBQU1oQkMsT0FBTSxDQU5VO0FBT2hCQyxPQUFNO0FBUFUsQ0FBakI7O0FBVUEsSUFBTUMsdUJBQXVCO0FBQzVCQyxTQUFRLFNBRG9CO0FBRTVCQyxXQUFVLGlCQUZrQjtBQUc1QjtBQUNBQyxhQUFZLGVBSmdCO0FBSzVCO0FBQ0FDLFlBQVcsU0FOaUI7QUFPNUJDLFdBQVUsUUFQa0I7QUFRNUJ6TSxRQUFPO0FBUnFCLENBQTdCOztBQVdBLElBQUkwTSxhQUFKOztBQUVBLElBQU1yQixPQUFPLFNBQVBBLElBQU8sQ0FBQ3o0QixPQUFEO0FBQUEsUUFBYSw4QkFBWSxVQUFDNnBCLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUMxRCxNQUFJLE9BQU85cEIsT0FBUixLQUFxQixRQUF4QixFQUFrQztBQUNqQzg1QixVQUFPOTVCLFFBQVFxckIsU0FBUixDQUFrQixDQUFsQixFQUFxQnJyQixRQUFRKzVCLFdBQVIsQ0FBb0IsR0FBcEIsSUFBeUIsQ0FBOUMsQ0FBUDtBQUNBLEdBRkQsTUFFTztBQUNORCxVQUFPLEVBQVA7QUFDQTs7QUFFREUsWUFBVWg2QixPQUFWLEVBQ0VpNkIsSUFERixDQUNPQyxRQURQLEVBRUVELElBRkYsQ0FFT0UsYUFGUCxFQUdFRixJQUhGLENBR09HLGtCQUhQLEVBSUVILElBSkYsQ0FJT0ksZUFKUCxFQUtFSixJQUxGLENBS09LLFVBTFAsRUFNRUwsSUFORixDQU1PTSxXQU5QLEVBT0VOLElBUEYsQ0FPTyxVQUFDTyxRQUFELEVBQVk7QUFDakIzUSxXQUFRMlEsUUFBUjtBQUNBLEdBVEYsRUFVRUMsS0FWRixDQVVRLGFBQUs7QUFDWHp4QyxXQUFRVSxHQUFSLENBQVksUUFBWixFQUFzQm1ILENBQXRCO0FBQ0EsR0FaRjtBQWFBLEVBcEJ5QixDQUFiO0FBQUEsQ0FBYjs7QUF1QkEsSUFBTTBwQyxjQUFjLFNBQWRBLFdBQWMsQ0FBQ0csSUFBRDtBQUFBLFFBQVUsOEJBQVksVUFBQzdRLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUFBLE1BQ3RENlEsS0FEc0QsR0FDcENELElBRG9DLENBQ3REQyxLQURzRDtBQUFBLE1BQy9DQyxNQUQrQyxHQUNwQ0YsSUFEb0MsQ0FDL0NFLE1BRCtDOzs7QUFHOUQsTUFBTUMsVUFBVSxTQUFWQSxPQUFVLENBQUNDLFNBQUQsRUFBZTtBQUM5QixPQUFNQyxPQUFPSixNQUFNRyxTQUFOLENBQWI7QUFDQSxPQUFNRSxRQUFRRCxLQUFLNStCLElBQUwsS0FBY3BULFNBQWQsR0FBMEIsd0JBQTFCLEdBQTJDMnhDLEtBQUtPLE1BQUwsQ0FBWTdDLE1BQVosQ0FBbUIyQyxLQUFLNStCLElBQXhCLENBQXpEOztBQUdBLE9BQUc0K0IsS0FBS3Y3QixLQUFSLEVBQWU7QUFDZHc3QixVQUFNRSxNQUFOLEdBQWVILEtBQUt2N0IsS0FBTCxDQUFXLENBQVgsQ0FBZjtBQUNBdzdCLFVBQU1HLE1BQU4sR0FBZUosS0FBS3Y3QixLQUFMLENBQVcsQ0FBWCxDQUFmO0FBQ0F3N0IsVUFBTUksTUFBTixHQUFlTCxLQUFLdjdCLEtBQUwsQ0FBVyxDQUFYLENBQWY7QUFDQTs7QUFFRCxPQUFHdTdCLEtBQUtNLFFBQVIsRUFBa0I7QUFDakJMLFVBQU1NLHlCQUFOLENBQWdDUCxLQUFLTSxRQUFyQztBQUNBOztBQUVELE9BQUdOLEtBQUtRLFdBQVIsRUFBcUI7QUFDcEJQLFVBQU0xd0MsQ0FBTixHQUFVeXdDLEtBQUtRLFdBQUwsQ0FBaUIsQ0FBakIsQ0FBVjtBQUNBUCxVQUFNendDLENBQU4sR0FBVXd3QyxLQUFLUSxXQUFMLENBQWlCLENBQWpCLENBQVY7QUFDQVAsVUFBTXY5QixDQUFOLEdBQVVzOUIsS0FBS1EsV0FBTCxDQUFpQixDQUFqQixDQUFWO0FBQ0E7O0FBRUQsT0FBR1IsS0FBSzdzQyxRQUFSLEVBQWtCO0FBQ2pCNnNDLFNBQUs3c0MsUUFBTCxDQUFjQyxPQUFkLENBQXNCLGlCQUFTO0FBQzlCLFNBQU1xdEMsU0FBU1gsUUFBUXpzQyxLQUFSLENBQWY7QUFDQTRzQyxXQUFNUyxRQUFOLENBQWVELE1BQWY7QUFDQSxLQUhEO0FBSUE7O0FBR0QsVUFBT1IsS0FBUDtBQUNBLEdBOUJEOztBQWdDQU4sT0FBS08sTUFBTCxDQUFZTCxNQUFaLEdBQXFCQSxPQUFPNXpCLEdBQVAsQ0FBVyxpQkFBUztBQUN4QyxPQUFNMDBCLFlBQVksd0JBQWxCO0FBQ0FDLFNBQU1oQixLQUFOLENBQVl4c0MsT0FBWixDQUFvQixxQkFBYTtBQUNoQyxRQUFNeXRDLFlBQVlmLFFBQVFDLFNBQVIsQ0FBbEI7QUFDQVksY0FBVUQsUUFBVixDQUFtQkcsU0FBbkI7QUFDQSxJQUhEOztBQUtBLFVBQU9GLFNBQVA7QUFDQSxHQVJvQixDQUFyQjs7QUFVQTdSLFVBQVE2USxJQUFSO0FBQ0EsRUE5QzZCLENBQVY7QUFBQSxDQUFwQjs7QUFpREEsSUFBTUosYUFBYSxTQUFiQSxVQUFhLENBQUNJLElBQUQ7QUFBQSxRQUFVLDhCQUFZLFVBQUM3USxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFBQSxNQUNyRHNPLE1BRHFELEdBQzFDc0MsSUFEMEMsQ0FDckR0QyxNQURxRDs7O0FBSTdEQSxTQUFPanFDLE9BQVAsQ0FBZ0IsZ0JBQVE7QUFBQSxPQUNmMHRDLFVBRGUsR0FDQTEvQixJQURBLENBQ2YwL0IsVUFEZTs7O0FBR3ZCLE9BQU1DLGVBQWUsRUFBckI7O0FBRUFELGNBQVcxdEMsT0FBWCxDQUFvQix5QkFBaUI7QUFDcEMsUUFBTTR0QyxZQUFZQyxPQUFPQyxJQUFQLENBQVlDLGNBQWNydEMsVUFBMUIsQ0FBbEI7QUFDQSxRQUFJeVksVUFBVSxFQUFkOztBQUVBeTBCLGNBQVU1dEMsT0FBVixDQUFtQixvQkFBWTtBQUM5QixTQUFNZ3VDLGNBQWNELGNBQWNydEMsVUFBZCxDQUF5QnV0QyxRQUF6QixDQUFwQjtBQUNBLFNBQU1DLGdCQUFnQjNCLEtBQUs0QixTQUFMLENBQWVILFdBQWYsQ0FBdEI7QUFDQSxTQUFNSSxnQkFBZ0IvQyxxQkFBcUI0QyxRQUFyQixDQUF0QjtBQUNBLFNBQUcsQ0FBQ0csYUFBSixFQUFtQjtBQUNsQjtBQUNBO0FBQ0QsU0FBR0gsYUFBYSxRQUFoQixFQUEwQjtBQUN6QjkwQixjQUFRazFCLFdBQVIsR0FBc0IsQ0FBdEI7QUFDQTtBQUNELFNBQUdKLFNBQVNyb0MsT0FBVCxDQUFpQixVQUFqQixJQUErQixDQUFDLENBQW5DLEVBQXNDO0FBQ3JDdVQsY0FBUW0xQixNQUFSLEdBQWlCLENBQWpCO0FBQ0E7O0FBR0QsU0FBTWpnQyxPQUFPdzhCLFNBQVNxRCxjQUFjem9DLElBQXZCLENBQWI7QUFDQSxTQUFJOG9DLGlCQUFpQkMsaUJBQWlCakMsSUFBakIsRUFBdUJ5QixXQUF2QixDQUFyQjtBQUNBLFNBQUlPLDBCQUEwQjNELFdBQTlCLEVBQTJDO0FBQzFDMkQsdUJBQWlCLElBQUkvcUMsWUFBSixDQUFpQitxQyxjQUFqQixDQUFqQjtBQUNBOztBQUVELFNBQUdOLGFBQWEsWUFBaEIsRUFBOEI7QUFDN0JwekMsY0FBUVUsR0FBUixDQUFZOFMsSUFBWixFQUFrQmtnQyxjQUFsQjtBQUNBOztBQUVEWixrQkFBYVMsYUFBYixJQUE4QjtBQUM3QjFvQyxhQUFNNm9DLGNBRHVCO0FBRTdCbGdDO0FBRjZCLE1BQTlCO0FBSUE7QUFDQSxLQTlCRDs7QUFnQ0E7QUFDQSxRQUFJMC9CLGNBQWNoaUMsT0FBZCxJQUF5QixJQUE3QixFQUFtQztBQUNsQyxTQUFNd2lDLGlCQUFpQkMsaUJBQWlCakMsSUFBakIsRUFBdUJ3QixjQUFjaGlDLE9BQXJDLEVBQThDLElBQTlDLENBQXZCO0FBQ0E0aEMsa0JBQWE1aEMsT0FBYixHQUF1QjtBQUN0QnJHLGFBQU02b0MsY0FEZ0I7QUFFdEJsZ0MsWUFBSztBQUZpQixNQUF2QjtBQUlBOztBQUVELFFBQU0vTyxXQUFXLHdCQUFqQjs7QUFFQSxTQUFJLElBQU00VixDQUFWLElBQWV5NEIsWUFBZixFQUE2QjtBQUM1QixTQUFNdmpDLE9BQU91akMsYUFBYXo0QixDQUFiLENBQWI7QUFDQSxTQUFHQSxNQUFNLFNBQVQsRUFBb0I7QUFDbkI1VixlQUFTK3FDLGlCQUFULENBQTJCamdDLEtBQUsxRSxLQUFoQyxFQUF1Q3dQLENBQXZDLEVBQTBDOUssS0FBS2lFLElBQS9DO0FBQ0EsTUFGRCxNQUVPO0FBQ04vTyxlQUFTNk8sV0FBVCxDQUFxQi9ELEtBQUsxRSxLQUExQjtBQUNBO0FBQ0Q7O0FBRUQsUUFBTStvQyxlQUFlbEMsS0FBS08sTUFBTCxDQUFZMkIsWUFBWixDQUF5QlYsY0FBYzF1QyxRQUF2QyxDQUFyQjtBQUNBOFosY0FBVSw0QkFBYUEsT0FBYixFQUFzQnMxQixhQUFhdDFCLE9BQW5DLENBQVY7O0FBekRvQyxRQTZEbkN1MUIsY0E3RG1DLEdBaUVoQ0QsWUFqRWdDLENBNkRuQ0MsY0E3RG1DO0FBQUEsUUE4RG5DQyxhQTlEbUMsR0FpRWhDRixZQWpFZ0MsQ0E4RG5DRSxhQTlEbUM7QUFBQSxRQStEbkNDLGdCQS9EbUMsR0FpRWhDSCxZQWpFZ0MsQ0ErRG5DRyxnQkEvRG1DO0FBQUEsUUFnRW5DQyxvQkFoRW1DLEdBaUVoQ0osWUFqRWdDLENBZ0VuQ0ksb0JBaEVtQztBQUFBLFFBb0VuQ0MsZ0JBcEVtQyxHQXNFaENELG9CQXRFZ0MsQ0FvRW5DQyxnQkFwRW1DO0FBQUEsUUFxRW5DQyx3QkFyRW1DLEdBc0VoQ0Ysb0JBdEVnQyxDQXFFbkNFLHdCQXJFbUM7OztBQXdFcEMsUUFBTWxZLFdBQVc7QUFDaEJtWSxzQkFBZ0JOLGtCQUFrQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQURsQjtBQUVoQk8saUJBQVdKLHFCQUFxQkssZUFBckIsSUFBd0MsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBRm5DO0FBR2hCQyxpQkFBV04scUJBQXFCTyxlQUFyQixJQUF3QyxDQUhuQztBQUloQkMsZ0JBQVVSLHFCQUFxQlMsY0FBckIsSUFBdUMsQ0FKakM7QUFLaEJDLHVCQUFpQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FMRDtBQU1oQkMsb0JBQWMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBTkU7QUFPaEJDLHVCQUFpQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FQRDtBQVFoQkMsc0JBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBUkE7QUFTaEJDLGtCQUFZLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBVEk7QUFVaEJDLGFBQU87QUFWUyxLQUFqQjs7QUFhQSxRQUFJZCxnQkFBSixFQUFzQjtBQUNyQmpZLGNBQVNnWixTQUFULEdBQXFCZixpQkFBaUIvUSxTQUF0QztBQUNBOztBQUVELFFBQUlnUix3QkFBSixFQUE4QjtBQUM3QmxZLGNBQVNpWixxQkFBVCxHQUFpQ2YseUJBQXlCaFIsU0FBMUQ7QUFDQTs7QUFFRCxRQUFJNFEsYUFBSixFQUFtQjtBQUNsQjlYLGNBQVNrWixZQUFULEdBQXdCcEIsY0FBY3Q5QixLQUFkLElBQXVCLENBQS9DO0FBQ0F3bEIsY0FBU21aLFVBQVQsR0FBc0JyQixjQUFjNVEsU0FBcEM7QUFDQTs7QUFFRCxRQUFJNlEsZ0JBQUosRUFBc0I7QUFDckIvWCxjQUFTb1osTUFBVCxHQUFrQnJCLGlCQUFpQjdRLFNBQW5DO0FBQ0FsSCxjQUFTcVosa0JBQVQsR0FBOEJ0QixpQkFBaUJ1QixRQUFqQixJQUE2QixDQUEzRDtBQUNBOztBQUVELFFBQU05d0MsV0FBVyx1QkFBYSxxQkFBVzJoQixRQUF4QixFQUFrQyxxQkFBV0MsUUFBN0MsRUFBdUQ0VixRQUF2RCxFQUFpRTFkLE9BQWpFLENBQWpCO0FBQ0EsUUFBTW5MLE9BQU8sbUJBQVMxTyxRQUFULEVBQW1CRCxRQUFuQixDQUFiO0FBQ0FrdEMsU0FBS08sTUFBTCxDQUFZN0MsTUFBWixDQUFtQjduQyxJQUFuQixDQUF3QjRMLElBQXhCO0FBQ0EsSUExR0Q7QUEyR0EsR0FoSEQ7O0FBa0hBMHRCLFVBQVE2USxJQUFSO0FBQ0EsRUF2SDRCLENBQVY7QUFBQSxDQUFuQjs7QUF5SEEsSUFBTU4scUJBQXFCLFNBQXJCQSxrQkFBcUIsQ0FBQ0ksUUFBRDtBQUFBLFFBQWMsOEJBQVksVUFBQzNRLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUFBLE1BQ2pFeVUsV0FEaUUsR0FDeEMvRCxRQUR3QyxDQUNqRStELFdBRGlFO0FBQUEsTUFDcERoMUIsT0FEb0QsR0FDeENpeEIsUUFEd0MsQ0FDcERqeEIsT0FEb0Q7OztBQUd6RWcxQixjQUFZcHdDLE9BQVosQ0FBb0IsVUFBQ3F3QyxjQUFELEVBQWlCMTBDLENBQWpCLEVBQXVCO0FBQzFDLE9BQU1tRixTQUFTc2EsUUFBUWkxQixlQUFldnZDLE1BQXZCLEVBQStCc0osSUFBOUM7QUFDQWltQyxrQkFBZWptQyxJQUFmLEdBQXNCdEosT0FBT3lDLEtBQVAsQ0FBYThzQyxlQUFlQyxVQUFmLElBQTZCLENBQTFDLEVBQTZDLENBQUNELGVBQWVDLFVBQWYsSUFBNkIsQ0FBOUIsS0FBb0NELGVBQWVFLFVBQWYsSUFBNkIsQ0FBakUsQ0FBN0MsQ0FBdEI7QUFDQSxHQUhEO0FBSUE3VSxVQUFRMlEsUUFBUjtBQUNBLEVBUndDLENBQWQ7QUFBQSxDQUEzQjs7QUFVQSxJQUFNUixZQUFZLFNBQVpBLFNBQVksQ0FBQ2g2QixPQUFEO0FBQUEsUUFBYSw4QkFBWSxVQUFDNnBCLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUMvRCxNQUFJLE9BQU85cEIsT0FBUixLQUFxQixRQUF4QixFQUFrQztBQUNqQzZwQixXQUFRN3BCLE9BQVI7QUFDQSxHQUZELE1BRU87QUFDTixzQkFBSUEsT0FBSixFQUFhaTZCLElBQWIsQ0FBa0IsVUFBQzFqQyxDQUFELEVBQUs7QUFDdEIsUUFBTWlrQyxXQUFXbUUsS0FBSzlJLEtBQUwsQ0FBV3QvQixDQUFYLENBQWpCO0FBQ0Fpa0MsYUFBU1MsTUFBVCxHQUFrQjtBQUNqQjdDLGFBQU8sRUFEVTtBQUVqQndDLGFBQU8sRUFGVTtBQUdqQmdFLGVBQVMsRUFIUTtBQUlqQnB4QyxlQUFTLEVBSlE7QUFLakJvdkMsbUJBQWE7QUFMSSxLQUFsQjs7QUFRQS9TLFlBQVEyUSxRQUFSO0FBQ0EsSUFYRCxFQVdHLFVBQUMzcEMsQ0FBRCxFQUFNO0FBQ1JpNUIsV0FBT2o1QixDQUFQO0FBQ0EsSUFiRDtBQWNBO0FBQ0QsRUFuQjhCLENBQWI7QUFBQSxDQUFsQjs7QUFzQkEsSUFBTXFwQyxXQUFXLFNBQVhBLFFBQVcsQ0FBQ00sUUFBRDtBQUFBLFFBQWMsOEJBQVksVUFBQzNRLE9BQUQsRUFBVUMsTUFBVixFQUFxQjs7QUFFL0QsTUFBRzBRLFNBQVNqeEIsT0FBWixFQUFxQjtBQUNwQixPQUFJN0wsUUFBUTg4QixTQUFTanhCLE9BQVQsQ0FBaUJ4ZixNQUE3Qjs7QUFFQXl3QyxZQUFTanhCLE9BQVQsQ0FBaUJwYixPQUFqQixDQUF5QixrQkFBVTs7QUFFbEMsUUFBTTB3QyxjQUFZL0UsSUFBWixHQUFtQlUsU0FBU2p4QixPQUFULENBQWlCLENBQWpCLEVBQW9CdTFCLEdBQTdDO0FBQ0EsdUJBQUlELE1BQUosRUFBWSxJQUFaLEVBQWtCNUUsSUFBbEIsQ0FBdUIsVUFBQzFqQyxDQUFELEVBQU07QUFDNUJ0SCxZQUFPc0osSUFBUCxHQUFjaEMsQ0FBZDs7QUFFQW1IO0FBQ0EsU0FBR0EsVUFBVSxDQUFiLEVBQWdCO0FBQ2Ztc0IsY0FBUTJRLFFBQVI7QUFDQTtBQUVELEtBUkQsRUFRRyxhQUFLO0FBQ1AxUSxZQUFPajVCLENBQVA7QUFDQSxLQVZEO0FBV0EsSUFkRDtBQWdCQSxHQW5CRCxNQW1CTztBQUNOZzVCLFdBQVEyUSxRQUFSO0FBQ0E7QUFFRCxFQXpCOEIsQ0FBZDtBQUFBLENBQWpCOztBQTJCQSxJQUFNTCxnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQUNLLFFBQUQ7QUFBQSxRQUFjLDhCQUFZLFVBQUMzUSxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFBQSxNQUM1RDhVLFFBRDRELEdBQzdCcEUsUUFENkIsQ0FDNURvRSxRQUQ0RDtBQUFBLE1BQ2xENzNCLE1BRGtELEdBQzdCeXpCLFFBRDZCLENBQ2xEenpCLE1BRGtEO0FBQUEsTUFDMUNnNEIsUUFEMEMsR0FDN0J2RSxRQUQ2QixDQUMxQ3VFLFFBRDBDOztBQUVwRSxNQUFHLENBQUNoNEIsTUFBSixFQUFZO0FBQ1g4aUIsV0FBUTJRLFFBQVI7QUFDQTs7QUFFRCxNQUFNd0UsZUFBZWo0QixPQUFPQyxHQUFQLENBQVc7QUFBQSxlQUFVOHlCLElBQVYsR0FBaUI3eUIsSUFBSTYzQixHQUFyQjtBQUFBLEdBQVgsQ0FBckI7O0FBRUEsNEJBQVdFLFlBQVgsRUFBeUIvRSxJQUF6QixDQUE4QixVQUFDMWpDLENBQUQsRUFBTztBQUNwQ2lrQyxZQUFTUyxNQUFULENBQWdCMkQsUUFBaEIsR0FBMkJyb0MsRUFBRXlRLEdBQUYsQ0FBTSxVQUFDQyxHQUFELEVBQU1uZCxDQUFOLEVBQVk7QUFDNUMsUUFBTW0xQyxXQUFXLDRCQUFhLEVBQWIsRUFBaUJGLFdBQVdBLFNBQVNILFNBQVM5MEMsQ0FBVCxFQUFZbzFDLE9BQXJCLENBQVgsR0FBMkMsRUFBNUQsQ0FBakI7QUFDQSxXQUFPLHdCQUFjajRCLEdBQWQsRUFBbUJnNEIsUUFBbkIsQ0FBUDtBQUNBLElBSDBCLENBQTNCO0FBSUFwVixXQUFRMlEsUUFBUjtBQUNBLEdBTkQsRUFNRyxVQUFDM3BDLENBQUQsRUFBTTtBQUNSaTVCLFVBQU9qNUIsQ0FBUDtBQUNBLEdBUkQ7QUFTQSxFQWpCbUMsQ0FBZDtBQUFBLENBQXRCOztBQW1CQSxJQUFNd3BDLGtCQUFrQixTQUFsQkEsZUFBa0IsQ0FBQ0csUUFBRDtBQUFBLFFBQWMsOEJBQVksVUFBQzNRLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUFBLE1BQzlEcVYsU0FEOEQsR0FDaEQzRSxRQURnRCxDQUM5RDJFLFNBRDhEO0FBQUEsTUFFOURQLFFBRjhELEdBRWpEcEUsU0FBU1MsTUFGd0MsQ0FFOUQyRCxRQUY4RDs7O0FBS3RFcEUsV0FBU1MsTUFBVCxDQUFnQjJCLFlBQWhCLEdBQStCdUMsVUFBVW40QixHQUFWLENBQWMsb0JBQVk7QUFDeER4WixZQUFTOFosT0FBVCxHQUFtQjtBQUNsQjgzQixhQUFRO0FBRFUsSUFBbkI7O0FBSUEsT0FBRzV4QyxTQUFTc3ZDLGFBQVosRUFBMkI7QUFDMUJ0dkMsYUFBUzhaLE9BQVQsQ0FBaUIrM0IsYUFBakIsR0FBaUMsQ0FBakM7QUFDQTd4QyxhQUFTc3ZDLGFBQVQsQ0FBdUI1USxTQUF2QixHQUFtQzBTLFNBQVNweEMsU0FBU3N2QyxhQUFULENBQXVCaGhDLEtBQWhDLENBQW5DO0FBQ0E7O0FBRUQsT0FBR3RPLFNBQVN1dkMsZ0JBQVosRUFBOEI7QUFDN0J2dkMsYUFBUzhaLE9BQVQsQ0FBaUJnNEIsZ0JBQWpCLEdBQW9DLENBQXBDO0FBQ0E5eEMsYUFBU3V2QyxnQkFBVCxDQUEwQjdRLFNBQTFCLEdBQXNDMFMsU0FBU3B4QyxTQUFTdXZDLGdCQUFULENBQTBCamhDLEtBQW5DLENBQXRDO0FBQ0E7O0FBR0Q7QUFDQSxPQUFHdE8sU0FBU3d2QyxvQkFBVCxDQUE4QkMsZ0JBQWpDLEVBQW1EO0FBQ2xEenZDLGFBQVM4WixPQUFULENBQWlCaTRCLGdCQUFqQixHQUFvQyxDQUFwQztBQUNBL3hDLGFBQVN3dkMsb0JBQVQsQ0FBOEJDLGdCQUE5QixDQUErQy9RLFNBQS9DLEdBQTJEMFMsU0FBU3B4QyxTQUFTd3ZDLG9CQUFULENBQThCQyxnQkFBOUIsQ0FBK0NuaEMsS0FBeEQsQ0FBM0Q7QUFDQTs7QUFFRCxPQUFHdE8sU0FBU3d2QyxvQkFBVCxDQUE4QkUsd0JBQWpDLEVBQTJEO0FBQzFEMXZDLGFBQVM4WixPQUFULENBQWlCazRCLHFCQUFqQixHQUF5QyxDQUF6QztBQUNBaHlDLGFBQVN3dkMsb0JBQVQsQ0FBOEJFLHdCQUE5QixDQUF1RGhSLFNBQXZELEdBQW1FMFMsU0FBU3B4QyxTQUFTd3ZDLG9CQUFULENBQThCRSx3QkFBOUIsQ0FBdURwaEMsS0FBaEUsQ0FBbkU7QUFDQTs7QUFFRDs7QUFFQSxVQUFPdE8sUUFBUDtBQUNBLEdBOUI4QixDQUEvQjs7QUFpQ0FxOEIsVUFBUTJRLFFBQVI7QUFDQSxFQXZDcUMsQ0FBZDtBQUFBLENBQXhCOztBQXlDQSxJQUFNM0UsUUFBUSxTQUFSQSxLQUFRLENBQUM0SixTQUFELEVBQVlDLElBQVo7QUFBQSxRQUFxQiw4QkFBWSxVQUFDN1YsT0FBRCxFQUFVQyxNQUFWLEVBQXFCO0FBQ25FRCxVQUFRN3BCLE9BQVI7QUFDQSxFQUZrQyxDQUFyQjtBQUFBLENBQWQ7O0FBS0EsSUFBTTI4QixtQkFBbUIsU0FBbkJBLGdCQUFtQixDQUFDakMsSUFBRCxFQUFPeUIsV0FBUCxFQUEwQztBQUFBLEtBQXRCd0QsU0FBc0IsdUVBQVYsS0FBVTs7QUFDbEUsS0FBTUMsZUFBZWxGLEtBQUs0QixTQUFMLENBQWVILFdBQWYsQ0FBckI7QUFDQSxLQUFNbHRDLFNBQVN5ckMsS0FBSzZELFdBQUwsQ0FBaUJxQixhQUFhQyxVQUE5QixFQUEwQ3RuQyxJQUF6RDtBQUNBLEtBQU1rbUMsYUFBYW1CLGFBQWFuQixVQUFiLElBQTJCLENBQTlDO0FBQ0EsS0FBTXFCLFlBQVlsSCxlQUFlZ0gsYUFBYUcsYUFBNUIsS0FBOENwdUMsWUFBaEU7QUFDQSxLQUFJNkssT0FBT3c4QixTQUFTNEcsYUFBYWhzQyxJQUF0QixDQUFYO0FBQ0EsS0FBSTRJLFFBQVEsSUFBUixJQUFnQm1qQyxTQUFwQixFQUErQjtBQUM5Qm5qQyxTQUFPLENBQVA7QUFDQTtBQUNELEtBQUl3akMsTUFBTSxJQUFJRixTQUFKLENBQWM3d0MsTUFBZCxFQUFzQnd2QyxVQUF0QixFQUFrQ2ppQyxPQUFPb2pDLGFBQWFsaUMsS0FBdEQsQ0FBVjtBQUNBLEtBQU11aUMsb0JBQW9CTCxhQUFhLzFDLFVBQWIsSUFBMkIrMUMsYUFBYS8xQyxVQUFiLENBQXdCLDRCQUF4QixDQUFyRDtBQUNBLEtBQUlvMkMsaUJBQUosRUFBdUI7QUFDdEIsTUFBTUMsYUFBYSxJQUFJdnVDLFlBQUosQ0FBaUI2SyxPQUFPb2pDLGFBQWFsaUMsS0FBckMsQ0FBbkI7QUFDQSxNQUFNeWlDLGVBQWVGLGtCQUFrQkUsWUFBdkM7QUFDQSxNQUFNQyxlQUFlLElBQUlqb0MsS0FBSixDQUFVcUUsSUFBVixDQUFyQjtBQUNBLE1BQU02akMsY0FBYyxJQUFJbG9DLEtBQUosQ0FBVXFFLElBQVYsQ0FBcEI7QUFDQSxPQUFLLElBQUkyeEIsSUFBSSxDQUFiLEVBQWdCQSxJQUFJM3hCLElBQXBCLEVBQTBCMnhCLEdBQTFCLEVBQStCO0FBQzlCaVMsZ0JBQWFqUyxDQUFiLElBQWtCZ1MsYUFBYTNqQyxRQUFRQSxPQUFPLENBQWYsSUFBb0IyeEIsQ0FBakMsQ0FBbEI7QUFDQWtTLGVBQVlsUyxDQUFaLElBQWlCZ1MsYUFBYWhTLEtBQUszeEIsT0FBTyxDQUFaLElBQWlCMnhCLENBQTlCLENBQWpCO0FBQ0E7QUFDRCxPQUFLLElBQUlya0MsSUFBSSxDQUFiLEVBQWdCQSxJQUFJODFDLGFBQWFsaUMsS0FBakMsRUFBd0M1VCxHQUF4QyxFQUE2QztBQUM1QyxRQUFLLElBQUlxa0MsS0FBSSxDQUFiLEVBQWdCQSxLQUFJM3hCLElBQXBCLEVBQTBCMnhCLElBQTFCLEVBQStCO0FBQzlCK1IsZUFBV3AyQyxJQUFJMFMsSUFBSixHQUFXMnhCLEVBQXRCLElBQTJCNlIsSUFBSWwyQyxJQUFJMFMsSUFBSixHQUFXMnhCLEVBQWYsSUFBb0JrUyxZQUFZbFMsRUFBWixDQUFwQixHQUFxQ2lTLGFBQWFqUyxFQUFiLENBQWhFO0FBQ0E7QUFDRDs7QUFFRDZSLFFBQU1FLFVBQU47QUFDQTs7QUFFRDs7QUFFQSxRQUFPRixHQUFQO0FBQ0EsQ0FoQ0Q7O2tCQWtDZTtBQUNkdkgsV0FEYztBQUVkNUM7QUFGYyxDOzs7Ozs7Ozs7Ozs7QUNsWmY7O0FBRUEsSUFBTTRDLE9BQU8sU0FBUEEsSUFBTyxDQUFDQyxLQUFELEVBQVFubkIsYUFBUjtBQUFBLFFBQTBCLElBQUkrdUIsT0FBSixDQUFZLFVBQUN6VyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDdkUsTUFBTXlXLE1BQU0sSUFBSTl1QixjQUFKLEVBQVo7QUFDQTh1QixNQUFJN3VCLGdCQUFKLENBQXFCLE1BQXJCLEVBQTZCLFVBQUM3Z0IsQ0FBRCxFQUFPO0FBQ25DZzVCLFdBQVEwVyxJQUFJcHVCLFFBQVo7QUFDQSxHQUZEOztBQUlBb3VCLE1BQUk3dUIsZ0JBQUosQ0FBcUIsT0FBckIsRUFBOEIsVUFBQzdnQixDQUFELEVBQU87QUFDcENpNUIsVUFBT2o1QixDQUFQO0FBQ0EsR0FGRDs7QUFJQSxNQUFHMGdCLGFBQUgsRUFBa0I7QUFDakJndkIsT0FBSTF1QixZQUFKLEdBQW1CLGFBQW5CO0FBQ0E7O0FBRUQwdUIsTUFBSXR1QixJQUFKLENBQVMsS0FBVCxFQUFnQnltQixLQUFoQjtBQUNBNkgsTUFBSXJ1QixJQUFKO0FBRUEsRUFqQnNDLENBQTFCO0FBQUEsQ0FBYjs7a0JBbUJldW1CLEk7Ozs7OztBQ3JCZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcERBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUN6TEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBLG1EQUFtRCxFQUFFO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7O0FBR0EsQ0FBQztBQUNEOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTCxxQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7O0FBR0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyx3RUFBd0U7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsNEJBQTRCO0FBQzVCLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7QUFHQSx5QkFBeUIsb0NBQW9DO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvQ0FBb0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBLEtB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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDZKQUE2SjtBQUM3SiwwSkFBMEo7QUFDMUoscUpBQXFKO0FBQ3JKLHNKQUFzSjtBQUN0SixrSkFBa0o7QUFDbEo7OztBQUdBOztBQUVBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0I7Ozs7OztBQzNrSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOzs7QUFHQSxpRDs7QUFFQTs7QUFFQSxPQUFPLDBDQUEwQzs7QUFFakQseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7OztBQUdEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBLG1EQUFtRCxFQUFFO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7O0FBR0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0Esa0I7Ozs7OztBQ2x2QkE7QUFDQSxlQUFlLHNGQUF1SSxrQkFBa0IsaUJBQWlCLGNBQWMscUJBQXFCLFNBQVMsY0FBYyxZQUFZLG9CQUFvQixxREFBcUQsSUFBSSx3Q0FBd0MsZ0NBQWdDLE1BQU0sT0FBTyxlQUFlLFlBQVksZUFBZSx1Q0FBdUM7QUFDbGYseUJBQXlCLEtBQUssbUhBQW1ILHNGQUFzRixLQUFLLE9BQU8sMERBQTBELDRCQUE0QixnQkFBZ0IsSUFBSSxnQ0FBZ0Msa0JBQWtCLG1EQUFtRCx5QkFBeUI7QUFDM2QsbUNBQW1DLFNBQVMsbUJBQW1CLGFBQWEsMEJBQTBCLHdCQUF3Qix3SkFBd0osVUFBVSxXQUFXLDRCQUE0QixhQUFhLHlCQUF5QixtREFBbUQscUJBQXFCLGNBQWMsb0JBQW9CLGNBQWM7QUFDcmUsb0JBQW9CLGNBQWMsaUJBQWlCLG9CQUFvQixPQUFPLDJCQUEyQixnQkFBZ0IsZ0JBQWdCLGNBQWMsZ0JBQWdCLG9CQUFvQixjQUFjLGtEQUFrRCxxQ0FBcUMsd0JBQXdCLGNBQWMsaUJBQWlCLHNDQUFzQyxTQUFTIiwiZmlsZSI6ImFzc2V0cy9qcy9kZWJ1Zy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdGZ1bmN0aW9uIGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKSB7XG4gXHRcdGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHR9XG4gXHR2YXIgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2sgPSB3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdO1xuIFx0d2luZG93W1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IFxyXG4gXHRmdW5jdGlvbiB3ZWJwYWNrSG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcclxuIFx0XHRpZihwYXJlbnRIb3RVcGRhdGVDYWxsYmFjaykgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHR9IDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcbiBcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiBcdFx0c2NyaXB0LnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiO1xyXG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xyXG4gXHRcdHNjcmlwdC5zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzXCI7XHJcbiBcdFx0O1xyXG4gXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChyZXF1ZXN0VGltZW91dCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0cmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0VGltZW91dCB8fCAxMDAwMDtcclxuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiBcdFx0XHRpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdHJldHVybiByZWplY3QobmV3IEVycm9yKFwiTm8gYnJvd3NlciBzdXBwb3J0XCIpKTtcclxuIFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiBcdFx0XHRcdHZhciByZXF1ZXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNvblwiO1xyXG4gXHRcdFx0XHRyZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgcmVxdWVzdFBhdGgsIHRydWUpO1xyXG4gXHRcdFx0XHRyZXF1ZXN0LnRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcclxuIFx0XHRcdFx0cmVxdWVzdC5zZW5kKG51bGwpO1xyXG4gXHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChlcnIpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0cmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0aWYocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm47XHJcbiBcdFx0XHRcdGlmKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XHJcbiBcdFx0XHRcdFx0Ly8gdGltZW91dFxyXG4gXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiB0aW1lZCBvdXQuXCIpKTtcclxuIFx0XHRcdFx0fSBlbHNlIGlmKHJlcXVlc3Quc3RhdHVzID09PSA0MDQpIHtcclxuIFx0XHRcdFx0XHQvLyBubyB1cGRhdGUgYXZhaWxhYmxlXHJcbiBcdFx0XHRcdFx0cmVzb2x2ZSgpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XHJcbiBcdFx0XHRcdFx0Ly8gb3RoZXIgZmFpbHVyZVxyXG4gXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiBmYWlsZWQuXCIpKTtcclxuIFx0XHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0XHQvLyBzdWNjZXNzXHJcbiBcdFx0XHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0XHRcdHZhciB1cGRhdGUgPSBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcclxuIFx0XHRcdFx0XHRcdHJlamVjdChlKTtcclxuIFx0XHRcdFx0XHRcdHJldHVybjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0cmVzb2x2ZSh1cGRhdGUpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9O1xyXG4gXHRcdH0pO1xyXG4gXHR9XHJcblxuIFx0XHJcbiBcdFxyXG4gXHR2YXIgaG90QXBwbHlPblVwZGF0ZSA9IHRydWU7XHJcbiBcdHZhciBob3RDdXJyZW50SGFzaCA9IFwiNjBjMTg3YTVmNTNjMTA5ZGZkY2NcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHR2YXIgaG90UmVxdWVzdFRpbWVvdXQgPSAxMDAwMDtcclxuIFx0dmFyIGhvdEN1cnJlbnRNb2R1bGVEYXRhID0ge307XHJcbiBcdHZhciBob3RDdXJyZW50Q2hpbGRNb2R1bGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgbWUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRpZighbWUpIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fO1xyXG4gXHRcdHZhciBmbiA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuIFx0XHRcdGlmKG1lLmhvdC5hY3RpdmUpIHtcclxuIFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xyXG4gXHRcdFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKSA8IDApXHJcbiBcdFx0XHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMucHVzaChtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHJlcXVlc3Q7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYobWUuY2hpbGRyZW4uaW5kZXhPZihyZXF1ZXN0KSA8IDApXHJcbiBcdFx0XHRcdFx0bWUuY2hpbGRyZW4ucHVzaChyZXF1ZXN0KTtcclxuIFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIHJlcXVlc3QgKyBcIikgZnJvbSBkaXNwb3NlZCBtb2R1bGUgXCIgKyBtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW107XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhyZXF1ZXN0KTtcclxuIFx0XHR9O1xyXG4gXHRcdHZhciBPYmplY3RGYWN0b3J5ID0gZnVuY3Rpb24gT2JqZWN0RmFjdG9yeShuYW1lKSB7XHJcbiBcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXHJcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcbiBcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX19bbmFtZV07XHJcbiBcdFx0XHRcdH0sXHJcbiBcdFx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuIFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdID0gdmFsdWU7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH07XHJcbiBcdFx0fTtcclxuIFx0XHRmb3IodmFyIG5hbWUgaW4gX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9fd2VicGFja19yZXF1aXJlX18sIG5hbWUpICYmIG5hbWUgIT09IFwiZVwiKSB7XHJcbiBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgT2JqZWN0RmFjdG9yeShuYW1lKSk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcdGZuLmUgPSBmdW5jdGlvbihjaHVua0lkKSB7XHJcbiBcdFx0XHRpZihob3RTdGF0dXMgPT09IFwicmVhZHlcIilcclxuIFx0XHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcclxuIFx0XHRcdGhvdENodW5rc0xvYWRpbmcrKztcclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmUoY2h1bmtJZCkudGhlbihmaW5pc2hDaHVua0xvYWRpbmcsIGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRmaW5pc2hDaHVua0xvYWRpbmcoKTtcclxuIFx0XHRcdFx0dGhyb3cgZXJyO1xyXG4gXHRcdFx0fSk7XHJcbiBcdFxyXG4gXHRcdFx0ZnVuY3Rpb24gZmluaXNoQ2h1bmtMb2FkaW5nKCkge1xyXG4gXHRcdFx0XHRob3RDaHVua3NMb2FkaW5nLS07XHJcbiBcdFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIpIHtcclxuIFx0XHRcdFx0XHRpZighaG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdKSB7XHJcbiBcdFx0XHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0aWYoaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcclxuIFx0XHRcdFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9O1xyXG4gXHRcdHJldHVybiBmbjtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgaG90ID0ge1xyXG4gXHRcdFx0Ly8gcHJpdmF0ZSBzdHVmZlxyXG4gXHRcdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXHJcbiBcdFx0XHRfc2VsZkFjY2VwdGVkOiBmYWxzZSxcclxuIFx0XHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXHJcbiBcdFx0XHRfbWFpbjogaG90Q3VycmVudENoaWxkTW9kdWxlICE9PSBtb2R1bGVJZCxcclxuIFx0XHJcbiBcdFx0XHQvLyBNb2R1bGUgQVBJXHJcbiBcdFx0XHRhY3RpdmU6IHRydWUsXHJcbiBcdFx0XHRhY2NlcHQ6IGZ1bmN0aW9uKGRlcCwgY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0aWYodHlwZW9mIGRlcCA9PT0gXCJ1bmRlZmluZWRcIilcclxuIFx0XHRcdFx0XHRob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2UgaWYodHlwZW9mIGRlcCA9PT0gXCJmdW5jdGlvblwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXHJcbiBcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcclxuIFx0XHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcF0gPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRlY2xpbmU6IGZ1bmN0aW9uKGRlcCkge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkRlY2xpbmVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxyXG4gXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlXHJcbiBcdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRkaXNwb3NlOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0cmVtb3ZlRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIGhvdC5fZGlzcG9zZUhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHJcbiBcdFx0XHQvLyBNYW5hZ2VtZW50IEFQSVxyXG4gXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxyXG4gXHRcdFx0YXBwbHk6IGhvdEFwcGx5LFxyXG4gXHRcdFx0c3RhdHVzOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdGlmKCFsKSByZXR1cm4gaG90U3RhdHVzO1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3RTdGF0dXNIYW5kbGVycy5pbmRleE9mKGwpO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90U3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxyXG4gXHRcdFx0ZGF0YTogaG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXHJcbiBcdFx0fTtcclxuIFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XHJcbiBcdFx0cmV0dXJuIGhvdDtcclxuIFx0fVxyXG4gXHRcclxuIFx0dmFyIGhvdFN0YXR1c0hhbmRsZXJzID0gW107XHJcbiBcdHZhciBob3RTdGF0dXMgPSBcImlkbGVcIjtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdFNldFN0YXR1cyhuZXdTdGF0dXMpIHtcclxuIFx0XHRob3RTdGF0dXMgPSBuZXdTdGF0dXM7XHJcbiBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGhvdFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0aG90U3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHQvLyB3aGlsZSBkb3dubG9hZGluZ1xyXG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzID0gMDtcclxuIFx0dmFyIGhvdENodW5rc0xvYWRpbmcgPSAwO1xyXG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90QXZhaWxhYmxlRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdERlZmVycmVkO1xyXG4gXHRcclxuIFx0Ly8gVGhlIHVwZGF0ZSBpbmZvXHJcbiBcdHZhciBob3RVcGRhdGUsIGhvdFVwZGF0ZU5ld0hhc2g7XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiB0b01vZHVsZUlkKGlkKSB7XHJcbiBcdFx0dmFyIGlzTnVtYmVyID0gKCtpZCkgKyBcIlwiID09PSBpZDtcclxuIFx0XHRyZXR1cm4gaXNOdW1iZXIgPyAraWQgOiBpZDtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90Q2hlY2soYXBwbHkpIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwiaWRsZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcclxuIFx0XHRob3RBcHBseU9uVXBkYXRlID0gYXBwbHk7XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiY2hlY2tcIik7XHJcbiBcdFx0cmV0dXJuIGhvdERvd25sb2FkTWFuaWZlc3QoaG90UmVxdWVzdFRpbWVvdXQpLnRoZW4oZnVuY3Rpb24odXBkYXRlKSB7XHJcbiBcdFx0XHRpZighdXBkYXRlKSB7XHJcbiBcdFx0XHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XHJcbiBcdFx0XHRcdHJldHVybiBudWxsO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcclxuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90QXZhaWxhYmxlRmlsZXNNYXAgPSB1cGRhdGUuYztcclxuIFx0XHRcdGhvdFVwZGF0ZU5ld0hhc2ggPSB1cGRhdGUuaDtcclxuIFx0XHJcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuIFx0XHRcdFx0aG90RGVmZXJyZWQgPSB7XHJcbiBcdFx0XHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcclxuIFx0XHRcdFx0XHRyZWplY3Q6IHJlamVjdFxyXG4gXHRcdFx0XHR9O1xyXG4gXHRcdFx0fSk7XHJcbiBcdFx0XHRob3RVcGRhdGUgPSB7fTtcclxuIFx0XHRcdHZhciBjaHVua0lkID0gMTtcclxuIFx0XHRcdHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lLWJsb2Nrc1xyXG4gXHRcdFx0XHQvKmdsb2JhbHMgY2h1bmtJZCAqL1xyXG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcclxuIFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdFx0cmV0dXJuIHByb21pc2U7XHJcbiBcdFx0fSk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHRpZighaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gfHwgIWhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdKVxyXG4gXHRcdFx0cmV0dXJuO1xyXG4gXHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gZmFsc2U7XHJcbiBcdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0aG90VXBkYXRlW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFx0aWYoLS1ob3RXYWl0aW5nRmlsZXMgPT09IDAgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCkge1xyXG4gXHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdH1cclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCkge1xyXG4gXHRcdGlmKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSkge1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzKys7XHJcbiBcdFx0XHRob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG4gXHRcdH1cclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90VXBkYXRlRG93bmxvYWRlZCgpIHtcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJyZWFkeVwiKTtcclxuIFx0XHR2YXIgZGVmZXJyZWQgPSBob3REZWZlcnJlZDtcclxuIFx0XHRob3REZWZlcnJlZCA9IG51bGw7XHJcbiBcdFx0aWYoIWRlZmVycmVkKSByZXR1cm47XHJcbiBcdFx0aWYoaG90QXBwbHlPblVwZGF0ZSkge1xyXG4gXHRcdFx0Ly8gV3JhcCBkZWZlcnJlZCBvYmplY3QgaW4gUHJvbWlzZSB0byBtYXJrIGl0IGFzIGEgd2VsbC1oYW5kbGVkIFByb21pc2UgdG9cclxuIFx0XHRcdC8vIGF2b2lkIHRyaWdnZXJpbmcgdW5jYXVnaHQgZXhjZXB0aW9uIHdhcm5pbmcgaW4gQ2hyb21lLlxyXG4gXHRcdFx0Ly8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ2NTY2NlxyXG4gXHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0cmV0dXJuIGhvdEFwcGx5KGhvdEFwcGx5T25VcGRhdGUpO1xyXG4gXHRcdFx0fSkudGhlbihcclxuIFx0XHRcdFx0ZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiBcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xyXG4gXHRcdFx0XHR9LFxyXG4gXHRcdFx0XHRmdW5jdGlvbihlcnIpIHtcclxuIFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3QoZXJyKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0KTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2godG9Nb2R1bGVJZChpZCkpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKG91dGRhdGVkTW9kdWxlcyk7XHJcbiBcdFx0fVxyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RBcHBseShvcHRpb25zKSB7XHJcbiBcdFx0aWYoaG90U3RhdHVzICE9PSBcInJlYWR5XCIpIHRocm93IG5ldyBFcnJvcihcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1c1wiKTtcclxuIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuIFx0XHJcbiBcdFx0dmFyIGNiO1xyXG4gXHRcdHZhciBpO1xyXG4gXHRcdHZhciBqO1xyXG4gXHRcdHZhciBtb2R1bGU7XHJcbiBcdFx0dmFyIG1vZHVsZUlkO1xyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBnZXRBZmZlY3RlZFN0dWZmKHVwZGF0ZU1vZHVsZUlkKSB7XHJcbiBcdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW3VwZGF0ZU1vZHVsZUlkXTtcclxuIFx0XHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG4gXHRcclxuIFx0XHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpLm1hcChmdW5jdGlvbihpZCkge1xyXG4gXHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdGNoYWluOiBbaWRdLFxyXG4gXHRcdFx0XHRcdGlkOiBpZFxyXG4gXHRcdFx0XHR9O1xyXG4gXHRcdFx0fSk7XHJcbiBcdFx0XHR3aGlsZShxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiBcdFx0XHRcdHZhciBxdWV1ZUl0ZW0gPSBxdWV1ZS5wb3AoKTtcclxuIFx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xyXG4gXHRcdFx0XHR2YXIgY2hhaW4gPSBxdWV1ZUl0ZW0uY2hhaW47XHJcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRpZighbW9kdWxlIHx8IG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZClcclxuIFx0XHRcdFx0XHRjb250aW51ZTtcclxuIFx0XHRcdFx0aWYobW9kdWxlLmhvdC5fc2VsZkRlY2xpbmVkKSB7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxyXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxyXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXHJcbiBcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9tYWluKSB7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIHtcclxuIFx0XHRcdFx0XHRcdHR5cGU6IFwidW5hY2NlcHRlZFwiLFxyXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxyXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXHJcbiBcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbW9kdWxlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcclxuIFx0XHRcdFx0XHR2YXIgcGFyZW50ID0gaW5zdGFsbGVkTW9kdWxlc1twYXJlbnRJZF07XHJcbiBcdFx0XHRcdFx0aWYoIXBhcmVudCkgY29udGludWU7XHJcbiBcdFx0XHRcdFx0aWYocGFyZW50LmhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XHJcbiBcdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHRcdFx0XHR0eXBlOiBcImRlY2xpbmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXHJcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0cGFyZW50SWQ6IHBhcmVudElkXHJcbiBcdFx0XHRcdFx0XHR9O1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRpZihvdXRkYXRlZE1vZHVsZXMuaW5kZXhPZihwYXJlbnRJZCkgPj0gMCkgY29udGludWU7XHJcbiBcdFx0XHRcdFx0aWYocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XHJcbiBcdFx0XHRcdFx0XHRpZighb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdKVxyXG4gXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcclxuIFx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSwgW21vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXTtcclxuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChwYXJlbnRJZCk7XHJcbiBcdFx0XHRcdFx0cXVldWUucHVzaCh7XHJcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxyXG4gXHRcdFx0XHRcdFx0aWQ6IHBhcmVudElkXHJcbiBcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHJcbiBcdFx0XHRyZXR1cm4ge1xyXG4gXHRcdFx0XHR0eXBlOiBcImFjY2VwdGVkXCIsXHJcbiBcdFx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcclxuIFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzOiBvdXRkYXRlZE1vZHVsZXMsXHJcbiBcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzOiBvdXRkYXRlZERlcGVuZGVuY2llc1xyXG4gXHRcdFx0fTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcclxuIFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdHZhciBpdGVtID0gYltpXTtcclxuIFx0XHRcdFx0aWYoYS5pbmRleE9mKGl0ZW0pIDwgMClcclxuIFx0XHRcdFx0XHRhLnB1c2goaXRlbSk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBhdCBiZWdpbiBhbGwgdXBkYXRlcyBtb2R1bGVzIGFyZSBvdXRkYXRlZFxyXG4gXHRcdC8vIHRoZSBcIm91dGRhdGVkXCIgc3RhdHVzIGNhbiBwcm9wYWdhdGUgdG8gcGFyZW50cyBpZiB0aGV5IGRvbid0IGFjY2VwdCB0aGUgY2hpbGRyZW5cclxuIFx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcclxuIFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XHJcbiBcdFx0dmFyIGFwcGxpZWRVcGRhdGUgPSB7fTtcclxuIFx0XHJcbiBcdFx0dmFyIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSA9IGZ1bmN0aW9uIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSgpIHtcclxuIFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIHJlc3VsdC5tb2R1bGVJZCArIFwiKSB0byBkaXNwb3NlZCBtb2R1bGVcIik7XHJcbiBcdFx0fTtcclxuIFx0XHJcbiBcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGVJZCA9IHRvTW9kdWxlSWQoaWQpO1xyXG4gXHRcdFx0XHR2YXIgcmVzdWx0O1xyXG4gXHRcdFx0XHRpZihob3RVcGRhdGVbaWRdKSB7XHJcbiBcdFx0XHRcdFx0cmVzdWx0ID0gZ2V0QWZmZWN0ZWRTdHVmZihtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0cmVzdWx0ID0ge1xyXG4gXHRcdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxyXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IGlkXHJcbiBcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR2YXIgYWJvcnRFcnJvciA9IGZhbHNlO1xyXG4gXHRcdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xyXG4gXHRcdFx0XHR2YXIgZG9EaXNwb3NlID0gZmFsc2U7XHJcbiBcdFx0XHRcdHZhciBjaGFpbkluZm8gPSBcIlwiO1xyXG4gXHRcdFx0XHRpZihyZXN1bHQuY2hhaW4pIHtcclxuIFx0XHRcdFx0XHRjaGFpbkluZm8gPSBcIlxcblVwZGF0ZSBwcm9wYWdhdGlvbjogXCIgKyByZXN1bHQuY2hhaW4uam9pbihcIiAtPiBcIik7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0c3dpdGNoKHJlc3VsdC50eXBlKSB7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25EZWNsaW5lZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRpZighb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcclxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgY2hhaW5JbmZvKTtcclxuIFx0XHRcdFx0XHRcdGJyZWFrO1xyXG4gXHRcdFx0XHRcdGNhc2UgXCJkZWNsaW5lZFwiOlxyXG4gXHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkRlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcclxuIFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxyXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIgaW4gXCIgKyByZXN1bHQucGFyZW50SWQgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcInVuYWNjZXB0ZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25VbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uVW5hY2NlcHRlZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcclxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIgKyBjaGFpbkluZm8pO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XHJcbiBcdFx0XHRcdFx0XHRpZihvcHRpb25zLm9uQWNjZXB0ZWQpXHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25BY2NlcHRlZChyZXN1bHQpO1xyXG4gXHRcdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XHJcbiBcdFx0XHRcdFx0XHRicmVhaztcclxuIFx0XHRcdFx0XHRjYXNlIFwiZGlzcG9zZWRcIjpcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25EaXNwb3NlZClcclxuIFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkRpc3Bvc2VkKHJlc3VsdCk7XHJcbiBcdFx0XHRcdFx0XHRkb0Rpc3Bvc2UgPSB0cnVlO1xyXG4gXHRcdFx0XHRcdFx0YnJlYWs7XHJcbiBcdFx0XHRcdFx0ZGVmYXVsdDpcclxuIFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhjZXB0aW9uIHR5cGUgXCIgKyByZXN1bHQudHlwZSk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYoYWJvcnRFcnJvcikge1xyXG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xyXG4gXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihkb0FwcGx5KSB7XHJcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBob3RVcGRhdGVbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XHJcbiBcdFx0XHRcdFx0Zm9yKG1vZHVsZUlkIGluIHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG4gXHRcdFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XHJcbiBcdFx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSwgcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGlmKGRvRGlzcG9zZSkge1xyXG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgW3Jlc3VsdC5tb2R1bGVJZF0pO1xyXG4gXHRcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBTdG9yZSBzZWxmIGFjY2VwdGVkIG91dGRhdGVkIG1vZHVsZXMgdG8gcmVxdWlyZSB0aGVtIGxhdGVyIGJ5IHRoZSBtb2R1bGUgc3lzdGVtXHJcbiBcdFx0dmFyIG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdGZvcihpID0gMDsgaSA8IG91dGRhdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0bW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZClcclxuIFx0XHRcdFx0b3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLnB1c2goe1xyXG4gXHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxyXG4gXHRcdFx0XHR9KTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImRpc3Bvc2VcIik7XHJcbiBcdFx0T2JqZWN0LmtleXMoaG90QXZhaWxhYmxlRmlsZXNNYXApLmZvckVhY2goZnVuY3Rpb24oY2h1bmtJZCkge1xyXG4gXHRcdFx0aWYoaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gPT09IGZhbHNlKSB7XHJcbiBcdFx0XHRcdGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9KTtcclxuIFx0XHJcbiBcdFx0dmFyIGlkeDtcclxuIFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcclxuIFx0XHR3aGlsZShxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiBcdFx0XHRtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRpZighbW9kdWxlKSBjb250aW51ZTtcclxuIFx0XHJcbiBcdFx0XHR2YXIgZGF0YSA9IHt9O1xyXG4gXHRcclxuIFx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xyXG4gXHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcclxuIFx0XHRcdGZvcihqID0gMDsgaiA8IGRpc3Bvc2VIYW5kbGVycy5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHRjYiA9IGRpc3Bvc2VIYW5kbGVyc1tqXTtcclxuIFx0XHRcdFx0Y2IoZGF0YSk7XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF0gPSBkYXRhO1xyXG4gXHRcclxuIFx0XHRcdC8vIGRpc2FibGUgbW9kdWxlICh0aGlzIGRpc2FibGVzIHJlcXVpcmVzIGZyb20gdGhpcyBtb2R1bGUpXHJcbiBcdFx0XHRtb2R1bGUuaG90LmFjdGl2ZSA9IGZhbHNlO1xyXG4gXHRcclxuIFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxyXG4gXHRcdFx0ZGVsZXRlIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcclxuIFx0XHRcdC8vIHdoZW4gZGlzcG9zaW5nIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBkaXNwb3NlIGhhbmRsZXJcclxuIFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cclxuIFx0XHRcdGZvcihqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gXHRcdFx0XHR2YXIgY2hpbGQgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZS5jaGlsZHJlbltqXV07XHJcbiBcdFx0XHRcdGlmKCFjaGlsZCkgY29udGludWU7XHJcbiBcdFx0XHRcdGlkeCA9IGNoaWxkLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdGlmKGlkeCA+PSAwKSB7XHJcbiBcdFx0XHRcdFx0Y2hpbGQucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gcmVtb3ZlIG91dGRhdGVkIGRlcGVuZGVuY3kgZnJvbSBtb2R1bGUgY2hpbGRyZW5cclxuIFx0XHR2YXIgZGVwZW5kZW5jeTtcclxuIFx0XHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXM7XHJcbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0aWYobW9kdWxlKSB7XHJcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdFx0Zm9yKGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcclxuIFx0XHRcdFx0XHRcdGlkeCA9IG1vZHVsZS5jaGlsZHJlbi5pbmRleE9mKGRlcGVuZGVuY3kpO1xyXG4gXHRcdFx0XHRcdFx0aWYoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIE5vdCBpbiBcImFwcGx5XCIgcGhhc2VcclxuIFx0XHRob3RTZXRTdGF0dXMoXCJhcHBseVwiKTtcclxuIFx0XHJcbiBcdFx0aG90Q3VycmVudEhhc2ggPSBob3RVcGRhdGVOZXdIYXNoO1xyXG4gXHRcclxuIFx0XHQvLyBpbnNlcnQgbmV3IGNvZGVcclxuIFx0XHRmb3IobW9kdWxlSWQgaW4gYXBwbGllZFVwZGF0ZSkge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcGxpZWRVcGRhdGUsIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRtb2R1bGVzW21vZHVsZUlkXSA9IGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gY2FsbCBhY2NlcHQgaGFuZGxlcnNcclxuIFx0XHR2YXIgZXJyb3IgPSBudWxsO1xyXG4gXHRcdGZvcihtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKG1vZHVsZSkge1xyXG4gXHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID0gb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcclxuIFx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2ldO1xyXG4gXHRcdFx0XHRcdFx0Y2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcclxuIFx0XHRcdFx0XHRcdGlmKGNiKSB7XHJcbiBcdFx0XHRcdFx0XHRcdGlmKGNhbGxiYWNrcy5pbmRleE9mKGNiKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goY2IpO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0XHRcdGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gXHRcdFx0XHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0XHRcdFx0Y2IobW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xyXG4gXHRcdFx0XHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XHJcbiBcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2ldLFxyXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxyXG4gXHRcdFx0XHRcdFx0XHRcdH0pO1xyXG4gXHRcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcclxuIFx0XHRmb3IoaSA9IDA7IGkgPCBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW2ldO1xyXG4gXHRcdFx0bW9kdWxlSWQgPSBpdGVtLm1vZHVsZTtcclxuIFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcclxuIFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xyXG4gXHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0aWYodHlwZW9mIGl0ZW0uZXJyb3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyKTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGVycjIpIHtcclxuIFx0XHRcdFx0XHRcdGlmKG9wdGlvbnMub25FcnJvcmVkKSB7XHJcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxyXG4gXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcclxuIFx0XHRcdFx0XHRcdFx0XHRvcmdpbmFsRXJyb3I6IGVyciwgLy8gVE9ETyByZW1vdmUgaW4gd2VicGFjayA0XHJcbiBcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXHJcbiBcdFx0XHRcdFx0XHRcdH0pO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0aWYoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xyXG4gXHRcdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnIyO1xyXG4gXHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0aWYob3B0aW9ucy5vbkVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcclxuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXHJcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcclxuIFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxyXG4gXHRcdFx0XHRcdFx0fSk7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFlcnJvcilcclxuIFx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxyXG4gXHRcdGlmKGVycm9yKSB7XHJcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xyXG4gXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XHJcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcclxuIFx0XHRcdHJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0XHR9KTtcclxuIFx0fVxyXG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGhvdDogaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSxcbiBcdFx0XHRwYXJlbnRzOiAoaG90Q3VycmVudFBhcmVudHNUZW1wID0gaG90Q3VycmVudFBhcmVudHMsIGhvdEN1cnJlbnRQYXJlbnRzID0gW10sIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCksXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gX193ZWJwYWNrX2hhc2hfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5oID0gZnVuY3Rpb24oKSB7IHJldHVybiBob3RDdXJyZW50SGFzaDsgfTtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gaG90Q3JlYXRlUmVxdWlyZSgxMzIpKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEzMik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNjBjMTg3YTVmNTNjMTA5ZGZkY2MiLCIvLyBHTFRvb2wuanNcblxuaW1wb3J0IHsgbWF0NCwgbWF0MyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCBnZXRBbmRBcHBseUV4dGVuc2lvbiBmcm9tICcuL3V0aWxzL2dldEFuZEFwcGx5RXh0ZW5zaW9uJztcbmltcG9ydCBleHBvc2VBdHRyaWJ1dGVzIGZyb20gJy4vdXRpbHMvZXhwb3NlQXR0cmlidXRlcyc7XG5pbXBvcnQgZ2V0RmxvYXQgZnJvbSAnLi91dGlscy9nZXRGbG9hdCc7XG5pbXBvcnQgZ2V0SGFsZkZsb2F0IGZyb20gJy4vdXRpbHMvZ2V0SGFsZkZsb2F0JztcbmltcG9ydCBnZXRBdHRyaWJMb2MgZnJvbSAnLi91dGlscy9nZXRBdHRyaWJMb2MnO1xuaW1wb3J0IEV4dGVuc2lvbnNMaXN0IGZyb20gJy4vdXRpbHMvRXh0ZW5zaW9uc0xpc3QnO1xuXG5pbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi9HZW9tZXRyeSc7XG5pbXBvcnQgTWVzaCBmcm9tICcuL01lc2gnO1xuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4vb2JqZWN0cy9PYmplY3QzRCc7XG5cbmxldCBnbDtcblxuY2xhc3MgR0xUb29sIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmNhbnZhcztcblx0XHR0aGlzLl92aWV3cG9ydCAgICAgICAgICAgICAgID0gWzAsIDAsIDAsIDBdO1xuXHRcdHRoaXMuX2VuYWJsZWRWZXJ0ZXhBdHRyaWJ1dGUgPSBbXTtcblx0XHR0aGlzLmlkZW50aXR5TWF0cml4ICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9ub3JtYWxNYXRyaXggICAgICAgICAgID0gbWF0My5jcmVhdGUoKTtcblx0XHR0aGlzLl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4ID0gbWF0My5jcmVhdGUoKTtcblx0XHR0aGlzLl9tb2RlbE1hdHJpeCAgICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXggICAgICAgICAgICAgICAgID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhTdGFja3MgXHRcdFx0ID0gW107XG5cdFx0dGhpcy5fbGFzdE1lc2hcdFx0XHRcdCA9IG51bGw7XG5cdFx0dGhpcy5fdXNlV2ViR0wyIFx0XHRcdCA9IGZhbHNlO1xuXHRcdHRoaXMuX2hhc0FycmF5SW5zdGFuY2U7XG5cdFx0dGhpcy5fZXh0QXJyYXlJbnN0YW5jZTtcblx0XHR0aGlzLl9oYXNDaGVja2VkRXh0ID0gZmFsc2U7XG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLmlkZW50aXR5TWF0cml4LCB0aGlzLmlkZW50aXR5TWF0cml4KTtcblxuXHRcdHRoaXMuaXNNb2JpbGUgPSBmYWxzZTtcblx0XHRpZigvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcblx0XHRcdHRoaXMuaXNNb2JpbGUgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8vXHRJTklUSUFMSVpFXG5cblx0aW5pdChtQ2FudmFzLCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cblx0XHRpZihtQ2FudmFzID09PSBudWxsIHx8IG1DYW52YXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignQ2FudmFzIG5vdCBleGlzdCcpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRcblx0XHRpZih0aGlzLmNhbnZhcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuY2FudmFzICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLmRlc3Ryb3koKTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5jYW52YXMgPSBtQ2FudmFzO1xuXHRcdHRoaXMuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcblxuXHRcdG1QYXJhbWV0ZXJzLnVzZVdlYmdsMiA9IG1QYXJhbWV0ZXJzLnVzZVdlYmdsMiB8fCBmYWxzZTtcblxuXHRcdGxldCBjdHg7XG5cdFx0aWYobVBhcmFtZXRlcnMudXNlV2ViZ2wyKSB7XG5cdFx0XHRjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wyJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIG1QYXJhbWV0ZXJzKTtcblxuXHRcdFx0aWYoIWN0eCkge1xuXHRcdFx0XHRjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG1QYXJhbWV0ZXJzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBtUGFyYW1ldGVycyk7XHRcblx0XHRcdFx0dGhpcy5fdXNlV2ViR0wyID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl91c2VXZWJHTDIgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbDInLCBtUGFyYW1ldGVycykgfHwgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgbVBhcmFtZXRlcnMpO1xuXHRcdFx0Ly8gaWYoY3R4KSB7XG5cdFx0XHQvLyBcdHRoaXMuX3VzZVdlYkdMMiA9IHRydWU7XG5cdFx0XHQvLyB9IGVsc2Uge1xuXHRcdFx0Ly8gXHRjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG1QYXJhbWV0ZXJzKSB8fCB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBtUGFyYW1ldGVycyk7XG5cdFx0XHQvLyB9XG5cblx0XHRcdGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgbVBhcmFtZXRlcnMpIHx8IHRoaXMuY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG1QYXJhbWV0ZXJzKTtcdFxuXHRcdFx0dGhpcy5fdXNlV2ViR0wyID0gZmFsc2U7XG5cdFx0XHRcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygnVXNpbmcgV2ViR0wgMiA/JywgdGhpcy53ZWJnbDIpO1xuXG5cdFx0Ly9cdGV4dGVuc2lvbnNcblx0XHR0aGlzLmluaXRXaXRoR0woY3R4KTtcblx0fVxuXG5cdGluaXRXaXRoR0woY3R4KSB7XG5cdFx0aWYoIXRoaXMuY2FudmFzKSB7XHR0aGlzLmNhbnZhcyA9IGN0eC5jYW52YXM7XHR9XG5cdFx0Z2wgPSB0aGlzLmdsID0gY3R4O1xuXG5cdFx0dGhpcy5leHRlbnNpb25zID0ge307XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IEV4dGVuc2lvbnNMaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmV4dGVuc2lvbnNbRXh0ZW5zaW9uc0xpc3RbaV1dID0gZ2wuZ2V0RXh0ZW5zaW9uKEV4dGVuc2lvbnNMaXN0W2ldKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly9cdENvcHkgZ2wgQXR0cmlidXRlc1xuXHRcdGV4cG9zZUF0dHJpYnV0ZXMoKTtcblx0XHRnZXRBbmRBcHBseUV4dGVuc2lvbihnbCwgJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG5cdFx0Z2V0QW5kQXBwbHlFeHRlbnNpb24oZ2wsICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG5cdFx0Z2V0QW5kQXBwbHlFeHRlbnNpb24oZ2wsICdXRUJHTF9kcmF3X2J1ZmZlcnMnKTtcblx0XHRcblx0XHR0aGlzLmVuYWJsZSh0aGlzLkRFUFRIX1RFU1QpO1xuXHRcdHRoaXMuZW5hYmxlKHRoaXMuQ1VMTF9GQUNFKTtcblx0XHR0aGlzLmVuYWJsZSh0aGlzLkJMRU5EKTtcblx0XHR0aGlzLmVuYWJsZUFscGhhQmxlbmRpbmcoKTtcblx0fSBcblxuXG5cblx0Ly9cdFBVQkxJQyBNRVRIT0RTXG5cblx0c2V0Vmlld3BvcnQoeCwgeSwgdywgaCkge1xuXHRcdGxldCBoYXNDaGFuZ2VkID0gZmFsc2U7XG5cdFx0aWYoeCAhPT0gdGhpcy5fdmlld3BvcnRbMF0pIHsgaGFzQ2hhbmdlZCA9IHRydWU7IH1cblx0XHRpZih5ICE9PSB0aGlzLl92aWV3cG9ydFsxXSkgeyBoYXNDaGFuZ2VkID0gdHJ1ZTsgfVxuXHRcdGlmKHcgIT09IHRoaXMuX3ZpZXdwb3J0WzJdKSB7IGhhc0NoYW5nZWQgPSB0cnVlOyB9XG5cdFx0aWYoaCAhPT0gdGhpcy5fdmlld3BvcnRbM10pIHsgaGFzQ2hhbmdlZCA9IHRydWU7IH1cblxuXHRcdGlmKGhhc0NoYW5nZWQpIHtcblx0XHRcdGdsLnZpZXdwb3J0KHgsIHksIHcsIGgpO1xuXHRcdFx0dGhpcy5fdmlld3BvcnQgPSBbeCwgeSwgdywgaF07XG5cdFx0fVxuXHR9XG5cblx0c2Npc3Nvcih4LCB5LCB3LCBoKSB7XG5cdFx0Z2wuc2Npc3Nvcih4LCB5LCB3LCBoKTtcblx0fVxuXG5cblx0Y2xlYXIociwgZywgYiwgYSkge1xuXHRcdGdsLmNsZWFyQ29sb3IociwgZywgYiwgYSk7XG5cdFx0Z2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuXHR9XG5cblxuXHRjdWxsRmFjZShtVmFsdWUpIHtcblx0XHRnbC5jdWxsRmFjZShtVmFsdWUpO1xuXHR9XG5cblxuXHRzZXRNYXRyaWNlcyhtQ2FtZXJhKSB7XG5cdFx0dGhpcy5jYW1lcmEgPSBtQ2FtZXJhO1xuXHRcdHRoaXMucm90YXRlKHRoaXMuaWRlbnRpdHlNYXRyaXgpO1xuXHR9XG5cblxuXHR1c2VTaGFkZXIobVNoYWRlcikge1xuXHRcdHRoaXMuc2hhZGVyID0gbVNoYWRlcjtcblx0XHR0aGlzLnNoYWRlclByb2dyYW0gPSB0aGlzLnNoYWRlci5zaGFkZXJQcm9ncmFtO1xuXHR9XG5cblxuXHRyb3RhdGUobVJvdGF0aW9uKSB7XG5cdFx0bWF0NC5jb3B5KHRoaXMuX21vZGVsTWF0cml4LCBtUm90YXRpb24pO1xuXHRcdG1hdDQubXVsdGlwbHkodGhpcy5fbWF0cml4LCB0aGlzLmNhbWVyYS5tYXRyaXgsIHRoaXMuX21vZGVsTWF0cml4KTtcblx0XHRtYXQzLmZyb21NYXQ0KHRoaXMuX25vcm1hbE1hdHJpeCwgdGhpcy5fbWF0cml4KTtcblx0XHRtYXQzLmludmVydCh0aGlzLl9ub3JtYWxNYXRyaXgsIHRoaXMuX25vcm1hbE1hdHJpeCk7XG5cdFx0bWF0My50cmFuc3Bvc2UodGhpcy5fbm9ybWFsTWF0cml4LCB0aGlzLl9ub3JtYWxNYXRyaXgpO1xuXHRcdFxuXG5cdFx0bWF0My5mcm9tTWF0NCh0aGlzLl9pbnZlcnNlTW9kZWxWaWV3TWF0cml4LCB0aGlzLl9tYXRyaXgpO1xuXHRcdG1hdDMuaW52ZXJ0KHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgsIHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgpO1xuXHR9XG5cblxuXHRkcmF3R2VvbWV0cnkobUdlb21ldHJ5LCBtb2RlbE1hdHJpeCkge1xuXHRcdGlmKG1HZW9tZXRyeS5sZW5ndGgpIHtcblx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBtR2VvbWV0cnkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5kcmF3KG1HZW9tZXRyeVtpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bUdlb21ldHJ5LmJpbmQodGhpcy5zaGFkZXJQcm9ncmFtKTtcblxuXHRcdC8vXHRERUZBVUxUIFVOSUZPUk1TXG5cdFx0aWYodGhpcy5jYW1lcmEgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndVByb2plY3Rpb25NYXRyaXgnLCAnbWF0NCcsIHRoaXMuY2FtZXJhLnByb2plY3Rpb24pO1x0XG5cdFx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1Vmlld01hdHJpeCcsICdtYXQ0JywgdGhpcy5jYW1lcmEubWF0cml4KTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndUNhbWVyYVBvcycsICd2ZWMzJywgdGhpcy5jYW1lcmEucG9zaXRpb24pO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VNb2RlbE1hdHJpeCcsICdtYXQ0JywgbW9kZWxNYXRyaXggfHwgdGhpcy5fbW9kZWxNYXRyaXgpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3VOb3JtYWxNYXRyaXgnLCAnbWF0MycsIHRoaXMuX25vcm1hbE1hdHJpeCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndU1vZGVsVmlld01hdHJpeEludmVyc2UnLCAnbWF0MycsIHRoaXMuX2ludmVyc2VNb2RlbFZpZXdNYXRyaXgpO1xuXG5cdFx0Y29uc3QgZHJhd1R5cGUgPSBtR2VvbWV0cnkuZHJhd1R5cGU7XG5cblx0XHRpZihtR2VvbWV0cnkuaXNJbnN0YW5jZWQpIHtcblx0XHRcdGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZChtR2VvbWV0cnkuZHJhd1R5cGUsIG1HZW9tZXRyeS5pQnVmZmVyLm51bUl0ZW1zLCBnbC5VTlNJR05FRF9TSE9SVCwgMCwgbUdlb21ldHJ5Lm51bUluc3RhbmNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYoZHJhd1R5cGUgPT09IGdsLlBPSU5UUykge1xuXHRcdFx0XHRnbC5kcmF3QXJyYXlzKGRyYXdUeXBlLCAwLCBtR2VvbWV0cnkudmVydGV4U2l6ZSk7XHRcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsLmRyYXdFbGVtZW50cyhkcmF3VHlwZSwgbUdlb21ldHJ5LmlCdWZmZXIubnVtSXRlbXMsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcdFxuXHRcdFx0fVx0XG5cdFx0fVxuXG5cdFx0bUdlb21ldHJ5LnVuYmluZCgpO1xuXHR9XG5cblxuXHRkcmF3TWVzaChtTWVzaCkge1xuXHRcdGNvbnN0IHsgbWF0ZXJpYWwsIGdlb21ldHJ5IH0gPSBtTWVzaDtcblxuXHRcdGlmKG1hdGVyaWFsLmRvdWJsZVNpZGVkKSB7XG5cdFx0XHR0aGlzLmRpc2FibGUoR0wuQ1VMTF9GQUNFKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5lbmFibGUoR0wuQ1VMTF9GQUNFKTtcblx0XHR9XG5cblx0XHRtYXRlcmlhbC51cGRhdGUoKTtcblx0XHR0aGlzLmRyYXdHZW9tZXRyeShnZW9tZXRyeSwgbU1lc2gubWF0cml4KTtcblx0fVxuXG5cblx0ZHJhdyhtT2JqKSB7XG5cdFx0aWYobU9iaiBpbnN0YW5jZW9mIEdlb21ldHJ5KSB7XG5cdFx0XHR0aGlzLmRyYXdHZW9tZXRyeShtT2JqKTtcblx0XHR9IGVsc2UgaWYobU9iaiBpbnN0YW5jZW9mIE1lc2gpIHtcblx0XHRcdHRoaXMuZHJhd01lc2gobU9iaik7XG5cdFx0fSBlbHNlIGlmKG1PYmogaW5zdGFuY2VvZiBPYmplY3QzRCkge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coJ2hlcmUnKTtcblx0XHRcdG1PYmoudXBkYXRlTWF0cml4KCk7XG5cdFx0XHRtT2JqLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHR0aGlzLmRyYXcoY2hpbGQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblxuXHRkcmF3VHJhbnNmb3JtRmVlZGJhY2sobVRyYW5zZm9ybU9iamVjdCkge1xuXG5cdFx0Y29uc3QgeyBtZXNoU291cmNlLCBtZXNoRGVzdGluYXRpb24sIG51bVBvaW50cywgdHJhbnNmb3JtRmVlZGJhY2sgfSA9IG1UcmFuc2Zvcm1PYmplY3Q7XG5cdFx0XG5cdFx0Ly9cdEJJTkQgU09VUkNFIEJVRkZFUlMgLT4gc2V0dXBWZXJ0ZXhBdHRyKHNvdXJjZVZBTylcblx0XHRtZXNoU291cmNlLmJpbmQodGhpcy5zaGFkZXJQcm9ncmFtKTtcblx0XHRtZXNoRGVzdGluYXRpb24uZ2VuZXJhdGVCdWZmZXJzKHRoaXMuc2hhZGVyUHJvZ3JhbSk7XG5cblx0XHQvL1x0QklORCBERVNUSU5BVElPTiBCVUZGRVJTXG5cdFx0Z2wuYmluZFRyYW5zZm9ybUZlZWRiYWNrKGdsLlRSQU5TRk9STV9GRUVEQkFDSywgdHJhbnNmb3JtRmVlZGJhY2spO1xuXG5cdFx0bWVzaERlc3RpbmF0aW9uLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ciwgaSk9PiB7XG5cdFx0XHRnbC5iaW5kQnVmZmVyQmFzZShnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBhdHRyLmJ1ZmZlcik7XG5cdFx0fSk7XG5cblx0XHRnbC5lbmFibGUoZ2wuUkFTVEVSSVpFUl9ESVNDQVJEKTtcblxuXHRcdGdsLmJlZ2luVHJhbnNmb3JtRmVlZGJhY2soZ2wuUE9JTlRTKTtcblx0XHRnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgbnVtUG9pbnRzKTtcblx0XHRnbC5lbmRUcmFuc2Zvcm1GZWVkYmFjaygpO1x0XG5cdFx0XG5cblx0XHQvL1x0cmVzZXQgc3RhdGVcblx0XHRnbC5kaXNhYmxlKGdsLlJBU1RFUklaRVJfRElTQ0FSRCk7XG5cdFx0Z2wudXNlUHJvZ3JhbShudWxsKTtcblx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG5cdFx0bWVzaERlc3RpbmF0aW9uLmF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ciwgaSk9PiB7XG5cdFx0XHRnbC5iaW5kQnVmZmVyQmFzZShnbC5UUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSLCBpLCBudWxsKTtcblx0XHR9KTtcblx0XHRnbC5iaW5kVHJhbnNmb3JtRmVlZGJhY2soZ2wuVFJBTlNGT1JNX0ZFRURCQUNLLCBudWxsKTtcblxuXHRcdG1lc2hTb3VyY2UudW5iaW5kKCk7XG5cdH1cblxuXG5cdHNldFNpemUobVdpZHRoLCBtSGVpZ2h0KSB7XG5cdFx0dGhpcy5fd2lkdGggICAgICAgID0gbVdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCAgICAgICA9IG1IZWlnaHQ7XG5cdFx0dGhpcy5jYW52YXMud2lkdGggID0gdGhpcy5fd2lkdGg7XG5cdFx0dGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXHRcdHRoaXMuX2FzcGVjdFJhdGlvICA9IHRoaXMuX3dpZHRoIC8gdGhpcy5faGVpZ2h0O1xuXG5cdFx0aWYoZ2wpIHtcblx0XHRcdHRoaXMudmlld3BvcnQoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XHRcblx0XHR9XG5cdH1cblxuXG5cdHNob3dFeHRlbnNpb25zKCkge1xuXHRcdGNvbnNvbGUubG9nKCdFeHRlbnNpb25zIDogJywgdGhpcy5leHRlbnNpb25zKTtcblx0XHRmb3IoY29uc3QgZXh0IGluIHRoaXMuZXh0ZW5zaW9ucykge1xuXHRcdFx0aWYodGhpcy5leHRlbnNpb25zW2V4dF0pIHtcblx0XHRcdFx0Y29uc29sZS5sb2coZXh0LCAnOicsIHRoaXMuZXh0ZW5zaW9uc1tleHRdKTtcdFxuXHRcdFx0fVxuXHRcdH1cdFxuXHR9XG5cblx0Y2hlY2tFeHRlbnNpb24obUV4dGVuc2lvbikge1xuXHRcdHJldHVybiAhIXRoaXMuZXh0ZW5zaW9uc1ttRXh0ZW5zaW9uXTtcblx0fVxuXG5cblx0Z2V0RXh0ZW5zaW9uKG1FeHRlbnNpb24pIHtcblx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zW21FeHRlbnNpb25dO1xuXHR9XG5cblx0Ly9cdEJMRU5EIE1PREVTXG5cblx0ZW5hYmxlQWxwaGFCbGVuZGluZygpIHtcblx0XHRnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcdFxuXHR9XG5cblx0ZW5hYmxlQWRkaXRpdmVCbGVuZGluZygpIHtcblx0XHRnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuXHR9XG5cblx0Ly9cdG1hdHJpY2VzXG5cblx0cHVzaE1hdHJpeCgpIHtcblx0XHRjb25zdCBtdHggPSBtYXQ0LmNsb25lKHRoaXMuX21vZGVsTWF0cml4KTtcblx0XHR0aGlzLl9tYXRyaXhTdGFja3MucHVzaChtdHgpO1xuXHR9XG5cblxuXHRwb3BNYXRyaXgoKSB7XG5cdFx0aWYodGhpcy5fbWF0cml4U3RhY2tzLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0Y29uc3QgbXR4ID0gdGhpcy5fbWF0cml4U3RhY2tzLnBvcCgpO1xuXHRcdHRoaXMucm90YXRlKG10eCk7XG5cdH1cblxuXG5cdC8vXHRHTCBOQVRJVkUgRlVOQ1RJT05TXG5cblx0ZW5hYmxlKG1QYXJhbWV0ZXIpIHtcdGdsLmVuYWJsZShtUGFyYW1ldGVyKTtcdFx0fVxuXG5cdGRpc2FibGUobVBhcmFtZXRlcikge1x0Z2wuZGlzYWJsZShtUGFyYW1ldGVyKTtcdH1cblxuXHR2aWV3cG9ydCh4LCB5LCB3LCBoKSB7XHR0aGlzLnNldFZpZXdwb3J0KHgsIHksIHcsIGgpO1x0fVxuXG5cblx0Ly9cdEdFVFRFUiBBTkQgU0VUVEVSU1xuXG5cdGdldCBGTE9BVCgpIHsgcmV0dXJuIGdldEZsb2F0KCk7IH1cblx0XG5cdGdldCBIQUxGX0ZMT0FUKCkgeyByZXR1cm4gZ2V0SGFsZkZsb2F0KCk7IH1cblxuXHRnZXQgd2lkdGgoKSB7XHRyZXR1cm4gdGhpcy5fd2lkdGg7XHRcdH1cblxuXHRnZXQgaGVpZ2h0KCkge1x0cmV0dXJuIHRoaXMuX2hlaWdodDtcdH1cblxuXHRnZXQgYXNwZWN0UmF0aW8oKSB7XHRyZXR1cm4gdGhpcy5fYXNwZWN0UmF0aW87XHR9XG5cblx0Z2V0IHdlYmdsMigpIHtcdHJldHVybiB0aGlzLl91c2VXZWJHTDI7XHR9XG5cblx0Ly9cdERFU1RST1lcblxuXHRkZXN0cm95KCkge1xuXHRcdFxuXHRcdGlmKHRoaXMuY2FudmFzLnBhcmVudE5vZGUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnRXJyb3IgOiAnLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmNhbnZhcyA9IG51bGw7XG5cdH1cbn1cblxuY29uc3QgR0wgPSBuZXcgR0xUb29sKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEdMO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR0xUb29sLmpzIiwiLy8gR0xTaGFkZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuL0dMVGV4dHVyZSc7XG5pbXBvcnQgR0xDdWJlVGV4dHVyZSBmcm9tICcuL0dMQ3ViZVRleHR1cmUnO1xuXG5jb25zdCBnbHNsaWZ5ID0gcmVxdWlyZSgnZ2xzbGlmeScpO1xuY29uc3QgaXNTYW1lID0gKGFycmF5MSwgYXJyYXkyKSA9PiB7XG5cdGlmKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmb3IobGV0IGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGFkZExpbmVOdW1iZXJzID0gKHN0cmluZykgPT4ge1xuXHRjb25zdCBsaW5lcyA9IHN0cmluZy5zcGxpdCgnXFxuJyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrKSB7XG5cdFx0bGluZXNbaV0gPSBgJHsoaSArIDEpfTogJHtsaW5lc1tpXX1gO1xuXHR9XG5cdHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cblxuY29uc3QgY2xvbmVBcnJheSA9IChtQXJyYXkpID0+IHtcblx0aWYobUFycmF5LnNsaWNlKSB7XG5cdFx0cmV0dXJuIG1BcnJheS5zbGljZSgwKTsgXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobUFycmF5KTtcblx0fVxufTtcblxubGV0IGdsO1xuY29uc3QgZGVmYXVsdFZlcnRleFNoYWRlciA9IHJlcXVpcmUoJy4vZ2xzbC9iYXNpYy52ZXJ0Jyk7XG5jb25zdCBkZWZhdWx0RnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuL2dsc2wvYmFzaWMuZnJhZycpO1xuXG5jb25zdCB1bmlmb3JtTWFwcGluZyA9IHtcblx0ZmxvYXQ6ICd1bmlmb3JtMWYnLFxuXHR2ZWMyOiAndW5pZm9ybTJmdicsXG5cdHZlYzM6ICd1bmlmb3JtM2Z2Jyxcblx0dmVjNDogJ3VuaWZvcm00ZnYnLFxuXHRpbnQ6ICd1bmlmb3JtMWknLFxuXHRtYXQzOiAndW5pZm9ybU1hdHJpeDNmdicsXG5cdG1hdDQ6ICd1bmlmb3JtTWF0cml4NGZ2J1xufTtcblxuY2xhc3MgR0xTaGFkZXIge1xuXHRjb25zdHJ1Y3RvcihzdHJWZXJ0ZXhTaGFkZXIgPSBkZWZhdWx0VmVydGV4U2hhZGVyLCBzdHJGcmFnbWVudFNoYWRlciA9IGRlZmF1bHRGcmFnbWVudFNoYWRlciwgbVZhcnlpbmdzKSB7XG5cblx0XHRnbCAgICAgICAgICAgICAgICAgICA9IEdMLmdsO1xuXHRcdHRoaXMucGFyYW1ldGVycyAgICAgID0gW107XG5cdFx0dGhpcy5fdW5pZm9ybVRleHR1cmVzID0gW107XG5cdFx0dGhpcy5fdmFyeWluZ3MgXHRcdCA9IG1WYXJ5aW5ncztcblxuXHRcdGlmKCFzdHJWZXJ0ZXhTaGFkZXIpIHsgc3RyVmVydGV4U2hhZGVyID0gZGVmYXVsdFZlcnRleFNoYWRlcjsgfVxuXHRcdGlmKCFzdHJGcmFnbWVudFNoYWRlcikgeyBzdHJGcmFnbWVudFNoYWRlciA9IGRlZmF1bHRWZXJ0ZXhTaGFkZXI7IH1cblxuXHRcdGNvbnN0IHZzU2hhZGVyID0gdGhpcy5fY3JlYXRlU2hhZGVyUHJvZ3JhbShzdHJWZXJ0ZXhTaGFkZXIsIHRydWUpO1xuXHRcdGNvbnN0IGZzU2hhZGVyID0gdGhpcy5fY3JlYXRlU2hhZGVyUHJvZ3JhbShzdHJGcmFnbWVudFNoYWRlciwgZmFsc2UpO1xuXHRcdHRoaXMuX2F0dGFjaFNoYWRlclByb2dyYW0odnNTaGFkZXIsIGZzU2hhZGVyKTtcblxuXHR9XG5cblxuXHRiaW5kKCkge1xuXG5cdFx0aWYoR0wuc2hhZGVyID09PSB0aGlzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGdsLnVzZVByb2dyYW0odGhpcy5zaGFkZXJQcm9ncmFtKTtcblx0XHRHTC51c2VTaGFkZXIodGhpcyk7XG5cdFx0Ly8gdGhpcy51bmlmb3JtVGV4dHVyZXMgPSBbXTtcblxuXHR9XG5cblxuXHR1bmlmb3JtKG1OYW1lLCBtVHlwZSwgbVZhbHVlKSB7XG5cdFx0aWYodHlwZW9mIG1OYW1lID09PSAnb2JqZWN0Jykge1xuXHRcdFx0dGhpcy51bmlmb3JtT2JqZWN0KG1OYW1lKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Lypcblx0XHRpZighIW1WYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IG1WYWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdtVmFsdWUgRXJyb3I6JywgbU5hbWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0Ki9cblx0XHRjb25zdCB1bmlmb3JtVHlwZSA9IHVuaWZvcm1NYXBwaW5nW21UeXBlXSB8fCBtVHlwZTtcblx0XHRcblx0XHRsZXQgaGFzVW5pZm9ybSA9IGZhbHNlO1xuXHRcdGxldCBvVW5pZm9ybTtcblx0XHRsZXQgcGFyYW1ldGVySW5kZXggPSAtMTtcblxuXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRoaXMucGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0b1VuaWZvcm0gPSB0aGlzLnBhcmFtZXRlcnNbaV07XG5cdFx0XHRpZihvVW5pZm9ybS5uYW1lID09PSBtTmFtZSkge1xuXHRcdFx0XHRoYXNVbmlmb3JtID0gdHJ1ZTtcblx0XHRcdFx0cGFyYW1ldGVySW5kZXggPSBpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgaXNOdW1iZXIgPSBmYWxzZTtcblxuXHRcdGlmKCFoYXNVbmlmb3JtKSB7XG5cdFx0XHRpc051bWJlciA9IHVuaWZvcm1UeXBlID09PSAndW5pZm9ybTFpJyB8fCB1bmlmb3JtVHlwZSA9PT0gJ3VuaWZvcm0xZic7XG5cdFx0XHR0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuc2hhZGVyUHJvZ3JhbSwgbU5hbWUpO1xuXHRcdFx0aWYoaXNOdW1iZXIpIHtcblx0XHRcdFx0dGhpcy5wYXJhbWV0ZXJzLnB1c2goeyBuYW1lIDogbU5hbWUsIHR5cGU6IHVuaWZvcm1UeXBlLCB2YWx1ZTogbVZhbHVlLCB1bmlmb3JtTG9jOiB0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdLCBpc051bWJlciB9KTtcdFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wYXJhbWV0ZXJzLnB1c2goeyBuYW1lIDogbU5hbWUsIHR5cGU6IHVuaWZvcm1UeXBlLCB2YWx1ZTogY2xvbmVBcnJheShtVmFsdWUpLCB1bmlmb3JtTG9jOiB0aGlzLnNoYWRlclByb2dyYW1bbU5hbWVdLCBpc051bWJlciB9KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cGFyYW1ldGVySW5kZXggPSB0aGlzLnBhcmFtZXRlcnMubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSA9IG9Vbmlmb3JtLnVuaWZvcm1Mb2M7XG5cdFx0XHRpc051bWJlciA9IG9Vbmlmb3JtLmlzTnVtYmVyO1xuXHRcdH1cblxuXG5cdFx0aWYoIXRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udW5pZm9ybUxvYykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXG5cdFx0aWYodW5pZm9ybVR5cGUuaW5kZXhPZignTWF0cml4JykgPT09IC0xKSB7XG5cdFx0XHRpZighaXNOdW1iZXIpIHtcblx0XHRcdFx0aWYoIWlzU2FtZSh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlLCBtVmFsdWUpIHx8ICFoYXNVbmlmb3JtKSB7XG5cdFx0XHRcdFx0Z2xbdW5pZm9ybVR5cGVdKHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0sIG1WYWx1ZSk7XHRcblx0XHRcdFx0XHR0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdLnZhbHVlID0gY2xvbmVBcnJheShtVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBuZWVkVXBkYXRlID0gKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUgIT09IG1WYWx1ZSB8fCAhaGFzVW5pZm9ybSk7XG5cdFx0XHRcdGlmKG5lZWRVcGRhdGUpIHtcblx0XHRcdFx0XHRnbFt1bmlmb3JtVHlwZV0odGhpcy5zaGFkZXJQcm9ncmFtW21OYW1lXSwgbVZhbHVlKTtcdFxuXHRcdFx0XHRcdHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUgPSBtVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZighaXNTYW1lKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUsIG1WYWx1ZSkgfHwgIWhhc1VuaWZvcm0pIHtcblx0XHRcdFx0Z2xbdW5pZm9ybVR5cGVdKHRoaXMuc2hhZGVyUHJvZ3JhbVttTmFtZV0sIGZhbHNlLCBtVmFsdWUpO1x0XG5cdFx0XHRcdHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF0udmFsdWUgPSBjbG9uZUFycmF5KG1WYWx1ZSk7XG5cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdHVuaWZvcm1PYmplY3QobVVuaWZvcm1PYmopIHtcblx0XHRmb3IoY29uc3QgdW5pZm9ybU5hbWUgaW4gbVVuaWZvcm1PYmopIHtcblx0XHRcdFxuXHRcdFx0aWYgKG1Vbmlmb3JtT2JqW3VuaWZvcm1OYW1lXSBpbnN0YW5jZW9mIEdMVGV4dHVyZSB8fCBtVW5pZm9ybU9ialt1bmlmb3JtTmFtZV0gaW5zdGFuY2VvZiBHTEN1YmVUZXh0dXJlKSB7XG5cdFx0XHRcdGNvbnN0IHRleHR1cmUgPSBtVW5pZm9ybU9ialt1bmlmb3JtTmFtZV07XG5cblx0XHRcdFx0bGV0IHRleHR1cmVJbmRleCA9IC0xOyA7XG5cdFx0XHRcdHRoaXMuX3VuaWZvcm1UZXh0dXJlcy5mb3JFYWNoKCh1dCwgaSkgPT4ge1xuXHRcdFx0XHRcdGlmKHV0Lm5hbWUgPT09IHVuaWZvcm1OYW1lKSB7XG5cdFx0XHRcdFx0XHR0ZXh0dXJlSW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0dXQudGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZih0ZXh0dXJlSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdFx0dGV4dHVyZUluZGV4ID0gdGhpcy5fdW5pZm9ybVRleHR1cmVzLmxlbmd0aDtcdFxuXHRcdFx0XHRcdHRoaXMuX3VuaWZvcm1UZXh0dXJlcy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6dW5pZm9ybU5hbWUsXG5cdFx0XHRcdFx0XHR0ZXh0dXJlXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnVuaWZvcm0odW5pZm9ybU5hbWUsICd1bmlmb3JtMWknLCB0ZXh0dXJlSW5kZXgpO1xuXHRcdFx0XHR0ZXh0dXJlLmJpbmQodGV4dHVyZUluZGV4KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCB1bmlmb3JtVmFsdWUgPSBtVW5pZm9ybU9ialt1bmlmb3JtTmFtZV07XG5cdFx0XHRcdGNvbnN0IHVuaWZvcm1UeXBlID0gR0xTaGFkZXIuZ2V0VW5pZm9ybVR5cGUodW5pZm9ybVZhbHVlKTtcblxuXHRcdFx0XHRpZih1bmlmb3JtVmFsdWUuY29uY2F0ICYmIHVuaWZvcm1WYWx1ZVswXS5jb25jYXQpIHtcblx0XHRcdFx0XHRsZXQgdG1wID0gW107XG5cdFx0XHRcdFx0Zm9yKGxldCBpPTA7IGk8dW5pZm9ybVZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0bXAuY29uY2F0KHVuaWZvcm1WYWx1ZVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHVuaWZvcm1WYWx1ZSA9IHRtcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0dGhpcy51bmlmb3JtKHVuaWZvcm1OYW1lLCB1bmlmb3JtVHlwZSwgdW5pZm9ybVZhbHVlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdH1cblxuXHR9XG5cblxuXHRfY3JlYXRlU2hhZGVyUHJvZ3JhbShtU2hhZGVyU3RyLCBpc1ZlcnRleFNoYWRlcikge1xuXHRcdFxuXHRcdGNvbnN0IHNoYWRlclR5cGUgPSBpc1ZlcnRleFNoYWRlciA/IEdMLlZFUlRFWF9TSEFERVIgOiBHTC5GUkFHTUVOVF9TSEFERVI7XG5cdFx0Y29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKHNoYWRlciwgbVNoYWRlclN0cik7XG5cdFx0Z2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG5cdFx0aWYoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdFcnJvciBpbiBTaGFkZXIgOiAnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuXHRcdFx0Y29uc29sZS5sb2coYWRkTGluZU51bWJlcnMobVNoYWRlclN0cikpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNoYWRlcjtcblx0fVxuXG5cdF9hdHRhY2hTaGFkZXJQcm9ncmFtKG1WZXJ0ZXhTaGFkZXIsIG1GcmFnbWVudFNoYWRlcikge1xuXG5cdFx0dGhpcy5zaGFkZXJQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIG1WZXJ0ZXhTaGFkZXIpO1xuXHRcdGdsLmF0dGFjaFNoYWRlcih0aGlzLnNoYWRlclByb2dyYW0sIG1GcmFnbWVudFNoYWRlcik7XG5cblx0XHRnbC5kZWxldGVTaGFkZXIobVZlcnRleFNoYWRlcik7XG5cdFx0Z2wuZGVsZXRlU2hhZGVyKG1GcmFnbWVudFNoYWRlcik7XG5cblx0XHRpZih0aGlzLl92YXJ5aW5ncykge1xuXHRcdFx0Y29uc29sZS5sb2coJ1RyYW5zZm9ybSBmZWVkYmFjayBzZXR1cCA6ICcsIHRoaXMuX3ZhcnlpbmdzKTtcblx0XHRcdGdsLnRyYW5zZm9ybUZlZWRiYWNrVmFyeWluZ3ModGhpcy5zaGFkZXJQcm9ncmFtLCB0aGlzLl92YXJ5aW5ncywgZ2wuU0VQQVJBVEVfQVRUUklCUyk7XG5cdFx0fVxuXG5cdFx0Z2wubGlua1Byb2dyYW0odGhpcy5zaGFkZXJQcm9ncmFtKTtcblxuXHR9XG5cbn1cblxuR0xTaGFkZXIuZ2V0VW5pZm9ybVR5cGUgPSBmdW5jdGlvbiAobVZhbHVlKSB7XG5cdGNvbnN0IGlzQXJyYXkgPSAhIW1WYWx1ZS5jb25jYXQ7XG5cblx0Y29uc3QgZ2V0QXJyYXlVbmlmb3JtVHlwZSA9IGZ1bmN0aW9uIChtVmFsdWUpIHtcblx0XHRpZihtVmFsdWUubGVuZ3RoID09PSA5KSB7XG5cdFx0XHRyZXR1cm4gJ3VuaWZvcm1NYXRyaXgzZnYnO1xuXHRcdH0gZWxzZSBpZihtVmFsdWUubGVuZ3RoID09PSAxNikge1xuXHRcdFx0cmV0dXJuICd1bmlmb3JtTWF0cml4NGZ2Jztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGB2ZWMke21WYWx1ZS5sZW5ndGh9YDtcdFxuXHRcdH1cblx0fTtcblxuXHRpZighaXNBcnJheSkge1xuXHRcdHJldHVybiAnZmxvYXQnO1xuXHR9IGVsc2Uge1xuXHRcdGlmICghbVZhbHVlWzBdLmNvbmNhdCkge1xuXHRcdFx0cmV0dXJuIGdldEFycmF5VW5pZm9ybVR5cGUobVZhbHVlKTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZ2V0QXJyYXlVbmlmb3JtVHlwZShtVmFsdWVbMF0pO1xuXHRcdH1cblx0fVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBHTFNoYWRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9HTFNoYWRlci5qcyIsIi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuNC4wXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cbi8vIEVORCBIRUFERVJcblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vZ2wtbWF0cml4L2NvbW1vblwiO1xuaW1wb3J0ICogYXMgbWF0MiBmcm9tIFwiLi9nbC1tYXRyaXgvbWF0MlwiO1xuaW1wb3J0ICogYXMgbWF0MmQgZnJvbSBcIi4vZ2wtbWF0cml4L21hdDJkXCI7XG5pbXBvcnQgKiBhcyBtYXQzIGZyb20gXCIuL2dsLW1hdHJpeC9tYXQzXCI7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCIuL2dsLW1hdHJpeC9tYXQ0XCI7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gXCIuL2dsLW1hdHJpeC9xdWF0XCI7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gXCIuL2dsLW1hdHJpeC92ZWMyXCI7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gXCIuL2dsLW1hdHJpeC92ZWMzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL2dsLW1hdHJpeC92ZWM0XCI7XG5cbmV4cG9ydCB7XG4gIGdsTWF0cml4LFxuICBtYXQyLCBtYXQyZCwgbWF0MywgbWF0NCxcbiAgcXVhdCxcbiAgdmVjMiwgdmVjMywgdmVjNCxcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXguanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgZ2V0QXR0cmliTG9jIGZyb20gJy4vdXRpbHMvZ2V0QXR0cmliTG9jJztcblxubGV0IGdsO1xuY29uc3QgU1RBVElDX0RSQVcgPSAzNTA0NDtcblxuY29uc3QgZ2V0QnVmZmVyID0gZnVuY3Rpb24gKGF0dHIpIHtcblx0bGV0IGJ1ZmZlcjtcblx0XG5cdGlmKGF0dHIuYnVmZmVyICE9PSB1bmRlZmluZWQpIHtcblx0XHRidWZmZXIgPSBhdHRyLmJ1ZmZlcjtcdFxuXHR9IGVsc2Uge1xuXHRcdGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGF0dHIuYnVmZmVyID0gYnVmZmVyO1xuXHR9XG5cblx0cmV0dXJuIGJ1ZmZlcjtcbn07XG5cblxuY29uc3QgZm9ybUJ1ZmZlciA9IGZ1bmN0aW9uIChtRGF0YSwgbU51bSkge1xuXHRjb25zdCBhcnkgPSBbXTtcblxuXHRmb3IobGV0IGk9MDsgaTxtRGF0YS5sZW5ndGg7IGkrPSBtTnVtKSB7XG5cdFx0Y29uc3QgbyA9IFtdO1xuXHRcdGZvcihsZXQgaj0wOyBqPG1OdW07IGorKykge1xuXHRcdFx0by5wdXNoKG1EYXRhW2kral0pO1xuXHRcdH1cblxuXHRcdGFyeS5wdXNoKG8pO1xuXHR9XG5cblx0cmV0dXJuIGFyeTtcbn07XG5cbmNsYXNzIEdlb21ldHJ5IHtcblx0Y29uc3RydWN0b3IobURyYXdpbmdUeXBlID0gNCwgbVVzZVZhbyA9IHRydWUpIHtcblx0XHRnbCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gR0wuZ2w7XG5cdFx0dGhpcy5kcmF3VHlwZSAgICAgICAgICAgICAgICA9IG1EcmF3aW5nVHlwZTtcblx0XHR0aGlzLl9hdHRyaWJ1dGVzICAgICAgICAgICAgID0gW107XG5cdFx0dGhpcy5fbnVtSW5zdGFuY2UgXHRcdFx0ID0gLTE7XG5cdFx0dGhpcy5fZW5hYmxlZFZlcnRleEF0dHJpYnV0ZSA9IFtdO1xuXHRcdFxuXHRcdHRoaXMuX2luZGljZXMgICAgICAgICAgICAgICAgPSBbXTtcblx0XHR0aGlzLl9mYWNlcyAgICAgICAgICAgICAgICAgID0gW107XG5cdFx0dGhpcy5fYnVmZmVyQ2hhbmdlZCAgICAgICAgICA9IFtdO1xuXHRcdHRoaXMuX2hhc0luZGV4QnVmZmVyQ2hhbmdlZCAgPSBmYWxzZTtcblx0XHR0aGlzLl9oYXNWQU8gICAgICAgICAgICAgICAgID0gZmFsc2U7XG5cdFx0dGhpcy5faXNJbnN0YW5jZWQgXHRcdFx0ID0gZmFsc2U7XG5cdFx0XG5cdFx0dGhpcy5fZXh0VkFPICAgICAgICAgICAgICAgICA9ICEhR0wuZ2wuY3JlYXRlVmVydGV4QXJyYXk7XG5cdFx0dGhpcy5fdXNlVkFPICAgICAgICAgICAgIFx0ID0gISF0aGlzLl9leHRWQU8gJiYgbVVzZVZhbztcblx0XHQvLyB0aGlzLl91c2VWQU8gPSBmYWxzZTtcblx0fVxuXG5cblx0YnVmZmVyVmVydGV4KG1BcnJheVZlcnRpY2VzLCBtRHJhd1R5cGUgPSBTVEFUSUNfRFJBVykge1xuXG5cdFx0dGhpcy5idWZmZXJEYXRhKG1BcnJheVZlcnRpY2VzLCAnYVZlcnRleFBvc2l0aW9uJywgMywgbURyYXdUeXBlKTtcblxuXHRcdGlmICh0aGlzLm5vcm1hbHMubGVuZ3RoIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuYnVmZmVyTm9ybWFsKG1BcnJheVZlcnRpY2VzLCBtRHJhd1R5cGUpO1x0XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXG5cdGJ1ZmZlclRleENvb3JkKG1BcnJheVRleENvb3JkcywgbURyYXdUeXBlID0gU1RBVElDX0RSQVcpIHtcblxuXHRcdHRoaXMuYnVmZmVyRGF0YShtQXJyYXlUZXhDb29yZHMsICdhVGV4dHVyZUNvb3JkJywgMiwgbURyYXdUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblxuXHRidWZmZXJOb3JtYWwobU5vcm1hbHMsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXKSB7XG5cblx0XHR0aGlzLmJ1ZmZlckRhdGEobU5vcm1hbHMsICdhTm9ybWFsJywgMywgbURyYXdUeXBlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblxuXHRidWZmZXJJbmRleChtQXJyYXlJbmRpY2VzLCBpc0R5bmFtaWMgPSBmYWxzZSkge1xuXHRcdHRoaXMuX2RyYXdUeXBlICAgICAgICA9IGlzRHluYW1pYyA/IGdsLkRZTkFNSUNfRFJBVyA6IGdsLlNUQVRJQ19EUkFXO1xuXHRcdGlmKG1BcnJheUluZGljZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0dGhpcy5faW5kaWNlc1x0ICA9IG5ldyBVaW50MTZBcnJheShtQXJyYXlJbmRpY2VzKTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbmRpY2VzID0gbUFycmF5SW5kaWNlcztcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5fbnVtSXRlbXMgXHRcdCAgPSB0aGlzLl9pbmRpY2VzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YnVmZmVyRmxhdHRlbkRhdGEobURhdGEsIG1OYW1lLCBtSXRlbVNpemUsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXLCBpc0luc3RhbmNlZCA9IGZhbHNlKSB7XG5cdFx0XG5cdFx0Y29uc3QgZGF0YSA9IGZvcm1CdWZmZXIobURhdGEsIG1JdGVtU2l6ZSk7XG5cdFx0dGhpcy5idWZmZXJEYXRhKGRhdGEsIG1OYW1lLCBtSXRlbVNpemUsIG1EcmF3VHlwZSA9IFNUQVRJQ19EUkFXLCBpc0luc3RhbmNlZCA9IGZhbHNlKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YnVmZmVyRGF0YShtRGF0YSwgbU5hbWUsIG1JdGVtU2l6ZSwgbURyYXdUeXBlID0gU1RBVElDX0RSQVcsIGlzSW5zdGFuY2VkID0gZmFsc2UpIHtcblx0XHRsZXQgaSA9IDA7XG5cdFx0Y29uc3QgZHJhd1R5cGUgICA9IG1EcmF3VHlwZTtcblx0XHRpZighZHJhd1R5cGUpIGRlYnVnZ2VyO1xuXG5cdFx0Y29uc3QgYnVmZmVyRGF0YSA9IFtdO1xuXHRcdGlmICghbUl0ZW1TaXplKSB7XHRtSXRlbVNpemUgPSBtRGF0YVswXS5sZW5ndGg7IH1cblx0XHR0aGlzLl9pc0luc3RhbmNlZCA9IGlzSW5zdGFuY2VkIHx8IHRoaXMuX2lzSW5zdGFuY2VkO1xuXG5cdFx0Ly9cdGZsYXR0ZW4gYnVmZmVyIGRhdGFcdFx0XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbURhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGZvcihsZXQgaiA9IDA7IGogPCBtRGF0YVtpXS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRidWZmZXJEYXRhLnB1c2gobURhdGFbaV1bal0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb25zdCBkYXRhQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlckRhdGEpO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKG1OYW1lKTtcblxuXHRcdFxuXHRcdGlmKGF0dHJpYnV0ZSkge1x0XG5cdFx0XHQvL1x0YXR0cmlidXRlIGV4aXN0ZWQsIHJlcGxhY2Ugd2l0aCBuZXcgZGF0YVxuXHRcdFx0YXR0cmlidXRlLml0ZW1TaXplID0gbUl0ZW1TaXplO1xuXHRcdFx0YXR0cmlidXRlLmRhdGFBcnJheSA9IGRhdGFBcnJheTtcblx0XHRcdGF0dHJpYnV0ZS5zb3VyY2UgPSBtRGF0YTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly9cdGF0dHJpYnV0ZSBub3QgZXhpc3QgeWV0LCBjcmVhdGUgbmV3IGF0dHJpYnV0ZSBvYmplY3Rcblx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMucHVzaCh7IG5hbWU6bU5hbWUsIHNvdXJjZTptRGF0YSwgaXRlbVNpemU6IG1JdGVtU2l6ZSwgZHJhd1R5cGUsIGRhdGFBcnJheSwgaXNJbnN0YW5jZWQgfSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYnVmZmVyQ2hhbmdlZC5wdXNoKG1OYW1lKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGJ1ZmZlckluc3RhbmNlKG1EYXRhLCBtTmFtZSkge1xuXHRcdGlmICghR0wuZ2wudmVydGV4QXR0cmliRGl2aXNvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXh0ZW5zaW9uIDogQU5HTEVfaW5zdGFuY2VkX2FycmF5cyBpcyBub3Qgc3VwcG9ydGVkIHdpdGggdGhpcyBkZXZpY2UgIScpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGl0ZW1TaXplID0gbURhdGFbMF0ubGVuZ3RoO1xuXHRcdHRoaXMuX251bUluc3RhbmNlID0gbURhdGEubGVuZ3RoO1xuXHRcdHRoaXMuYnVmZmVyRGF0YShtRGF0YSwgbU5hbWUsIGl0ZW1TaXplLCBTVEFUSUNfRFJBVywgdHJ1ZSk7XG5cdH1cblxuXG5cdGJpbmQobVNoYWRlclByb2dyYW0pIHtcblx0XHR0aGlzLmdlbmVyYXRlQnVmZmVycyhtU2hhZGVyUHJvZ3JhbSk7XG5cblx0XHRpZih0aGlzLmhhc1ZBTykge1xuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KHRoaXMudmFvKTsgXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyaWJ1dGUpPT4ge1xuXHRcdFx0XHRnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYXR0cmlidXRlLmJ1ZmZlcik7XG5cdFx0XHRcdGNvbnN0IGF0dHJQb3NpdGlvbiA9IGF0dHJpYnV0ZS5hdHRyUG9zaXRpb247XG5cdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0clBvc2l0aW9uLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cblx0XHRcdFx0aWYoYXR0cmlidXRlLmlzSW5zdGFuY2VkKSB7XG5cdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyUG9zaXRpb24sIDEpO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXG5cdFx0XHQvL1x0QklORCBJTkRFWCBCVUZGRVJcblx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaUJ1ZmZlcik7XHRcblx0XHR9XG5cdH1cblxuXHRnZW5lcmF0ZUJ1ZmZlcnMobVNoYWRlclByb2dyYW0pIHtcblx0XHRpZih0aGlzLl9idWZmZXJDaGFuZ2VkLmxlbmd0aCA9PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0aWYodGhpcy5fdXNlVkFPKSB7IC8vXHRJRiBTVVBQT1JURUQsIENSRUFURSBWQU9cblxuXHRcdFx0Ly9cdENSRUFURSAmIEJJTkQgVkFPXG5cdFx0XHRpZighdGhpcy5fdmFvKSB7XG5cdFx0XHRcdHRoaXMuX3ZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XHRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Z2wuYmluZFZlcnRleEFycmF5KHRoaXMuX3Zhbyk7XG5cblx0XHRcdC8vXHRVUERBVEUgQlVGRkVSU1xuXHRcdFx0dGhpcy5fYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyT2JqKSA9PiB7XG5cblx0XHRcdFx0aWYodGhpcy5fYnVmZmVyQ2hhbmdlZC5pbmRleE9mKGF0dHJPYmoubmFtZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gZ2V0QnVmZmVyKGF0dHJPYmopO1xuXHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdFx0XHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyT2JqLmRhdGFBcnJheSwgYXR0ck9iai5kcmF3VHlwZSk7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyUG9zaXRpb24gPSBnZXRBdHRyaWJMb2MoZ2wsIG1TaGFkZXJQcm9ncmFtLCBhdHRyT2JqLm5hbWUpO1xuXHRcdFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJQb3NpdGlvbik7IFxuXHRcdFx0XHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0clBvc2l0aW9uLCBhdHRyT2JqLml0ZW1TaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXHRcdFx0XHRcdGF0dHJPYmouYXR0clBvc2l0aW9uID0gYXR0clBvc2l0aW9uO1xuXG5cdFx0XHRcdFx0aWYoYXR0ck9iai5pc0luc3RhbmNlZCkge1xuXHRcdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyUG9zaXRpb24sIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdC8vXHRjaGVjayBpbmRleCBidWZmZXJcblx0XHRcdHRoaXMuX3VwZGF0ZUluZGV4QnVmZmVyKCk7XG5cblx0XHRcdC8vXHRVTkJJTkQgVkFPXG5cdFx0XHRnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XHRcblx0XHRcdFxuXHRcdFx0dGhpcy5faGFzVkFPID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7IC8vXHRFTFNFLCBVU0UgVFJBRElUSU9OQUwgTUVUSE9EXG5cblx0XHRcdHRoaXMuX2F0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0ck9iaikgPT4ge1xuXHRcdFx0XHQvL1x0U0tJUCBJRiBCVUZGRVIgSEFTTidUIENIQU5HRURcblx0XHRcdFx0aWYodGhpcy5fYnVmZmVyQ2hhbmdlZC5pbmRleE9mKGF0dHJPYmoubmFtZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0Y29uc3QgYnVmZmVyID0gZ2V0QnVmZmVyKGF0dHJPYmopO1xuXHRcdFx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuXHRcdFx0XHRcdGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyT2JqLmRhdGFBcnJheSwgYXR0ck9iai5kcmF3VHlwZSk7XG5cblx0XHRcdFx0XHRjb25zdCBhdHRyUG9zaXRpb24gPSBnZXRBdHRyaWJMb2MoZ2wsIG1TaGFkZXJQcm9ncmFtLCBhdHRyT2JqLm5hbWUpO1xuXHRcdFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJQb3NpdGlvbik7XG5cdFx0XHRcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyUG9zaXRpb24sIGF0dHJPYmouaXRlbVNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cdFx0XHRcdFx0YXR0ck9iai5hdHRyUG9zaXRpb24gPSBhdHRyUG9zaXRpb247XG5cblx0XHRcdFx0XHRpZihhdHRyT2JqLmlzSW5zdGFuY2VkKSB7XG5cdFx0XHRcdFx0XHRnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJQb3NpdGlvbiwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fdXBkYXRlSW5kZXhCdWZmZXIoKTtcblx0XHR9XG5cblx0XHR0aGlzLl9oYXNJbmRleEJ1ZmZlckNoYW5nZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9idWZmZXJDaGFuZ2VkID0gW107XG5cdH1cblxuXG5cdHVuYmluZCgpIHtcblx0XHRpZih0aGlzLl91c2VWQU8pIHtcblx0XHRcdGdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcdFxuXHRcdH1cblx0XHRcblx0XHR0aGlzLl9hdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZSk9PiB7XG5cdFx0XHRpZihhdHRyaWJ1dGUuaXNJbnN0YW5jZWQpIHtcblx0XHRcdFx0Z2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyaWJ1dGUuYXR0clBvc2l0aW9uLCAwKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cblx0X3VwZGF0ZUluZGV4QnVmZmVyKCkge1xuXHRcdGlmKCF0aGlzLl9oYXNJbmRleEJ1ZmZlckNoYW5nZWQpIHtcblx0XHRcdGlmICghdGhpcy5pQnVmZmVyKSB7IHRoaXMuaUJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1x0IH1cblx0XHRcdGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaUJ1ZmZlcik7XG5cdFx0XHRnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9pbmRpY2VzLCB0aGlzLl9kcmF3VHlwZSk7XG5cdFx0XHR0aGlzLmlCdWZmZXIuaXRlbVNpemUgPSAxO1xuXHRcdFx0dGhpcy5pQnVmZmVyLm51bUl0ZW1zID0gdGhpcy5fbnVtSXRlbXM7XG5cdFx0fVxuXHR9XG5cblxuXHRjb21wdXRlTm9ybWFscyh1c2luZ0ZhY2VOb3JtYWxzID0gZmFsc2UpIHtcblxuXHRcdHRoaXMuZ2VuZXJhdGVGYWNlcygpO1xuXG5cdFx0aWYodXNpbmdGYWNlTm9ybWFscykge1xuXHRcdFx0dGhpcy5fY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cdFx0fVxuXHR9XG5cblx0Ly9cdFBSSVZBVEUgTUVUSE9EU1xuXG5cdF9jb21wdXRlRmFjZU5vcm1hbHMoKSB7XG5cblx0XHRsZXQgZmFjZUluZGV4O1xuXHRcdGxldCBmYWNlO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbmRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHRmYWNlSW5kZXggPSBpIC8gMztcblx0XHRcdGZhY2UgPSB0aGlzLl9mYWNlc1tmYWNlSW5kZXhdO1xuXHRcdFx0Y29uc3QgTiA9IGZhY2Uubm9ybWFsO1xuXG5cdFx0XHRub3JtYWxzW2ZhY2UuaW5kaWNlc1swXV0gPSBOO1xuXHRcdFx0bm9ybWFsc1tmYWNlLmluZGljZXNbMV1dID0gTjtcblx0XHRcdG5vcm1hbHNbZmFjZS5pbmRpY2VzWzJdXSA9IE47XG5cdFx0fVxuXG5cdFx0dGhpcy5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cdH1cblxuXG5cdF9jb21wdXRlVmVydGV4Tm9ybWFscygpIHtcblx0XHQvL1x0bG9vcCB0aHJvdWdoIGFsbCB2ZXJ0aWNlc1xuXHRcdGxldCBmYWNlO1xuXHRcdGNvbnN0IHN1bU5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHsgdmVydGljZXMgfSA9IHRoaXM7XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcblxuXHRcdFx0dmVjMy5zZXQoc3VtTm9ybWFsLCAwLCAwLCAwKTtcblxuXHRcdFx0Zm9yKGxldCBqID0gMDsgaiA8IHRoaXMuX2ZhY2VzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGZhY2UgPSB0aGlzLl9mYWNlc1tqXTtcblxuXHRcdFx0XHQvL1x0aWYgdmVydGV4IGV4aXN0IGluIHRoZSBmYWNlLCBhZGQgdGhlIG5vcm1hbCB0byBzdW0gbm9ybWFsXG5cdFx0XHRcdGlmKGZhY2UuaW5kaWNlcy5pbmRleE9mKGkpID49IDApIHtcblxuXHRcdFx0XHRcdHN1bU5vcm1hbFswXSArPSBmYWNlLm5vcm1hbFswXTtcblx0XHRcdFx0XHRzdW1Ob3JtYWxbMV0gKz0gZmFjZS5ub3JtYWxbMV07XG5cdFx0XHRcdFx0c3VtTm9ybWFsWzJdICs9IGZhY2Uubm9ybWFsWzJdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2ZWMzLm5vcm1hbGl6ZShzdW1Ob3JtYWwsIHN1bU5vcm1hbCk7XG5cdFx0XHRub3JtYWxzLnB1c2goW3N1bU5vcm1hbFswXSwgc3VtTm9ybWFsWzFdLCBzdW1Ob3JtYWxbMl1dKTtcblx0XHR9XG5cblx0XHR0aGlzLmJ1ZmZlck5vcm1hbChub3JtYWxzKTtcblxuXHR9XG5cblxuXHRnZW5lcmF0ZUZhY2VzKCkge1xuXHRcdGxldCBpYSwgaWIsIGljO1xuXHRcdGxldCBhLCBiLCBjO1xuXHRcdGNvbnN0IHZiYSA9IHZlYzMuY3JlYXRlKCksIHZjYSA9IHZlYzMuY3JlYXRlKCksIHZOb3JtYWwgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IHsgdmVydGljZXMgfSA9IHRoaXM7XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5kaWNlcy5sZW5ndGg7IGkgKz0gMykge1xuXG5cdFx0XHRpYSA9IHRoaXMuX2luZGljZXNbaV07XG5cdFx0XHRpYiA9IHRoaXMuX2luZGljZXNbaSArIDFdO1xuXHRcdFx0aWMgPSB0aGlzLl9pbmRpY2VzW2kgKyAyXTtcblxuXHRcdFx0YSA9IHZlcnRpY2VzW2lhXTtcblx0XHRcdGIgPSB2ZXJ0aWNlc1tpYl07XG5cdFx0XHRjID0gdmVydGljZXNbaWNdO1xuXG5cdFx0XHRjb25zdCBmYWNlID0ge1xuXHRcdFx0XHRpbmRpY2VzOltpYSwgaWIsIGljXSxcblx0XHRcdFx0dmVydGljZXM6W2EsIGIsIGNdLFxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5fZmFjZXMucHVzaChmYWNlKTtcblx0XHR9XG5cblx0fVxuXG5cblx0Z2V0QXR0cmlidXRlKG1OYW1lKSB7XHRyZXR1cm4gdGhpcy5fYXR0cmlidXRlcy5maW5kKChhKSA9PiBhLm5hbWUgPT09IG1OYW1lKTtcdH1cblx0Z2V0U291cmNlKG1OYW1lKSB7XG5cdFx0Y29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKG1OYW1lKTtcblx0XHRyZXR1cm4gYXR0ciA/IGF0dHIuc291cmNlIDogW107XG5cdH1cblxuXG5cdC8vXHRHRVRURVIgQU5EIFNFVFRFUlNcblxuXHRnZXQgdmVydGljZXMoKSB7XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoJ2FWZXJ0ZXhQb3NpdGlvbicpO1x0fVxuXG5cdGdldCBub3JtYWxzKCkge1x0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoJ2FOb3JtYWwnKTtcdH1cblxuXHRnZXQgY29vcmRzKCkge1x0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoJ2FUZXh0dXJlQ29vcmQnKTtcdH1cblxuXHRnZXQgaW5kaWNlcygpIHtcdFx0cmV0dXJuIHRoaXMuX2luZGljZXM7XHR9XG5cblx0Z2V0IHZlcnRleFNpemUoKSB7XHRyZXR1cm4gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHR9XG5cblx0Z2V0IGZhY2VzKCkge1x0cmV0dXJuIHRoaXMuX2ZhY2VzO1x0fVxuXG5cdGdldCBhdHRyaWJ1dGVzKCkge1x0cmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXM7XHR9XG5cblx0Z2V0IGhhc1ZBTygpIHtcdHJldHVybiB0aGlzLl9oYXNWQU87XHR9XG5cblx0Z2V0IHZhbygpIHtcdHJldHVybiB0aGlzLl92YW87XHR9XG5cblx0Z2V0IG51bUluc3RhbmNlKCkge1x0cmV0dXJuIHRoaXMuX251bUluc3RhbmNlO1x0fVxuXG5cdGdldCBpc0luc3RhbmNlZCgpIHsgcmV0dXJuIHRoaXMuX2lzSW5zdGFuY2VkO1x0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgR2VvbWV0cnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR2VvbWV0cnkuanMiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG4vKipcbiAqIENvbW1vbiB1dGlsaXRpZXNcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcbiAqL1xuXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xuZXhwb3J0IGNvbnN0IEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCBsZXQgQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmV4cG9ydCBjb25zdCBSQU5ET00gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcbiAqXG4gKiBAcGFyYW0ge1R5cGV9IHR5cGUgQXJyYXkgdHlwZSwgc3VjaCBhcyBGbG9hdDMyQXJyYXkgb3IgQXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxuXG5jb25zdCBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiAqIENvbnZlcnQgRGVncmVlIFRvIFJhZGlhblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFuKGEpIHtcbiAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xuICogdGhhbiBvciBlcXVhbCB0byAxLjAsIGFuZCBhIHJlbGF0aXZlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciBsYXJnZXIgdmFsdWVzKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgbnVtYmVyIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBFUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L2NvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEJhdGNoLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5cbmNsYXNzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcihtR2VvbWV0cnksIG1TaGFkZXIpIHtcblx0XHR0aGlzLl9nZW9tZXRyeSA9IG1HZW9tZXRyeTtcblx0XHR0aGlzLl9zaGFkZXIgPSBtU2hhZGVyO1xuXHR9XG5cblxuXHQvL1x0UFVCTElDIE1FVEhPRFNcblxuXHRkcmF3KCkge1xuXHRcdHRoaXMuX3NoYWRlci5iaW5kKCk7XG5cdFx0R0wuZHJhdyh0aGlzLl9nZW9tZXRyeSk7XG5cdH1cblxuXG5cdC8vXHRHRVRURVIgQU5EIFNFVFRFUlxuXG5cdGdldCBnZW9tZXRyeSgpIHtcdHJldHVybiB0aGlzLl9nZW9tZXRyeTtcdH1cblxuXHRnZXQgc2hhZGVyKCkge1x0cmV0dXJuIHRoaXMuX3NoYWRlcjtcdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2g7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvQmF0Y2guanMiLCIvLyBTY2hlZHVsZXIuanNcblxuXG5jbGFzcyBTY2hlZHVsZXIge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX2RlbGF5VGFza3MgPSBbXTtcblx0XHR0aGlzLl9uZXh0VGFza3MgPSBbXTtcblx0XHR0aGlzLl9kZWZlclRhc2tzID0gW107XG5cdFx0dGhpcy5faGlnaFRhc2tzID0gW107XG5cdFx0dGhpcy5fdXN1cnBUYXNrID0gW107XG5cdFx0dGhpcy5fZW50ZXJmcmFtZVRhc2tzID0gW107XG5cdFx0dGhpcy5faWRUYWJsZSA9IDA7XG5cdFx0dGhpcy5mcmFtZVJhdGUgPSA2MDtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuXHRcdHRoaXMuX2RlbHRhVGltZSA9IDA7XG5cblx0XHR0aGlzLl9sb29wKCk7XG5cdH1cblxuXG5cdC8vICBQVUJMSUMgTUVUSE9EU1xuXG5cdGFkZEVGKGZ1bmMsIHBhcmFtcykge1xuXHRcdHBhcmFtcyA9IHBhcmFtcyB8fCBbXTtcblx0XHRjb25zdCBpZCA9IHRoaXMuX2lkVGFibGU7XG5cdFx0dGhpcy5fZW50ZXJmcmFtZVRhc2tzW2lkXSA9IHsgZnVuYywgcGFyYW1zIH07XG5cdFx0dGhpcy5faWRUYWJsZSArKztcblx0XHRyZXR1cm4gaWQ7XG5cdH1cblxuXHRyZW1vdmVFRihpZCkge1xuXHRcdGlmICh0aGlzLl9lbnRlcmZyYW1lVGFza3NbaWRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2VudGVyZnJhbWVUYXNrc1tpZF0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH1cblxuXHRkZWxheShmdW5jLCBwYXJhbXMsIGRlbGF5KSB7XG5cdFx0Y29uc3QgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdGNvbnN0IHQgPSB7IGZ1bmMsIHBhcmFtcywgZGVsYXksIHRpbWUgfTtcblx0XHR0aGlzLl9kZWxheVRhc2tzLnB1c2godCk7XG5cdH1cblxuXHRkZWZlcihmdW5jLCBwYXJhbXMpIHtcblx0XHRjb25zdCB0ID0geyBmdW5jLCBwYXJhbXMgfTtcblx0XHR0aGlzLl9kZWZlclRhc2tzLnB1c2godCk7XG5cdH1cblxuXHRuZXh0KGZ1bmMsIHBhcmFtcykge1xuXHRcdGNvbnN0IHQgPSB7IGZ1bmMsIHBhcmFtcyB9O1xuXHRcdHRoaXMuX25leHRUYXNrcy5wdXNoKHQpO1xuXHR9XG5cblx0dXN1cnAoZnVuYywgcGFyYW1zKSB7XG5cdFx0Y29uc3QgdCA9IHsgZnVuYywgcGFyYW1zIH07XG5cdFx0dGhpcy5fdXN1cnBUYXNrLnB1c2godCk7XG5cdH1cblxuXG5cdC8vICBQUklWQVRFIE1FVEhPRFNcblxuXHRfcHJvY2VzcygpIHtcblx0XHRsZXQgaSA9IDA7XG5cdFx0bGV0IHRhc2s7XG5cdFx0bGV0IGludGVydmFsO1xuXHRcdGxldCBjdXJyZW50O1xuXHRcdGZvciAoaSA9IDA7IGkgPCB0aGlzLl9lbnRlcmZyYW1lVGFza3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9lbnRlcmZyYW1lVGFza3NbaV07XG5cdFx0XHRpZiAodGFzayAhPT0gbnVsbCAmJiB0YXNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAodGhpcy5faGlnaFRhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9oaWdoVGFza3MucG9wKCk7XG5cdFx0XHR0YXNrLmZ1bmModGFzay5wYXJhbXMpO1xuXHRcdH1cblxuXG5cdFx0bGV0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdHRoaXMuX2RlbHRhVGltZSA9IChzdGFydFRpbWUgLSB0aGlzLl9zdGFydFRpbWUpLzEwMDA7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGhpcy5fZGVsYXlUYXNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGFzayA9IHRoaXMuX2RlbGF5VGFza3NbaV07XG5cdFx0XHRpZiAoc3RhcnRUaW1lIC0gdGFzay50aW1lID4gdGFzay5kZWxheSkge1xuXHRcdFx0XHR0YXNrLmZ1bmModGFzay5wYXJhbXMpO1xuXHRcdFx0XHR0aGlzLl9kZWxheVRhc2tzLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHR0aGlzLl9kZWx0YVRpbWUgPSAoc3RhcnRUaW1lIC0gdGhpcy5fc3RhcnRUaW1lKS8xMDAwO1xuXHRcdGludGVydmFsID0gMTAwMCAvIHRoaXMuZnJhbWVSYXRlO1xuXHRcdHdoaWxlICh0aGlzLl9kZWZlclRhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl9kZWZlclRhc2tzLnNoaWZ0KCk7XG5cdFx0XHRjdXJyZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHRpZiAoY3VycmVudCAtIHN0YXJ0VGltZSA8IGludGVydmFsKSB7XG5cdFx0XHRcdHRhc2suZnVuYyh0YXNrLnBhcmFtcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9kZWZlclRhc2tzLnVuc2hpZnQodGFzayk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0c3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0dGhpcy5fZGVsdGFUaW1lID0gKHN0YXJ0VGltZSAtIHRoaXMuX3N0YXJ0VGltZSkvMTAwMDtcblx0XHRpbnRlcnZhbCA9IDEwMDAgLyB0aGlzLmZyYW1lUmF0ZTtcblx0XHR3aGlsZSAodGhpcy5fdXN1cnBUYXNrLmxlbmd0aCA+IDApIHtcblx0XHRcdHRhc2sgPSB0aGlzLl91c3VycFRhc2suc2hpZnQoKTtcblx0XHRcdGN1cnJlbnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdGlmIChjdXJyZW50IC0gc3RhcnRUaW1lIDwgaW50ZXJ2YWwpIHtcblx0XHRcdFx0dGFzay5mdW5jKHRhc2sucGFyYW1zKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9oaWdoVGFza3MgPSB0aGlzLl9oaWdoVGFza3MuY29uY2F0KHRoaXMuX25leHRUYXNrcyk7XG5cdFx0dGhpcy5fbmV4dFRhc2tzID0gW107XG5cdFx0dGhpcy5fdXN1cnBUYXNrID0gW107XG5cdH1cblxuXG5cdF9sb29wKCkge1xuXHRcdHRoaXMuX3Byb2Nlc3MoKTtcblx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuX2xvb3AoKSk7XG5cdH1cblxuXHRnZXQgZGVsdGFUaW1lKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWx0YVRpbWU7XG5cdH1cbn1cblxuY29uc3Qgc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcigpO1xuXG5leHBvcnQgZGVmYXVsdCBzY2hlZHVsZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY2hlZHVsaW5nL3NyYy9zY2hlZHVsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBHZW9tLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4vR2VvbWV0cnknO1xuXG5jb25zdCBHZW9tID0ge307XG5sZXQgbWVzaFRyaTtcblxuR2VvbS5wbGFuZSA9IGZ1bmN0aW9uIHBsYW5lKHdpZHRoLCBoZWlnaHQsIG51bVNlZ21lbnRzLCBheGlzID0gJ3h5JywgZHJhd1R5cGUgPSA0KSB7XG5cdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRjb25zdCBjb29yZHMgICAgPSBbXTtcblx0Y29uc3QgaW5kaWNlcyAgID0gW107XG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdO1xuXG5cdGNvbnN0IGdhcFggID0gd2lkdGggLyBudW1TZWdtZW50cztcblx0Y29uc3QgZ2FwWSAgPSBoZWlnaHQgLyBudW1TZWdtZW50cztcblx0Y29uc3QgZ2FwVVYgPSAxIC8gbnVtU2VnbWVudHM7XG5cdGNvbnN0IHN4ICAgID0gLXdpZHRoICogMC41O1xuXHRjb25zdCBzeSAgICA9IC1oZWlnaHQgKiAwLjU7XG5cdGxldCBpbmRleCA9IDA7XG5cblx0Zm9yKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG51bVNlZ21lbnRzOyBqKyspIHtcblx0XHRcdGNvbnN0IHR4ID0gZ2FwWCAqIGkgKyBzeDtcblx0XHRcdGNvbnN0IHR5ID0gZ2FwWSAqIGogKyBzeTtcblxuXHRcdFx0Y29uc3QgdSA9IGkgLyBudW1TZWdtZW50cztcblx0XHRcdGNvbnN0IHYgPSBqIC8gbnVtU2VnbWVudHM7XG5cblx0XHRcdGlmKGF4aXMgPT09ICd4eicpIHtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4LCBcdFx0MCwgXHQgdHkgKyBnYXBZXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCArIGdhcFgsIFx0MCwgXHQgdHkgKyBnYXBZXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFt0eCArIGdhcFgsIFx0MCwgXHQgdHldKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4LCBcdFx0MCwgXHQgdHldKTtcdFxuXG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1LCAxLjAgLSAodiArIGdhcFVWKV0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCAxLjAgLSAodiArIGdhcFVWKV0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCAxLjAgLSB2XSk7XG5cdFx0XHRcdGNvb3Jkcy5wdXNoKFt1LCAxLjAgLSB2XSk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdFx0XHR9IGVsc2UgaWYoYXhpcyA9PT0gJ3l6Jykge1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbMCwgdHksIHR4XSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFswLCB0eSwgdHggKyBnYXBYXSk7XG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFswLCB0eSArIGdhcFksIHR4ICsgZ2FwWF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbMCwgdHkgKyBnYXBZLCB0eF0pO1x0XG5cblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIHZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UgKyBnYXBVViwgdl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCB2ICsgZ2FwVVZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIHYgKyBnYXBVVl0pO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4LCBcdFx0dHksIFx0MF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHggKyBnYXBYLCBcdHR5LCBcdDBdKTtcblx0XHRcdFx0cG9zaXRpb25zLnB1c2goW3R4ICsgZ2FwWCwgXHR0eSArIGdhcFksIFx0MF0pO1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbdHgsIFx0XHR0eSArIGdhcFksIFx0MF0pO1x0XG5cblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIHZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UgKyBnYXBVViwgdl0pO1xuXHRcdFx0XHRjb29yZHMucHVzaChbdSArIGdhcFVWLCB2ICsgZ2FwVVZdKTtcblx0XHRcdFx0Y29vcmRzLnB1c2goW3UsIHYgKyBnYXBVVl0pO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRcdFx0XHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0XHRcdFx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRcdFx0fSBcblxuXG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMSk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMyk7XG5cblx0XHRcdGluZGV4Kys7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgbWVzaCA9IG5ldyBHZW9tZXRyeShkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLnNwaGVyZSA9IGZ1bmN0aW9uIHNwaGVyZShzaXplLCBudW1TZWdtZW50cywgaXNJbnZlcnQgPSBmYWxzZSwgZHJhd1R5cGUgPSA0KSB7XG5cdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRjb25zdCBjb29yZHMgICAgPSBbXTtcblx0Y29uc3QgaW5kaWNlcyAgID0gW107XG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdO1xuXHRjb25zdCBnYXBVViAgICAgPSAxIC8gbnVtU2VnbWVudHM7XG5cdGxldCBpbmRleCAgICAgXHQ9IDA7XG5cdFxuXG5cdGZ1bmN0aW9uIGdldFBvc2l0aW9uKGksIGosIGlzTm9ybWFsID0gZmFsc2UpIHtcdC8vXHRyeCA6IC05MCB+IDkwICwgcnkgOiAwIH4gMzYwXG5cdFx0Y29uc3QgcnggICAgICAgID0gaSAvIG51bVNlZ21lbnRzICogTWF0aC5QSSAtIE1hdGguUEkgKiAwLjU7XG5cdFx0Y29uc3QgcnkgICAgICAgID0gaiAvIG51bVNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cdFx0Y29uc3QgciAgICAgICAgID0gaXNOb3JtYWwgPyAxIDogc2l6ZTtcblx0XHRjb25zdCBwb3MgICAgICAgPSBbXTtcblx0XHRwb3NbMV0gICAgICAgIFx0PSBNYXRoLnNpbihyeCkgKiByO1xuXHRcdGNvbnN0IHQgICAgICAgICA9IE1hdGguY29zKHJ4KSAqIHI7XG5cdFx0cG9zWzBdICAgICAgICBcdD0gTWF0aC5jb3MocnkpICogdDtcblx0XHRwb3NbMl0gICAgICAgIFx0PSBNYXRoLnNpbihyeSkgKiB0O1xuXHRcdFxuXHRcdGNvbnN0IHByZWNpc2lvbiA9IDEwMDAwO1xuXHRcdHBvc1swXSAgICAgICAgPSBNYXRoLmZsb29yKHBvc1swXSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG5cdFx0cG9zWzFdICAgICAgICA9IE1hdGguZmxvb3IocG9zWzFdICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblx0XHRwb3NbMl0gICAgICAgID0gTWF0aC5mbG9vcihwb3NbMl0gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXG5cdFx0cmV0dXJuIHBvcztcblx0fTtcblxuXHRcblx0Zm9yKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRmb3IobGV0IGogPSAwOyBqIDwgbnVtU2VnbWVudHM7IGorKykge1xuXHRcdFx0cG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSwgaikpO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSArIDEsIGopKTtcblx0XHRcdHBvc2l0aW9ucy5wdXNoKGdldFBvc2l0aW9uKGkgKyAxLCBqICsgMSkpO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goZ2V0UG9zaXRpb24oaSwgaiArIDEpKTtcblxuXHRcdFx0bm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGksIGosIHRydWUpKTtcblx0XHRcdG5vcm1hbHMucHVzaChnZXRQb3NpdGlvbihpICsgMSwgaiwgdHJ1ZSkpO1xuXHRcdFx0bm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGkgKyAxLCBqICsgMSwgdHJ1ZSkpO1xuXHRcdFx0bm9ybWFscy5wdXNoKGdldFBvc2l0aW9uKGksIGogKyAxLCB0cnVlKSk7XG5cdFx0XHRcblxuXHRcdFx0Y29uc3QgdSA9IGogLyBudW1TZWdtZW50cztcblx0XHRcdGNvbnN0IHYgPSBpIC8gbnVtU2VnbWVudHM7XG5cdFx0XHRcblx0XHRcdFxuXHRcdFx0Y29vcmRzLnB1c2goWzEuMCAtIHUsIHZdKTtcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1LCB2ICsgZ2FwVVZdKTtcblx0XHRcdGNvb3Jkcy5wdXNoKFsxLjAgLSB1IC0gZ2FwVVYsIHYgKyBnYXBVVl0pO1xuXHRcdFx0Y29vcmRzLnB1c2goWzEuMCAtIHUgLSBnYXBVViwgdl0pO1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMSk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMik7XG5cdFx0XHRpbmRpY2VzLnB1c2goaW5kZXggKiA0ICsgMyk7XG5cblx0XHRcdGluZGV4Kys7XG5cdFx0fVxuXHR9XG5cblxuXHRpZihpc0ludmVydCkge1xuXHRcdGluZGljZXMucmV2ZXJzZSgpO1xuXHR9XG5cblx0Y29uc3QgbWVzaCA9IG5ldyBHZW9tZXRyeShkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLmN1YmUgPSBmdW5jdGlvbiBjdWJlKHcsIGgsIGQsIGRyYXdUeXBlID0gNCkge1xuXHRoID0gaCB8fCB3O1xuXHRkID0gZCB8fCB3O1xuXG5cdGNvbnN0IHggPSB3IC8gMjtcblx0Y29uc3QgeSA9IGggLyAyO1xuXHRjb25zdCB6ID0gZCAvIDI7XG5cblx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRjb25zdCBpbmRpY2VzICAgPSBbXTsgXG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdOyBcblx0bGV0IGNvdW50ICAgICA9IDA7XG5cblxuXHQvLyBCQUNLXG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAgeSwgLXpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsIC15LCAtel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gUklHSFRcblx0cG9zaXRpb25zLnB1c2goW3gsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgIHpdKTtcblx0cG9zaXRpb25zLnB1c2goW3gsIC15LCAtel0pO1xuXG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBGUk9OVFxuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgIHpdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblxuXHQvLyBMRUZUXG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgIHksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXG5cdGNvb3Jkcy5wdXNoKFswLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAwXSk7XG5cdGNvb3Jkcy5wdXNoKFsxLCAxXSk7XG5cdGNvb3Jkcy5wdXNoKFswLCAxXSk7XG5cblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMSk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDApO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAzKTtcblxuXHRjb3VudCArKztcblxuXHQvLyBUT1Bcblx0cG9zaXRpb25zLnB1c2goW3gsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsICB5LCAtel0pO1xuXHRwb3NpdGlvbnMucHVzaChbLXgsICB5LCAgel0pO1xuXHRwb3NpdGlvbnMucHVzaChbeCwgIHksICB6XSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIEJPVFRPTVxuXHRwb3NpdGlvbnMucHVzaChbeCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksICB6XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFsteCwgLXksIC16XSk7XG5cdHBvc2l0aW9ucy5wdXNoKFt4LCAteSwgLXpdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cblx0Y29uc3QgbWVzaCA9IG5ldyBHZW9tZXRyeShkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLnNreWJveCA9IGZ1bmN0aW9uIHNreWJveChzaXplLCBkcmF3VHlwZSA9IDQpIHtcblx0Y29uc3QgcG9zaXRpb25zID0gW107XG5cdGNvbnN0IGNvb3JkcyAgICA9IFtdO1xuXHRjb25zdCBpbmRpY2VzICAgPSBbXTsgXG5cdGNvbnN0IG5vcm1hbHMgICA9IFtdOyBcblx0bGV0IGNvdW50ICAgICA9IDA7XG5cblx0Ly8gQkFDS1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgIHNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgLXNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgLXNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgLTFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAtMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIC0xXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIFJJR0hUXG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgLXNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFsxLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzEsIDAsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gRlJPTlRcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsICBzaXplLCAgc2l6ZV0pO1xuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgLXNpemUsICBzaXplXSk7XG5cblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMCwgMV0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDAsIDFdKTtcblx0bm9ybWFscy5wdXNoKFswLCAwLCAxXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIExFRlRcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAgc2l6ZSwgIHNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbLTEsIDAsIDBdKTtcblx0bm9ybWFscy5wdXNoKFstMSwgMCwgMF0pO1xuXHRub3JtYWxzLnB1c2goWy0xLCAwLCAwXSk7XG5cblx0Y29vcmRzLnB1c2goWzAsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDBdKTtcblx0Y29vcmRzLnB1c2goWzEsIDFdKTtcblx0Y29vcmRzLnB1c2goWzAsIDFdKTtcblxuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAxKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMCk7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAyKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDMpO1xuXG5cdGNvdW50ICsrO1xuXG5cdC8vIFRPUFxuXHRwb3NpdGlvbnMucHVzaChbc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgIHNpemUsICBzaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFstc2l6ZSwgIHNpemUsIC1zaXplXSk7XG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAgc2l6ZSwgLXNpemVdKTtcblxuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAxLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIDEsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y291bnQgKys7XG5cblx0Ly8gQk9UVE9NXG5cdHBvc2l0aW9ucy5wdXNoKFtzaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgLXNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goWy1zaXplLCAtc2l6ZSwgIHNpemVdKTtcblx0cG9zaXRpb25zLnB1c2goW3NpemUsIC1zaXplLCAgc2l6ZV0pO1xuXG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblx0bm9ybWFscy5wdXNoKFswLCAtMSwgMF0pO1xuXHRub3JtYWxzLnB1c2goWzAsIC0xLCAwXSk7XG5cdG5vcm1hbHMucHVzaChbMCwgLTEsIDBdKTtcblxuXHRjb29yZHMucHVzaChbMCwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMF0pO1xuXHRjb29yZHMucHVzaChbMSwgMV0pO1xuXHRjb29yZHMucHVzaChbMCwgMV0pO1xuXG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDEpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMik7XG5cdGluZGljZXMucHVzaChjb3VudCAqIDQgKyAwKTtcblx0aW5kaWNlcy5wdXNoKGNvdW50ICogNCArIDIpO1xuXHRpbmRpY2VzLnB1c2goY291bnQgKiA0ICsgMyk7XG5cblx0Y29uc3QgbWVzaCA9IG5ldyBHZW9tZXRyeShkcmF3VHlwZSk7XG5cdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdG1lc2guYnVmZmVyVGV4Q29vcmQoY29vcmRzKTtcblx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0bWVzaC5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cblx0cmV0dXJuIG1lc2g7XG59O1xuXG5HZW9tLmJpZ1RyaWFuZ2xlID0gZnVuY3Rpb24gYmlnVHJpYW5nbGUoKSB7XG5cblx0aWYoIW1lc2hUcmkpIHtcblx0XHRjb25zdCBpbmRpY2VzID0gWzIsIDEsIDBdO1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtcblx0XHRcdFstMSwgLTFdLCBcblx0XHRcdFstMSwgNF0sIFxuXHRcdFx0WzQsIC0xXVxuXHRcdF07XG5cdFx0XG5cdFx0bWVzaFRyaSA9IG5ldyBHZW9tZXRyeSgpO1xuXHRcdG1lc2hUcmkuYnVmZmVyRGF0YShwb3NpdGlvbnMsICdhUG9zaXRpb24nLCAyKTtcblx0XHRtZXNoVHJpLmJ1ZmZlckluZGV4KGluZGljZXMpO1x0XG5cdH1cblx0XG5cblx0cmV0dXJuIG1lc2hUcmk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHZW9tO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL0dlb20uanMiLCIvLyBPYmplY3QzRC5qc1xuXG5pbXBvcnQgeyB2ZWMzLCBtYXQ0LCBxdWF0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY2xhc3MgT2JqZWN0M0Qge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5feCA9IDA7XG5cdFx0dGhpcy5feSA9IDA7XG5cdFx0dGhpcy5feiA9IDA7XG5cblx0XHR0aGlzLl9zeCA9IDE7XG5cdFx0dGhpcy5fc3kgPSAxO1xuXHRcdHRoaXMuX3N6ID0gMTtcblxuXHRcdHRoaXMuX3J4ID0gMDtcblx0XHR0aGlzLl9yeSA9IDA7XG5cdFx0dGhpcy5fcnogPSAwO1xuXG5cdFx0dGhpcy5fcG9zaXRpb24gPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3NjYWxlID0gdmVjMy5mcm9tVmFsdWVzKDEsIDEsIDEpO1xuXHRcdHRoaXMuX3JvdGF0aW9uID0gdmVjMy5jcmVhdGUoKTtcblxuXHRcdHRoaXMuX21hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fbWF0cml4UGFyZW50ID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhSb3RhdGlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fbWF0cml4U2NhbGUgPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9tYXRyaXhRdWF0ZXJuaW9uID0gbWF0NC5jcmVhdGUoKTtcblx0XHR0aGlzLl9xdWF0ID0gcXVhdC5jcmVhdGUoKTtcblxuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdH1cblxuXHR1cGRhdGVNYXRyaXgoKSB7XG5cdFx0aWYoIXRoaXMuX25lZWRVcGRhdGUpIHtcdHJldHVybjsgfVxuXG5cdFx0dmVjMy5zZXQodGhpcy5fc2NhbGUsIHRoaXMuX3N4LCB0aGlzLl9zeSwgdGhpcy5fc3opO1xuXHRcdHZlYzMuc2V0KHRoaXMuX3JvdGF0aW9uLCB0aGlzLl9yeCwgdGhpcy5fcnksIHRoaXMuX3J6KTtcblx0XHR2ZWMzLnNldCh0aGlzLl9wb3NpdGlvbiwgdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feik7XG5cblx0XHRtYXQ0LmlkZW50aXR5KHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uLCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbik7XG5cdFx0bWF0NC5pZGVudGl0eSh0aGlzLl9tYXRyaXhTY2FsZSwgdGhpcy5fbWF0cml4U2NhbGUpO1xuXHRcdG1hdDQuaWRlbnRpdHkodGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uKTtcblxuXHRcdG1hdDQucm90YXRlWCh0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX3J4KTtcblx0XHRtYXQ0LnJvdGF0ZVkodGhpcy5fbWF0cml4Um90YXRpb24sIHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9yeSk7XG5cdFx0bWF0NC5yb3RhdGVaKHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbiwgdGhpcy5fcnopO1xuXG5cblx0XHRtYXQ0LmZyb21RdWF0KHRoaXMuX21hdHJpeFF1YXRlcm5pb24sIHRoaXMuX3F1YXQpO1xuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeFJvdGF0aW9uLCB0aGlzLl9tYXRyaXhRdWF0ZXJuaW9uLCB0aGlzLl9tYXRyaXhSb3RhdGlvbik7XG5cblx0XHRtYXQ0LnNjYWxlKHRoaXMuX21hdHJpeFNjYWxlLCB0aGlzLl9tYXRyaXhTY2FsZSwgdGhpcy5fc2NhbGUpO1xuXHRcdG1hdDQudHJhbnNsYXRlKHRoaXMuX21hdHJpeFRyYW5zbGF0aW9uLCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fcG9zaXRpb24pO1xuXG5cdFx0bWF0NC5tdWwodGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhUcmFuc2xhdGlvbiwgdGhpcy5fbWF0cml4Um90YXRpb24pO1xuXHRcdG1hdDQubXVsKHRoaXMuX21hdHJpeCwgdGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhTY2FsZSk7XG5cdFx0bWF0NC5tdWwodGhpcy5fbWF0cml4LCB0aGlzLl9tYXRyaXhQYXJlbnQsIHRoaXMuX21hdHJpeCk7XG5cblx0XHR0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdGNoaWxkLnVwZGF0ZVBhcmVudE1hdHJpeCh0aGlzLl9tYXRyaXgpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR9XG5cblx0dXBkYXRlUGFyZW50TWF0cml4KG1QYXJlbnRNYXRyaXgpIHtcblx0XHRtUGFyZW50TWF0cml4ID0gbVBhcmVudE1hdHJpeCB8fCBtYXQ0LmNyZWF0ZSgpO1xuXHRcdG1hdDQuY29weSh0aGlzLl9tYXRyaXhQYXJlbnQsIG1QYXJlbnRNYXRyaXgpO1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHR9XG5cblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbihtUXVhdCkge1xuXHRcdHF1YXQuY29weSh0aGlzLl9xdWF0LCBtUXVhdCk7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdH1cblxuXG5cdGFkZENoaWxkKG1DaGlsZCkge1xuXHRcdHRoaXMuX2NoaWxkcmVuLnB1c2gobUNoaWxkKTtcblx0fVxuXG5cdHJlbW92ZUNoaWxkKG1DaGlsZCkge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihtQ2hpbGQpO1xuXHRcdGlmKGluZGV4ID09IC0xKSB7XHRjb25zb2xlLndhcm4oJ0NoaWxkIG5vIGV4aXN0Jyk7IHJldHVybjtcdH1cblxuXHRcdHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXG5cdGdldCBtYXRyaXgoKSB7XG5cdFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9XG5cblx0Z2V0IHgoKSB7XHRyZXR1cm4gdGhpcy5feDtcdH1cblx0c2V0IHgobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5feCA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCB5KCkge1x0cmV0dXJuIHRoaXMuX3k7XHR9XG5cdHNldCB5KG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3kgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgeigpIHtcdHJldHVybiB0aGlzLl96O1x0fVxuXHRzZXQgeihtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl96ID0gbVZhbHVlO1xuXHR9XG5cblx0XG5cdGdldCBzY2FsZVgoKSB7XHRyZXR1cm4gdGhpcy5fc3g7XHR9XG5cdHNldCBzY2FsZVgobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fc3ggPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgc2NhbGVZKCkge1x0cmV0dXJuIHRoaXMuX3N5O1x0fVxuXHRzZXQgc2NhbGVZKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3N5ID0gbVZhbHVlO1xuXHR9XG5cblx0Z2V0IHNjYWxlWigpIHtcdHJldHVybiB0aGlzLl9zejtcdH1cblx0c2V0IHNjYWxlWihtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9zeiA9IG1WYWx1ZTtcblx0fVxuXG5cblx0Z2V0IHJvdGF0aW9uWCgpIHtcdHJldHVybiB0aGlzLl9yeDtcdH1cblx0c2V0IHJvdGF0aW9uWChtVmFsdWUpIHtcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9yeCA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCByb3RhdGlvblkoKSB7XHRyZXR1cm4gdGhpcy5fcnk7XHR9XG5cdHNldCByb3RhdGlvblkobVZhbHVlKSB7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5fcnkgPSBtVmFsdWU7XG5cdH1cblxuXHRnZXQgcm90YXRpb25aKCkge1x0cmV0dXJuIHRoaXMuX3J6O1x0fVxuXHRzZXQgcm90YXRpb25aKG1WYWx1ZSkge1xuXHRcdHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuX3J6ID0gbVZhbHVlO1xuXHR9XG5cblxuXHRnZXQgY2hpbGRyZW4oKSB7XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QzRDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9vYmplY3RzL09iamVjdDNELmpzIiwiLy8gR0xUZXh0dXJlLmpzXG5cbmltcG9ydCBnZXRUZXh0dXJlUGFyYW1ldGVycyBmcm9tICcuL3V0aWxzL2dldFRleHR1cmVQYXJhbWV0ZXJzJztcbmltcG9ydCBXZWJnbE51bWJlciBmcm9tICcuL3V0aWxzL1dlYmdsTnVtYmVyJztcbmltcG9ydCBHTCBmcm9tICcuL0dMVG9vbCc7XG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJ3NjaGVkdWxpbmcnO1xuXG5sZXQgZ2w7XG5cbmNsYXNzIEdMVGV4dHVyZSB7XG5cblx0Y29uc3RydWN0b3IobVNvdXJjZSwgbVBhcmFtID0ge30sIG1XaWR0aCA9IDAsIG1IZWlnaHQgPSAwKSB7XG5cdFx0Z2wgPSBHTC5nbDtcblxuXHRcdHRoaXMuX3NvdXJjZSA9IG1Tb3VyY2U7XG5cdFx0dGhpcy5fZ2V0RGltZW5zaW9uKG1Tb3VyY2UsIG1XaWR0aCwgbUhlaWdodCk7XG5cdFx0dGhpcy5fc291cmNlVHlwZSA9IG1QYXJhbS50eXBlIHx8IGdldFNvdXJjZVR5cGUobVNvdXJjZSk7XG5cdFx0dGhpcy5fY2hlY2tTb3VyY2UoKTtcblx0XHR0aGlzLl90ZXhlbFR5cGUgPSB0aGlzLl9nZXRUZXhlbFR5cGUoKTtcblx0XHR0aGlzLl9pc1RleHR1cmVSZWFkeSA9IHRydWU7XG5cblx0XHR0aGlzLl9wYXJhbXMgPSBnZXRUZXh0dXJlUGFyYW1ldGVycyhtUGFyYW0sIG1Tb3VyY2UsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuXHRcdHRoaXMuX2NoZWNrTWlwbWFwKCk7XG5cdFx0dGhpcy5fY2hlY2tXcmFwcGluZygpO1xuXG5cdFx0Ly9cdHNldHVwIHRleHR1cmVcblx0XHR0aGlzLl90ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0aWYodGhpcy5fc291cmNlVHlwZSA9PT0gJ3ZpZGVvJykge1xuXHRcdFx0dGhpcy5faXNUZXh0dXJlUmVhZHkgPSBmYWxzZTtcblx0XHRcdFNjaGVkdWxlci5hZGRFRigoKT0+dGhpcy5fbG9vcCgpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fdXBsb2FkVGV4dHVyZSgpO1x0XG5cdFx0fVxuXHRcdFxuXHR9XG5cblx0X2xvb3AoKSB7XG5cdFx0aWYodGhpcy5fc291cmNlLnJlYWR5U3RhdGUgPT0gNCkge1xuXHRcdFx0dGhpcy5faXNUZXh0dXJlUmVhZHkgPSB0cnVlO1xuXHRcdFx0dGhpcy5fdXBsb2FkVGV4dHVyZSgpO1xuXHRcdH1cblx0fVxuXG5cblx0X3VwbG9hZFRleHR1cmUoKSB7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG5cblx0XHRpZih0aGlzLl9pc1NvdXJjZUh0bWxFbGVtZW50KCkpIHtcblx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5fcGFyYW1zLmludGVybmFsRm9ybWF0LCB0aGlzLl9wYXJhbXMuZm9ybWF0LCB0aGlzLl90ZXhlbFR5cGUsIHRoaXMuX3NvdXJjZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5fcGFyYW1zLmludGVybmFsRm9ybWF0LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCAwLCB0aGlzLl9wYXJhbXMuZm9ybWF0LCB0aGlzLl90ZXhlbFR5cGUsIHRoaXMuX3NvdXJjZSk7XHRcblx0XHR9XG5cdFx0XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuX3BhcmFtcy5tYWdGaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9wYXJhbXMubWluRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9wYXJhbXMud3JhcFMpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX3BhcmFtcy53cmFwVCk7XG5cdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0aGlzLl9wYXJhbXMucHJlbXVsdGlwbHlBbHBoYSk7XG5cblx0XHRpZih0aGlzLl9wYXJhbXMuYW5pc290cm9weSA+IDApIHtcblx0XHRcdGNvbnN0IGV4dCA9IEdMLmdldEV4dGVuc2lvbignRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyk7XG5cdFx0XHRpZihleHQpIHtcblx0XHRcdFx0Y29uc3QgbWF4ID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpO1xuXHRcdFx0XHRjb25zdCBsZXZlbCA9IE1hdGgubWluKG1heCwgdGhpcy5fcGFyYW1zLmFuaXNvdHJvcHkpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJmKGdsLlRFWFRVUkVfMkQsIGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgbGV2ZWwpO1xuXHRcdFx0fVx0XG5cdFx0fVxuXHRcdFxuXG5cdFx0aWYodGhpcy5fZ2VuZXJhdGVNaXBtYXApIHtcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1x0fVxuXG5cdFx0Ly9cdHVuYmluZCB0ZXh0dXJlXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXG5cdGJpbmQoaW5kZXgpIHtcblx0XHRpZihpbmRleCA9PT0gdW5kZWZpbmVkKSB7IGluZGV4ID0gMDsgfVxuXHRcdGlmKCFHTC5zaGFkZXIpIHsgcmV0dXJuOyB9XG5cblx0XHRnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaW5kZXgpO1xuXHRcdGlmKHRoaXMuX2lzVGV4dHVyZVJlYWR5KSB7XG5cdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBHTFRleHR1cmUuYmxhY2tUZXh0dXJlKCkudGV4dHVyZSk7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuX2JpbmRJbmRleCA9IGluZGV4O1xuXHR9XG5cblxuXHR1cGRhdGVUZXh0dXJlKG1Tb3VyY2UpIHtcblx0XHR0aGlzLl9zb3VyY2UgPSBtU291cmNlO1xuXHRcdHRoaXMuX2NoZWNrU291cmNlKCk7XG5cdFx0dGhpcy5fdXBsb2FkVGV4dHVyZSgpO1xuXHR9XG5cblxuXHRnZW5lcmF0ZU1pcG1hcCgpIHtcblx0XHRpZiAoIXRoaXMuX2dlbmVyYXRlTWlwbWFwKSB7IHJldHVybjsgfVxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblx0c2hvd1BhcmFtZXRlcnMoKSB7XG5cdFx0Y29uc29sZS5sb2coJ1NvdXJjZSB0eXBlIDogJywgV2ViZ2xOdW1iZXJbdGhpcy5fc291cmNlVHlwZV0gfHwgdGhpcy5fc291cmNlVHlwZSk7XG5cdFx0Y29uc29sZS5sb2coJ1RleGVsIHR5cGU6JywgV2ViZ2xOdW1iZXJbdGhpcy50ZXhlbFR5cGVdKTtcblx0XHRjb25zb2xlLmxvZygnRGltZW5zaW9uIDonLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcblx0XHRmb3IoY29uc3QgcyBpbiB0aGlzLl9wYXJhbXMpIHtcblx0XHRcdGNvbnNvbGUubG9nKHMsIFdlYmdsTnVtYmVyW3RoaXMuX3BhcmFtc1tzXV0gfHwgdGhpcy5fcGFyYW1zW3NdKTtcblx0XHR9XG5cblx0XHRjb25zb2xlLmxvZygnTWlwbWFwcGluZyA6JywgdGhpcy5fZ2VuZXJhdGVNaXBtYXApO1xuXHR9XG5cblx0X2dldERpbWVuc2lvbihtU291cmNlLCBtV2lkdGgsIG1IZWlnaHQpIHtcblx0XHRpZihtU291cmNlKSB7XG5cdFx0XHQvL1x0Zm9yIGh0bWwgaW1hZ2UgLyB2aWRlbyBlbGVtZW50XG5cdFx0XHR0aGlzLl93aWR0aCA9IG1Tb3VyY2Uud2lkdGggfHwgbVNvdXJjZS52aWRlb1dpZHRoO1xuXHRcdFx0dGhpcy5faGVpZ2h0ID0gbVNvdXJjZS5oZWlnaHQgfHwgbVNvdXJjZS52aWRlb1dpZHRoO1xuXG5cdFx0XHQvL1x0Zm9yIG1hbnVhbCB3aWR0aCAvIGhlaWdodCBzZXR0aW5nc1xuXHRcdFx0dGhpcy5fd2lkdGggPSB0aGlzLl93aWR0aCB8fCBtV2lkdGg7XG5cdFx0XHR0aGlzLl9oZWlnaHQgPSB0aGlzLl9oZWlnaHQgfHwgbUhlaWdodDtcblxuXHRcdFx0Ly9cdGF1dG8gZGV0ZWN0ICggZGF0YSBhcnJheSkgPyBub3Qgc3VyZSBpcyBnb29kIGlkZWEgPyBcblx0XHRcdC8vXHR0b2RvIDogY2hlY2sgSERSIFxuXHRcdFx0aWYoIXRoaXMuX3dpZHRoIHx8ICF0aGlzLl9oZWlnaHQpIHtcblx0XHRcdFx0dGhpcy5fd2lkdGggPSB0aGlzLl9oZWlnaHQgPSBNYXRoLnNxcnQobVNvdXJjZS5sZW5ndGggLyA0KTtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ0F1dG8gZGV0ZWN0LCBkYXRhIGRpbWVuc2lvbiA6ICcsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1x0XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fd2lkdGggPSBtV2lkdGg7XG5cdFx0XHR0aGlzLl9oZWlnaHQgPSBtSGVpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdF9jaGVja1NvdXJjZSgpIHtcblx0XHRpZighdGhpcy5fc291cmNlKSB7XHRyZXR1cm47IH1cblxuXHRcdGlmKHRoaXMuX3NvdXJjZVR5cGUgPT09IEdMLlVOU0lHTkVEX0JZVEUpIHtcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdDb252ZXJ0aW5nIHRvIFVpbnQ4QXJyYXknKTtcblx0XHRcdFx0dGhpcy5fc291cmNlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fc291cmNlKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYodGhpcy5fc291cmNlVHlwZSA9PT0gR0wuRkxPQVQpIHtcblx0XHRcdGlmICghKHRoaXMuX3NvdXJjZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coJ0NvbnZlcnRpbmcgdG8gRmxvYXQzMkFycmF5Jyk7XG5cdFx0XHRcdHRoaXMuX3NvdXJjZSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdF9nZXRUZXhlbFR5cGUoKSB7XG5cdFx0aWYodGhpcy5faXNTb3VyY2VIdG1sRWxlbWVudCgpKSB7XG5cdFx0XHRyZXR1cm4gR0wuVU5TSUdORURfQllURTtcdFxuXHRcdH1cblxuXHRcdC8vXHRiYWQgY29kZSBoZXJlLCBpZiB0aGUgdHlwZSBpcyBub3Qgb24gdGhlIHdlYmdsTnVtYmVyIGxpc3QsIGl0IGRvZXNuJ3Qgd29ya1xuXHRcdHJldHVybiBHTFtXZWJnbE51bWJlclt0aGlzLl9zb3VyY2VUeXBlXV0gfHwgdGhpcy5fc291cmNlVHlwZTtcblx0fVxuXG5cdF9jaGVja01pcG1hcCgpIHtcblx0XHR0aGlzLl9nZW5lcmF0ZU1pcG1hcCA9IHRoaXMuX3BhcmFtcy5taXBtYXA7XG5cblx0XHRpZighKGlzUG93ZXJPZlR3byh0aGlzLl93aWR0aCkgJiYgaXNQb3dlck9mVHdvKHRoaXMuX2hlaWdodCkpKSB7XG5cdFx0XHR0aGlzLl9nZW5lcmF0ZU1pcG1hcCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1pbkZpbHRlciA9IFdlYmdsTnVtYmVyW3RoaXMuX3BhcmFtcy5taW5GaWx0ZXJdO1xuXHRcdGlmKG1pbkZpbHRlci5pbmRleE9mKCdNSVBNQVAnKSA9PSAtMSkge1xuXHRcdFx0dGhpcy5fZ2VuZXJhdGVNaXBtYXAgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRfY2hlY2tXcmFwcGluZygpIHtcblx0XHRpZighdGhpcy5fZ2VuZXJhdGVNaXBtYXApIHtcblx0XHRcdHRoaXMuX3BhcmFtcy53cmFwUyA9IEdMLkNMQU1QX1RPX0VER0U7XG5cdFx0XHR0aGlzLl9wYXJhbXMud3JhcFQgPSBHTC5DTEFNUF9UT19FREdFO1xuXHRcdH1cblx0fVxuXG5cdF9pc1NvdXJjZUh0bWxFbGVtZW50KCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3VyY2VUeXBlID09PSAnaW1hZ2UnIHx8IHRoaXMuX3NvdXJjZVR5cGUgPT09ICd2aWRlbycgfHwgdGhpcy5fc291cmNlVHlwZSA9PT0gJ2NhbnZhcyc7XG5cdH1cblxuXG5cdGdldCBtaW5GaWx0ZXIoKSB7XHRyZXR1cm4gdGhpcy5fcGFyYW1zLm1pbkZpbHRlcjtcdH1cblxuXHRzZXQgbWluRmlsdGVyKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3BhcmFtcy5taW5GaWx0ZXIgPSBtVmFsdWU7XG5cdFx0dGhpcy5fY2hlY2tNaXBtYXAoKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9wYXJhbXMubWluRmlsdGVyKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuXHRcdHRoaXMuZ2VuZXJhdGVNaXBtYXAoKTtcblx0fVxuXG5cdGdldCBtYWdGaWx0ZXIoKSB7XHRyZXR1cm4gdGhpcy5fcGFyYW1zLm1pbkZpbHRlcjtcdH1cblxuXHRzZXQgbWFnRmlsdGVyKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3BhcmFtcy5tYWdGaWx0ZXIgPSBtVmFsdWU7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fcGFyYW1zLm1hZ0ZpbHRlcik7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cdH1cblxuXG5cdGdldCB3cmFwUygpIHtcdHJldHVybiB0aGlzLl9wYXJhbXMud3JhcFM7XHR9XG5cblx0c2V0IHdyYXBTKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3BhcmFtcy53cmFwUyA9IG1WYWx1ZTtcblx0XHR0aGlzLl9jaGVja1dyYXBwaW5nKCk7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9wYXJhbXMud3JhcFMpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuXHR9XG5cblxuXHRnZXQgd3JhcFQoKSB7XHRyZXR1cm4gdGhpcy5fcGFyYW1zLndyYXBUO1x0fVxuXG5cdHNldCB3cmFwVChtVmFsdWUpIHtcblx0XHR0aGlzLl9wYXJhbXMud3JhcFQgPSBtVmFsdWU7XG5cdFx0dGhpcy5fY2hlY2tXcmFwcGluZygpO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fcGFyYW1zLndyYXBUKTtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0fVxuXG5cdGdldCB0ZXhlbFR5cGUoKSB7XHRyZXR1cm4gdGhpcy5fdGV4ZWxUeXBlO1x0fVxuXG5cdGdldCB3aWR0aCgpIHtcdHJldHVybiB0aGlzLl93aWR0aDtcdH1cblxuXHRnZXQgaGVpZ2h0KCkge1x0cmV0dXJuIHRoaXMuX2hlaWdodDtcdH1cblxuXHRnZXQgdGV4dHVyZSgpIHtcdHJldHVybiB0aGlzLl90ZXh0dXJlO1x0fVxuXG5cdGdldCBpc1RleHR1cmVSZWFkeSgpIHtcdHJldHVybiB0aGlzLl9pc1RleHR1cmVSZWFkeTtcdH1cblxufVxuXG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byh4KSB7XHRcblx0cmV0dXJuICh4ICE9PSAwKSAmJiAoISh4ICYgKHggLSAxKSkpO1xufTtcblxuZnVuY3Rpb24gZ2V0U291cmNlVHlwZShtU291cmNlKSB7XG5cdC8vXHRwb3NzaWJsZSBzb3VyY2UgdHlwZSA6IEltYWdlIC8gVmlkZW8gLyBVbml0OEFycmF5IC8gRmxvYXQzMkFycmF5XG5cdC8vXHR0aGlzIGxpc3QgbXVzdCBiZSBmbGV4aWJsZVxuXG5cdGxldCB0eXBlID0gR0wuVU5TSUdORURfQllURTtcblxuXHRpZihtU291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHR0eXBlID0gR0wuVU5TSUdORURfQllURTtcblx0fSBlbHNlIGlmKG1Tb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdFx0dHlwZSA9IEdMLlVOU0lHTkVEX0JZVEU7XG5cdH0gZWxzZSBpZihtU291cmNlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG5cdFx0dHlwZSA9IEdMLkZMT0FUO1xuXHR9IGVsc2UgaWYobVNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHR0eXBlID0gJ2ltYWdlJztcblx0fSBlbHNlIGlmKG1Tb3VyY2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuXHRcdHR5cGUgPSAnY2FudmFzJztcblx0fSBlbHNlIGlmKG1Tb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG5cdFx0dHlwZSA9ICd2aWRlbyc7XG5cdH1cblx0cmV0dXJuIHR5cGU7XG59XG5cbmxldCBfd2hpdGVUZXh0dXJlLCBfZ3JleVRleHR1cmUsIF9ibGFja1RleHR1cmU7XG5cbkdMVGV4dHVyZS53aGl0ZVRleHR1cmUgPSBmdW5jdGlvbiB3aGl0ZVRleHR1cmUoKSB7XG5cdGlmKF93aGl0ZVRleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAyO1xuXHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSAnI2ZmZic7XG5cdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDIsIDIpO1xuXHRcdF93aGl0ZVRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGNhbnZhcyk7XG5cdH1cblx0XG5cdHJldHVybiBfd2hpdGVUZXh0dXJlO1xufTtcblxuR0xUZXh0dXJlLmdyZXlUZXh0dXJlID0gZnVuY3Rpb24gZ3JleVRleHR1cmUoKSB7XG5cdGlmKF9ncmV5VGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDI7XG5cdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0Y3R4LmZpbGxTdHlsZSA9ICdyZ2IoMTI3LCAxMjcsIDEyNyknO1xuXHRcdGN0eC5maWxsUmVjdCgwLCAwLCAyLCAyKTtcblx0XHRfZ3JleVRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKGNhbnZhcyk7XG5cdH1cblx0cmV0dXJuIF9ncmV5VGV4dHVyZTtcbn07XG5cbkdMVGV4dHVyZS5ibGFja1RleHR1cmUgPSBmdW5jdGlvbiBibGFja1RleHR1cmUoKSB7XG5cdGlmKF9ibGFja1RleHR1cmUgPT09IHVuZGVmaW5lZCkge1xuXHRcdGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAyO1xuXHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSAncmdiKDAsIDAsIDApJztcblx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMiwgMik7XG5cdFx0X2JsYWNrVGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY2FudmFzKTtcblx0fVxuXHRyZXR1cm4gX2JsYWNrVGV4dHVyZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdMVGV4dHVyZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9HTFRleHR1cmUuanMiLCIvLyBzdG9sZW4gdGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2dsLWNvbnN0YW50cyB0aGFua3MgQG1hdHRkZXNsIF5eXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0MDogJ05PTkUnLFxuXHQxOiAnT05FJyxcblx0MjogJ0xJTkVfTE9PUCcsXG5cdDM6ICdMSU5FX1NUUklQJyxcblx0NDogJ1RSSUFOR0xFUycsXG5cdDU6ICdUUklBTkdMRV9TVFJJUCcsXG5cdDY6ICdUUklBTkdMRV9GQU4nLFxuXHQyNTY6ICdERVBUSF9CVUZGRVJfQklUJyxcblx0NTEyOiAnTkVWRVInLFxuXHQ1MTM6ICdMRVNTJyxcblx0NTE0OiAnRVFVQUwnLFxuXHQ1MTU6ICdMRVFVQUwnLFxuXHQ1MTY6ICdHUkVBVEVSJyxcblx0NTE3OiAnTk9URVFVQUwnLFxuXHQ1MTg6ICdHRVFVQUwnLFxuXHQ1MTk6ICdBTFdBWVMnLFxuXHQ3Njg6ICdTUkNfQ09MT1InLFxuXHQ3Njk6ICdPTkVfTUlOVVNfU1JDX0NPTE9SJyxcblx0NzcwOiAnU1JDX0FMUEhBJyxcblx0NzcxOiAnT05FX01JTlVTX1NSQ19BTFBIQScsXG5cdDc3MjogJ0RTVF9BTFBIQScsXG5cdDc3MzogJ09ORV9NSU5VU19EU1RfQUxQSEEnLFxuXHQ3NzQ6ICdEU1RfQ09MT1InLFxuXHQ3NzU6ICdPTkVfTUlOVVNfRFNUX0NPTE9SJyxcblx0Nzc2OiAnU1JDX0FMUEhBX1NBVFVSQVRFJyxcblx0MTAyNDogJ1NURU5DSUxfQlVGRkVSX0JJVCcsXG5cdDEwMjg6ICdGUk9OVCcsXG5cdDEwMjk6ICdCQUNLJyxcblx0MTAzMjogJ0ZST05UX0FORF9CQUNLJyxcblx0MTI4MDogJ0lOVkFMSURfRU5VTScsXG5cdDEyODE6ICdJTlZBTElEX1ZBTFVFJyxcblx0MTI4MjogJ0lOVkFMSURfT1BFUkFUSU9OJyxcblx0MTI4NTogJ09VVF9PRl9NRU1PUlknLFxuXHQxMjg2OiAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nLFxuXHQyMzA0OiAnQ1cnLFxuXHQyMzA1OiAnQ0NXJyxcblx0Mjg0OTogJ0xJTkVfV0lEVEgnLFxuXHQyODg0OiAnQ1VMTF9GQUNFJyxcblx0Mjg4NTogJ0NVTExfRkFDRV9NT0RFJyxcblx0Mjg4NjogJ0ZST05UX0ZBQ0UnLFxuXHQyOTI4OiAnREVQVEhfUkFOR0UnLFxuXHQyOTI5OiAnREVQVEhfVEVTVCcsXG5cdDI5MzA6ICdERVBUSF9XUklURU1BU0snLFxuXHQyOTMxOiAnREVQVEhfQ0xFQVJfVkFMVUUnLFxuXHQyOTMyOiAnREVQVEhfRlVOQycsXG5cdDI5NjA6ICdTVEVOQ0lMX1RFU1QnLFxuXHQyOTYxOiAnU1RFTkNJTF9DTEVBUl9WQUxVRScsXG5cdDI5NjI6ICdTVEVOQ0lMX0ZVTkMnLFxuXHQyOTYzOiAnU1RFTkNJTF9WQUxVRV9NQVNLJyxcblx0Mjk2NDogJ1NURU5DSUxfRkFJTCcsXG5cdDI5NjU6ICdTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTCcsXG5cdDI5NjY6ICdTVEVOQ0lMX1BBU1NfREVQVEhfUEFTUycsXG5cdDI5Njc6ICdTVEVOQ0lMX1JFRicsXG5cdDI5Njg6ICdTVEVOQ0lMX1dSSVRFTUFTSycsXG5cdDI5Nzg6ICdWSUVXUE9SVCcsXG5cdDMwMjQ6ICdESVRIRVInLFxuXHQzMDQyOiAnQkxFTkQnLFxuXHQzMDg4OiAnU0NJU1NPUl9CT1gnLFxuXHQzMDg5OiAnU0NJU1NPUl9URVNUJyxcblx0MzEwNjogJ0NPTE9SX0NMRUFSX1ZBTFVFJyxcblx0MzEwNzogJ0NPTE9SX1dSSVRFTUFTSycsXG5cdDMzMTc6ICdVTlBBQ0tfQUxJR05NRU5UJyxcblx0MzMzMzogJ1BBQ0tfQUxJR05NRU5UJyxcblx0MzM3OTogJ01BWF9URVhUVVJFX1NJWkUnLFxuXHQzMzg2OiAnTUFYX1ZJRVdQT1JUX0RJTVMnLFxuXHQzNDA4OiAnU1VCUElYRUxfQklUUycsXG5cdDM0MTA6ICdSRURfQklUUycsXG5cdDM0MTE6ICdHUkVFTl9CSVRTJyxcblx0MzQxMjogJ0JMVUVfQklUUycsXG5cdDM0MTM6ICdBTFBIQV9CSVRTJyxcblx0MzQxNDogJ0RFUFRIX0JJVFMnLFxuXHQzNDE1OiAnU1RFTkNJTF9CSVRTJyxcblx0MzU1MzogJ1RFWFRVUkVfMkQnLFxuXHQ0MzUyOiAnRE9OVF9DQVJFJyxcblx0NDM1MzogJ0ZBU1RFU1QnLFxuXHQ0MzU0OiAnTklDRVNUJyxcblx0NTEyMDogJ0JZVEUnLFxuXHQ1MTIxOiAnVU5TSUdORURfQllURScsXG5cdDUxMjI6ICdTSE9SVCcsXG5cdDUxMjM6ICdVTlNJR05FRF9TSE9SVCcsXG5cdDUxMjQ6ICdJTlQnLFxuXHQ1MTI1OiAnVU5TSUdORURfSU5UJyxcblx0NTEyNjogJ0ZMT0FUJyxcblx0NTM4NjogJ0lOVkVSVCcsXG5cdDU4OTA6ICdURVhUVVJFJyxcblx0NjQwMTogJ1NURU5DSUxfSU5ERVgnLFxuXHQ2NDAyOiAnREVQVEhfQ09NUE9ORU5UJyxcblx0NjQwMzogJ1JFRCcsXG5cdDY0MDY6ICdBTFBIQScsXG5cdDY0MDc6ICdSR0InLFxuXHQ2NDA4OiAnUkdCQScsXG5cdDY0MDk6ICdMVU1JTkFOQ0UnLFxuXHQ2NDEwOiAnTFVNSU5BTkNFX0FMUEhBJyxcblx0NzY4MDogJ0tFRVAnLFxuXHQ3NjgxOiAnUkVQTEFDRScsXG5cdDc2ODI6ICdJTkNSJyxcblx0NzY4MzogJ0RFQ1InLFxuXHQ3OTM2OiAnVkVORE9SJyxcblx0NzkzNzogJ1JFTkRFUkVSJyxcblx0NzkzODogJ1ZFUlNJT04nLFxuXHQ5NzI4OiAnTkVBUkVTVCcsXG5cdDk3Mjk6ICdMSU5FQVInLFxuXHQ5OTg0OiAnTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCcsXG5cdDk5ODU6ICdMSU5FQVJfTUlQTUFQX05FQVJFU1QnLFxuXHQ5OTg2OiAnTkVBUkVTVF9NSVBNQVBfTElORUFSJyxcblx0OTk4NzogJ0xJTkVBUl9NSVBNQVBfTElORUFSJyxcblx0MTAyNDA6ICdURVhUVVJFX01BR19GSUxURVInLFxuXHQxMDI0MTogJ1RFWFRVUkVfTUlOX0ZJTFRFUicsXG5cdDEwMjQyOiAnVEVYVFVSRV9XUkFQX1MnLFxuXHQxMDI0MzogJ1RFWFRVUkVfV1JBUF9UJyxcblx0MTA0OTc6ICdSRVBFQVQnLFxuXHQxMDc1MjogJ1BPTFlHT05fT0ZGU0VUX1VOSVRTJyxcblx0MTYzODQ6ICdDT0xPUl9CVUZGRVJfQklUJyxcblx0MzI3Njk6ICdDT05TVEFOVF9DT0xPUicsXG5cdDMyNzcwOiAnT05FX01JTlVTX0NPTlNUQU5UX0NPTE9SJyxcblx0MzI3NzE6ICdDT05TVEFOVF9BTFBIQScsXG5cdDMyNzcyOiAnT05FX01JTlVTX0NPTlNUQU5UX0FMUEhBJyxcblx0MzI3NzM6ICdCTEVORF9DT0xPUicsXG5cdDMyNzc0OiAnRlVOQ19BREQnLFxuXHQzMjc3NzogJ0JMRU5EX0VRVUFUSU9OX1JHQicsXG5cdDMyNzc4OiAnRlVOQ19TVUJUUkFDVCcsXG5cdDMyNzc5OiAnRlVOQ19SRVZFUlNFX1NVQlRSQUNUJyxcblx0MzI4MTk6ICdVTlNJR05FRF9TSE9SVF80XzRfNF80Jyxcblx0MzI4MjA6ICdVTlNJR05FRF9TSE9SVF81XzVfNV8xJyxcblx0MzI4MjM6ICdQT0xZR09OX09GRlNFVF9GSUxMJyxcblx0MzI4MjQ6ICdQT0xZR09OX09GRlNFVF9GQUNUT1InLFxuXHQzMjg1NDogJ1JHQkE0Jyxcblx0MzI4NTU6ICdSR0I1X0ExJyxcblx0MzI4NzM6ICdURVhUVVJFX0JJTkRJTkdfMkQnLFxuXHQzMjkyNjogJ1NBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRScsXG5cdDMyOTI4OiAnU0FNUExFX0NPVkVSQUdFJyxcblx0MzI5MzY6ICdTQU1QTEVfQlVGRkVSUycsXG5cdDMyOTM3OiAnU0FNUExFUycsXG5cdDMyOTM4OiAnU0FNUExFX0NPVkVSQUdFX1ZBTFVFJyxcblx0MzI5Mzk6ICdTQU1QTEVfQ09WRVJBR0VfSU5WRVJUJyxcblx0MzI5Njg6ICdCTEVORF9EU1RfUkdCJyxcblx0MzI5Njk6ICdCTEVORF9TUkNfUkdCJyxcblx0MzI5NzA6ICdCTEVORF9EU1RfQUxQSEEnLFxuXHQzMjk3MTogJ0JMRU5EX1NSQ19BTFBIQScsXG5cdDMzMDcxOiAnQ0xBTVBfVE9fRURHRScsXG5cdDMzMTcwOiAnR0VORVJBVEVfTUlQTUFQX0hJTlQnLFxuXHQzMzE4OTogJ0RFUFRIX0NPTVBPTkVOVDE2Jyxcblx0MzMzMDY6ICdERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQnLFxuXHQzMzMyMTogJ1I4Jyxcblx0MzM2MzU6ICdVTlNJR05FRF9TSE9SVF81XzZfNScsXG5cdDMzNjQ4OiAnTUlSUk9SRURfUkVQRUFUJyxcblx0MzM5MDE6ICdBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UnLFxuXHQzMzkwMjogJ0FMSUFTRURfTElORV9XSURUSF9SQU5HRScsXG5cdDMzOTg0OiAnVEVYVFVSRTAnLFxuXHQzMzk4NTogJ1RFWFRVUkUxJyxcblx0MzM5ODY6ICdURVhUVVJFMicsXG5cdDMzOTg3OiAnVEVYVFVSRTMnLFxuXHQzMzk4ODogJ1RFWFRVUkU0Jyxcblx0MzM5ODk6ICdURVhUVVJFNScsXG5cdDMzOTkwOiAnVEVYVFVSRTYnLFxuXHQzMzk5MTogJ1RFWFRVUkU3Jyxcblx0MzM5OTI6ICdURVhUVVJFOCcsXG5cdDMzOTkzOiAnVEVYVFVSRTknLFxuXHQzMzk5NDogJ1RFWFRVUkUxMCcsXG5cdDMzOTk1OiAnVEVYVFVSRTExJyxcblx0MzM5OTY6ICdURVhUVVJFMTInLFxuXHQzMzk5NzogJ1RFWFRVUkUxMycsXG5cdDMzOTk4OiAnVEVYVFVSRTE0Jyxcblx0MzM5OTk6ICdURVhUVVJFMTUnLFxuXHQzNDAwMDogJ1RFWFRVUkUxNicsXG5cdDM0MDAxOiAnVEVYVFVSRTE3Jyxcblx0MzQwMDI6ICdURVhUVVJFMTgnLFxuXHQzNDAwMzogJ1RFWFRVUkUxOScsXG5cdDM0MDA0OiAnVEVYVFVSRTIwJyxcblx0MzQwMDU6ICdURVhUVVJFMjEnLFxuXHQzNDAwNjogJ1RFWFRVUkUyMicsXG5cdDM0MDA3OiAnVEVYVFVSRTIzJyxcblx0MzQwMDg6ICdURVhUVVJFMjQnLFxuXHQzNDAwOTogJ1RFWFRVUkUyNScsXG5cdDM0MDEwOiAnVEVYVFVSRTI2Jyxcblx0MzQwMTE6ICdURVhUVVJFMjcnLFxuXHQzNDAxMjogJ1RFWFRVUkUyOCcsXG5cdDM0MDEzOiAnVEVYVFVSRTI5Jyxcblx0MzQwMTQ6ICdURVhUVVJFMzAnLFxuXHQzNDAxNTogJ1RFWFRVUkUzMScsXG5cdDM0MDE2OiAnQUNUSVZFX1RFWFRVUkUnLFxuXHQzNDAyNDogJ01BWF9SRU5ERVJCVUZGRVJfU0laRScsXG5cdDM0MDQxOiAnREVQVEhfU1RFTkNJTCcsXG5cdDM0MDU1OiAnSU5DUl9XUkFQJyxcblx0MzQwNTY6ICdERUNSX1dSQVAnLFxuXHQzNDA2NzogJ1RFWFRVUkVfQ1VCRV9NQVAnLFxuXHQzNDA2ODogJ1RFWFRVUkVfQklORElOR19DVUJFX01BUCcsXG5cdDM0MDY5OiAnVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJyxcblx0MzQwNzA6ICdURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gnLFxuXHQzNDA3MTogJ1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWScsXG5cdDM0MDcyOiAnVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZJyxcblx0MzQwNzM6ICdURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1onLFxuXHQzNDA3NDogJ1RFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWicsXG5cdDM0MDc2OiAnTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRScsXG5cdDM0MzM4OiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9FTkFCTEVEJyxcblx0MzQzMzk6ICdWRVJURVhfQVRUUklCX0FSUkFZX1NJWkUnLFxuXHQzNDM0MDogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfU1RSSURFJyxcblx0MzQzNDE6ICdWRVJURVhfQVRUUklCX0FSUkFZX1RZUEUnLFxuXHQzNDM0MjogJ0NVUlJFTlRfVkVSVEVYX0FUVFJJQicsXG5cdDM0MzczOiAnVkVSVEVYX0FUVFJJQl9BUlJBWV9QT0lOVEVSJyxcblx0MzQ0NjY6ICdOVU1fQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMnLFxuXHQzNDQ2NzogJ0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTJyxcblx0MzQ2NjA6ICdCVUZGRVJfU0laRScsXG5cdDM0NjYxOiAnQlVGRkVSX1VTQUdFJyxcblx0MzQ4MTY6ICdTVEVOQ0lMX0JBQ0tfRlVOQycsXG5cdDM0ODE3OiAnU1RFTkNJTF9CQUNLX0ZBSUwnLFxuXHQzNDgxODogJ1NURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUwnLFxuXHQzNDgxOTogJ1NURU5DSUxfQkFDS19QQVNTX0RFUFRIX1BBU1MnLFxuXHQzNDg3NzogJ0JMRU5EX0VRVUFUSU9OX0FMUEhBJyxcblx0MzQ5MjE6ICdNQVhfVkVSVEVYX0FUVFJJQlMnLFxuXHQzNDkyMjogJ1ZFUlRFWF9BVFRSSUJfQVJSQVlfTk9STUFMSVpFRCcsXG5cdDM0OTMwOiAnTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMnLFxuXHQzNDk2MjogJ0FSUkFZX0JVRkZFUicsXG5cdDM0OTYzOiAnRUxFTUVOVF9BUlJBWV9CVUZGRVInLFxuXHQzNDk2NDogJ0FSUkFZX0JVRkZFUl9CSU5ESU5HJyxcblx0MzQ5NjU6ICdFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HJyxcblx0MzQ5NzU6ICdWRVJURVhfQVRUUklCX0FSUkFZX0JVRkZFUl9CSU5ESU5HJyxcblx0MzUwNDA6ICdTVFJFQU1fRFJBVycsXG5cdDM1MDQ0OiAnU1RBVElDX0RSQVcnLFxuXHQzNTA0ODogJ0RZTkFNSUNfRFJBVycsXG5cdDM1NjMyOiAnRlJBR01FTlRfU0hBREVSJyxcblx0MzU2MzM6ICdWRVJURVhfU0hBREVSJyxcblx0MzU2NjA6ICdNQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMnLFxuXHQzNTY2MTogJ01BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTJyxcblx0MzU2NjM6ICdTSEFERVJfVFlQRScsXG5cdDM1NjY0OiAnRkxPQVRfVkVDMicsXG5cdDM1NjY1OiAnRkxPQVRfVkVDMycsXG5cdDM1NjY2OiAnRkxPQVRfVkVDNCcsXG5cdDM1NjY3OiAnSU5UX1ZFQzInLFxuXHQzNTY2ODogJ0lOVF9WRUMzJyxcblx0MzU2Njk6ICdJTlRfVkVDNCcsXG5cdDM1NjcwOiAnQk9PTCcsXG5cdDM1NjcxOiAnQk9PTF9WRUMyJyxcblx0MzU2NzI6ICdCT09MX1ZFQzMnLFxuXHQzNTY3MzogJ0JPT0xfVkVDNCcsXG5cdDM1Njc0OiAnRkxPQVRfTUFUMicsXG5cdDM1Njc1OiAnRkxPQVRfTUFUMycsXG5cdDM1Njc2OiAnRkxPQVRfTUFUNCcsXG5cdDM1Njc4OiAnU0FNUExFUl8yRCcsXG5cdDM1NjgwOiAnU0FNUExFUl9DVUJFJyxcblx0MzU3MTI6ICdERUxFVEVfU1RBVFVTJyxcblx0MzU3MTM6ICdDT01QSUxFX1NUQVRVUycsXG5cdDM1NzE0OiAnTElOS19TVEFUVVMnLFxuXHQzNTcxNTogJ1ZBTElEQVRFX1NUQVRVUycsXG5cdDM1NzE2OiAnSU5GT19MT0dfTEVOR1RIJyxcblx0MzU3MTc6ICdBVFRBQ0hFRF9TSEFERVJTJyxcblx0MzU3MTg6ICdBQ1RJVkVfVU5JRk9STVMnLFxuXHQzNTcxOTogJ0FDVElWRV9VTklGT1JNX01BWF9MRU5HVEgnLFxuXHQzNTcyMDogJ1NIQURFUl9TT1VSQ0VfTEVOR1RIJyxcblx0MzU3MjE6ICdBQ1RJVkVfQVRUUklCVVRFUycsXG5cdDM1NzIyOiAnQUNUSVZFX0FUVFJJQlVURV9NQVhfTEVOR1RIJyxcblx0MzU3MjQ6ICdTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04nLFxuXHQzNTcyNTogJ0NVUlJFTlRfUFJPR1JBTScsXG5cdDM2MDAzOiAnU1RFTkNJTF9CQUNLX1JFRicsXG5cdDM2MDA0OiAnU1RFTkNJTF9CQUNLX1ZBTFVFX01BU0snLFxuXHQzNjAwNTogJ1NURU5DSUxfQkFDS19XUklURU1BU0snLFxuXHQzNjAwNjogJ0ZSQU1FQlVGRkVSX0JJTkRJTkcnLFxuXHQzNjAwNzogJ1JFTkRFUkJVRkZFUl9CSU5ESU5HJyxcblx0MzYwNDg6ICdGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9UWVBFJyxcblx0MzYwNDk6ICdGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX09CSkVDVF9OQU1FJyxcblx0MzYwNTA6ICdGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfTEVWRUwnLFxuXHQzNjA1MTogJ0ZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9DVUJFX01BUF9GQUNFJyxcblx0MzYwNTM6ICdGUkFNRUJVRkZFUl9DT01QTEVURScsXG5cdDM2MDU0OiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UJyxcblx0MzYwNTU6ICdGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCcsXG5cdDM2MDU3OiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TJyxcblx0MzYwNjE6ICdGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRCcsXG5cdDM2MDY0OiAnQ09MT1JfQVRUQUNITUVOVDAnLFxuXHQzNjA5NjogJ0RFUFRIX0FUVEFDSE1FTlQnLFxuXHQzNjEyODogJ1NURU5DSUxfQVRUQUNITUVOVCcsXG5cdDM2MTYwOiAnRlJBTUVCVUZGRVInLFxuXHQzNjE2MTogJ1JFTkRFUkJVRkZFUicsXG5cdDM2MTYyOiAnUkVOREVSQlVGRkVSX1dJRFRIJyxcblx0MzYxNjM6ICdSRU5ERVJCVUZGRVJfSEVJR0hUJyxcblx0MzYxNjQ6ICdSRU5ERVJCVUZGRVJfSU5URVJOQUxfRk9STUFUJyxcblx0MzYxNjg6ICdTVEVOQ0lMX0lOREVYOCcsXG5cdDM2MTc2OiAnUkVOREVSQlVGRkVSX1JFRF9TSVpFJyxcblx0MzYxNzc6ICdSRU5ERVJCVUZGRVJfR1JFRU5fU0laRScsXG5cdDM2MTc4OiAnUkVOREVSQlVGRkVSX0JMVUVfU0laRScsXG5cdDM2MTc5OiAnUkVOREVSQlVGRkVSX0FMUEhBX1NJWkUnLFxuXHQzNjE4MDogJ1JFTkRFUkJVRkZFUl9ERVBUSF9TSVpFJyxcblx0MzYxODE6ICdSRU5ERVJCVUZGRVJfU1RFTkNJTF9TSVpFJyxcblx0MzYxOTQ6ICdSR0I1NjUnLFxuXHQzNjMzNjogJ0xPV19GTE9BVCcsXG5cdDM2MzM3OiAnTUVESVVNX0ZMT0FUJyxcblx0MzYzMzg6ICdISUdIX0ZMT0FUJyxcblx0MzYzMzk6ICdMT1dfSU5UJyxcblx0MzYzNDA6ICdNRURJVU1fSU5UJyxcblx0MzYzNDE6ICdISUdIX0lOVCcsXG5cdDM2MzQ2OiAnU0hBREVSX0NPTVBJTEVSJyxcblx0MzYzNDc6ICdNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUycsXG5cdDM2MzQ4OiAnTUFYX1ZBUllJTkdfVkVDVE9SUycsXG5cdDM2MzQ5OiAnTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUycsXG5cdDM3NDQwOiAnVU5QQUNLX0ZMSVBfWV9XRUJHTCcsXG5cdDM3NDQxOiAnVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMJyxcblx0Mzc0NDI6ICdDT05URVhUX0xPU1RfV0VCR0wnLFxuXHQzNzQ0MzogJ1VOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wnLFxuXHQzNzQ0NDogJ0JST1dTRVJfREVGQVVMVF9XRUJHTCdcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvV2ViZ2xOdW1iZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gc2ltcGxlQ29sb3IuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0lNUExFX0NPTE9SXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzMgY29sb3I7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9zaW1wbGVDb2xvci5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFBhc3MuanNcblxuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBGcmFtZUJ1ZmZlciBmcm9tICcuLi9GcmFtZUJ1ZmZlcic7XG5pbXBvcnQgU2hhZGVyTGlicyBmcm9tICcuLi9zaGFkZXJzL1NoYWRlckxpYnMnO1xuXG5jbGFzcyBQYXNzIHtcblx0Y29uc3RydWN0b3IobVNvdXJjZSwgbVdpZHRoID0gMCwgbUhlaWdodCA9IDAsIG1QYXJhbXMgPSB7fSkge1xuXHRcdHRoaXMuc2hhZGVyID0gbmV3IEdMU2hhZGVyKFNoYWRlckxpYnMuYmlnVHJpYW5nbGVWZXJ0LCBtU291cmNlKTtcblxuXHRcdHRoaXMuX3dpZHRoID0gbVdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IG1IZWlnaHQ7XG5cdFx0dGhpcy5fdW5pZm9ybXMgPSB7fTtcblx0XHR0aGlzLl9oYXNPd25GYm8gPSB0aGlzLl93aWR0aCA+IDAgJiYgdGhpcy5fd2lkdGggPiAwO1xuXHRcdHRoaXMuX3VuaWZvcm1zID0ge307XG5cblx0XHRpZiAodGhpcy5faGFzT3duRmJvKSB7XG5cdFx0XHR0aGlzLl9mYm8gPSBuZXcgRnJhbWVCdWZmZXIodGhpcy5fd2lkdGgsIHRoaXMuaGVpZ2h0LCBtUGFybWFzKTtcblx0XHR9XG5cdH1cblxuXG5cdHVuaWZvcm0obU5hbWUsIG1WYWx1ZSkge1xuXHRcdHRoaXMuX3VuaWZvcm1zW21OYW1lXSA9IG1WYWx1ZTtcblx0fVxuXG5cblx0cmVuZGVyKHRleHR1cmUpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgndGV4dHVyZScsICd1bmlmb3JtMWknLCAwKTtcblx0XHR0ZXh0dXJlLmJpbmQoMCk7XG5cblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKHRoaXMuX3VuaWZvcm1zKTtcblx0fVxuXG5cdGdldCB3aWR0aCgpIHtcdHJldHVybiB0aGlzLl93aWR0aDtcdH1cblx0Z2V0IGhlaWdodCgpIHtcdHJldHVybiB0aGlzLl9oZWlnaHQ7XHR9XG5cdGdldCBmYm8oKSB7XHRyZXR1cm4gdGhpcy5fZmJvO1x0fVxuXHRnZXQgaGFzRmJvKCkge1x0cmV0dXJuIHRoaXMuX2hhc093bkZibzsgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzcy5qcyIsIlxuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4vb2JqZWN0cy9PYmplY3QzRCc7XG5cbmNsYXNzIE1lc2ggZXh0ZW5kcyBPYmplY3QzRCB7XG5cblx0Y29uc3RydWN0b3IoZ2VvbWV0cnksIG1hdGVyaWFsKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cdH1cblxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1lc2g7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvTWVzaC5qcyIsIi8vIEdMQ3ViZVRleHR1cmUuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IHBhcnNlIGZyb20gJ3BhcnNlLWRkcyc7XG5sZXQgZ2w7XG5jb25zdCBERFNEX01JUE1BUENPVU5UID0gMHgyMDAwMDtcbmNvbnN0IE9GRl9NSVBNQVBDT1VOVCA9IDc7XG5jb25zdCBoZWFkZXJMZW5ndGhJbnQgPSAzMTtcblxuY2xhc3MgR0xDdWJlVGV4dHVyZSB7XG5cdGNvbnN0cnVjdG9yKG1Tb3VyY2UsIG1QYXJhbWV0ZXJzID0ge30sIGlzQ3ViZVRleHR1cmUgPSBmYWxzZSkge1xuXHRcdGdsID0gR0wuZ2w7XG5cblx0XHRpZihpc0N1YmVUZXh0dXJlKSB7XG5cdFx0XHR0aGlzLnRleHR1cmUgPSBtU291cmNlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxldCBoYXNNaXBtYXBzID0gbVNvdXJjZS5sZW5ndGggPiA2O1xuXHRcdGlmKG1Tb3VyY2VbMF0ubWlwbWFwQ291bnQpIHtcblx0XHRcdGhhc01pcG1hcHMgPSBtU291cmNlWzBdLm1pcG1hcENvdW50ID4gMTtcblx0XHR9XG5cblx0XHR0aGlzLnRleHR1cmUgICA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHR0aGlzLm1hZ0ZpbHRlciA9IG1QYXJhbWV0ZXJzLm1hZ0ZpbHRlciB8fCBnbC5MSU5FQVI7XG5cdFx0dGhpcy5taW5GaWx0ZXIgPSBtUGFyYW1ldGVycy5taW5GaWx0ZXIgfHwgZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cdFx0dGhpcy53cmFwUyAgICAgPSBtUGFyYW1ldGVycy53cmFwUyB8fCBnbC5DTEFNUF9UT19FREdFO1xuXHRcdHRoaXMud3JhcFQgICAgID0gbVBhcmFtZXRlcnMud3JhcFQgfHwgZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdGlmKCFoYXNNaXBtYXBzICYmIHRoaXMubWluRmlsdGVyID09IGdsLkxJTkVBUl9NSVBNQVBfTElORUFSKSB7XG5cdFx0XHR0aGlzLm1pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHR9XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0aGlzLnRleHR1cmUpO1xuXHRcdGNvbnN0IHRhcmdldHMgPSBbXG5cdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCwgXG5cdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ksIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWSwgXG5cdFx0XHRnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWiBcblx0XHRdO1xuXG5cdFx0XG5cdFx0bGV0IG51bUxldmVscyA9IDE7XG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRudW1MZXZlbHMgPSBtU291cmNlLmxlbmd0aCAvIDY7XG5cdFx0dGhpcy5udW1MZXZlbHMgPSBudW1MZXZlbHM7XG5cblx0XHRpZiAoaGFzTWlwbWFwcykge1xuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCA2OyBqKyspIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBudW1MZXZlbHM7IGkrKykge1xuXHRcdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcblx0XHRcdFx0XG5cdFx0XHRcdFx0aW5kZXggPSBqICogbnVtTGV2ZWxzICsgaTtcblx0XHRcdFx0XHRpZihtU291cmNlW2luZGV4XS5zaGFwZSkge1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2pdLCBpLCBnbC5SR0JBLCBtU291cmNlW2luZGV4XS5zaGFwZVswXSwgbVNvdXJjZVtpbmRleF0uc2hhcGVbMV0sIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBtU291cmNlW2luZGV4XS5kYXRhKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2pdLCBpLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBtU291cmNlW2luZGV4XSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy53cmFwUyk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy53cmFwVCk7XG5cdFx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5taW5GaWx0ZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IDY7IGorKykge1xuXHRcdFx0XHRpbmRleCA9IGogKiBudW1MZXZlbHM7XG5cdFx0XHRcdGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcblx0XHRcdFx0aWYobVNvdXJjZVtpbmRleF0uc2hhcGUpIHtcblx0XHRcdFx0XHRnbC50ZXhJbWFnZTJEKHRhcmdldHNbal0sIDAsIGdsLlJHQkEsIG1Tb3VyY2VbaW5kZXhdLnNoYXBlWzBdLCBtU291cmNlW2luZGV4XS5zaGFwZVsxXSwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG1Tb3VyY2VbaW5kZXhdLmRhdGEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGdsLnRleEltYWdlMkQodGFyZ2V0c1tqXSwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbVNvdXJjZVtpbmRleF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuXHRcdFx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRcdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMubWluRmlsdGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Z2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV9DVUJFX01BUCk7XG5cdFx0fVxuXG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCk7XG5cdH1cblxuXHRcblxuXHQvL1x0UFVCTElDIE1FVEhPRFxuXG5cdGJpbmQoaW5kZXggPSAwKSB7XG5cdFx0aWYoIUdMLnNoYWRlcikgeyByZXR1cm47IH1cblxuXHRcdGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpbmRleCk7XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy50ZXh0dXJlKTtcblx0XHQvLyBnbC51bmlmb3JtMWkoR0wuc2hhZGVyLnVuaWZvcm1UZXh0dXJlc1tpbmRleF0sIGluZGV4KTtcblx0XHR0aGlzLl9iaW5kSW5kZXggPSBpbmRleDtcblx0fVxuXG5cdHVuYmluZCgpIHtcblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsKTtcdFxuXHR9XG59XG5cblxuR0xDdWJlVGV4dHVyZS5wYXJzZUREUyA9IGZ1bmN0aW9uIHBhcnNlRERTKG1BcnJheUJ1ZmZlcikge1xuXG5cdGZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuXHRcdGlmIChtaW4gPiBtYXgpIHtcblx0XHRcdHJldHVybiBjbGFtcCh2YWx1ZSwgbWF4LCBtaW4pO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSA8IG1pbikgcmV0dXJuIG1pbjtcblx0XHRlbHNlIGlmICh2YWx1ZSA+IG1heCkgcmV0dXJuIG1heDtcblx0XHRlbHNlIHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdC8vXHRDSEVDS0lORyBNSVAgTUFQIExFVkVMU1xuXHRjb25zdCBkZHNJbmZvcyA9IHBhcnNlKG1BcnJheUJ1ZmZlcik7XG5cdGNvbnN0IHsgZmxhZ3MgfSA9IGRkc0luZm9zO1xuXHRjb25zdCBoZWFkZXIgPSBuZXcgSW50MzJBcnJheShtQXJyYXlCdWZmZXIsIDAsIGhlYWRlckxlbmd0aEludCk7XG5cdGxldCBtaXBtYXBDb3VudCA9IDE7XG5cdGlmIChmbGFncyAmIEREU0RfTUlQTUFQQ09VTlQpIHtcblx0XHRtaXBtYXBDb3VudCA9IE1hdGgubWF4KDEsIGhlYWRlcltPRkZfTUlQTUFQQ09VTlRdKTtcblx0fVxuXHRjb25zdCBzb3VyY2VzID0gZGRzSW5mb3MuaW1hZ2VzLm1hcCgoaW1nKSA9PiB7XG5cdFx0Y29uc3QgZmFjZURhdGEgPSBuZXcgRmxvYXQzMkFycmF5KG1BcnJheUJ1ZmZlci5zbGljZShpbWcub2Zmc2V0LCBpbWcub2Zmc2V0ICsgaW1nLmxlbmd0aCkpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRkYXRhOiBmYWNlRGF0YSxcblx0XHRcdHNoYXBlOiBpbWcuc2hhcGUsXG5cdFx0XHRtaXBtYXBDb3VudCxcblx0XHR9O1xuXHR9KTtcblxuXHRyZXR1cm4gbmV3IEdMQ3ViZVRleHR1cmUoc291cmNlcyk7XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEdMQ3ViZVRleHR1cmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvR0xDdWJlVGV4dHVyZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiYXNpYy52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCQVNJQ19WRVJURVhcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuICAgIHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9iYXNpYy52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFNoYWRlcnMuanNcblxuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcblxuY29uc3Qgc2hhZGVyQ2FjaGUgPSBbXTtcblxuY29uc3QgZGVmaW5lc1RvU3RyaW5nID0gZnVuY3Rpb24gKGRlZmluZXMpIHtcblx0bGV0IG91dFN0ciA9ICcnO1xuXHRmb3IgKGNvbnN0IGRlZiBpbiBkZWZpbmVzKSB7XG5cdFx0aWYoZGVmaW5lc1tkZWZdKSB7XG5cdFx0XHRvdXRTdHIgKz0gYCNkZWZpbmUgJHtkZWZ9ICR7ZGVmaW5lc1tkZWZdfVxcbmA7XHRcblx0XHR9XG5cdFx0XG5cdH1cblx0cmV0dXJuIG91dFN0cjtcbn07XG5cbmNvbnN0IGdldFVuaWZvcm1UeXBlID0gZnVuY3Rpb24gKG1WYWx1ZSkge1xuXHRpZihtVmFsdWUubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGB2ZWMke21WYWx1ZS5sZW5ndGh9YDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gJ2Zsb2F0Jztcblx0fVxufTtcblxuY29uc3QgYWRkVW5pZm9ybXMgPSBmdW5jdGlvbiAobVNoYWRlciwgbU9ialVuaWZvcm1zKSB7XG5cblx0bGV0IHN0clVuaWZvcm1zID0gJyc7XG5cdGZvcihjb25zdCB1bmlmb3JtTmFtZSBpbiBtT2JqVW5pZm9ybXMpIHtcblx0XHRjb25zdCB1bmlmb3JtVmFsdWUgPSBtT2JqVW5pZm9ybXNbdW5pZm9ybU5hbWVdO1xuXHRcdGNvbnN0IHVuaWZvcm1UeXBlID0gZ2V0VW5pZm9ybVR5cGUodW5pZm9ybVZhbHVlKTtcblxuXHRcdHN0clVuaWZvcm1zICs9IGB1bmlmb3JtICR7dW5pZm9ybVR5cGV9ICR7dW5pZm9ybU5hbWV9O1xcbmA7XG5cdH1cblxuXHRtU2hhZGVyID0gbVNoYWRlci5yZXBsYWNlKCd7e1VOSUZPUk1TfX0nLCBzdHJVbmlmb3Jtcyk7XG5cblx0cmV0dXJuIG1TaGFkZXI7XG59O1xuXG5cbmNvbnN0IGJpbmRVbmlmb3JtcyA9IGZ1bmN0aW9uIChtU2hhZGVyLCBtT2JqVW5pZm9ybXMpIHtcblxuXHRmb3IoY29uc3QgdW5pZm9ybU5hbWUgaW4gbU9ialVuaWZvcm1zKSB7XG5cdFx0Y29uc3QgdW5pZm9ybVZhbHVlID0gbU9ialVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcblx0XHRjb25zdCB1bmlmb3JtVHlwZSA9IGdldFVuaWZvcm1UeXBlKHVuaWZvcm1WYWx1ZSk7XG5cdFx0bVNoYWRlci51bmlmb3JtKHVuaWZvcm1OYW1lLCB1bmlmb3JtVHlwZSwgdW5pZm9ybVZhbHVlKTtcblx0fVxuXHRcbn07XG5cbmNvbnN0IGluamVjdERlZmluZXMgPSBmdW5jdGlvbiAobVNoYWRlciwgbURlZmluZXMpIHtcblxuXHRyZXR1cm4gYCR7ZGVmaW5lc1RvU3RyaW5nKG1EZWZpbmVzKX1cXG4ke21TaGFkZXJ9YDtcblxufTtcblxuY29uc3QgZ2V0ID0gKHZzLCBmcywgZGVmaW5lcyA9IHt9KSA9PiB7XG5cdGxldCBfc2hhZGVyO1xuXHRjb25zdCBfdnMgPSBpbmplY3REZWZpbmVzKHZzLCBkZWZpbmVzKTtcblx0Y29uc3QgX2ZzID0gaW5qZWN0RGVmaW5lcyhmcywgZGVmaW5lcyk7XG5cblx0c2hhZGVyQ2FjaGUuZm9yRWFjaChzaGFkZXIgPT4ge1xuXHRcdGlmKF92cyA9PT0gc2hhZGVyLnZzICYmIF9mcyA9PT0gc2hhZGVyLmZzKSB7XG5cdFx0XHRfc2hhZGVyID0gc2hhZGVyLmdsU2hhZGVyO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKCFfc2hhZGVyKSB7XG5cdFx0X3NoYWRlciA9IG5ldyBHTFNoYWRlcihfdnMsIF9mcyk7XG5cdFx0c2hhZGVyQ2FjaGUucHVzaCh7XG5cdFx0XHR2czpfdnMsXG5cdFx0XHRmczpfZnMsXG5cdFx0XHRnbFNoYWRlcjpfc2hhZGVyXG5cdFx0fSk7XG5cdH1cblxuXG5cdHJldHVybiBfc2hhZGVyO1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGdldCxcblx0YWRkVW5pZm9ybXMsXG5cdGJpbmRVbmlmb3Jtcyxcblx0aW5qZWN0RGVmaW5lc1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9zaGFkZXJzL1NoYWRlcnMuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBGcmFtZUJ1ZmZlci5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuL0dMVGV4dHVyZSc7XG5pbXBvcnQgV2ViZ2xOdW1iZXIgZnJvbSAnLi91dGlscy9XZWJnbE51bWJlcic7XG5pbXBvcnQgb2JqZWN0QXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nO1xuXG5sZXQgZ2w7XG5sZXQgd2ViZ2xEZXB0aFRleHR1cmU7XG5sZXQgaGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCA9IGZhbHNlO1xubGV0IGV4dERyYXdCdWZmZXI7XG5cblxuY29uc3QgY2hlY2tNdWx0aVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblx0aWYoR0wud2ViZ2wyKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gZWxzZSB7XG5cdFx0ZXh0RHJhd0J1ZmZlciA9IEdMLmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyk7XG5cdFx0cmV0dXJuICEhZXh0RHJhd0J1ZmZlcjtcblx0fVxuXHRcblx0aGFzQ2hlY2tlZE11bHRpUmVuZGVyU3VwcG9ydCA9IHRydWU7XG59O1xuXG5jbGFzcyBGcmFtZUJ1ZmZlciB7XG5cblx0Y29uc3RydWN0b3IobVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1ldGVycyA9IHt9LCBtTnVtVGFyZ2V0cyA9IDEpIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHdlYmdsRGVwdGhUZXh0dXJlID0gR0wuY2hlY2tFeHRlbnNpb24oJ1dFQkdMX2RlcHRoX3RleHR1cmUnKTtcblxuXHRcdHRoaXMud2lkdGggICAgICAgICAgICA9IG1XaWR0aDtcblx0XHR0aGlzLmhlaWdodCAgICAgICAgICAgPSBtSGVpZ2h0O1xuXHRcdHRoaXMuX251bVRhcmdldHMgXHQgID0gbU51bVRhcmdldHM7XG5cdFx0dGhpcy5fbXVsdGlwbGVUYXJnZXRzID0gbU51bVRhcmdldHMgPiAxO1xuXHRcdHRoaXMuX3BhcmFtZXRlcnMgPSBtUGFyYW1ldGVycztcblxuXHRcdGlmKCFoYXNDaGVja2VkTXVsdGlSZW5kZXJTdXBwb3J0KSB7XG5cdFx0XHRjaGVja011bHRpUmVuZGVyKCk7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5fbXVsdGlwbGVUYXJnZXRzKSB7XG5cdFx0XHR0aGlzLl9jaGVja01heE51bVJlbmRlclRhcmdldCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy5faW5pdFRleHR1cmVzKCk7XG5cdFx0XG5cdFx0dGhpcy5mcmFtZUJ1ZmZlciAgICAgICAgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1x0XHRcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXG5cdFx0aWYoR0wud2ViZ2wyKSB7XG5cdFx0XHQvLyB0aGlzLnJlbmRlckJ1ZmZlckRlcHRoID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHQvLyBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0XHQvLyBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRcdC8vIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHRoaXMucmVuZGVyQnVmZmVyRGVwdGgpO1xuXG5cdFx0XHRjb25zdCBidWZmZXJzID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVRhcmdldHM7IGkrKykge1xuXHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5EUkFXX0ZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmVzW2ldLnRleHR1cmUsIDApO1xuXHRcdFx0XHRidWZmZXJzLnB1c2goZ2xbYENPTE9SX0FUVEFDSE1FTlQke2l9YF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRnbC5kcmF3QnVmZmVycyhidWZmZXJzKTtcblxuXHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRFJBV19GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbERlcHRoVGV4dHVyZS50ZXh0dXJlLCAwKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX251bVRhcmdldHM7IGkrKykge1xuXHRcdFx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlc1tpXS50ZXh0dXJlLCAwKTtcdFxuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLl9tdWx0aXBsZVRhcmdldHMpIHtcblx0XHRcdFx0Y29uc3QgZHJhd0J1ZmZlcnMgPSBbXTtcblx0XHRcdFx0Zm9yKGxldCBpPTA7IGk8dGhpcy5fbnVtVGFyZ2V0czsgaSsrKSB7XG5cdFx0XHRcdFx0ZHJhd0J1ZmZlcnMucHVzaChleHREcmF3QnVmZmVyW2BDT0xPUl9BVFRBQ0hNRU5UJHtpfV9XRUJHTGBdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV4dERyYXdCdWZmZXIuZHJhd0J1ZmZlcnNXRUJHTChkcmF3QnVmZmVycyk7XHRcblx0XHRcdH1cblxuXHRcdFx0aWYod2ViZ2xEZXB0aFRleHR1cmUpIHtcblx0XHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMCk7XHRcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cblx0XHQvL1x0Q0hFQ0tJTkcgRkJPXG5cdFx0Y29uc3QgRkJPc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG5cdFx0aWYoRkJPc3RhdHVzICE9IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdHTF9GUkFNRUJVRkZFUl9DT01QTEVURSBmYWlsZWQsIENBTk5PVCB1c2UgRnJhbWVidWZmZXInLCBXZWJnbE51bWJlcltGQk9zdGF0dXNdKTtcblx0XHR9XG5cblx0XHQvL1x0VU5CSU5EXG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdFxuXHRcdC8vXHRDTEVBUiBGUkFNRUJVRkZFUiBcblxuXHRcdHRoaXMuY2xlYXIoKTtcblx0fVxuXG5cdF9jaGVja01heE51bVJlbmRlclRhcmdldCgpIHtcblx0XHRjb25zdCBtYXhOdW1EcmF3QnVmZmVycyA9IEdMLmdsLmdldFBhcmFtZXRlcihleHREcmF3QnVmZmVyLk1BWF9EUkFXX0JVRkZFUlNfV0VCR0wpO1xuXHRcdGlmKHRoaXMuX251bVRhcmdldHMgPiBtYXhOdW1EcmF3QnVmZmVycykge1xuXHRcdFx0Y29uc29sZS5lcnJvcignT3ZlciBtYXggbnVtYmVyIG9mIGRyYXcgYnVmZmVycyBzdXBwb3J0ZWQgOiAnLCBtYXhOdW1EcmF3QnVmZmVycyk7XG5cdFx0XHR0aGlzLl9udW1UYXJnZXRzID0gbWF4TnVtRHJhd0J1ZmZlcnM7XG5cdFx0fVxuXHR9XG5cblx0X2luaXRUZXh0dXJlcygpIHtcblx0XHR0aGlzLl90ZXh0dXJlcyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbnVtVGFyZ2V0czsgaSsrKSB7XG5cdFx0XHRjb25zdCBnbHQgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKCk7XG5cdFx0XHR0aGlzLl90ZXh0dXJlcy5wdXNoKGdsdCk7XG5cdFx0fVxuXG5cdFx0XG5cdFx0aWYoR0wud2ViZ2wyKSB7IFxuXHRcdFx0dGhpcy5nbERlcHRoVGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZ2wuREVQVEhfQ09NUE9ORU5UMTYsIGdsLlVOU0lHTkVEX1NIT1JULCBnbC5ERVBUSF9DT01QT05FTlQsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmdsRGVwdGhUZXh0dXJlID0gdGhpcy5fY3JlYXRlVGV4dHVyZShnbC5ERVBUSF9DT01QT05FTlQsIGdsLlVOU0lHTkVEX1NIT1JULCBnbC5ERVBUSF9DT01QT05FTlQsIHsgbWluRmlsdGVyOkdMLkxJTkVBUiB9KTtcblx0XHR9XG5cdH1cblxuXHRfY3JlYXRlVGV4dHVyZShtSW50ZXJuYWxmb3JtYXQsIG1UZXhlbFR5cGUsIG1Gb3JtYXQsIG1QYXJhbWV0ZXJzID0ge30pIHtcblx0XHRjb25zdCBwYXJhbWV0ZXJzID0gb2JqZWN0QXNzaWduKHt9LCB0aGlzLl9wYXJhbWV0ZXJzKTtcblx0XHRpZighbUZvcm1hdCkge1x0bUZvcm1hdCA9IG1JbnRlcm5hbGZvcm1hdDsgfVxuXHRcdFxuXHRcdHBhcmFtZXRlcnMuaW50ZXJuYWxGb3JtYXQgPSBtSW50ZXJuYWxmb3JtYXQgfHwgZ2wuUkdCQTtcblx0XHRwYXJhbWV0ZXJzLmZvcm1hdCA9IG1Gb3JtYXQ7XG5cdFx0cGFyYW1ldGVycy50eXBlID0gbVRleGVsVHlwZSB8fCBwYXJhbWV0ZXJzLnR5cGUgfHwgR0wuVU5TSUdORURfQllURTtcblx0XHRmb3IoY29uc3QgcyBpbiBtUGFyYW1ldGVycykge1xuXHRcdFx0cGFyYW1ldGVyc1tzXSA9IG1QYXJhbWV0ZXJzW3NdO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRleHR1cmUgPSBuZXcgR0xUZXh0dXJlKG51bGwsIHBhcmFtZXRlcnMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRyZXR1cm4gdGV4dHVyZTtcblx0fVxuXG5cdC8vXHRQVUJMSUMgTUVUSE9EU1xuXG5cdGJpbmQobUF1dG9TZXRWaWV3cG9ydD10cnVlKSB7XG5cdFx0aWYobUF1dG9TZXRWaWV3cG9ydCkge1xuXHRcdFx0R0wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1x0XG5cdFx0fVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlcik7XG5cdH1cblxuXG5cdHVuYmluZChtQXV0b1NldFZpZXdwb3J0PXRydWUpIHtcblx0XHRpZihtQXV0b1NldFZpZXdwb3J0KSB7XG5cdFx0XHRHTC52aWV3cG9ydCgwLCAwLCBHTC53aWR0aCwgR0wuaGVpZ2h0KTtcdFxuXHRcdH1cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cdFx0dGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcblx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXAoKTtcblx0XHR9KTtcblx0fVxuXG5cblx0Y2xlYXIociA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDApIHtcblx0XHR0aGlzLmJpbmQoKTtcblx0XHRHTC5jbGVhcihyLCBnLCBiLCBhKTtcblx0XHR0aGlzLnVuYmluZCgpO1xuXHR9XHRcblxuXG5cdC8vXHRURVhUVVJFU1xuXG5cdGdldFRleHR1cmUobUluZGV4ID0gMCkge1xuXHRcdHJldHVybiB0aGlzLl90ZXh0dXJlc1ttSW5kZXhdO1xuXHR9XG5cblx0Z2V0RGVwdGhUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLmdsRGVwdGhUZXh0dXJlO1xuXHR9XG5cblx0Ly9cdFRPVUdIVFMgOiBTaG91bGQgSSByZW1vdmUgdGhlc2UgZnJvbSBmcmFtZSBidWZmZXIgPyBcblx0Ly9cdFNob3VsZG4ndCB0aGVzZSBiZSBzZXQgaW5kaXZpZHVhbGx5IHRvIGVhY2ggdGV4dHVyZSA/IFxuXHQvL1x0ZS5nLiBmYm8uZ2V0VGV4dHVyZSgwKS5taW5GaWx0ZXIgPSBHTC5ORUFSRVNUO1xuXHQvL1x0XHQgZmJvLmdldFRleHR1cmUoMSkubWluRmlsdGVyID0gR0wuTElORUFSOyAuLi4gZXRjID8gXG5cblx0Ly9cdE1JUE1BUCBGSUxURVJcblxuXHRnZXQgbWluRmlsdGVyKCkge1x0cmV0dXJuIHRoaXMuX3RleHR1cmVzWzBdLm1pbkZpbHRlcjtcdH1cblxuXHRzZXQgbWluRmlsdGVyKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG5cdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IG1WYWx1ZTtcblx0XHR9KTtcblx0fVxuXG5cdGdldCBtYWdGaWx0ZXIoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ubWFnRmlsdGVyO1x0fVxuXG5cdHNldCBtYWdGaWx0ZXIobVZhbHVlKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblxuXHQvL1x0V1JBUFBJTkdcblxuXHRnZXQgd3JhcFMoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ud3JhcFM7XHR9XG5cblx0c2V0IHdyYXBTKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblxuXHRnZXQgd3JhcFQoKSB7XHRyZXR1cm4gdGhpcy5fdGV4dHVyZXNbMF0ud3JhcFQ7XHR9XG5cblx0c2V0IHdyYXBUKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gbVZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly9cdFVUSUxTXG5cblx0c2hvd1BhcmFtZXRlcnMoKSB7XG5cdFx0dGhpcy5fdGV4dHVyZXNbMF0uc2hvd1BhcmFtZXRlcnMoKTtcblx0fVxuXG5cdGdldCBudW1UYXJnZXRzKCkge1x0cmV0dXJuIHRoaXMuX251bVRhcmdldHM7XHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgRnJhbWVCdWZmZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvRnJhbWVCdWZmZXIuanMiLCIvLyBFYXNlTnVtYmVyLmpzXG5cbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnc2NoZWR1bGluZyc7XG5cbmNsYXNzIEVhc2VOdW1iZXIge1xuXHRjb25zdHJ1Y3RvcihtVmFsdWUsIG1FYXNpbmcgPSAwLjEpIHtcblx0XHR0aGlzLmVhc2luZyAgICAgICA9IG1FYXNpbmc7XG5cdFx0dGhpcy5fdmFsdWUgICAgICAgPSBtVmFsdWU7XG5cdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fZWZJbmRleCAgICAgPSBTY2hlZHVsZXIuYWRkRUYoKCk9PiB0aGlzLl91cGRhdGUoKSk7XG5cdH1cblxuXG5cdF91cGRhdGUoKSB7XG5cdFx0Y29uc3QgTUlOX0RJRkYgPSAwLjAwMDE7XG5cdFx0dGhpcy5fY2hlY2tMaW1pdCgpO1xuXHRcdHRoaXMuX3ZhbHVlICs9ICh0aGlzLl90YXJnZXRWYWx1ZSAtIHRoaXMuX3ZhbHVlKSAqIHRoaXMuZWFzaW5nO1x0XG5cdFx0aWYoTWF0aC5hYnModGhpcy5fdGFyZ2V0VmFsdWUgLSB0aGlzLl92YWx1ZSkgPCBNSU5fRElGRikge1xuXHRcdFx0dGhpcy5fdmFsdWUgPSB0aGlzLl90YXJnZXRWYWx1ZTtcblx0XHR9XG5cdH1cblxuXHRzZXRUbyhtVmFsdWUpIHtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX3ZhbHVlID0gbVZhbHVlO1xuXHR9XG5cblxuXHRhZGQobUFkZCkge1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlICs9IG1BZGQ7XG5cdH1cblxuXHRsaW1pdChtTWluLCBtTWF4KSB7XG5cdFx0aWYobU1pbiA+IG1NYXgpIHtcblx0XHRcdHRoaXMubGltaXQobU1heCwgbU1pbik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWluID0gbU1pbjtcblx0XHR0aGlzLl9tYXggPSBtTWF4O1xuXG5cdFx0dGhpcy5fY2hlY2tMaW1pdCgpO1xuXHR9XG5cblxuXHRfY2hlY2tMaW1pdCgpIHtcblx0XHRpZih0aGlzLl9taW4gIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90YXJnZXRWYWx1ZSA8IHRoaXMuX21pbikge1xuXHRcdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSB0aGlzLl9taW47XG5cdFx0fSBcblxuXHRcdGlmKHRoaXMuX21heCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX3RhcmdldFZhbHVlID4gdGhpcy5fbWF4KSB7XG5cdFx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IHRoaXMuX21heDtcblx0XHR9IFxuXHR9XG5cblxuXHRkZXN0cm95KCkge1xuXHRcdFNjaGVkdWxlci5yZW1vdmVFRih0aGlzLl9lZkluZGV4KTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUlMgLyBTRVRURVJTXG5cblx0c2V0IHZhbHVlKG1WYWx1ZSkge1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gbVZhbHVlO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0fVxuXG5cdGdldCB0YXJnZXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGFyZ2V0VmFsdWU7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEVhc2VOdW1iZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvRWFzZU51bWJlci5qcyIsIi8vIFJheS5qc1xuXG5pbXBvcnQgeyBtYXQ0LCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuXG5jb25zdCBhID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IGIgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgYyA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCB0YXJnZXQgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgZWRnZTEgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3QgZWRnZTIgPSB2ZWMzLmNyZWF0ZSgpO1xuY29uc3Qgbm9ybWFsID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IGRpZmYgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5jbGFzcyBSYXkge1xuXHRjb25zdHJ1Y3RvcihtT3JpZ2luLCBtRGlyZWN0aW9uKSB7XG5cdFx0dGhpcy5vcmlnaW4gPSB2ZWMzLmNsb25lKG1PcmlnaW4pO1xuXHRcdHRoaXMuZGlyZWN0aW9uID0gdmVjMy5jbG9uZShtRGlyZWN0aW9uKTtcblx0fVxuXG5cdGF0KHQpIHtcblx0XHR2ZWMzLmNvcHkodGFyZ2V0LCB0aGlzLmRpcmVjdGlvbik7XG5cdFx0dmVjMy5zY2FsZSh0YXJnZXQsIHRhcmdldCwgdCk7XG5cdFx0dmVjMy5hZGQodGFyZ2V0LCB0YXJnZXQsIHRoaXMub3JpZ2luKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXG5cdGxvb2tBdChtVGFyZ2V0KSB7XG5cdFx0dmVjMy5zdWIodGhpcy5kaXJlY3Rpb24sIG1UYXJnZXQsIHRoaXMub3JpZ2luKTtcblx0XHR2ZWMzLm5vcm1hbGl6ZSh0aGlzLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuXHR9XG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludChtUG9pbnQpIHtcblx0XHRjb25zdCByZXN1bHQgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHZlYzMuc3ViKG1Qb2ludCwgdGhpcy5vcmlnaW4pO1xuXHRcdGNvbnN0IGRpcmVjdGlvbkRpc3RhbmNlID0gdmVjMy5kb3QocmVzdWx0LCB0aGlzLmRpcmVjdGlvbik7XG5cblx0XHRpZiAoZGlyZWN0aW9uRGlzdGFuY2UgPCAwKSB7XG5cdFx0XHRyZXR1cm4gdmVjMy5jbG9uZSh0aGlzLm9yaWdpbik7XG5cdFx0fVxuXG5cdFx0dmVjMy5jb3B5KHJlc3VsdCwgdGhpcy5kaXJlY3Rpb24pO1xuXHRcdHZlYzMuc2NhbGUocmVzdWx0LCByZXN1bHQsIGRpcmVjdGlvbkRpc3RhbmNlKTtcblx0XHR2ZWMzLmFkZChyZXN1bHQsIHJlc3VsdCwgdGhpcy5vcmlnaW4pO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cblx0ZGlzdGFuY2VUb1BvaW50KG1Qb2ludCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVNxVG9Qb2ludChtUG9pbnQpKTtcblx0fVxuXG5cblx0ZGlzdGFuY2VTcVRvUG9pbnQobVBvaW50KSB7XG5cdFx0Y29uc3QgdjEgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5cdFx0dmVjMy5zdWIodjEsIG1Qb2ludCwgdGhpcy5vcmlnaW4pO1xuXHRcdGNvbnN0IGRpcmVjdGlvbkRpc3RhbmNlID0gdmVjMy5kb3QodjEsIHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdGlmIChkaXJlY3Rpb25EaXN0YW5jZSA8IDApIHtcblx0XHRcdHJldHVybiB2ZWMzLnNxdWFyZWREaXN0YW5jZSh0aGlzLm9yaWdpbiwgbVBvaW50KTtcblx0XHR9XG5cblx0XHR2ZWMzLmNvcHkodjEsIHRoaXMuZGlyZWN0aW9uKTtcblx0XHR2ZWMzLnNjYWxlKHYxLCB2MSwgZGlyZWN0aW9uRGlzdGFuY2UpO1xuXHRcdHZlYzMuYWRkKHYxLCB2MSwgdGhpcy5vcmlnaW4pO1xuXHRcdHJldHVybiB2ZWMzLnNxdWFyZWREaXN0YW5jZSh2MSwgbVBvaW50KTtcblx0fVxuXG5cblx0aW50ZXJzZWN0c1NwaGVyZShtQ2VudGVyLCBtUmFkaXVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KG1DZW50ZXIpIDw9IG1SYWRpdXM7XG5cdH1cblxuXG5cdGludGVyc2VjdFNwaGVyZShtQ2VudGVyLCBtUmFkaXVzKSB7XG5cdFx0Y29uc3QgdjEgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHZlYzMuc3ViKHYxLCBtQ2VudGVyLCB0aGlzLm9yaWdpbik7XG5cdFx0Y29uc3QgdGNhID0gdmVjMy5kb3QodjEsIHRoaXMuZGlyZWN0aW9uKTtcblx0XHRjb25zdCBkMiA9IHZlYzMuZG90KHYxLCB2MSkgLSB0Y2EgKiB0Y2E7XG5cdFx0Y29uc3QgcmFkaXVzMiA9IG1SYWRpdXMgKiBtUmFkaXVzO1xuXG5cdFx0aWYoZDIgPiByYWRpdXMyKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IHRoYyA9IE1hdGguc3FydChyYWRpdXMyIC0gZDIpO1xuXG5cdFx0Y29uc3QgdDAgPSB0Y2EgLSB0aGM7XG5cblx0XHRjb25zdCB0MSA9IHRjYSArIHRoYztcblxuXHRcdGlmKHQwIDwgMCAmJiB0MSA8IDApIHJldHVybiBudWxsO1xuXG5cdFx0aWYodDAgPCAwKSByZXR1cm4gdGhpcy5hdCh0MSk7XG5cblx0XHRyZXR1cm4gdGhpcy5hdCh0MCk7XG5cdH1cblxuXG5cdGRpc3RhbmNlVG9QbGFuZShtUGxhbmVDZW50ZXIsIG1Ob3JtYWwpIHtcblx0XHRjb25zdCBkZW5vbWluYXRvciA9IHZlYzMuZG90KG1Ob3JtYWwsIHRoaXMuZGlyZWN0aW9uKTtcblxuXHRcdGlmKGRlbm9taW5hdG9yID09PSAwKSB7XG5cdFx0fVxuXHR9XG5cblxuXHRpbnRlcnNlY3RUcmlhbmdsZShtUEEsIG1QQiwgbVBDLCBiYWNrZmFjZUN1bGxpbmcgPSB0cnVlKSB7XG5cdFx0dmVjMy5jb3B5KGEsIG1QQSk7XG5cdFx0dmVjMy5jb3B5KGIsIG1QQik7XG5cdFx0dmVjMy5jb3B5KGMsIG1QQyk7XG5cblx0XHQvLyBjb25zdCBlZGdlMSA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Ly8gY29uc3QgZWRnZTIgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdC8vIGNvbnN0IG5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0Ly8gY29uc3QgZGlmZiA9IHZlYzMuY3JlYXRlKCk7XG5cblx0XHR2ZWMzLnN1YihlZGdlMSwgYiwgYSk7XG5cdFx0dmVjMy5zdWIoZWRnZTIsIGMsIGEpO1xuXHRcdHZlYzMuY3Jvc3Mobm9ybWFsLCBlZGdlMSwgZWRnZTIpO1xuXG5cdFx0bGV0IERkTiA9IHZlYzMuZG90KHRoaXMuZGlyZWN0aW9uLCBub3JtYWwpO1xuXHRcdGxldCBzaWduO1xuXG5cdFx0aWYgKERkTiA+IDApIHtcblx0XHRcdGlmIChiYWNrZmFjZUN1bGxpbmcpIHtcdHJldHVybiBudWxsO1x0fVxuXHRcdFx0c2lnbiA9IDE7XG5cdFx0fSBlbHNlIGlmIChEZE4gPCAwKSB7XG5cdFx0XHRzaWduID0gLTE7XG5cdFx0XHREZE4gPSAtIERkTjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmVjMy5zdWIoZGlmZiwgdGhpcy5vcmlnaW4sIGEpO1xuXG5cdFx0dmVjMy5jcm9zcyhlZGdlMiwgZGlmZiwgZWRnZTIpO1xuXHRcdGNvbnN0IERkUXhFMiA9IHNpZ24gKiB2ZWMzLmRvdCh0aGlzLmRpcmVjdGlvbiwgZWRnZTIpO1xuXHRcdGlmIChEZFF4RTIgPCAwKSB7IFx0cmV0dXJuIG51bGw7IFx0fVxuXG5cdFx0dmVjMy5jcm9zcyhlZGdlMSwgZWRnZTEsIGRpZmYpO1xuXHRcdGNvbnN0IERkRTF4USA9IHNpZ24gKiB2ZWMzLmRvdCh0aGlzLmRpcmVjdGlvbiwgZWRnZTEpO1xuXHRcdGlmIChEZEUxeFEgPCAwKSB7XHRyZXR1cm4gbnVsbDtcdH1cblxuXHRcdGlmKERkUXhFMiArIERkRTF4USA+IERkTikge1x0cmV0dXJuIG51bGw7XHR9XG5cblx0XHRjb25zdCBRZG4gPSAtIHNpZ24gKiB2ZWMzLmRvdChkaWZmLCBub3JtYWwpO1xuXHRcdGlmKFFkbiA8IDApIHtcdHJldHVybiBudWxsO1x0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYXQoUWRuIC8gRGROKTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL21hdGgvUmF5LmpzIiwiLy8gU2hhZGVyTGJzLmpzXG5cbmltcG9ydCBzaW1wbGVDb2xvckZyYWcgZnJvbSAnLi4vZ2xzbC9zaW1wbGVDb2xvci5mcmFnJztcbmltcG9ydCBiaWdUcmlhbmdsZVZlcnQgZnJvbSAnLi4vZ2xzbC9iaWdUcmlhbmdsZS52ZXJ0JztcbmltcG9ydCBnZW5lcmFsVmVydCBmcm9tICcuLi9nbHNsL2dlbmVyYWwudmVydCc7XG5pbXBvcnQgY29weUZyYWcgZnJvbSAnLi4vZ2xzbC9jb3B5LmZyYWcnO1xuaW1wb3J0IGJhc2ljVmVydCBmcm9tICcuLi9nbHNsL2Jhc2ljLnZlcnQnO1xuaW1wb3J0IHNreWJveFZlcnQgZnJvbSAnLi4vZ2xzbC9za3lib3gudmVydCc7XG5pbXBvcnQgc2t5Ym94RnJhZyBmcm9tICcuLi9nbHNsL3NreWJveC5mcmFnJztcbmltcG9ydCBnbHRmVmVydCBmcm9tICcuLi9nbHNsL2dsdGYudmVydCc7XG5pbXBvcnQgZ2x0ZkZyYWcgZnJvbSAnLi4vZ2xzbC9nbHRmLmZyYWcnO1xuaW1wb3J0IGRlYnVnRnJhZyBmcm9tICcuLi9nbHNsL2RlYnVnLmZyYWcnO1xuXG5jb25zdCBTaGFkZXJMaWJzID0ge1xuXHRzaW1wbGVDb2xvckZyYWcsXG5cdGJpZ1RyaWFuZ2xlVmVydCxcblx0Z2VuZXJhbFZlcnQsXG5cdGNvcHlGcmFnLFxuXHRiYXNpY1ZlcnQsXG5cdHNreWJveFZlcnQsXG5cdHNreWJveEZyYWcsXG5cdGdsdGZWZXJ0LFxuXHRnbHRmRnJhZyxcblx0ZGVidWdGcmFnLFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTaGFkZXJMaWJzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3NoYWRlcnMvU2hhZGVyTGlicy5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiaWdUcmlhbmdsZS52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCSUdfVFJJQU5HTEVfVkVSVEVYXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVBvc2l0aW9uICogLjUgKyAuNTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYmlnVHJpYW5nbGUudmVydFxuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gY29weS5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBDT1BZX0ZSQUdNRU5UXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4dHVyZUNvb3JkKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvY29weS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIENhbWVyYS5qc1xuXG5pbXBvcnQgeyBtYXQ0LCBtYXQzLCBxdWF0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuY2xhc3MgQ2FtZXJhIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0Ly9cdFZJRVcgTUFUUklYXG5cdFx0dGhpcy5fbWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuXHRcdC8vXHRGT1IgVFJBTlNGT1JNIEZST00gT1JJRU5UQVRJT05cblx0XHR0aGlzLl9xdWF0ID0gcXVhdC5jcmVhdGUoKTtcblx0XHR0aGlzLl9vcmllbnRhdGlvbiA9IG1hdDQuY3JlYXRlKCk7XG5cblx0XHQvL1x0UFJPSkVDVElPTiBNQVRSSVhcblx0XHR0aGlzLl9wcm9qZWN0aW9uID0gbWF0NC5jcmVhdGUoKTtcblxuXHRcdC8vXHRQT1NJVElPTiBPRiBDQU1FUkFcblx0XHR0aGlzLnBvc2l0aW9uID0gdmVjMy5jcmVhdGUoKTtcblx0fVxuXG5cblx0bG9va0F0KGFFeWUsIGFDZW50ZXIsIGFVcCA9IFswLCAxLCAwXSkge1xuXHRcdHRoaXMuX2V5ZSA9IHZlYzMuY2xvbmUoYUV5ZSk7XG5cdFx0dGhpcy5fY2VudGVyID0gdmVjMy5jbG9uZShhQ2VudGVyKTtcblxuXHRcdHZlYzMuY29weSh0aGlzLnBvc2l0aW9uLCBhRXllKTtcblx0XHRtYXQ0LmlkZW50aXR5KHRoaXMuX21hdHJpeCk7XG5cdFx0bWF0NC5sb29rQXQodGhpcy5fbWF0cml4LCBhRXllLCBhQ2VudGVyLCBhVXApO1xuXHR9XG5cblxuXHRzZXRGcm9tT3JpZW50YXRpb24oeCwgeSwgeiwgdykge1xuXHRcdHF1YXQuc2V0KHRoaXMuX3F1YXQsIHgsIHksIHosIHcpO1xuXHRcdG1hdDQuZnJvbVF1YXQodGhpcy5fb3JpZW50YXRpb24sIHRoaXMuX3F1YXQpO1xuXHRcdG1hdDQudHJhbnNsYXRlKHRoaXMuX21hdHJpeCwgdGhpcy5fb3JpZW50YXRpb24sIHRoaXMucG9zaXRpb25PZmZzZXQpO1xuXHR9XG5cblxuXHRzZXRQcm9qZWN0aW9uKG1Qcm9qKSB7XG5cdFx0dGhpcy5fcHJvamVjdGlvbiA9IG1hdDQuY2xvbmUobVByb2opO1xuXHR9XG5cblxuXHRzZXRWaWV3KG1WaWV3KSB7XG5cdFx0dGhpcy5fbWF0cml4ID0gbWF0NC5jbG9uZShtVmlldyk7XG5cdH1cblx0XG5cblx0c2V0RnJvbVZpZXdQcm9qKG1WaWV3LCBtUHJvaikge1xuXHRcdHRoaXMuc2V0VmlldyhtVmlldyk7XG5cdFx0dGhpcy5zZXRQcm9qZWN0aW9uKG1Qcm9qKTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUlMgXG5cblx0Z2V0IG1hdHJpeCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9XG5cblx0Z2V0IHZpZXdNYXRyaXgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeDtcblx0fVxuXG5cblx0Z2V0IHByb2plY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Rpb247XG5cdH0gXG5cblx0Z2V0IHByb2plY3Rpb25NYXRyaXgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Rpb247XG5cdH0gXG5cblxuXHRnZXQgZXllKCkge1x0cmV0dXJuIHRoaXMuX2V5ZTtcdH1cblxuXHRnZXQgY2VudGVyKCkge1x0cmV0dXJuIHRoaXMuX2NlbnRlcjtcdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmE7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmEuanMiLCIvLyBDYW1lcmFQZXJzcGVjdGl2ZS5qc1xuXG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4vQ2FtZXJhJztcbmltcG9ydCBSYXkgZnJvbSAnLi4vbWF0aC9SYXknO1xuaW1wb3J0IHsgbWF0NCwgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IG1JbnZlcnNlVmlld1Byb2ogPSBtYXQ0LmNyZWF0ZSgpO1xuY29uc3QgY2FtZXJhRGlyID0gdmVjMy5jcmVhdGUoKTtcblxuXG5jbGFzcyBDYW1lcmFQZXJzcGVjdGl2ZSBleHRlbmRzIENhbWVyYSB7XG5cblx0c2V0UGVyc3BlY3RpdmUobUZvdiwgbUFzcGVjdFJhdGlvLCBtTmVhciwgbUZhcikge1xuXHRcdFxuXHRcdHRoaXMuX2ZvdiAgICAgICAgID0gbUZvdjtcblx0XHR0aGlzLl9uZWFyICAgICAgICA9IG1OZWFyO1xuXHRcdHRoaXMuX2ZhciAgICAgICAgID0gbUZhcjtcblx0XHR0aGlzLl9hc3BlY3RSYXRpbyA9IG1Bc3BlY3RSYXRpbztcblx0XHRtYXQ0LnBlcnNwZWN0aXZlKHRoaXMuX3Byb2plY3Rpb24sIG1Gb3YsIG1Bc3BlY3RSYXRpbywgbU5lYXIsIG1GYXIpO1xuXG5cdFx0Ly8gdGhpcy5fZnJ1c3R1bVRvcCA9IHRoaXMuX25lYXIgKiBNYXRoLnRhbih0aGlzLl9mb3YgKiAwLjUpO1xuXHRcdC8vIHRoaXMuX2ZydXN0dW1CdXR0b20gPSAtdGhpcy5fZnJ1c3R1bVRvcDtcblx0XHQvLyB0aGlzLl9mcnVzdHVtUmlnaHQgPSB0aGlzLl9mcnVzdHVtVG9wICogdGhpcy5fYXNwZWN0UmF0aW87XG5cdFx0Ly8gdGhpcy5fZnJ1c3R1bUxlZnQgPSAtdGhpcy5fZnJ1c3R1bVJpZ2h0O1xuXHR9XG5cblxuXHRzZXRBc3BlY3RSYXRpbyhtQXNwZWN0UmF0aW8pIHtcblx0XHR0aGlzLl9hc3BlY3RSYXRpbyA9IG1Bc3BlY3RSYXRpbztcblx0XHRtYXQ0LnBlcnNwZWN0aXZlKHRoaXMucHJvamVjdGlvbiwgdGhpcy5fZm92LCBtQXNwZWN0UmF0aW8sIHRoaXMuX25lYXIsIHRoaXMuX2Zhcik7XG5cdH1cblxuXG5cdGdlbmVyYXRlUmF5KG1TY3JlZW5Qb3NpdGlvbiwgbVJheSkge1xuXHRcdGNvbnN0IHByb2ogPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG5cdFx0Y29uc3QgdmlldyA9IHRoaXMudmlld01hdHJpeDtcblxuXHRcdG1hdDQubXVsdGlwbHkobUludmVyc2VWaWV3UHJvaiwgcHJvaiwgdmlldyk7XG5cdFx0bWF0NC5pbnZlcnQobUludmVyc2VWaWV3UHJvaiwgbUludmVyc2VWaWV3UHJvaik7XG5cblx0XHR2ZWMzLnRyYW5zZm9ybU1hdDQoY2FtZXJhRGlyLCBtU2NyZWVuUG9zaXRpb24sIG1JbnZlcnNlVmlld1Byb2opO1xuXHRcdHZlYzMuc3ViKGNhbWVyYURpciwgY2FtZXJhRGlyLCB0aGlzLnBvc2l0aW9uKTtcblx0XHR2ZWMzLm5vcm1hbGl6ZShjYW1lcmFEaXIsIGNhbWVyYURpcik7XG5cblx0XHRpZiAoIW1SYXkpIHtcblx0XHRcdG1SYXkgPSBuZXcgUmF5KHRoaXMucG9zaXRpb24sIGNhbWVyYURpcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1SYXkub3JpZ2luID0gdGhpcy5wb3NpdGlvbjtcblx0XHRcdG1SYXkuZGlyZWN0aW9uID0gY2FtZXJhRGlyO1xuXHRcdH1cblxuXG5cdFx0cmV0dXJuIG1SYXk7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmFQZXJzcGVjdGl2ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9jYW1lcmFzL0NhbWVyYVBlcnNwZWN0aXZlLmpzIiwiLy8gQmluYXJ5TG9hZGVyLmpzXG5cbmNsYXNzIEJpbmFyeUxvYWRlciB7XG5cblx0Y29uc3RydWN0b3IoaXNBcnJheUJ1ZmZlciA9IGZhbHNlKSB7XG5cdFx0dGhpcy5fcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0dGhpcy5fcmVxLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoZSk9PnRoaXMuX29uTG9hZGVkKGUpKTtcblx0XHR0aGlzLl9yZXEuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCAoZSk9PnRoaXMuX29uUHJvZ3Jlc3MoZSkpO1xuXHRcdGlmKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMuX3JlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHRcdH1cblx0fVx0XG5cblxuXHRsb2FkKHVybCwgY2FsbGJhY2spIHtcblx0XHRjb25zb2xlLmxvZygnTG9hZGluZyA6ICcsIHVybCk7XG5cdFx0dGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHRoaXMuX3JlcS5vcGVuKCdHRVQnLCB1cmwpO1xuXHRcdHRoaXMuX3JlcS5zZW5kKCk7XG5cdH1cblxuXG5cdF9vbkxvYWRlZCgpIHtcblx0XHR0aGlzLl9jYWxsYmFjayh0aGlzLl9yZXEucmVzcG9uc2UpO1xuXHR9XG5cblx0X29uUHJvZ3Jlc3MoLyogZSovKSB7XG5cdFx0Ly8gY29uc29sZS5sb2coJ29uIFByb2dyZXNzOicsIChlLmxvYWRlZC9lLnRvdGFsKjEwMCkudG9GaXhlZCgyKSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmluYXJ5TG9hZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvQmluYXJ5TG9hZGVyLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIGFsZnJpZC5qc1xuXG5pbXBvcnQgKiBhcyBHTE0gXHRcdFx0ZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBHTCBcdFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvR0xUb29sJztcbmltcG9ydCBHTFNoYWRlciBcdFx0XHRmcm9tICcuL2FsZnJpZC9HTFNoYWRlcic7XG5pbXBvcnQgR0xUZXh0dXJlIFx0XHRcdGZyb20gJy4vYWxmcmlkL0dMVGV4dHVyZSc7XG5pbXBvcnQgR0xDdWJlVGV4dHVyZSBcdFx0ZnJvbSAnLi9hbGZyaWQvR0xDdWJlVGV4dHVyZSc7XG5pbXBvcnQgTWVzaCBcdFx0XHRcdGZyb20gJy4vYWxmcmlkL01lc2gnO1xuaW1wb3J0IEdlb21ldHJ5IFx0XHRcdGZyb20gJy4vYWxmcmlkL0dlb21ldHJ5JztcbmltcG9ydCBNYXRlcmlhbCBcdFx0XHRmcm9tICcuL2FsZnJpZC9NYXRlcmlhbCc7XG5pbXBvcnQgR2VvbVx0XHRcdFx0XHRmcm9tICcuL2FsZnJpZC9HZW9tJztcbmltcG9ydCBCYXRjaFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvQmF0Y2gnO1xuaW1wb3J0IEZyYW1lQnVmZmVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvRnJhbWVCdWZmZXInO1xuaW1wb3J0IEN1YmVGcmFtZUJ1ZmZlclx0XHRmcm9tICcuL2FsZnJpZC9DdWJlRnJhbWVCdWZmZXInO1xuXG4vL1x0V0VCR0wgMlxuaW1wb3J0IE11bHRpc2FtcGxlRnJhbWVCdWZmZXIgIGZyb20gJy4vYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXInO1xuaW1wb3J0IFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IGZyb20gJy4vYWxmcmlkL1RyYW5zZm9ybUZlZWRiYWNrT2JqZWN0JztcblxuLy9cdFRPT0xTXG5pbXBvcnQgU2NoZWR1bGVyIFx0XHRcdGZyb20gJ3NjaGVkdWxpbmcnO1xuaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvRXZlbnREaXNwYXRjaGVyJztcbmltcG9ydCBFYXNlTnVtYmVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL0Vhc2VOdW1iZXInO1xuaW1wb3J0IFR3ZWVuTnVtYmVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL1R3ZWVuTnVtYmVyJztcbmltcG9ydCBPcmJpdGFsQ29udHJvbFx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9PcmJpdGFsQ29udHJvbCc7XG5pbXBvcnQgUXVhdFJvdGF0aW9uXHRcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uJztcbmltcG9ydCBUb3VjaERldGVjdG9yXHRcdGZyb20gJy4vYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3InO1xuaW1wb3J0IFdlYmdsTnVtYmVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvdXRpbHMvV2ViZ2xOdW1iZXInO1xuaW1wb3J0IFdlYmdsQ29uc3RcdFx0XHRmcm9tICcuL2FsZnJpZC91dGlscy9XZWJnbENvbnN0JztcblxuLy9cdFNIQURFUlNcbmltcG9ydCBTaGFkZXJzXHRcdFx0XHRmcm9tICcuL2FsZnJpZC9zaGFkZXJzL1NoYWRlcnMnO1xuaW1wb3J0IFNoYWRlckxpYnNcdFx0XHRmcm9tICcuL2FsZnJpZC9zaGFkZXJzL1NoYWRlckxpYnMnO1xuXG4vL1x0Q0FNRVJBU1xuaW1wb3J0IENhbWVyYSBcdFx0XHRcdGZyb20gJy4vYWxmcmlkL2NhbWVyYXMvQ2FtZXJhJztcbmltcG9ydCBDYW1lcmFPcnRobyBcdFx0XHRmcm9tICcuL2FsZnJpZC9jYW1lcmFzL0NhbWVyYU9ydGhvJztcbmltcG9ydCBDYW1lcmFQZXJzcGVjdGl2ZVx0ZnJvbSAnLi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFQZXJzcGVjdGl2ZSc7XG5pbXBvcnQgQ2FtZXJhQ3ViZVx0XHRcdGZyb20gJy4vYWxmcmlkL2NhbWVyYXMvQ2FtZXJhQ3ViZSc7XG5cbi8vXHRNQVRIXG5pbXBvcnQgUmF5IFx0XHRcdFx0XHRmcm9tICcuL2FsZnJpZC9tYXRoL1JheSc7XG5cbi8vXHRPQkpFQ1RcbmltcG9ydCBPYmplY3QzRCBcdFx0XHRmcm9tICcuL2FsZnJpZC9vYmplY3RzL09iamVjdDNEJztcblxuLy9cdExPQURFUlNcbmltcG9ydCBCaW5hcnlMb2FkZXJcdFx0XHRmcm9tICcuL2FsZnJpZC9sb2FkZXJzL0JpbmFyeUxvYWRlcic7XG5pbXBvcnQgT2JqTG9hZGVyXHRcdFx0ZnJvbSAnLi9hbGZyaWQvbG9hZGVycy9PYmpMb2FkZXInO1xuaW1wb3J0IEhEUkxvYWRlclx0XHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvSERSTG9hZGVyJztcbmltcG9ydCBDb2xsYWRhUGFyc2VyXHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvQ29sbGFkYVBhcnNlcic7XG5pbXBvcnQgR0xURkxvYWRlclx0XHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvR2x0ZkxvYWRlcic7XG5pbXBvcnQgbG9hZEltYWdlc1x0XHRcdGZyb20gJy4vYWxmcmlkL2xvYWRlcnMvbG9hZEltYWdlcyc7XG5cbi8vXHRQT1NUIEVGRkVDVFxuaW1wb3J0IEVmZmVjdENvbXBvc2VyIFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L0VmZmVjdENvbXBvc2VyJztcbmltcG9ydCBQYXNzIFx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvcG9zdC9QYXNzJztcbmltcG9ydCBQYXNzTWFjcm8gXHRcdFx0ZnJvbSAnLi9hbGZyaWQvcG9zdC9QYXNzTWFjcm8nO1xuaW1wb3J0IFBhc3NCbHVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3Bvc3QvUGFzc0JsdXInO1xuaW1wb3J0IFBhc3NWQmx1ciBcdFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L1Bhc3NWQmx1cic7XG5pbXBvcnQgUGFzc0hCbHVyIFx0XHRcdGZyb20gJy4vYWxmcmlkL3Bvc3QvUGFzc0hCbHVyJztcbmltcG9ydCBQYXNzRnhhYSBcdFx0XHRmcm9tICcuL2FsZnJpZC9wb3N0L1Bhc3NGeGFhJztcblxuXG4vL1x0SEVMUEVSU1xuaW1wb3J0IEJhdGNoQ29weVx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hDb3B5JztcbmltcG9ydCBCYXRjaEF4aXNcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoQXhpcyc7XG5pbXBvcnQgQmF0Y2hCYWxsXHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaEJhbGwnO1xuaW1wb3J0IEJhdGNoRG90c1BsYW5lXHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvQmF0Y2hEb3RzUGxhbmUnO1xuaW1wb3J0IEJhdGNoTGluZSBcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZSc7XG5pbXBvcnQgQmF0Y2hTa3lib3hcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL0JhdGNoU2t5Ym94JztcbmltcG9ydCBCYXRjaFNreVx0XHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaFNreSc7XG5pbXBvcnQgQmF0Y2hGWEFBXHRcdFx0ZnJvbSAnLi9hbGZyaWQvaGVscGVycy9CYXRjaEZYQUEnO1xuaW1wb3J0IFNjZW5lXHRcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL1NjZW5lJztcbmltcG9ydCBWaWV3XHRcdFx0XHRcdGZyb20gJy4vYWxmcmlkL2hlbHBlcnMvVmlldyc7XG5pbXBvcnQgVmlldzNEXHRcdFx0XHRmcm9tICcuL2FsZnJpZC9oZWxwZXJzL1ZpZXczRCc7XG5cblxuXG5jb25zdCBWRVJTSU9OID0gJzAuMi4wJztcblxuY2xhc3MgQWxmcmlkIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpcy5nbG0gICAgICAgICAgICAgICA9IEdMTTtcblx0XHR0aGlzLkdMICAgICAgICAgICAgICAgID0gR0w7XG5cdFx0dGhpcy5HTFRvb2wgICAgICAgICAgICA9IEdMO1xuXHRcdHRoaXMuR0xTaGFkZXIgICAgICAgICAgPSBHTFNoYWRlcjtcblx0XHR0aGlzLkdMVGV4dHVyZSAgICAgICAgID0gR0xUZXh0dXJlO1xuXHRcdHRoaXMuR0xDdWJlVGV4dHVyZSAgICAgPSBHTEN1YmVUZXh0dXJlO1xuXHRcdHRoaXMuTWVzaCAgICAgICAgICAgICAgPSBNZXNoO1xuXHRcdHRoaXMuR2VvbWV0cnkgICAgICAgICAgPSBHZW9tZXRyeTtcblx0XHR0aGlzLk1hdGVyaWFsICAgICAgICAgID0gTWF0ZXJpYWw7XG5cdFx0dGhpcy5HZW9tICAgICAgICAgICAgICA9IEdlb207XG5cdFx0dGhpcy5CYXRjaCAgICAgICAgICAgICA9IEJhdGNoO1xuXHRcdHRoaXMuRnJhbWVCdWZmZXIgICAgICAgPSBGcmFtZUJ1ZmZlcjtcblx0XHR0aGlzLkN1YmVGcmFtZUJ1ZmZlciAgID0gQ3ViZUZyYW1lQnVmZmVyO1xuXHRcdHRoaXMuU2NoZWR1bGVyICAgICAgICAgPSBTY2hlZHVsZXI7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXIgICA9IEV2ZW50RGlzcGF0Y2hlcjtcblx0XHR0aGlzLkVhc2VOdW1iZXIgICAgICAgID0gRWFzZU51bWJlcjtcblx0XHR0aGlzLlR3ZWVuTnVtYmVyICAgICAgID0gVHdlZW5OdW1iZXI7XG5cdFx0dGhpcy5DYW1lcmEgICAgICAgICAgICA9IENhbWVyYTtcblx0XHR0aGlzLkNhbWVyYU9ydGhvICAgICAgID0gQ2FtZXJhT3J0aG87XG5cdFx0dGhpcy5DYW1lcmFQZXJzcGVjdGl2ZSA9IENhbWVyYVBlcnNwZWN0aXZlO1xuXHRcdHRoaXMuUmF5IFx0XHRcdCAgID0gUmF5O1xuXHRcdHRoaXMuQ2FtZXJhQ3ViZSAgICAgICAgPSBDYW1lcmFDdWJlO1xuXHRcdHRoaXMuT3JiaXRhbENvbnRyb2wgICAgPSBPcmJpdGFsQ29udHJvbDtcblx0XHR0aGlzLlF1YXRSb3RhdGlvbiAgICAgID0gUXVhdFJvdGF0aW9uO1xuXHRcdHRoaXMuVG91Y2hEZXRlY3RvciAgICAgPSBUb3VjaERldGVjdG9yO1xuXHRcdHRoaXMuQmluYXJ5TG9hZGVyICAgICAgPSBCaW5hcnlMb2FkZXI7XG5cdFx0dGhpcy5PYmpMb2FkZXIgICAgICAgICA9IE9iakxvYWRlcjtcblx0XHR0aGlzLkNvbGxhZGFQYXJzZXIgICAgID0gQ29sbGFkYVBhcnNlcjtcblx0XHR0aGlzLkhEUkxvYWRlciAgICAgICAgID0gSERSTG9hZGVyO1xuXHRcdHRoaXMuR0xURkxvYWRlciAgICAgICAgPSBHTFRGTG9hZGVyO1xuXHRcdHRoaXMubG9hZEltYWdlc1x0XHQgICA9IGxvYWRJbWFnZXM7XG5cdFx0dGhpcy5CYXRjaENvcHkgICAgICAgICA9IEJhdGNoQ29weTtcblx0XHR0aGlzLkJhdGNoQXhpcyAgICAgICAgID0gQmF0Y2hBeGlzO1xuXHRcdHRoaXMuQmF0Y2hCYWxsICAgICAgICAgPSBCYXRjaEJhbGw7XG5cdFx0dGhpcy5CYXRjaEJhbGwgICAgICAgICA9IEJhdGNoQmFsbDtcblx0XHR0aGlzLkJhdGNoTGluZSAgICAgICAgID0gQmF0Y2hMaW5lO1xuXHRcdHRoaXMuQmF0Y2hTa3lib3ggICAgICAgPSBCYXRjaFNreWJveDtcblx0XHR0aGlzLkJhdGNoU2t5ICAgICAgICAgID0gQmF0Y2hTa3k7XG5cdFx0dGhpcy5CYXRjaEZYQUEgICAgICAgICA9IEJhdGNoRlhBQTtcblx0XHR0aGlzLkJhdGNoRG90c1BsYW5lICAgID0gQmF0Y2hEb3RzUGxhbmU7XG5cdFx0dGhpcy5TY2VuZSAgICAgICAgICAgICA9IFNjZW5lO1xuXHRcdHRoaXMuVmlldyAgICAgICAgICAgICAgPSBWaWV3O1xuXHRcdHRoaXMuVmlldzNEICAgICAgICAgICAgPSBWaWV3M0Q7XG5cdFx0dGhpcy5PYmplY3QzRCAgICAgICAgICA9IE9iamVjdDNEO1xuXHRcdHRoaXMuU2hhZGVycyAgICAgICAgICAgPSBTaGFkZXJzO1xuXHRcdHRoaXMuU2hhZGVyTGlicyAgICAgICAgPSBTaGFkZXJMaWJzO1xuXHRcdHRoaXMuV2ViZ2xOdW1iZXIgICAgICAgPSBXZWJnbE51bWJlcjtcblx0XHRcblx0XHR0aGlzLkVmZmVjdENvbXBvc2VyICAgID0gRWZmZWN0Q29tcG9zZXI7XG5cdFx0dGhpcy5QYXNzICAgICAgICBcdCAgID0gUGFzcztcblx0XHR0aGlzLlBhc3NNYWNybyAgICAgICAgID0gUGFzc01hY3JvO1xuXHRcdHRoaXMuUGFzc0JsdXIgICAgICAgICAgPSBQYXNzQmx1cjtcblx0XHR0aGlzLlBhc3NWQmx1ciAgICAgICAgID0gUGFzc1ZCbHVyO1xuXHRcdHRoaXMuUGFzc0hCbHVyICAgICAgICAgPSBQYXNzSEJsdXI7XG5cdFx0dGhpcy5QYXNzRnhhYSAgICAgICAgICA9IFBhc3NGeGFhO1xuXG5cdFx0dGhpcy5NdWx0aXNhbXBsZUZyYW1lQnVmZmVyICAgPSBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyO1xuXHRcdHRoaXMuVHJhbnNmb3JtRmVlZGJhY2tPYmplY3QgID0gVHJhbnNmb3JtRmVlZGJhY2tPYmplY3Q7XG5cblxuXHRcdC8vXHROT1QgU1VQRVIgU1VSRSBJJ1ZFIERPTkUgVEhJUyBJUyBBIEdPT0QgV0FZXG5cblx0XHRmb3IoY29uc3QgcyBpbiBHTE0pIHtcblx0XHRcdGlmKEdMTVtzXSkge1xuXHRcdFx0XHR3aW5kb3dbc10gPSBHTE1bc107XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bG9nKCkge1xuXHRcdGlmKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSkge1xuXHRcdFx0Y29uc29sZS5sb2coYCVjbGliIGFsZnJpZCA6IFZFUlNJT04gJHtWRVJTSU9OfWAsICdiYWNrZ3JvdW5kOiAjMTkzNDQxOyBjb2xvcjogI0ZDRkZGNScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZygnbGliIGFsZnJpZCA6IFZFUlNJT04gJywgVkVSU0lPTik7XG5cdFx0fVxuXHRcdGNvbnNvbGUubG9nKCclY0NsYXNzZXMgOiAnLCAnY29sb3I6ICMxOTM0NDEnKTtcblxuXHRcdGZvcihjb25zdCBzIGluIHRoaXMpIHtcblx0XHRcdGlmKHRoaXNbc10pIHtcblx0XHRcdFx0Y29uc29sZS5sb2coYCVjIC0gJHtzfWAsICdjb2xvcjogIzNFNjA2RicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5jb25zdCBhbCA9IG5ldyBBbGZyaWQoKTtcblxuZXhwb3J0IGRlZmF1bHQgYWw7XG5leHBvcnQge1xuXHRHTCxcblx0R0xTaGFkZXIsXG5cdEdMVGV4dHVyZSxcblx0R0xDdWJlVGV4dHVyZSxcblx0TWVzaCxcblx0R2VvbWV0cnksXG5cdE1hdGVyaWFsLFxuXHRHZW9tLFxuXHRCYXRjaCxcblx0RnJhbWVCdWZmZXIsXG5cdEN1YmVGcmFtZUJ1ZmZlcixcblx0TXVsdGlzYW1wbGVGcmFtZUJ1ZmZlcixcblx0VHJhbnNmb3JtRmVlZGJhY2tPYmplY3QsXG5cdFNjaGVkdWxlcixcblx0RXZlbnREaXNwYXRjaGVyLFxuXHRFYXNlTnVtYmVyLFxuXHRUd2Vlbk51bWJlcixcblx0T3JiaXRhbENvbnRyb2wsXG5cdFdlYmdsTnVtYmVyLFxuXHRRdWF0Um90YXRpb24sXG5cdFRvdWNoRGV0ZWN0b3IsXG5cdENhbWVyYSxcblx0Q2FtZXJhT3J0aG8sXG5cdENhbWVyYVBlcnNwZWN0aXZlLFxuXHRDYW1lcmFDdWJlLFxuXHRSYXksXG5cdE9iamVjdDNELFxuXHRCaW5hcnlMb2FkZXIsXG5cdE9iakxvYWRlcixcblx0SERSTG9hZGVyLFxuXHRHTFRGTG9hZGVyLFxuXHRsb2FkSW1hZ2VzLFxuXHRDb2xsYWRhUGFyc2VyLFxuXHRFZmZlY3RDb21wb3Nlcixcblx0UGFzcyxcblx0UGFzc01hY3JvLFxuXHRQYXNzQmx1cixcblx0UGFzc1ZCbHVyLFxuXHRQYXNzSEJsdXIsXG5cdFBhc3NGeGFhLFxuXHRCYXRjaENvcHksXG5cdEJhdGNoQXhpcyxcblx0QmF0Y2hCYWxsLFxuXHRCYXRjaERvdHNQbGFuZSxcblx0QmF0Y2hMaW5lLFxuXHRCYXRjaFNreWJveCxcblx0QmF0Y2hTa3ksXG5cdEJhdGNoRlhBQSxcblx0U2NlbmUsXG5cdFZpZXcsXG5cdFZpZXczRCxcblx0U2hhZGVycyxcblx0U2hhZGVyTGlic1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC5qcyIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDN4MyBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0M1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXG4gKlxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzRdO1xuICBvdXRbNF0gPSBhWzVdO1xuICBvdXRbNV0gPSBhWzZdO1xuICBvdXRbNl0gPSBhWzhdO1xuICBvdXRbN10gPSBhWzldO1xuICBvdXRbOF0gPSBhWzEwXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0xMDtcbiAgb3V0WzRdID0gbTExO1xuICBvdXRbNV0gPSBtMTI7XG4gIG91dFs2XSA9IG0yMDtcbiAgb3V0WzddID0gbTIxO1xuICBvdXRbOF0gPSBtMjI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgb3V0WzBdID0gbTAwO1xuICBvdXRbMV0gPSBtMDE7XG4gIG91dFsyXSA9IG0wMjtcbiAgb3V0WzNdID0gbTEwO1xuICBvdXRbNF0gPSBtMTE7XG4gIG91dFs1XSA9IG0xMjtcbiAgb3V0WzZdID0gbTIwO1xuICBvdXRbN10gPSBtMjE7XG4gIG91dFs4XSA9IG0yMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICBsZXQgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTEyID0gYVs1XTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYTAxO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYTAyO1xuICAgIG91dFs3XSA9IGExMjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhWzFdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhWzJdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdO1xuICBsZXQgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XTtcbiAgbGV0IGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF07XG5cbiAgbGV0IGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcbiAgbGV0IGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XG4gIGxldCBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICBsZXQgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9IGIwMSAqIGRldDtcbiAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgb3V0WzNdID0gYjExICogZGV0O1xuICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICBvdXRbNl0gPSBiMjEgKiBkZXQ7XG4gIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl07XG4gIGxldCBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdO1xuICBsZXQgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICBvdXRbMF0gPSAoYTExICogYTIyIC0gYTEyICogYTIxKTtcbiAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gIG91dFsyXSA9IChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICBvdXRbM10gPSAoYTEyICogYTIwIC0gYTEwICogYTIyKTtcbiAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gIG91dFs1XSA9IChhMDIgKiBhMTAgLSBhMDAgKiBhMTIpO1xuICBvdXRbNl0gPSAoYTEwICogYTIxIC0gYTExICogYTIwKTtcbiAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gIG91dFs4XSA9IChhMDAgKiBhMTEgLSBhMDEgKiBhMTApO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXTtcbiAgbGV0IGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV07XG4gIGxldCBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBsZXQgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXTtcbiAgbGV0IGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV07XG4gIGxldCBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gIGxldCBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdO1xuICBsZXQgYjEwID0gYlszXSwgYjExID0gYls0XSwgYjEyID0gYls1XTtcbiAgbGV0IGIyMCA9IGJbNl0sIGIyMSA9IGJbN10sIGIyMiA9IGJbOF07XG5cbiAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcblxuICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuXG4gIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuICAgIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICBvdXRbMF0gPSBhMDA7XG4gIG91dFsxXSA9IGEwMTtcbiAgb3V0WzJdID0gYTAyO1xuXG4gIG91dFszXSA9IGExMDtcbiAgb3V0WzRdID0gYTExO1xuICBvdXRbNV0gPSBhMTI7XG5cbiAgb3V0WzZdID0geCAqIGEwMCArIHkgKiBhMTAgKyBhMjA7XG4gIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIG91dFswXSA9IGMgKiBhMDAgKyBzICogYTEwO1xuICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gIG91dFs0XSA9IGMgKiBhMTEgLSBzICogYTAxO1xuICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICBvdXRbNl0gPSBhMjA7XG4gIG91dFs3XSA9IGEyMTtcbiAgb3V0WzhdID0gYTIyO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICBsZXQgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gIG91dFswXSA9IHggKiBhWzBdO1xuICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgb3V0WzJdID0geCAqIGFbMl07XG5cbiAgb3V0WzNdID0geSAqIGFbM107XG4gIG91dFs0XSA9IHkgKiBhWzRdO1xuICBvdXRbNV0gPSB5ICogYVs1XTtcblxuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IHZbMF07XG4gIG91dFs3XSA9IHZbMV07XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IDA7XG5cbiAgb3V0WzNdID0gLXM7XG4gIG91dFs0XSA9IGM7XG4gIG91dFs1XSA9IDA7XG5cbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG5cbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gdlsxXTtcbiAgb3V0WzVdID0gMDtcblxuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQyZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gMDtcblxuICBvdXRbM10gPSBhWzJdO1xuICBvdXRbNF0gPSBhWzNdO1xuICBvdXRbNV0gPSAwO1xuXG4gIG91dFs2XSA9IGFbNF07XG4gIG91dFs3XSA9IGFbNV07XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIGxldCB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXTtcbiAgbGV0IHgyID0geCArIHg7XG4gIGxldCB5MiA9IHkgKyB5O1xuICBsZXQgejIgPSB6ICsgejtcblxuICBsZXQgeHggPSB4ICogeDI7XG4gIGxldCB5eCA9IHkgKiB4MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgenggPSB6ICogeDI7XG4gIGxldCB6eSA9IHogKiB5MjtcbiAgbGV0IHp6ID0geiAqIHoyO1xuICBsZXQgd3ggPSB3ICogeDI7XG4gIGxldCB3eSA9IHcgKiB5MjtcbiAgbGV0IHd6ID0gdyAqIHoyO1xuXG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbM10gPSB5eCAtIHd6O1xuICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFs1XSA9IHp5ICsgd3g7XG4gIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxGcm9tTWF0NChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgbGV0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgbGV0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgbGV0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgbGV0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgbGV0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgbGV0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgbGV0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgbGV0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgbGV0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgbGV0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgbGV0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgbGV0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIGxldCBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbMl0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcblxuICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuXG4gIG91dFs2XSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSAyRCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgeW91ciBnbCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiBnbCBjb250ZXh0XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0aW9uKG91dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIG91dFswXSA9IDIgLyB3aWR0aDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAtMiAvIGhlaWdodDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IC0xO1xuICAgIG91dFs3XSA9IDE7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArXG4gICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnLCAnICtcbiAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSkpXG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MydzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG5cblxuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgb3V0WzZdID0gYVs2XSArIChiWzZdICogc2NhbGUpO1xuICBvdXRbN10gPSBhWzddICsgKGJbN10gKiBzY2FsZSk7XG4gIG91dFs4XSA9IGFbOF0gKyAoYls4XSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJlxuICAgICAgICAgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiZcbiAgICAgICAgIGFbNl0gPT09IGJbNl0gJiYgYVs3XSA9PT0gYls3XSAmJiBhWzhdID09PSBiWzhdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLCBhNiA9IGFbNl0sIGE3ID0gYVs3XSwgYTggPSBhWzhdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XSwgYjYgPSBiWzZdLCBiNyA9IGJbN10sIGI4ID0gYls4XTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE4IC0gYjgpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDMuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjM1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICBsZXQgeCA9IGJbMF0gLSBhWzBdO1xuICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICBsZXQgeiA9IGJbMl0gLSBhWzJdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgbGV0IHggPSBiWzBdIC0gYVswXTtcbiAgbGV0IHkgPSBiWzFdIC0gYVsxXTtcbiAgbGV0IHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCBsZW4gPSB4KnggKyB5KnkgKyB6Kno7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl07XG4gIGxldCBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICBsZXQgYXggPSBhWzBdO1xuICBsZXQgYXkgPSBhWzFdO1xuICBsZXQgYXogPSBhWzJdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgaGVybWl0ZSBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXJtaXRlKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICBsZXQgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIGxldCBmYWN0b3IxID0gZmFjdG9yVGltZXMyICogKDIgKiB0IC0gMykgKyAxO1xuICBsZXQgZmFjdG9yMiA9IGZhY3RvclRpbWVzMiAqICh0IC0gMikgKyB0O1xuICBsZXQgZmFjdG9yMyA9IGZhY3RvclRpbWVzMiAqICh0IC0gMSk7XG4gIGxldCBmYWN0b3I0ID0gZmFjdG9yVGltZXMyICogKDMgLSAyICogdCk7XG5cbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlemllcihvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgbGV0IGludmVyc2VGYWN0b3IgPSAxIC0gdDtcbiAgbGV0IGludmVyc2VGYWN0b3JUaW1lc1R3byA9IGludmVyc2VGYWN0b3IgKiBpbnZlcnNlRmFjdG9yO1xuICBsZXQgZmFjdG9yVGltZXMyID0gdCAqIHQ7XG4gIGxldCBmYWN0b3IxID0gaW52ZXJzZUZhY3RvclRpbWVzVHdvICogaW52ZXJzZUZhY3RvcjtcbiAgbGV0IGZhY3RvcjIgPSAzICogdCAqIGludmVyc2VGYWN0b3JUaW1lc1R3bztcbiAgbGV0IGZhY3RvcjMgPSAzICogZmFjdG9yVGltZXMyICogaW52ZXJzZUZhY3RvcjtcbiAgbGV0IGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiB0O1xuXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgbGV0IHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIGxldCB6ID0gKGdsTWF0cml4LlJBTkRPTSgpICogMi4wKSAtIDEuMDtcbiAgbGV0IHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlO1xuXG4gIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZTtcbiAgb3V0WzJdID0geiAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDQuXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICBsZXQgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgdyA9IHcgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1RdWF0KG91dCwgYSwgcSkge1xuICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gIGxldCB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdO1xuICBsZXQgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdO1xuXG4gIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gIGxldCBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgbGV0IGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICBsZXQgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gIGxldCBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICBvdXRbMV0gPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpe1xuICBsZXQgcCA9IFtdLCByPVtdO1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07XG5cbiAgLy9wZXJmb3JtIHJvdGF0aW9uXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSpNYXRoLmNvcyhjKSAtIHBbMl0qTWF0aC5zaW4oYyk7XG4gIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuICAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIG91dFswXSA9IHJbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSByWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gclsyXSArIGJbMl07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCBjKXtcbiAgbGV0IHAgPSBbXSwgcj1bXTtcbiAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdO1xuXG4gIC8vcGVyZm9ybSByb3RhdGlvblxuICByWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIHJbMV0gPSBwWzFdO1xuICByWzJdID0gcFsyXSpNYXRoLmNvcyhjKSAtIHBbMF0qTWF0aC5zaW4oYyk7XG5cbiAgLy90cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICBvdXRbMF0gPSByWzBdICsgYlswXTtcbiAgb3V0WzFdID0gclsxXSArIGJbMV07XG4gIG91dFsyXSA9IHJbMl0gKyBiWzJdO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYyl7XG4gIGxldCBwID0gW10sIHI9W107XG4gIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgcFswXSA9IGFbMF0gLSBiWzBdO1xuICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIHBbMl0gPSBhWzJdIC0gYlsyXTtcblxuICAvL3BlcmZvcm0gcm90YXRpb25cbiAgclswXSA9IHBbMF0qTWF0aC5jb3MoYykgLSBwWzFdKk1hdGguc2luKGMpO1xuICByWzFdID0gcFswXSpNYXRoLnNpbihjKSArIHBbMV0qTWF0aC5jb3MoYyk7XG4gIHJbMl0gPSBwWzJdO1xuXG4gIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICBsZXQgdGVtcEEgPSBmcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pO1xuICBsZXQgdGVtcEIgPSBmcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuXG4gIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpO1xuICBub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcblxuICBsZXQgY29zaW5lID0gZG90KHRlbXBBLCB0ZW1wQik7XG5cbiAgaWYoY29zaW5lID4gMS4wKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZWxzZSBpZihjb3NpbmUgPCAtMS4wKSB7XG4gICAgcmV0dXJuIE1hdGguUEk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXTtcbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXN0ID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gIGxldCB2ZWMgPSBjcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgbGV0IGksIGw7XG4gICAgaWYoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMztcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzMuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjNFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxuICpcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6LCB3KSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjNCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHosIHcpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguZmxvb3IoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICBvdXRbM10gPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIG91dFszXSA9IE1hdGgubWF4KGFbM10sIGJbM10pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLnJvdW5kKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIGxldCB4ID0gYlswXSAtIGFbMF07XG4gIGxldCB5ID0gYlsxXSAtIGFbMV07XG4gIGxldCB6ID0gYlsyXSAtIGFbMl07XG4gIGxldCB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICBsZXQgeCA9IGJbMF0gLSBhWzBdO1xuICBsZXQgeSA9IGJbMV0gLSBhWzFdO1xuICBsZXQgeiA9IGJbMl0gLSBhWzJdO1xuICBsZXQgdyA9IGJbM10gLSBhWzNdO1xuICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgbGV0IHogPSBhWzJdO1xuICBsZXQgdyA9IGFbM107XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCB3ID0gYVszXTtcbiAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn1cblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSAtYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIGxldCB4ID0gYVswXTtcbiAgbGV0IHkgPSBhWzFdO1xuICBsZXQgeiA9IGFbMl07XG4gIGxldCB3ID0gYVszXTtcbiAgbGV0IGxlbiA9IHgqeCArIHkqeSArIHoqeiArIHcqdztcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgb3V0WzBdID0geCAqIGxlbjtcbiAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgIG91dFsyXSA9IHogKiBsZW47XG4gICAgb3V0WzNdID0gdyAqIGxlbjtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl0gKyBhWzNdICogYlszXTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIGxldCBheCA9IGFbMF07XG4gIGxldCBheSA9IGFbMV07XG4gIGxldCBheiA9IGFbMl07XG4gIGxldCBhdyA9IGFbM107XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIG91dFszXSA9IGF3ICsgdCAqIChiWzNdIC0gYXcpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCB2ZWN0b3JTY2FsZSkge1xuICB2ZWN0b3JTY2FsZSA9IHZlY3RvclNjYWxlIHx8IDEuMDtcblxuICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgb3V0WzBdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIG91dFsxXSA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICBvdXRbMl0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgb3V0WzNdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gIHNjYWxlKG91dCwgb3V0LCB2ZWN0b3JTY2FsZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgbWF0NC5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICBsZXQgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10gKiB3O1xuICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgbGV0IHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gIGxldCBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM107XG5cbiAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgbGV0IGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICBsZXQgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gIGxldCBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgbGV0IGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3ViID0gc3VidHJhY3Q7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXYgPSBkaXZpZGU7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkaXN0ID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBsZW4gPSBsZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gIGxldCB2ZWMgPSBjcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgbGV0IGksIGw7XG4gICAgaWYoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gNDtcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0pKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWM0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFdlYmdsQ29uc3QuanNcblxuLy8gc3RvbGVuIHRoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbC9nbC1jb25zdGFudHMgdGhhbmtzIEBtYXR0ZGVzbCBeXlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0QUNUSVZFX0FUVFJJQlVURVM6IDM1NzIxLFxuXHRBQ1RJVkVfQVRUUklCVVRFX01BWF9MRU5HVEg6IDM1NzIyLFxuXHRBQ1RJVkVfVEVYVFVSRTogMzQwMTYsXG5cdEFDVElWRV9VTklGT1JNUzogMzU3MTgsXG5cdEFDVElWRV9VTklGT1JNX01BWF9MRU5HVEg6IDM1NzE5LFxuXHRBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0U6IDMzOTAyLFxuXHRBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0U6IDMzOTAxLFxuXHRBTFBIQTogNjQwNixcblx0QUxQSEFfQklUUzogMzQxMyxcblx0QUxXQVlTOiA1MTksXG5cdEFSUkFZX0JVRkZFUjogMzQ5NjIsXG5cdEFSUkFZX0JVRkZFUl9CSU5ESU5HOiAzNDk2NCxcblx0QVRUQUNIRURfU0hBREVSUzogMzU3MTcsXG5cdEJBQ0s6IDEwMjksXG5cdEJMRU5EOiAzMDQyLFxuXHRCTEVORF9DT0xPUjogMzI3NzMsXG5cdEJMRU5EX0RTVF9BTFBIQTogMzI5NzAsXG5cdEJMRU5EX0RTVF9SR0I6IDMyOTY4LFxuXHRCTEVORF9FUVVBVElPTjogMzI3NzcsXG5cdEJMRU5EX0VRVUFUSU9OX0FMUEhBOiAzNDg3Nyxcblx0QkxFTkRfRVFVQVRJT05fUkdCOiAzMjc3Nyxcblx0QkxFTkRfU1JDX0FMUEhBOiAzMjk3MSxcblx0QkxFTkRfU1JDX1JHQjogMzI5NjksXG5cdEJMVUVfQklUUzogMzQxMixcblx0Qk9PTDogMzU2NzAsXG5cdEJPT0xfVkVDMjogMzU2NzEsXG5cdEJPT0xfVkVDMzogMzU2NzIsXG5cdEJPT0xfVkVDNDogMzU2NzMsXG5cdEJST1dTRVJfREVGQVVMVF9XRUJHTDogMzc0NDQsXG5cdEJVRkZFUl9TSVpFOiAzNDY2MCxcblx0QlVGRkVSX1VTQUdFOiAzNDY2MSxcblx0QllURTogNTEyMCxcblx0Q0NXOiAyMzA1LFxuXHRDTEFNUF9UT19FREdFOiAzMzA3MSxcblx0Q09MT1JfQVRUQUNITUVOVDA6IDM2MDY0LFxuXHRDT0xPUl9CVUZGRVJfQklUOiAxNjM4NCxcblx0Q09MT1JfQ0xFQVJfVkFMVUU6IDMxMDYsXG5cdENPTE9SX1dSSVRFTUFTSzogMzEwNyxcblx0Q09NUElMRV9TVEFUVVM6IDM1NzEzLFxuXHRDT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUzogMzQ0NjcsXG5cdENPTlNUQU5UX0FMUEhBOiAzMjc3MSxcblx0Q09OU1RBTlRfQ09MT1I6IDMyNzY5LFxuXHRDT05URVhUX0xPU1RfV0VCR0w6IDM3NDQyLFxuXHRDVUxMX0ZBQ0U6IDI4ODQsXG5cdENVTExfRkFDRV9NT0RFOiAyODg1LFxuXHRDVVJSRU5UX1BST0dSQU06IDM1NzI1LFxuXHRDVVJSRU5UX1ZFUlRFWF9BVFRSSUI6IDM0MzQyLFxuXHRDVzogMjMwNCxcblx0REVDUjogNzY4Myxcblx0REVDUl9XUkFQOiAzNDA1Nixcblx0REVMRVRFX1NUQVRVUzogMzU3MTIsXG5cdERFUFRIX0FUVEFDSE1FTlQ6IDM2MDk2LFxuXHRERVBUSF9CSVRTOiAzNDE0LFxuXHRERVBUSF9CVUZGRVJfQklUOiAyNTYsXG5cdERFUFRIX0NMRUFSX1ZBTFVFOiAyOTMxLFxuXHRERVBUSF9DT01QT05FTlQ6IDY0MDIsXG5cdFJFRDogNjQwMyxcblx0REVQVEhfQ09NUE9ORU5UMTY6IDMzMTg5LFxuXHRERVBUSF9GVU5DOiAyOTMyLFxuXHRERVBUSF9SQU5HRTogMjkyOCxcblx0REVQVEhfU1RFTkNJTDogMzQwNDEsXG5cdERFUFRIX1NURU5DSUxfQVRUQUNITUVOVDogMzMzMDYsXG5cdERFUFRIX1RFU1Q6IDI5MjksXG5cdERFUFRIX1dSSVRFTUFTSzogMjkzMCxcblx0RElUSEVSOiAzMDI0LFxuXHRET05UX0NBUkU6IDQzNTIsXG5cdERTVF9BTFBIQTogNzcyLFxuXHREU1RfQ09MT1I6IDc3NCxcblx0RFlOQU1JQ19EUkFXOiAzNTA0OCxcblx0RUxFTUVOVF9BUlJBWV9CVUZGRVI6IDM0OTYzLFxuXHRFTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HOiAzNDk2NSxcblx0RVFVQUw6IDUxNCxcblx0RkFTVEVTVDogNDM1Myxcblx0RkxPQVQ6IDUxMjYsXG5cdEZMT0FUX01BVDI6IDM1Njc0LFxuXHRGTE9BVF9NQVQzOiAzNTY3NSxcblx0RkxPQVRfTUFUNDogMzU2NzYsXG5cdEZMT0FUX1ZFQzI6IDM1NjY0LFxuXHRGTE9BVF9WRUMzOiAzNTY2NSxcblx0RkxPQVRfVkVDNDogMzU2NjYsXG5cdEZSQUdNRU5UX1NIQURFUjogMzU2MzIsXG5cdEZSQU1FQlVGRkVSOiAzNjE2MCxcblx0RlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRTogMzYwNDksXG5cdEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfT0JKRUNUX1RZUEU6IDM2MDQ4LFxuXHRGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfQ1VCRV9NQVBfRkFDRTogMzYwNTEsXG5cdEZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTDogMzYwNTAsXG5cdEZSQU1FQlVGRkVSX0JJTkRJTkc6IDM2MDA2LFxuXHRGUkFNRUJVRkZFUl9DT01QTEVURTogMzYwNTMsXG5cdEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDogMzYwNTQsXG5cdEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzogMzYwNTcsXG5cdEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOiAzNjA1NSxcblx0RlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6IDM2MDYxLFxuXHRGUk9OVDogMTAyOCxcblx0RlJPTlRfQU5EX0JBQ0s6IDEwMzIsXG5cdEZST05UX0ZBQ0U6IDI4ODYsXG5cdEZVTkNfQUREOiAzMjc3NCxcblx0RlVOQ19SRVZFUlNFX1NVQlRSQUNUOiAzMjc3OSxcblx0RlVOQ19TVUJUUkFDVDogMzI3NzgsXG5cdEdFTkVSQVRFX01JUE1BUF9ISU5UOiAzMzE3MCxcblx0R0VRVUFMOiA1MTgsXG5cdEdSRUFURVI6IDUxNixcblx0R1JFRU5fQklUUzogMzQxMSxcblx0SElHSF9GTE9BVDogMzYzMzgsXG5cdEhJR0hfSU5UOiAzNjM0MSxcblx0SU5DUjogNzY4Mixcblx0SU5DUl9XUkFQOiAzNDA1NSxcblx0SU5GT19MT0dfTEVOR1RIOiAzNTcxNixcblx0SU5UOiA1MTI0LFxuXHRJTlRfVkVDMjogMzU2NjcsXG5cdElOVF9WRUMzOiAzNTY2OCxcblx0SU5UX1ZFQzQ6IDM1NjY5LFxuXHRJTlZBTElEX0VOVU06IDEyODAsXG5cdElOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOiAxMjg2LFxuXHRJTlZBTElEX09QRVJBVElPTjogMTI4Mixcblx0SU5WQUxJRF9WQUxVRTogMTI4MSxcblx0SU5WRVJUOiA1Mzg2LFxuXHRLRUVQOiA3NjgwLFxuXHRMRVFVQUw6IDUxNSxcblx0TEVTUzogNTEzLFxuXHRMSU5FQVI6IDk3MjksXG5cdExJTkVBUl9NSVBNQVBfTElORUFSOiA5OTg3LFxuXHRMSU5FQVJfTUlQTUFQX05FQVJFU1Q6IDk5ODUsXG5cdExJTkVTOiAxLFxuXHRMSU5FX0xPT1A6IDIsXG5cdExJTkVfU1RSSVA6IDMsXG5cdExJTkVfV0lEVEg6IDI4NDksXG5cdExJTktfU1RBVFVTOiAzNTcxNCxcblx0TE9XX0ZMT0FUOiAzNjMzNixcblx0TE9XX0lOVDogMzYzMzksXG5cdExVTUlOQU5DRTogNjQwOSxcblx0TFVNSU5BTkNFX0FMUEhBOiA2NDEwLFxuXHRNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUzogMzU2NjEsXG5cdE1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkU6IDM0MDc2LFxuXHRNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTOiAzNjM0OSxcblx0TUFYX1JFTkRFUkJVRkZFUl9TSVpFOiAzNDAyNCxcblx0TUFYX1RFWFRVUkVfSU1BR0VfVU5JVFM6IDM0OTMwLFxuXHRNQVhfVEVYVFVSRV9TSVpFOiAzMzc5LFxuXHRNQVhfVkFSWUlOR19WRUNUT1JTOiAzNjM0OCxcblx0TUFYX1ZFUlRFWF9BVFRSSUJTOiAzNDkyMSxcblx0TUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTOiAzNTY2MCxcblx0TUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlM6IDM2MzQ3LFxuXHRNQVhfVklFV1BPUlRfRElNUzogMzM4Nixcblx0TUVESVVNX0ZMT0FUOiAzNjMzNyxcblx0TUVESVVNX0lOVDogMzYzNDAsXG5cdE1JUlJPUkVEX1JFUEVBVDogMzM2NDgsXG5cdE5FQVJFU1Q6IDk3MjgsXG5cdE5FQVJFU1RfTUlQTUFQX0xJTkVBUjogOTk4Nixcblx0TkVBUkVTVF9NSVBNQVBfTkVBUkVTVDogOTk4NCxcblx0TkVWRVI6IDUxMixcblx0TklDRVNUOiA0MzU0LFxuXHROT05FOiAwLFxuXHROT1RFUVVBTDogNTE3LFxuXHROT19FUlJPUjogMCxcblx0TlVNX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTOiAzNDQ2Nixcblx0T05FOiAxLFxuXHRPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEE6IDMyNzcyLFxuXHRPTkVfTUlOVVNfQ09OU1RBTlRfQ09MT1I6IDMyNzcwLFxuXHRPTkVfTUlOVVNfRFNUX0FMUEhBOiA3NzMsXG5cdE9ORV9NSU5VU19EU1RfQ09MT1I6IDc3NSxcblx0T05FX01JTlVTX1NSQ19BTFBIQTogNzcxLFxuXHRPTkVfTUlOVVNfU1JDX0NPTE9SOiA3NjksXG5cdE9VVF9PRl9NRU1PUlk6IDEyODUsXG5cdFBBQ0tfQUxJR05NRU5UOiAzMzMzLFxuXHRQT0lOVFM6IDAsXG5cdFBPTFlHT05fT0ZGU0VUX0ZBQ1RPUjogMzI4MjQsXG5cdFBPTFlHT05fT0ZGU0VUX0ZJTEw6IDMyODIzLFxuXHRQT0xZR09OX09GRlNFVF9VTklUUzogMTA3NTIsXG5cdFJFRF9CSVRTOiAzNDEwLFxuXHRSRU5ERVJCVUZGRVI6IDM2MTYxLFxuXHRSRU5ERVJCVUZGRVJfQUxQSEFfU0laRTogMzYxNzksXG5cdFJFTkRFUkJVRkZFUl9CSU5ESU5HOiAzNjAwNyxcblx0UkVOREVSQlVGRkVSX0JMVUVfU0laRTogMzYxNzgsXG5cdFJFTkRFUkJVRkZFUl9ERVBUSF9TSVpFOiAzNjE4MCxcblx0UkVOREVSQlVGRkVSX0dSRUVOX1NJWkU6IDM2MTc3LFxuXHRSRU5ERVJCVUZGRVJfSEVJR0hUOiAzNjE2Myxcblx0UkVOREVSQlVGRkVSX0lOVEVSTkFMX0ZPUk1BVDogMzYxNjQsXG5cdFJFTkRFUkJVRkZFUl9SRURfU0laRTogMzYxNzYsXG5cdFJFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkU6IDM2MTgxLFxuXHRSRU5ERVJCVUZGRVJfV0lEVEg6IDM2MTYyLFxuXHRSRU5ERVJFUjogNzkzNyxcblx0UkVQRUFUOiAxMDQ5Nyxcblx0UkVQTEFDRTogNzY4MSxcblx0UkdCOiA2NDA3LFxuXHRSR0I1X0ExOiAzMjg1NSxcblx0UkdCNTY1OiAzNjE5NCxcblx0UkdCQTogNjQwOCxcblx0UkdCQTQ6IDMyODU0LFxuXHRTQU1QTEVSXzJEOiAzNTY3OCxcblx0U0FNUExFUl9DVUJFOiAzNTY4MCxcblx0U0FNUExFUzogMzI5MzcsXG5cdFNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRTogMzI5MjYsXG5cdFNBTVBMRV9CVUZGRVJTOiAzMjkzNixcblx0U0FNUExFX0NPVkVSQUdFOiAzMjkyOCxcblx0U0FNUExFX0NPVkVSQUdFX0lOVkVSVDogMzI5MzksXG5cdFNBTVBMRV9DT1ZFUkFHRV9WQUxVRTogMzI5MzgsXG5cdFNDSVNTT1JfQk9YOiAzMDg4LFxuXHRTQ0lTU09SX1RFU1Q6IDMwODksXG5cdFNIQURFUl9DT01QSUxFUjogMzYzNDYsXG5cdFNIQURFUl9TT1VSQ0VfTEVOR1RIOiAzNTcyMCxcblx0U0hBREVSX1RZUEU6IDM1NjYzLFxuXHRTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT046IDM1NzI0LFxuXHRTSE9SVDogNTEyMixcblx0U1JDX0FMUEhBOiA3NzAsXG5cdFNSQ19BTFBIQV9TQVRVUkFURTogNzc2LFxuXHRTUkNfQ09MT1I6IDc2OCxcblx0U1RBVElDX0RSQVc6IDM1MDQ0LFxuXHRTVEVOQ0lMX0FUVEFDSE1FTlQ6IDM2MTI4LFxuXHRTVEVOQ0lMX0JBQ0tfRkFJTDogMzQ4MTcsXG5cdFNURU5DSUxfQkFDS19GVU5DOiAzNDgxNixcblx0U1RFTkNJTF9CQUNLX1BBU1NfREVQVEhfRkFJTDogMzQ4MTgsXG5cdFNURU5DSUxfQkFDS19QQVNTX0RFUFRIX1BBU1M6IDM0ODE5LFxuXHRTVEVOQ0lMX0JBQ0tfUkVGOiAzNjAwMyxcblx0U1RFTkNJTF9CQUNLX1ZBTFVFX01BU0s6IDM2MDA0LFxuXHRTVEVOQ0lMX0JBQ0tfV1JJVEVNQVNLOiAzNjAwNSxcblx0U1RFTkNJTF9CSVRTOiAzNDE1LFxuXHRTVEVOQ0lMX0JVRkZFUl9CSVQ6IDEwMjQsXG5cdFNURU5DSUxfQ0xFQVJfVkFMVUU6IDI5NjEsXG5cdFNURU5DSUxfRkFJTDogMjk2NCxcblx0U1RFTkNJTF9GVU5DOiAyOTYyLFxuXHRTVEVOQ0lMX0lOREVYOiA2NDAxLFxuXHRTVEVOQ0lMX0lOREVYODogMzYxNjgsXG5cdFNURU5DSUxfUEFTU19ERVBUSF9GQUlMOiAyOTY1LFxuXHRTVEVOQ0lMX1BBU1NfREVQVEhfUEFTUzogMjk2Nixcblx0U1RFTkNJTF9SRUY6IDI5NjcsXG5cdFNURU5DSUxfVEVTVDogMjk2MCxcblx0U1RFTkNJTF9WQUxVRV9NQVNLOiAyOTYzLFxuXHRTVEVOQ0lMX1dSSVRFTUFTSzogMjk2OCxcblx0U1RSRUFNX0RSQVc6IDM1MDQwLFxuXHRTVUJQSVhFTF9CSVRTOiAzNDA4LFxuXHRURVhUVVJFOiA1ODkwLFxuXHRURVhUVVJFMDogMzM5ODQsXG5cdFRFWFRVUkUxOiAzMzk4NSxcblx0VEVYVFVSRTI6IDMzOTg2LFxuXHRURVhUVVJFMzogMzM5ODcsXG5cdFRFWFRVUkU0OiAzMzk4OCxcblx0VEVYVFVSRTU6IDMzOTg5LFxuXHRURVhUVVJFNjogMzM5OTAsXG5cdFRFWFRVUkU3OiAzMzk5MSxcblx0VEVYVFVSRTg6IDMzOTkyLFxuXHRURVhUVVJFOTogMzM5OTMsXG5cdFRFWFRVUkUxMDogMzM5OTQsXG5cdFRFWFRVUkUxMTogMzM5OTUsXG5cdFRFWFRVUkUxMjogMzM5OTYsXG5cdFRFWFRVUkUxMzogMzM5OTcsXG5cdFRFWFRVUkUxNDogMzM5OTgsXG5cdFRFWFRVUkUxNTogMzM5OTksXG5cdFRFWFRVUkUxNjogMzQwMDAsXG5cdFRFWFRVUkUxNzogMzQwMDEsXG5cdFRFWFRVUkUxODogMzQwMDIsXG5cdFRFWFRVUkUxOTogMzQwMDMsXG5cdFRFWFRVUkUyMDogMzQwMDQsXG5cdFRFWFRVUkUyMTogMzQwMDUsXG5cdFRFWFRVUkUyMjogMzQwMDYsXG5cdFRFWFRVUkUyMzogMzQwMDcsXG5cdFRFWFRVUkUyNDogMzQwMDgsXG5cdFRFWFRVUkUyNTogMzQwMDksXG5cdFRFWFRVUkUyNjogMzQwMTAsXG5cdFRFWFRVUkUyNzogMzQwMTEsXG5cdFRFWFRVUkUyODogMzQwMTIsXG5cdFRFWFRVUkUyOTogMzQwMTMsXG5cdFRFWFRVUkUzMDogMzQwMTQsXG5cdFRFWFRVUkUzMTogMzQwMTUsXG5cdFRFWFRVUkVfMkQ6IDM1NTMsXG5cdFRFWFRVUkVfQklORElOR18yRDogMzI4NzMsXG5cdFRFWFRVUkVfQklORElOR19DVUJFX01BUDogMzQwNjgsXG5cdFRFWFRVUkVfQ1VCRV9NQVA6IDM0MDY3LFxuXHRURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1g6IDM0MDcwLFxuXHRURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1k6IDM0MDcyLFxuXHRURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1o6IDM0MDc0LFxuXHRURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1g6IDM0MDY5LFxuXHRURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1k6IDM0MDcxLFxuXHRURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1o6IDM0MDczLFxuXHRURVhUVVJFX01BR19GSUxURVI6IDEwMjQwLFxuXHRURVhUVVJFX01JTl9GSUxURVI6IDEwMjQxLFxuXHRURVhUVVJFX1dSQVBfUzogMTAyNDIsXG5cdFRFWFRVUkVfV1JBUF9UOiAxMDI0Myxcblx0VFJJQU5HTEVTOiA0LFxuXHRUUklBTkdMRV9GQU46IDYsXG5cdFRSSUFOR0xFX1NUUklQOiA1LFxuXHRVTlBBQ0tfQUxJR05NRU5UOiAzMzE3LFxuXHRVTlBBQ0tfQ09MT1JTUEFDRV9DT05WRVJTSU9OX1dFQkdMOiAzNzQ0Myxcblx0VU5QQUNLX0ZMSVBfWV9XRUJHTDogMzc0NDAsXG5cdFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTDogMzc0NDEsXG5cdFVOU0lHTkVEX0JZVEU6IDUxMjEsXG5cdFVOU0lHTkVEX0lOVDogNTEyNSxcblx0VU5TSUdORURfU0hPUlQ6IDUxMjMsXG5cdFVOU0lHTkVEX1NIT1JUXzRfNF80XzQ6IDMyODE5LFxuXHRVTlNJR05FRF9TSE9SVF81XzVfNV8xOiAzMjgyMCxcblx0VU5TSUdORURfU0hPUlRfNV82XzU6IDMzNjM1LFxuXHRWQUxJREFURV9TVEFUVVM6IDM1NzE1LFxuXHRWRU5ET1I6IDc5MzYsXG5cdFZFUlNJT046IDc5MzgsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfQlVGRkVSX0JJTkRJTkc6IDM0OTc1LFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX0VOQUJMRUQ6IDM0MzM4LFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRUQ6IDM0OTIyLFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX1BPSU5URVI6IDM0MzczLFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX1NJWkU6IDM0MzM5LFxuXHRWRVJURVhfQVRUUklCX0FSUkFZX1NUUklERTogMzQzNDAsXG5cdFZFUlRFWF9BVFRSSUJfQVJSQVlfVFlQRTogMzQzNDEsXG5cdFZFUlRFWF9TSEFERVI6IDM1NjMzLFxuXHRWSUVXUE9SVDogMjk3OCxcblx0WkVSTzogMCxcblx0Ujg6IDMzMzIxLFxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9XZWJnbENvbnN0LmpzIiwiLy8gZ2V0QXR0cmliTG9jLmpzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChnbCwgc2hhZGVyUHJvZ3JhbSwgbmFtZSkge1xuXHRpZihzaGFkZXJQcm9ncmFtLmNhY2hlQXR0cmliTG9jID09PSB1bmRlZmluZWQpIHtcdHNoYWRlclByb2dyYW0uY2FjaGVBdHRyaWJMb2MgPSB7fTtcdH1cblx0aWYoc2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvY1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0c2hhZGVyUHJvZ3JhbS5jYWNoZUF0dHJpYkxvY1tuYW1lXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHNoYWRlclByb2dyYW0sIG5hbWUpO1xuXHR9XG5cblx0cmV0dXJuIHNoYWRlclByb2dyYW0uY2FjaGVBdHRyaWJMb2NbbmFtZV07XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL2dldEF0dHJpYkxvYy5qcyIsIi8vIE1hdGVyaWFsLmpzXG5cbmltcG9ydCBTaGFkZXJzIGZyb20gJy4vc2hhZGVycy9TaGFkZXJzJztcbmltcG9ydCBvYmplY3RBc3NpZ24gZnJvbSAnb2JqZWN0LWFzc2lnbic7XG5cbmNsYXNzIE1hdGVyaWFsIHtcblxuXHRjb25zdHJ1Y3Rvcih2cywgZnMsIHVuaWZvcm1zPXt9LCBkZWZpbmVzPXt9KSB7XG5cdFx0dGhpcy5fc2hhZGVyID0gU2hhZGVycy5nZXQodnMsIGZzLCBkZWZpbmVzKTtcblx0XHR0aGlzLnVuaWZvcm1zID0gb2JqZWN0QXNzaWduKHt9LCB1bmlmb3Jtcyk7XG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cdFx0dGhpcy5fc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLl9zaGFkZXIudW5pZm9ybSh0aGlzLnVuaWZvcm1zKTtcblx0fVxuXG5cblx0Z2V0IHNoYWRlcigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2hhZGVyO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hdGVyaWFsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL01hdGVyaWFsLmpzIiwiLy8gRXZlbnREaXNwYXRjaGVyLmpzXG5cbmxldCBzdXBwb3J0c0N1c3RvbUV2ZW50cyA9IHRydWU7XG50cnkge1xuXHRsZXQgbmV3VGVzdEN1c3RvbUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG5cdG5ld1Rlc3RDdXN0b21FdmVudCA9IG51bGw7XG59IGNhdGNoKGUpIHtcblx0c3VwcG9ydHNDdXN0b21FdmVudHMgPSBmYWxzZTtcbn1cblxuY2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuXHR9XG5cblxuXHRhZGRFdmVudExpc3RlbmVyKGFFdmVudFR5cGUsIGFGdW5jdGlvbikge1xuXG5cdFx0aWYodGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IG51bGwgfHwgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHR9XG5cblx0XHRpZighdGhpcy5fZXZlbnRMaXN0ZW5lcnNbYUV2ZW50VHlwZV0pIHtcblx0XHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdID0gW107XG5cdFx0fVxuXHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzW2FFdmVudFR5cGVdLnB1c2goYUZ1bmN0aW9uKTtcblx0XHRcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0b24oYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKSB7XHRyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKGFFdmVudFR5cGUsIGFGdW5jdGlvbik7XHR9XG5cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pIHtcblx0XHRpZih0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gbnVsbCB8fCB0aGlzLl9ldmVudExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuXHRcdH1cblx0XHRjb25zdCBjdXJyZW50QXJyYXkgPSB0aGlzLl9ldmVudExpc3RlbmVyc1thRXZlbnRUeXBlXTtcblx0XHRcblx0XHRpZiAodHlwZW9mKGN1cnJlbnRBcnJheSkgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0XG5cdFx0bGV0IGN1cnJlbnRBcnJheUxlbmd0aCA9IGN1cnJlbnRBcnJheS5sZW5ndGg7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcnJheUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZihjdXJyZW50QXJyYXlbaV0gPT09IGFGdW5jdGlvbikge1xuXHRcdFx0XHRjdXJyZW50QXJyYXkuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRpLS07XG5cdFx0XHRcdGN1cnJlbnRBcnJheUxlbmd0aC0tO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdG9mZihhRXZlbnRUeXBlLCBhRnVuY3Rpb24pIHtcdHJldHVybiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoYUV2ZW50VHlwZSwgYUZ1bmN0aW9uKTtcdH1cblxuXHRkaXNwYXRjaEV2ZW50KGFFdmVudCkge1xuXHRcdGlmKHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSBudWxsIHx8IHRoaXMuX2V2ZW50TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge307XG5cdFx0fVxuXHRcdGNvbnN0IGV2ZW50VHlwZSA9IGFFdmVudC50eXBlO1xuXHRcdFxuXHRcdHRyeSB7XG5cdFx0XHRpZihhRXZlbnQudGFyZ2V0ID09PSBudWxsKSB7XG5cdFx0XHRcdGFFdmVudC50YXJnZXQgPSB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0YUV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXHRcdH0gY2F0Y2godGhlRXJyb3IpIHtcblx0XHRcdGNvbnN0IG5ld0V2ZW50ID0geyB0eXBlOiBldmVudFR5cGUsIGRldGFpbDogYUV2ZW50LmRldGFpbCwgZGlzcGF0Y2hlcjogdGhpcyB9O1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnN0IGN1cnJlbnRFdmVudExpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW2V2ZW50VHlwZV07XG5cdFx0aWYoY3VycmVudEV2ZW50TGlzdGVuZXJzICE9PSBudWxsICYmIGN1cnJlbnRFdmVudExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb25zdCBjdXJyZW50QXJyYXkgPSB0aGlzLl9jb3B5QXJyYXkoY3VycmVudEV2ZW50TGlzdGVuZXJzKTtcblx0XHRcdGNvbnN0IGN1cnJlbnRBcnJheUxlbmd0aCA9IGN1cnJlbnRBcnJheS5sZW5ndGg7XG5cdFx0XHRmb3IobGV0IGkgPSAwOyBpIDwgY3VycmVudEFycmF5TGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY3VycmVudEZ1bmN0aW9uID0gY3VycmVudEFycmF5W2ldO1xuXHRcdFx0XHRjdXJyZW50RnVuY3Rpb24uY2FsbCh0aGlzLCBhRXZlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGRpc3BhdGNoQ3VzdG9tRXZlbnQoYUV2ZW50VHlwZSwgYURldGFpbCkge1xuXHRcdGxldCBuZXdFdmVudDtcblx0XHRpZiAoc3VwcG9ydHNDdXN0b21FdmVudHMpIHtcblx0XHRcdG5ld0V2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG5cdFx0XHRuZXdFdmVudC5kaXNwYXRjaGVyID0gdGhpcztcblx0XHRcdG5ld0V2ZW50LmluaXRDdXN0b21FdmVudChhRXZlbnRUeXBlLCBmYWxzZSwgZmFsc2UsIGFEZXRhaWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdFdmVudCA9IHsgdHlwZTogYUV2ZW50VHlwZSwgZGV0YWlsOiBhRGV0YWlsLCBkaXNwYXRjaGVyOiB0aGlzIH07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9XG5cblx0dHJpZ2dlcihhRXZlbnRUeXBlLCBhRGV0YWlsKSB7XHRyZXR1cm4gdGhpcy5kaXNwYXRjaEN1c3RvbUV2ZW50KGFFdmVudFR5cGUsIGFEZXRhaWwpO1x0fVxuXG5cdF9kZXN0cm95KCkge1xuXHRcdGlmKHRoaXMuX2V2ZW50TGlzdGVuZXJzICE9PSBudWxsKSB7XG5cdFx0XHRmb3IoY29uc3Qgb2JqZWN0TmFtZSBpbiB0aGlzLl9ldmVudExpc3RlbmVycykge1xuXHRcdFx0XHRpZih0aGlzLl9ldmVudExpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShvYmplY3ROYW1lKSkge1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRBcnJheSA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW29iamVjdE5hbWVdO1xuXHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRBcnJheUxlbmd0aCA9IGN1cnJlbnRBcnJheS5sZW5ndGg7XG5cdFx0XHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcnJheUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50QXJyYXlbaV0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbb2JqZWN0TmFtZV07XHRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdF9jb3B5QXJyYXkoYUFycmF5KSB7XG5cdFx0Y29uc3QgY3VycmVudEFycmF5ID0gbmV3IEFycmF5KGFBcnJheS5sZW5ndGgpO1xuXHRcdGNvbnN0IGN1cnJlbnRBcnJheUxlbmd0aCA9IGN1cnJlbnRBcnJheS5sZW5ndGg7XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcnJheUxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjdXJyZW50QXJyYXlbaV0gPSBhQXJyYXlbaV07XG5cdFx0fVxuXHRcdHJldHVybiBjdXJyZW50QXJyYXk7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBFdmVudERpc3BhdGNoZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvRXZlbnREaXNwYXRjaGVyLmpzIiwiLy8gT3JiaXRhbENvbnRyb2wuanNcbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEVhc2VOdW1iZXIgZnJvbSAnLi9FYXNlTnVtYmVyJztcbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAgJ3NjaGVkdWxpbmcnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IGdldE1vdXNlID0gZnVuY3Rpb24gKG1FdmVudCwgbVRhcmdldCkge1xuXG5cdGNvbnN0IG8gPSBtVGFyZ2V0IHx8IHt9O1xuXHRpZihtRXZlbnQudG91Y2hlcykge1xuXHRcdG8ueCA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdG8ueSA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXHR9IGVsc2Uge1xuXHRcdG8ueCA9IG1FdmVudC5jbGllbnRYO1xuXHRcdG8ueSA9IG1FdmVudC5jbGllbnRZO1xuXHR9XG5cblx0cmV0dXJuIG87XG59O1xuXG5jbGFzcyBPcmJpdGFsQ29udHJvbCB7XG5cblx0Y29uc3RydWN0b3IobVRhcmdldCwgbUxpc3RlbmVyVGFyZ2V0ID0gd2luZG93LCBtUmFkaXVzID0gNTAwKSB7XG5cdFx0dGhpcy5fdGFyZ2V0ICAgICAgICAgPSBtVGFyZ2V0O1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0ID0gbUxpc3RlbmVyVGFyZ2V0O1xuXHRcdHRoaXMuX21vdXNlICAgICAgICAgID0ge307XG5cdFx0dGhpcy5fcHJlTW91c2UgICAgICAgPSB7fTtcblx0XHR0aGlzLmNlbnRlciAgICAgICAgICA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGhpcy5fdXAgICAgICAgICAgICAgPSB2ZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCk7XG5cdFx0dGhpcy5yYWRpdXMgICAgICAgICAgPSBuZXcgRWFzZU51bWJlcihtUmFkaXVzKTtcblx0XHR0aGlzLnBvc2l0aW9uICAgICAgICA9IHZlYzMuZnJvbVZhbHVlcygwLCAwLCB0aGlzLnJhZGl1cy52YWx1ZSk7XG5cdFx0dGhpcy5wb3NpdGlvbk9mZnNldCAgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRoaXMuX3J4ICAgICAgICAgICAgID0gbmV3IEVhc2VOdW1iZXIoMCk7XG5cdFx0dGhpcy5fcngubGltaXQoLU1hdGguUEkgLyAyLCBNYXRoLlBJIC8gMik7XG5cdFx0dGhpcy5fcnkgICAgICAgICAgICAgPSBuZXcgRWFzZU51bWJlcigwKTtcblx0XHR0aGlzLl9wcmVSWCAgICAgICAgICA9IDA7XG5cdFx0dGhpcy5fcHJlUlkgICAgICAgICAgPSAwO1xuXHRcdFxuXHRcdHRoaXMuX2lzTG9ja1pvb20gICAgID0gZmFsc2U7XG5cdFx0dGhpcy5faXNMb2NrUm90YXRpb24gPSBmYWxzZTtcblx0XHR0aGlzLl9pc0ludmVydCAgICAgICA9IGZhbHNlO1xuXHRcdHRoaXMuc2Vuc2l0aXZpdHlcdCA9IDEuMDtcblxuXG5cdFx0dGhpcy5fd2hlZWxCaW5kID0gKGUpID0+IHRoaXMuX29uV2hlZWwoZSk7XG5cdFx0dGhpcy5fZG93bkJpbmQgPSAoZSkgPT4gdGhpcy5fb25Eb3duKGUpO1xuXHRcdHRoaXMuX21vdmVCaW5kID0gKGUpID0+IHRoaXMuX29uTW92ZShlKTtcblx0XHR0aGlzLl91cEJpbmQgPSAoKSA9PiB0aGlzLl9vblVwKCk7XG5cdFxuXHRcdHRoaXMuY29ubmVjdCgpO1x0XHRcblx0XHRTY2hlZHVsZXIuYWRkRUYoKCkgPT4gdGhpcy5fbG9vcCgpKTtcblx0fVxuXG5cdGNvbm5lY3QoKSB7XG5cdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fd2hlZWxCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMuX3doZWVsQmluZCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9kb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2Rvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fbW92ZUJpbmQpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3VwQmluZCk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl91cEJpbmQpO1xuXHR9XG5cblx0ZGlzY29ubmVjdCgpIHtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5fd2hlZWxCaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Nb3VzZVNjcm9sbCcsIHRoaXMuX3doZWVsQmluZCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9kb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2Rvd25CaW5kKTtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9tb3ZlQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fbW92ZUJpbmQpO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX3VwQmluZCk7XG5cdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl91cEJpbmQpO1xuXHR9XG5cblxuXHQvL1x0UFVCTElDIE1FVEhPRFNcblxuXHRsb2NrKG1WYWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0xvY2tab29tID0gbVZhbHVlO1xuXHRcdHRoaXMuX2lzTG9ja1JvdGF0aW9uID0gbVZhbHVlO1xuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7XG5cdH1cblxuXHRsb2NrWm9vbShtVmFsdWUgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNMb2NrWm9vbSA9IG1WYWx1ZTtcblx0fVxuXG5cblx0bG9ja1JvdGF0aW9uKG1WYWx1ZSA9IHRydWUpIHtcblx0XHR0aGlzLl9pc0xvY2tSb3RhdGlvbiA9IG1WYWx1ZTtcblx0fVxuXG5cblx0aW52ZXJzZUNvbnRyb2woaXNJbnZlcnQgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNJbnZlcnQgPSBpc0ludmVydDtcblx0fVxuXG5cblx0Ly9cdEVWRU5UIEhBTkRMRVJFU1xuXHRfb25Eb3duKG1FdmVudCkge1xuXHRcdGlmKHRoaXMuX2lzTG9ja1JvdGF0aW9uKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gdHJ1ZTtcblx0XHRnZXRNb3VzZShtRXZlbnQsIHRoaXMuX21vdXNlKTtcblx0XHRnZXRNb3VzZShtRXZlbnQsIHRoaXMuX3ByZU1vdXNlKTtcblx0XHR0aGlzLl9wcmVSWCA9IHRoaXMuX3J4LnRhcmdldFZhbHVlO1xuXHRcdHRoaXMuX3ByZVJZID0gdGhpcy5fcnkudGFyZ2V0VmFsdWU7XG5cdH1cblxuXG5cdF9vbk1vdmUobUV2ZW50KSB7XG5cdFx0aWYodGhpcy5faXNMb2NrUm90YXRpb24pIHsgcmV0dXJuOyB9XG5cdFx0Z2V0TW91c2UobUV2ZW50LCB0aGlzLl9tb3VzZSk7XG5cdFx0aWYobUV2ZW50LnRvdWNoZXMpIHsgbUV2ZW50LnByZXZlbnREZWZhdWx0KCk7IH1cblxuXHRcdGlmKHRoaXMuX2lzTW91c2VEb3duKSB7XG5cdFx0XHRsZXQgZGlmZlggPSAtKHRoaXMuX21vdXNlLnggLSB0aGlzLl9wcmVNb3VzZS54KTtcblx0XHRcdGlmKHRoaXMuX2lzSW52ZXJ0KSB7IGRpZmZYICo9IC0xOyB9XG5cdFx0XHR0aGlzLl9yeS52YWx1ZSA9IHRoaXMuX3ByZVJZIC0gZGlmZlggKiAwLjAxICogdGhpcy5zZW5zaXRpdml0eTtcblxuXHRcdFx0bGV0IGRpZmZZID0gLSh0aGlzLl9tb3VzZS55IC0gdGhpcy5fcHJlTW91c2UueSk7XG5cdFx0XHRpZih0aGlzLl9pc0ludmVydCkgeyBkaWZmWSAqPSAtMTsgfVxuXHRcdFx0dGhpcy5fcngudmFsdWUgPSB0aGlzLl9wcmVSWCAtIGRpZmZZICogMC4wMSAqIHRoaXMuc2Vuc2l0aXZpdHk7XG5cdFx0fVxuXHR9XG5cblxuXHRfb25VcCgpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tSb3RhdGlvbikgeyByZXR1cm47IH1cblx0XHR0aGlzLl9pc01vdXNlRG93biA9IGZhbHNlO1xuXHR9XG5cblxuXHRfb25XaGVlbChtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tab29tKSB7XHRyZXR1cm47XHR9XG5cdFx0Y29uc3QgdyA9IG1FdmVudC53aGVlbERlbHRhO1xuXHRcdGNvbnN0IGQgPSBtRXZlbnQuZGV0YWlsO1xuXHRcdGxldCB2YWx1ZSA9IDA7XG5cdFx0aWYgKGQpIHtcblx0XHRcdGlmICh3KSB7XG5cdFx0XHRcdHZhbHVlID0gdyAvIGQgLyA0MCAqIGQgPiAwID8gMSA6IC0xOyAvLyBPcGVyYVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSAtZCAvIDM7ICAgICAgICAgICAgICAvLyBGaXJlZm94OyAgICAgICAgIFRPRE86IGRvIG5vdCAvMyBmb3IgT1MgWFxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHcgLyAxMjA7IFxuXHRcdH1cblxuXHRcdHRoaXMucmFkaXVzLmFkZCgtdmFsdWUgKiAyKTtcblx0fVxuXG5cblx0Ly9cdFBSSVZBVEUgTUVUSE9EU1xuXG5cdF9sb29wKCkge1xuXG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuXHRcdGlmKHRoaXMuX3RhcmdldCkge1xuXHRcdFx0dGhpcy5fdXBkYXRlQ2FtZXJhKCk7XG5cdFx0fVxuXHR9XG5cblxuXHRfdXBkYXRlUG9zaXRpb24oKSB7XG5cdFx0dGhpcy5wb3NpdGlvblsxXSA9IE1hdGguc2luKHRoaXMuX3J4LnZhbHVlKSAqIHRoaXMucmFkaXVzLnZhbHVlO1xuXHRcdGNvbnN0IHRyID0gTWF0aC5jb3ModGhpcy5fcngudmFsdWUpICogdGhpcy5yYWRpdXMudmFsdWU7XG5cdFx0dGhpcy5wb3NpdGlvblswXSA9IE1hdGguY29zKHRoaXMuX3J5LnZhbHVlICsgTWF0aC5QSSAqIDAuNSkgKiB0cjtcblx0XHR0aGlzLnBvc2l0aW9uWzJdID0gTWF0aC5zaW4odGhpcy5fcnkudmFsdWUgKyBNYXRoLlBJICogMC41KSAqIHRyO1xuXHRcdHZlYzMuYWRkKHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb24sIHRoaXMucG9zaXRpb25PZmZzZXQpO1xuXHR9XG5cblxuXHRfdXBkYXRlQ2FtZXJhKCkge1xuXHRcdHRoaXMuX3RhcmdldC5sb29rQXQodGhpcy5wb3NpdGlvbiwgdGhpcy5jZW50ZXIsIHRoaXMuX3VwKTtcblx0fVxuXG5cblx0Ly9cdEdFVFRFUiAvIFNFVFRFUlxuXG5cblx0Z2V0IHJ4KCkge1xuXHRcdHJldHVybiB0aGlzLl9yeDtcblx0fVxuXG5cblx0Z2V0IHJ5KCkge1xuXHRcdHJldHVybiB0aGlzLl9yeTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE9yYml0YWxDb250cm9sO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL09yYml0YWxDb250cm9sLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGdlbmVyYWxXaXRoTm9ybWFsLnZlcnRcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEdFTkVSQUxfVkVSVEVYXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzMgYVZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYU5vcm1hbDtcXG5cXG51bmlmb3JtIG1hdDQgdU1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1Vmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQzIHVOb3JtYWxNYXRyaXg7XFxuXFxudW5pZm9ybSB2ZWMzIHBvc2l0aW9uO1xcbnVuaWZvcm0gdmVjMyBzY2FsZTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdHZlYzMgcG9zICAgICAgPSBhVmVydGV4UG9zaXRpb24gKiBzY2FsZTtcXG5cXHRwb3MgICAgICAgICAgICs9IHBvc2l0aW9uO1xcblxcdGdsX1Bvc2l0aW9uICAgPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChwb3MsIDEuMCk7XFxuXFx0XFxuXFx0dlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxuXFx0dk5vcm1hbCAgICAgICA9IG5vcm1hbGl6ZSh1Tm9ybWFsTWF0cml4ICogYU5vcm1hbCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2dlbmVyYWwudmVydFxuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMudmVydFxcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0tZQk9YX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2VmVydGV4O1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuXFx0bWF0NCBtYXRWaWV3ID0gdVZpZXdNYXRyaXg7XFxuXFx0bWF0Vmlld1szXVswXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzFdID0gMC4wO1xcblxcdG1hdFZpZXdbM11bMl0gPSAwLjA7XFxuXFx0XFxuXFx0Z2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIG1hdFZpZXcgKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG5cXHR2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG5cXHRcXG5cXHR2VmVydGV4ID0gYVZlcnRleFBvc2l0aW9uO1xcblxcdHZOb3JtYWwgPSBhTm9ybWFsO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9za3lib3gudmVydFxuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmFzaWMuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgU0tZQk9YX0ZSQUdNRU5UXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG51bmlmb3JtIHNhbXBsZXJDdWJlIHRleHR1cmU7XFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxudmFyeWluZyB2ZWMzIHZWZXJ0ZXg7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUodGV4dHVyZSwgdlZlcnRleCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL3NreWJveC5mcmFnXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIENhbWVyYU9ydGhvLmpzXG5cbmltcG9ydCBDYW1lcmEgZnJvbSAnLi9DYW1lcmEnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNsYXNzIENhbWVyYU9ydGhvIGV4dGVuZHMgQ2FtZXJhIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdGNvbnN0IGV5ZSAgICA9IHZlYzMuY2xvbmUoWzAsIDAsIDE1XSk7XG5cdFx0Y29uc3QgY2VudGVyID0gdmVjMy5jcmVhdGUoKTtcblx0XHRjb25zdCB1cCAgICAgPSB2ZWMzLmNsb25lKFswLCAtMSwgMF0pO1xuXHRcdHRoaXMubG9va0F0KGV5ZSwgY2VudGVyLCB1cCk7XG5cdFx0dGhpcy5vcnRobygxLCAtMSwgMSwgLTEpO1xuXHR9XG5cblxuXHRzZXRCb3VuZGFyeShsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXI9MC4xLCBmYXI9MTAwKSB7XG5cdFx0dGhpcy5vcnRobyhsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhcik7XG5cdH1cblxuXG5cdG9ydGhvKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhcj0wLjEsIGZhcj0xMDApIHtcblx0XHR0aGlzLmxlZnQgICA9IGxlZnQ7XG5cdFx0dGhpcy5yaWdodCAgPSByaWdodDtcblx0XHR0aGlzLnRvcCAgICA9IHRvcDtcblx0XHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblx0XHRtYXQ0Lm9ydGhvKHRoaXMuX3Byb2plY3Rpb24sIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyKTtcblx0fVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FtZXJhT3J0aG87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvY2FtZXJhcy9DYW1lcmFPcnRoby5qcyIsIi8vIGxvYWRJbWFnZXMuanNcblxuaW1wb3J0IFByb21pc2UgZnJvbSAncHJvbWlzZS1wb2x5ZmlsbCc7XG5cbmNvbnN0IGdldCA9ICh1cmwpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0Y29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cdGltZy5vbmxvYWQgPSBmdW5jdGlvbiBvbkxvYWQoKSB7XG5cdFx0cmVzb2x2ZSh0aGlzKTtcblx0fTtcblxuXHRpbWcub25lcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IoKSB7XG5cdFx0cmVqZWN0KGBJbWFnZSBub3QgZm91bmQgOiAke3VybH1gKTtcblx0fTtcblxuXHRpbWcuc3JjID0gdXJsO1xufSk7XG5cblxuY29uc3QgbG9hZEltYWdlcyA9IChwYXRocykgPT4gUHJvbWlzZS5hbGwoXG5cdHBhdGhzLm1hcChnZXQpXG4pO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGxvYWRJbWFnZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9sb2FkSW1hZ2VzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG52YXIgc2V0VGltZW91dEZ1bmMgPSBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLy8gUG9seWZpbGwgZm9yIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG5mdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5fc3RhdGUgPSAwO1xuICB0aGlzLl9oYW5kbGVkID0gZmFsc2U7XG4gIHRoaXMuX3ZhbHVlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9kZWZlcnJlZHMgPSBbXTtcblxuICBkb1Jlc29sdmUoZm4sIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgd2hpbGUgKHNlbGYuX3N0YXRlID09PSAzKSB7XG4gICAgc2VsZiA9IHNlbGYuX3ZhbHVlO1xuICB9XG4gIGlmIChzZWxmLl9zdGF0ZSA9PT0gMCkge1xuICAgIHNlbGYuX2RlZmVycmVkcy5wdXNoKGRlZmVycmVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VsZi5faGFuZGxlZCA9IHRydWU7XG4gIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYiA9IHNlbGYuX3N0YXRlID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgKHNlbGYuX3N0YXRlID09PSAxID8gcmVzb2x2ZSA6IHJlamVjdCkoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICByZXQgPSBjYihzZWxmLl92YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gIHRyeSB7XG4gICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgIGlmIChcbiAgICAgIG5ld1ZhbHVlICYmXG4gICAgICAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW47XG4gICAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHNlbGYuX3N0YXRlID0gMztcbiAgICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRvUmVzb2x2ZShiaW5kKHRoZW4sIG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5fc3RhdGUgPSAxO1xuICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgZmluYWxlKHNlbGYpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHNlbGYsIGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICBzZWxmLl9zdGF0ZSA9IDI7XG4gIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gIGZpbmFsZShzZWxmKTtcbn1cblxuZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3N0YXRlID09PSAyICYmIHNlbGYuX2RlZmVycmVkcy5sZW5ndGggPT09IDApIHtcbiAgICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICAgIGlmICghc2VsZi5faGFuZGxlZCkge1xuICAgICAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbihzZWxmLl92YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZi5fZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaGFuZGxlKHNlbGYsIHNlbGYuX2RlZmVycmVkc1tpXSk7XG4gIH1cbiAgc2VsZi5fZGVmZXJyZWRzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSkge1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgc2VsZikge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIGZuKFxuICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICB9XG4gICAgKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlamVjdChzZWxmLCBleCk7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIHByb20gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgcmV0dXJuIHByb207XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHRoaXMudGhlbihcbiAgICBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZXNvbHZlKGNhbGxiYWNrKCkpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvci5yZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIWFyciB8fCB0eXBlb2YgYXJyLmxlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlLmFsbCBhY2NlcHRzIGFuIGFycmF5Jyk7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZWplY3QoZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuUHJvbWlzZS5faW1tZWRpYXRlRm4gPVxuICAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGZ1bmN0aW9uKGZuKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0pIHx8XG4gIGZ1bmN0aW9uKGZuKSB7XG4gICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICB9O1xuXG5Qcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF91bmhhbmRsZWRSZWplY3Rpb25GbihlcnIpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgY29uc29sZS53YXJuKCdQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb21pc2UtcG9seWZpbGwvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFBhc3NNYWNyby5qc1xuXG5jbGFzcyBQYXNzTWFjcm8ge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9wYXNzZXMgPSBbXTtcblx0fVxuXG5cdGFkZFBhc3MocGFzcykge1xuXHRcdHRoaXMuX3Bhc3Nlcy5wdXNoKHBhc3MpO1xuXHR9XG5cblx0Z2V0IHBhc3NlcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFzc2VzO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NNYWNybztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NNYWNyby5qcyIsIi8vIFBhc3NWQmx1ci5qc1xuXG5pbXBvcnQgUGFzc0JsdXJCYXNlIGZyb20gJy4vUGFzc0JsdXJCYXNlJztcblxuY2xhc3MgUGFzc1ZCbHVyIGV4dGVuZHMgUGFzc0JsdXJCYXNlIHtcblx0Y29uc3RydWN0b3IobVF1YWxpdHkgPSA5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpIHtcblx0XHRzdXBlcihtUXVhbGl0eSwgWzAsIDFdLCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NWQmx1cjtcblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvcG9zdC9QYXNzVkJsdXIuanMiLCIvLyBQYXNzQmx1ckJhc2UuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgUGFzcyBmcm9tICcuL1Bhc3MnO1xuXG5jb25zdCBmc0JsdXI1ID0gcmVxdWlyZSgnLi4vZ2xzbC9ibHVyNS5mcmFnJyk7XG5jb25zdCBmc0JsdXI5ID0gcmVxdWlyZSgnLi4vZ2xzbC9ibHVyOS5mcmFnJyk7XG5jb25zdCBmc0JsdXIxMyA9IHJlcXVpcmUoJy4uL2dsc2wvYmx1cjEzLmZyYWcnKTtcblxuY2xhc3MgUGFzc0JsdXJCYXNlIGV4dGVuZHMgUGFzcyB7XG5cdGNvbnN0cnVjdG9yKG1RdWFsaXR5ID0gOSwgbURpcmVjdGlvbiwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zID0ge30pIHtcblx0XHRsZXQgZnM7XG5cdFx0c3dpdGNoKG1RdWFsaXR5KSB7XG5cdFx0Y2FzZSA1OlxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRmcyA9IGZzQmx1cjU7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDkgOiBcblx0XHRcdGZzID0gZnNCbHVyOTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMTMgOiBcblx0XHRcdGZzID0gZnNCbHVyMTM7XG5cdFx0XHRicmVhaztcblxuXHRcdH1cblx0XHRzdXBlcihmcywgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKTtcblx0XHR0aGlzLnVuaWZvcm0oJ3VEaXJlY3Rpb24nLCBtRGlyZWN0aW9uKTtcblx0XHR0aGlzLnVuaWZvcm0oJ3VSZXNvbHV0aW9uJywgW0dMLndpZHRoLCBHTC5oZWlnaHRdKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzQmx1ckJhc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NCbHVyQmFzZS5qcyIsIi8vIFBhc3NIQmx1ci5qc1xuXG5pbXBvcnQgUGFzc0JsdXJCYXNlIGZyb20gJy4vUGFzc0JsdXJCYXNlJztcblxuY2xhc3MgUGFzc0hCbHVyIGV4dGVuZHMgUGFzc0JsdXJCYXNlIHtcblx0Y29uc3RydWN0b3IobVF1YWxpdHkgPSA5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpIHtcblx0XHRzdXBlcihtUXVhbGl0eSwgWzEsIDBdLCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBhc3NIQmx1cjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvUGFzc0hCbHVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGZ4YWEuZnJhZ1xcblxcbiNkZWZpbmUgU0hBREVSX05BTUUgRlhBQVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xcblxcblxcbmZsb2F0IEZYQUFfU1VCUElYX1NISUZUID0gMS4wLzQuMDtcXG4jZGVmaW5lIEZYQUFfUkVEVUNFX01JTiAgICgxLjAvIDEyOC4wKVxcbiNkZWZpbmUgRlhBQV9SRURVQ0VfTVVMICAgKDEuMCAvIDguMClcXG4jZGVmaW5lIEZYQUFfU1BBTl9NQVggICAgIDguMFxcblxcblxcbnZlYzQgYXBwbHlGWEFBKHNhbXBsZXIyRCB0ZXgpIHtcXG4gICAgdmVjNCBjb2xvcjtcXG4gICAgdmVjMiBmcmFnQ29vcmQgPSBnbF9GcmFnQ29vcmQueHk7XFxuICAgIHZlYzMgcmdiTlcgPSB0ZXh0dXJlMkQodGV4LCAoZnJhZ0Nvb3JkICsgdmVjMigtMS4wLCAtMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoMS4wLCAtMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoLTEuMCwgMS4wKSkgKiB1UmVzb2x1dGlvbikueHl6O1xcbiAgICB2ZWMzIHJnYlNFID0gdGV4dHVyZTJEKHRleCwgKGZyYWdDb29yZCArIHZlYzIoMS4wLCAxLjApKSAqIHVSZXNvbHV0aW9uKS54eXo7XFxuICAgIHZlYzMgcmdiTSAgPSB0ZXh0dXJlMkQodGV4LCBmcmFnQ29vcmQgICogdVJlc29sdXRpb24pLnh5ejtcXG4gICAgdmVjMyBsdW1hID0gdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KTtcXG4gICAgZmxvYXQgbHVtYU5XID0gZG90KHJnYk5XLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU5FID0gZG90KHJnYk5FLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNXID0gZG90KHJnYlNXLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYVNFID0gZG90KHJnYlNFLCBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU0gID0gZG90KHJnYk0sICBsdW1hKTtcXG4gICAgZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcXG4gICAgZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcXG5cXG4gICAgdmVjMiBkaXI7XFxuICAgIGRpci54ID0gLSgobHVtYU5XICsgbHVtYU5FKSAtIChsdW1hU1cgKyBsdW1hU0UpKTtcXG4gICAgZGlyLnkgPSAgKChsdW1hTlcgKyBsdW1hU1cpIC0gKGx1bWFORSArIGx1bWFTRSkpO1xcblxcbiAgICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKDAuMjUgKiBGWEFBX1JFRFVDRV9NVUwpLCBGWEFBX1JFRFVDRV9NSU4pO1xcblxcbiAgICBmbG9hdCByY3BEaXJNaW4gPSAxLjAgLyAobWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcXG4gICAgZGlyID0gbWluKHZlYzIoRlhBQV9TUEFOX01BWCwgRlhBQV9TUEFOX01BWCksXFxuICAgICAgICAgICAgICBtYXgodmVjMigtRlhBQV9TUEFOX01BWCwgLUZYQUFfU1BBTl9NQVgpLFxcbiAgICAgICAgICAgICAgZGlyICogcmNwRGlyTWluKSkgKiB1UmVzb2x1dGlvbjtcXG5cXG4gICAgdmVjMyByZ2JBID0gMC41ICogKFxcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogdVJlc29sdXRpb24gKyBkaXIgKiAoMS4wIC8gMy4wIC0gMC41KSkueHl6ICtcXG4gICAgICAgIHRleHR1cmUyRCh0ZXgsIGZyYWdDb29yZCAqIHVSZXNvbHV0aW9uICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XFxuICAgIHZlYzMgcmdiQiA9IHJnYkEgKiAwLjUgKyAwLjI1ICogKFxcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogdVJlc29sdXRpb24gKyBkaXIgKiAtMC41KS54eXogK1xcbiAgICAgICAgdGV4dHVyZTJEKHRleCwgZnJhZ0Nvb3JkICogdVJlc29sdXRpb24gKyBkaXIgKiAwLjUpLnh5eik7XFxuXFxuICAgIGZsb2F0IGx1bWFCID0gZG90KHJnYkIsIGx1bWEpO1xcbiAgICBpZiAoKGx1bWFCIDwgbHVtYU1pbikgfHwgKGx1bWFCID4gbHVtYU1heCkpXFxuICAgICAgICBjb2xvciA9IHZlYzQocmdiQSwgMS4wKTtcXG4gICAgZWxzZVxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHJnYkIsIDEuMCk7XFxuICAgIHJldHVybiBjb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gXFx0dmVjNCBjb2xvciA9IGFwcGx5RlhBQSh0ZXh0dXJlKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2Z4YWEuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG5pbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb25cIlxuXG4vKipcbiAqIDJ4MiBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0MlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDIgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dCBBIG5ldyAyeDIgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGVcbiAgLy8gc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIGxldCBhMSA9IGFbMV07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhMTtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYVsxXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIGxldCBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRldCA9IDEuMCAvIGRldDtcblxuICBvdXRbMF0gPSAgYTMgKiBkZXQ7XG4gIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgb3V0WzJdID0gLWEyICogZGV0O1xuICBvdXRbM10gPSAgYTAgKiBkZXQ7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIGxldCBhMCA9IGFbMF07XG4gIG91dFswXSA9ICBhWzNdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9ICBhMDtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiAgYyArIGEyICogcztcbiAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICBsZXQgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TY2FsaW5nKG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSkpXG59XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBMRFUoTCwgRCwgVSwgYSkge1xuICBMWzJdID0gYVsyXS9hWzBdO1xuICBVWzBdID0gYVswXTtcbiAgVVsxXSA9IGFbMV07XG4gIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV07XG4gIHJldHVybiBbTCwgRCwgVV07XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJ9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogMngzIE1hdHJpeFxuICogQG1vZHVsZSBtYXQyZFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MmRcbiAqXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQyZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IGMgQ29tcG9uZW50IEMgKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXG4gKiBAcGFyYW0ge051bWJlcn0gdHkgQ29tcG9uZW50IFRZIChpbmRleCA1KVxuICogQHJldHVybnMge21hdDJkfSBBIG5ldyBtYXQyZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVZhbHVlcyhhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSBhO1xuICBvdXRbMV0gPSBiO1xuICBvdXRbMl0gPSBjO1xuICBvdXRbM10gPSBkO1xuICBvdXRbNF0gPSB0eDtcbiAgb3V0WzVdID0gdHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0MmQgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgb3V0WzJdID0gYztcbiAgb3V0WzNdID0gZDtcbiAgb3V0WzRdID0gdHg7XG4gIG91dFs1XSA9IHR5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgbGV0IGFhID0gYVswXSwgYWIgPSBhWzFdLCBhYyA9IGFbMl0sIGFkID0gYVszXTtcbiAgbGV0IGF0eCA9IGFbNF0sIGF0eSA9IGFbNV07XG5cbiAgbGV0IGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICBpZighZGV0KXtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgb3V0WzJdID0gLWFjICogZGV0O1xuICBvdXRbM10gPSBhYSAqIGRldDtcbiAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsxXSAqIGFbMl07XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV07XG4gIGxldCB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTAgKiB2MDtcbiAgb3V0WzFdID0gYTEgKiB2MDtcbiAgb3V0WzJdID0gYTIgKiB2MTtcbiAgb3V0WzNdID0gYTMgKiB2MTtcbiAgb3V0WzRdID0gYTQ7XG4gIG91dFs1XSA9IGE1O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgbGV0IHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDtcbiAgb3V0WzFdID0gYTE7XG4gIG91dFsyXSA9IGEyO1xuICBvdXRbM10gPSBhMztcbiAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiB2MCArIGEzICogdjEgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB2WzBdO1xuICBvdXRbNV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArXG4gICAgICAgICAgYVszXSArICcsICcgKyBhWzRdICsgJywgJyArIGFbNV0gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIDEpKVxufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MmQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gIG91dFs0XSA9IGFbNF0gKyAoYls0XSAqIHNjYWxlKTtcbiAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV07XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICBsZXQgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgbGV0IGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV07XG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpKTtcbn1cblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBtdWwgPSBtdWx0aXBseTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDJkLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbmltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vblwiO1xuXG4vKipcbiAqIDR4NCBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0NFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICBvdXRbOV0gPSBhWzldO1xuICBvdXRbMTBdID0gYVsxMF07XG4gIG91dFsxMV0gPSBhWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBtYXQ0IHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBBIG5ldyBtYXQ0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0NCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG5cblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICBsZXQgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXTtcbiAgICBsZXQgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgICBsZXQgYTIzID0gYVsxMV07XG5cbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XTtcbiAgbGV0IGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXTtcbiAgbGV0IGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gIGxldCBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIGxldCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIGxldCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIGxldCBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIGxldCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIGxldCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIGxldCBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIGxldCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIGxldCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIGxldCBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIGxldCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIGxldCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICBsZXQgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgbGV0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgbGV0IGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgbGV0IGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgbGV0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgbGV0IGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgbGV0IGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgbGV0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgbGV0IGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgbGV0IGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgbGV0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgbGV0IGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgbGV0IGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgbGV0IGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM107XG4gIGxldCBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddO1xuICBsZXQgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdO1xuICBsZXQgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gIGxldCBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgbGV0IHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG4gIGxldCBhMDAsIGEwMSwgYTAyLCBhMDM7XG4gIGxldCBhMTAsIGExMSwgYTEyLCBhMTM7XG4gIGxldCBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgaWYgKGEgPT09IG91dCkge1xuICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICB9IGVsc2Uge1xuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzMgbm90IHVzaW5nIHZlY3Rvcml6YXRpb25cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIGxldCB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIGxldCB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdO1xuICBsZXQgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIGxldCBzLCBjLCB0O1xuICBsZXQgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICBsZXQgYTEwLCBhMTEsIGExMiwgYTEzO1xuICBsZXQgYTIwLCBhMjEsIGEyMiwgYTIzO1xuICBsZXQgYjAwLCBiMDEsIGIwMjtcbiAgbGV0IGIxMCwgYjExLCBiMTI7XG4gIGxldCBiMjAsIGIyMSwgYjIyO1xuXG4gIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG5cbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG5cbiAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcbiAgbGV0IGExMCA9IGFbNF07XG4gIGxldCBhMTEgPSBhWzVdO1xuICBsZXQgYTEyID0gYVs2XTtcbiAgbGV0IGExMyA9IGFbN107XG4gIGxldCBhMjAgPSBhWzhdO1xuICBsZXQgYTIxID0gYVs5XTtcbiAgbGV0IGEyMiA9IGFbMTBdO1xuICBsZXQgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzBdICA9IGFbMF07XG4gICAgb3V0WzFdICA9IGFbMV07XG4gICAgb3V0WzJdICA9IGFbMl07XG4gICAgb3V0WzNdICA9IGFbM107XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgcmFkKSB7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgbGV0IGMgPSBNYXRoLmNvcyhyYWQpO1xuICBsZXQgYTAwID0gYVswXTtcbiAgbGV0IGEwMSA9IGFbMV07XG4gIGxldCBhMDIgPSBhWzJdO1xuICBsZXQgYTAzID0gYVszXTtcbiAgbGV0IGEyMCA9IGFbOF07XG4gIGxldCBhMjEgPSBhWzldO1xuICBsZXQgYTIyID0gYVsxMF07XG4gIGxldCBhMjMgPSBhWzExXTtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gID0gYVs0XTtcbiAgICBvdXRbNV0gID0gYVs1XTtcbiAgICBvdXRbNl0gID0gYVs2XTtcbiAgICBvdXRbN10gID0gYVs3XTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBsZXQgYyA9IE1hdGguY29zKHJhZCk7XG4gIGxldCBhMDAgPSBhWzBdO1xuICBsZXQgYTAxID0gYVsxXTtcbiAgbGV0IGEwMiA9IGFbMl07XG4gIGxldCBhMDMgPSBhWzNdO1xuICBsZXQgYTEwID0gYVs0XTtcbiAgbGV0IGExMSA9IGFbNV07XG4gIGxldCBhMTIgPSBhWzZdO1xuICBsZXQgYTEzID0gYVs3XTtcblxuICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzhdICA9IGFbOF07XG4gICAgb3V0WzldICA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIGxldCB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdO1xuICBsZXQgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIGxldCBzLCBjLCB0O1xuXG4gIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gIGxlbiA9IDEgLyBsZW47XG4gIHggKj0gbGVuO1xuICB5ICo9IGxlbjtcbiAgeiAqPSBsZW47XG5cbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG5cbiAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVhSb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSAgPSAxO1xuICBvdXRbMV0gID0gMDtcbiAgb3V0WzJdICA9IDA7XG4gIG91dFszXSAgPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBjO1xuICBvdXRbNl0gPSBzO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAtcztcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSAgPSBjO1xuICBvdXRbMV0gID0gMDtcbiAgb3V0WzJdICA9IC1zO1xuICBvdXRbM10gID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gcztcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVpSb3RhdGlvbihvdXQsIHJhZCkge1xuICBsZXQgcyA9IE1hdGguc2luKHJhZCk7XG4gIGxldCBjID0gTWF0aC5jb3MocmFkKTtcblxuICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSAgPSBjO1xuICBvdXRbMV0gID0gcztcbiAgb3V0WzJdICA9IDA7XG4gIG91dFszXSAgPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeHkgPSB4ICogeTI7XG4gIGxldCB4eiA9IHggKiB6MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgeXogPSB5ICogejI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcblxuICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICBvdXRbMV0gPSB4eSArIHd6O1xuICBvdXRbMl0gPSB4eiAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4eSAtIHd6O1xuICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICBvdXRbNl0gPSB5eiArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4eiArIHd5O1xuICBvdXRbOV0gPSB5eiAtIHd4O1xuICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgbWF0KSB7XG4gIG91dFswXSA9IG1hdFsxMl07XG4gIG91dFsxXSA9IG1hdFsxM107XG4gIG91dFsyXSA9IG1hdFsxNF07XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlXG4gKiAgd2l0aCBhIG5vcm1hbGl6ZWQgUXVhdGVybmlvbiBwYXJhbXRlciwgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnRcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxpbmcob3V0LCBtYXQpIHtcbiAgbGV0IG0xMSA9IG1hdFswXTtcbiAgbGV0IG0xMiA9IG1hdFsxXTtcbiAgbGV0IG0xMyA9IG1hdFsyXTtcbiAgbGV0IG0yMSA9IG1hdFs0XTtcbiAgbGV0IG0yMiA9IG1hdFs1XTtcbiAgbGV0IG0yMyA9IG1hdFs2XTtcbiAgbGV0IG0zMSA9IG1hdFs4XTtcbiAgbGV0IG0zMiA9IG1hdFs5XTtcbiAgbGV0IG0zMyA9IG1hdFsxMF07XG5cbiAgb3V0WzBdID0gTWF0aC5zcXJ0KG0xMSAqIG0xMSArIG0xMiAqIG0xMiArIG0xMyAqIG0xMyk7XG4gIG91dFsxXSA9IE1hdGguc3FydChtMjEgKiBtMjEgKyBtMjIgKiBtMjIgKyBtMjMgKiBtMjMpO1xuICBvdXRbMl0gPSBNYXRoLnNxcnQobTMxICogbTMxICsgbTMyICogbTMyICsgbTMzICogbTMzKTtcblxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0ge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0aW9uKG91dCwgbWF0KSB7XG4gIC8vIEFsZ29yaXRobSB0YWtlbiBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG4gIGxldCB0cmFjZSA9IG1hdFswXSArIG1hdFs1XSArIG1hdFsxMF07XG4gIGxldCBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMV0gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7XG4gICAgb3V0WzJdID0gKG1hdFsxXSAtIG1hdFs0XSkgLyBTO1xuICB9IGVsc2UgaWYgKChtYXRbMF0gPiBtYXRbNV0pJihtYXRbMF0gPiBtYXRbMTBdKSkge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzBdIC0gbWF0WzVdIC0gbWF0WzEwXSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAobWF0WzFdICsgbWF0WzRdKSAvIFM7XG4gICAgb3V0WzJdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTO1xuICB9IGVsc2UgaWYgKG1hdFs1XSA+IG1hdFsxMF0pIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFs1XSAtIG1hdFswXSAtIG1hdFsxMF0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFsxXSArIG1hdFs0XSkgLyBTO1xuICAgIG91dFsxXSA9IDAuMjUgKiBTO1xuICAgIG91dFsyXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUztcbiAgfSBlbHNlIHtcbiAgICBTID0gTWF0aC5zcXJ0KDEuMCArIG1hdFsxMF0gLSBtYXRbMF0gLSBtYXRbNV0pICogMjtcbiAgICBvdXRbM10gPSAobWF0WzFdIC0gbWF0WzRdKSAvIFM7XG4gICAgb3V0WzBdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTO1xuICAgIG91dFsxXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeHkgPSB4ICogeTI7XG4gIGxldCB4eiA9IHggKiB6MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgeXogPSB5ICogejI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcbiAgbGV0IHN4ID0gc1swXTtcbiAgbGV0IHN5ID0gc1sxXTtcbiAgbGV0IHN6ID0gc1syXTtcblxuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG9yaWdpbik7XG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4ob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICBsZXQgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM107XG4gIGxldCB4MiA9IHggKyB4O1xuICBsZXQgeTIgPSB5ICsgeTtcbiAgbGV0IHoyID0geiArIHo7XG5cbiAgbGV0IHh4ID0geCAqIHgyO1xuICBsZXQgeHkgPSB4ICogeTI7XG4gIGxldCB4eiA9IHggKiB6MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgeXogPSB5ICogejI7XG4gIGxldCB6eiA9IHogKiB6MjtcbiAgbGV0IHd4ID0gdyAqIHgyO1xuICBsZXQgd3kgPSB3ICogeTI7XG4gIGxldCB3eiA9IHcgKiB6MjtcblxuICBsZXQgc3ggPSBzWzBdO1xuICBsZXQgc3kgPSBzWzFdO1xuICBsZXQgc3ogPSBzWzJdO1xuXG4gIGxldCBveCA9IG9bMF07XG4gIGxldCBveSA9IG9bMV07XG4gIGxldCBveiA9IG9bMl07XG5cbiAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIG91dFsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gKHh5IC0gd3opICogc3k7XG4gIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICBvdXRbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dFswXSAqIG94ICsgb3V0WzRdICogb3kgKyBvdXRbOF0gKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0WzFdICogb3ggKyBvdXRbNV0gKiBveSArIG91dFs5XSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXRbMl0gKiBveCArIG91dFs2XSAqIG95ICsgb3V0WzEwXSAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIGxldCB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXTtcbiAgbGV0IHgyID0geCArIHg7XG4gIGxldCB5MiA9IHkgKyB5O1xuICBsZXQgejIgPSB6ICsgejtcblxuICBsZXQgeHggPSB4ICogeDI7XG4gIGxldCB5eCA9IHkgKiB4MjtcbiAgbGV0IHl5ID0geSAqIHkyO1xuICBsZXQgenggPSB6ICogeDI7XG4gIGxldCB6eSA9IHogKiB5MjtcbiAgbGV0IHp6ID0geiAqIHoyO1xuICBsZXQgd3ggPSB3ICogeDI7XG4gIGxldCB3eSA9IHcgKiB5MjtcbiAgbGV0IHd6ID0gdyAqIHoyO1xuXG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuXG4gIG91dFs0XSA9IHl4IC0gd3o7XG4gIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbNl0gPSB6eSArIHd4O1xuICBvdXRbN10gPSAwO1xuXG4gIG91dFs4XSA9IHp4ICsgd3k7XG4gIG91dFs5XSA9IHp5IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgb3V0WzExXSA9IDA7XG5cbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZydXN0dW0ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICBsZXQgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCk7XG4gIGxldCB0YiA9IDEgLyAodG9wIC0gYm90dG9tKTtcbiAgbGV0IG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAobmVhciAqIDIpICogdGI7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XG4gIG91dFsxNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZShvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gIGxldCBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpO1xuICBsZXQgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtPYmplY3R9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgbGV0IHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApO1xuICBsZXQgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSS8xODAuMCk7XG4gIGxldCB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKTtcbiAgbGV0IHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKCh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41KTtcbiAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzExXSA9IC0xLjA7XG4gIG91dFsxMl0gPSAwLjA7XG4gIG91dFsxM10gPSAwLjA7XG4gIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gIG91dFsxNV0gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgbGV0IGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICBsZXQgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIGxldCBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9va0F0KG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gIGxldCB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW47XG4gIGxldCBleWV4ID0gZXllWzBdO1xuICBsZXQgZXlleSA9IGV5ZVsxXTtcbiAgbGV0IGV5ZXogPSBleWVbMl07XG4gIGxldCB1cHggPSB1cFswXTtcbiAgbGV0IHVweSA9IHVwWzFdO1xuICBsZXQgdXB6ID0gdXBbMl07XG4gIGxldCBjZW50ZXJ4ID0gY2VudGVyWzBdO1xuICBsZXQgY2VudGVyeSA9IGNlbnRlclsxXTtcbiAgbGV0IGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gbWF0NC5pZGVudGl0eShvdXQpO1xuICB9XG5cbiAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gIHowICo9IGxlbjtcbiAgejEgKj0gbGVuO1xuICB6MiAqPSBsZW47XG5cbiAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gIGlmICghbGVuKSB7XG4gICAgeTAgPSAwO1xuICAgIHkxID0gMDtcbiAgICB5MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB5MCAqPSBsZW47XG4gICAgeTEgKj0gbGVuO1xuICAgIHkyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB5MDtcbiAgb3V0WzJdID0gejA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHgxO1xuICBvdXRbNV0gPSB5MTtcbiAgb3V0WzZdID0gejE7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHgyO1xuICBvdXRbOV0gPSB5MjtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgb3V0WzE1XSA9IDE7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgbGV0IGV5ZXggPSBleWVbMF0sXG4gICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICB1cHogPSB1cFsyXTtcblxuICBsZXQgejAgPSBleWV4IC0gdGFyZ2V0WzBdLFxuICAgICAgejEgPSBleWV5IC0gdGFyZ2V0WzFdLFxuICAgICAgejIgPSBleWV6IC0gdGFyZ2V0WzJdO1xuXG4gIGxldCBsZW4gPSB6MCp6MCArIHoxKnoxICsgejIqejI7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuICB9XG5cbiAgbGV0IHgwID0gdXB5ICogejIgLSB1cHogKiB6MSxcbiAgICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MixcbiAgICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgIGFbOF0gKyAnLCAnICsgYVs5XSArICcsICcgKyBhWzEwXSArICcsICcgKyBhWzExXSArICcsICcgK1xuICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufVxuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn1cblxuLyoqXG4gKiBBZGRzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gKyBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gKyBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICBvdXRbNV0gPSBhWzVdICsgKGJbNV0gKiBzY2FsZSk7XG4gIG91dFs2XSA9IGFbNl0gKyAoYls2XSAqIHNjYWxlKTtcbiAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICBvdXRbOF0gPSBhWzhdICsgKGJbOF0gKiBzY2FsZSk7XG4gIG91dFs5XSA9IGFbOV0gKyAoYls5XSAqIHNjYWxlKTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgKGJbMTBdICogc2NhbGUpO1xuICBvdXRbMTFdID0gYVsxMV0gKyAoYlsxMV0gKiBzY2FsZSk7XG4gIG91dFsxMl0gPSBhWzEyXSArIChiWzEyXSAqIHNjYWxlKTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgKGJbMTNdICogc2NhbGUpO1xuICBvdXRbMTRdID0gYVsxNF0gKyAoYlsxNF0gKiBzY2FsZSk7XG4gIG91dFsxNV0gPSBhWzE1XSArIChiWzE1XSAqIHNjYWxlKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmXG4gICAgICAgICBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmXG4gICAgICAgICBhWzhdID09PSBiWzhdICYmIGFbOV0gPT09IGJbOV0gJiYgYVsxMF0gPT09IGJbMTBdICYmIGFbMTFdID09PSBiWzExXSAmJlxuICAgICAgICAgYVsxMl0gPT09IGJbMTJdICYmIGFbMTNdID09PSBiWzEzXSAmJiBhWzE0XSA9PT0gYlsxNF0gJiYgYVsxNV0gPT09IGJbMTVdO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGxldCBhMCAgPSBhWzBdLCAgYTEgID0gYVsxXSwgIGEyICA9IGFbMl0sICBhMyAgPSBhWzNdO1xuICBsZXQgYTQgID0gYVs0XSwgIGE1ICA9IGFbNV0sICBhNiAgPSBhWzZdLCAgYTcgID0gYVs3XTtcbiAgbGV0IGE4ICA9IGFbOF0sICBhOSAgPSBhWzldLCAgYTEwID0gYVsxMF0sIGExMSA9IGFbMTFdO1xuICBsZXQgYTEyID0gYVsxMl0sIGExMyA9IGFbMTNdLCBhMTQgPSBhWzE0XSwgYTE1ID0gYVsxNV07XG5cbiAgbGV0IGIwICA9IGJbMF0sICBiMSAgPSBiWzFdLCAgYjIgID0gYlsyXSwgIGIzICA9IGJbM107XG4gIGxldCBiNCAgPSBiWzRdLCAgYjUgID0gYls1XSwgIGI2ICA9IGJbNl0sICBiNyAgPSBiWzddO1xuICBsZXQgYjggID0gYls4XSwgIGI5ICA9IGJbOV0sICBiMTAgPSBiWzEwXSwgYjExID0gYlsxMV07XG4gIGxldCBiMTIgPSBiWzEyXSwgYjEzID0gYlsxM10sIGIxNCA9IGJbMTRdLCBiMTUgPSBiWzE1XTtcblxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE4KSwgTWF0aC5hYnMoYjgpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOSksIE1hdGguYWJzKGI5KSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTApLCBNYXRoLmFicyhiMTApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMSksIE1hdGguYWJzKGIxMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEyKSwgTWF0aC5hYnMoYjEyKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTMpLCBNYXRoLmFicyhiMTMpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNCksIE1hdGguYWJzKGIxNCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE1KSwgTWF0aC5hYnMoYjE1KSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzdWIgPSBzdWJ0cmFjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDQuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCJcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vbWF0M1wiXG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gXCIuL3ZlYzNcIlxuaW1wb3J0ICogYXMgdmVjNCBmcm9tIFwiLi92ZWM0XCJcblxuLyoqXG4gKiBRdWF0ZXJuaW9uXG4gKiBAbW9kdWxlIHF1YXRcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIGxldCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcbiAqIHRoZW4gcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyBhcm91bmQgd2hpY2ggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiovXG5leHBvcnQgZnVuY3Rpb24gc2V0QXhpc0FuZ2xlKG91dCwgYXhpcywgcmFkKSB7XG4gIHJhZCA9IHJhZCAqIDAuNTtcbiAgbGV0IHMgPSBNYXRoLnNpbihyYWQpO1xuICBvdXRbMF0gPSBzICogYXhpc1swXTtcbiAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICBvdXRbM10gPSBNYXRoLmNvcyhyYWQpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHJvdGF0aW9uIGF4aXMgYW5kIGFuZ2xlIGZvciBhIGdpdmVuXG4gKiAgcXVhdGVybmlvbi4gSWYgYSBxdWF0ZXJuaW9uIGlzIGNyZWF0ZWQgd2l0aFxuICogIHNldEF4aXNBbmdsZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWVcbiAqICB2YWx1ZXMgYXMgcHJvdmlkaWVkIGluIHRoZSBvcmlnaW5hbCBwYXJhbWV0ZXIgbGlzdFxuICogIE9SIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqIEV4YW1wbGU6IFRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieSBheGlzIFswLCAwLCAxXSBhbmRcbiAqICBhbmdsZSAtOTAgaXMgdGhlIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5XG4gKiAgWzAsIDAsIDFdIGFuZCAyNzAuIFRoaXMgbWV0aG9kIGZhdm9ycyB0aGUgbGF0dGVyLlxuICogQHBhcmFtICB7dmVjM30gb3V0X2F4aXMgIFZlY3RvciByZWNlaXZpbmcgdGhlIGF4aXMgb2Ygcm90YXRpb25cbiAqIEBwYXJhbSAge3F1YXR9IHEgICAgIFF1YXRlcm5pb24gdG8gYmUgZGVjb21wb3NlZFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSByb3RhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpc0FuZ2xlKG91dF9heGlzLCBxKSB7XG4gIGxldCByYWQgPSBNYXRoLmFjb3MocVszXSkgKiAyLjA7XG4gIGxldCBzID0gTWF0aC5zaW4ocmFkIC8gMi4wKTtcbiAgaWYgKHMgIT0gMC4wKSB7XG4gICAgb3V0X2F4aXNbMF0gPSBxWzBdIC8gcztcbiAgICBvdXRfYXhpc1sxXSA9IHFbMV0gLyBzO1xuICAgIG91dF9heGlzWzJdID0gcVsyXSAvIHM7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgcyBpcyB6ZXJvLCByZXR1cm4gYW55IGF4aXMgKG5vIHJvdGF0aW9uIC0gYXhpcyBkb2VzIG5vdCBtYXR0ZXIpXG4gICAgb3V0X2F4aXNbMF0gPSAxO1xuICAgIG91dF9heGlzWzFdID0gMDtcbiAgICBvdXRfYXhpc1syXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHJhZDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIGxldCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM107XG4gIGxldCBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG5cbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXTtcbiAgbGV0IGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXogKiBieDtcbiAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcblxuICBsZXQgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdO1xuICBsZXQgYnkgPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuXG4gIGxldCBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM107XG4gIGxldCBieiA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVXKG91dCwgYSkge1xuICBsZXQgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcblxuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgLy8gYmVuY2htYXJrczpcbiAgLy8gICAgaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi1zbGVycC1pbXBsZW1lbnRhdGlvbnNcbiAgbGV0IGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXTtcbiAgbGV0IGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICBsZXQgb21lZ2EsIGNvc29tLCBzaW5vbSwgc2NhbGUwLCBzY2FsZTE7XG5cbiAgLy8gY2FsYyBjb3NpbmVcbiAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAvLyBhZGp1c3Qgc2lnbnMgKGlmIG5lY2Vzc2FyeSlcbiAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICBjb3NvbSA9IC1jb3NvbTtcbiAgICBieCA9IC0gYng7XG4gICAgYnkgPSAtIGJ5O1xuICAgIGJ6ID0gLSBiejtcbiAgICBidyA9IC0gYnc7XG4gIH1cbiAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICBpZiAoICgxLjAgLSBjb3NvbSkgPiAwLjAwMDAwMSApIHtcbiAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICBvbWVnYSAgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgIHNpbm9tICA9IE1hdGguc2luKG9tZWdhKTtcbiAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gIH0gZWxzZSB7XG4gICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZVxuICAgIC8vICAuLi4gc28gd2UgY2FuIGRvIGEgbGluZWFyIGludGVycG9sYXRpb25cbiAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgIHNjYWxlMSA9IHQ7XG4gIH1cbiAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIGxldCBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gIGxldCBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMztcbiAgbGV0IGludkRvdCA9IGRvdCA/IDEuMC9kb3QgOiAwO1xuXG4gIC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgb3V0WzBdID0gLWEwKmludkRvdDtcbiAgb3V0WzFdID0gLWExKmludkRvdDtcbiAgb3V0WzJdID0gLWEyKmludkRvdDtcbiAgb3V0WzNdID0gYTMqaW52RG90O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25qdWdhdGUob3V0LCBhKSB7XG4gIG91dFswXSA9IC1hWzBdO1xuICBvdXRbMV0gPSAtYVsxXTtcbiAgb3V0WzJdID0gLWFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gM3gzIHJvdGF0aW9uIG1hdHJpeC5cbiAqXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxuICogdG8gcmVub3JtYWxpemUgdGhlIHF1YXRlcm5pb24geW91cnNlbGYgd2hlcmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHttYXQzfSBtIHJvdGF0aW9uIG1hdHJpeFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0MyhvdXQsIG0pIHtcbiAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gIGxldCBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gIGxldCBmUm9vdDtcblxuICBpZiAoIGZUcmFjZSA+IDAuMCApIHtcbiAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yXG4gICAgZlJvb3QgPSBNYXRoLnNxcnQoZlRyYWNlICsgMS4wKTsgIC8vIDJ3XG4gICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUvZlJvb3Q7ICAvLyAxLyg0dylcbiAgICBvdXRbMF0gPSAobVs1XS1tWzddKSpmUm9vdDtcbiAgICBvdXRbMV0gPSAobVs2XS1tWzJdKSpmUm9vdDtcbiAgICBvdXRbMl0gPSAobVsxXS1tWzNdKSpmUm9vdDtcbiAgfSBlbHNlIHtcbiAgICAvLyB8d3wgPD0gMS8yXG4gICAgbGV0IGkgPSAwO1xuICAgIGlmICggbVs0XSA+IG1bMF0gKVxuICAgICAgaSA9IDE7XG4gICAgaWYgKCBtWzhdID4gbVtpKjMraV0gKVxuICAgICAgaSA9IDI7XG4gICAgbGV0IGogPSAoaSsxKSUzO1xuICAgIGxldCBrID0gKGkrMiklMztcblxuICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSozK2ldLW1baiozK2pdLW1bayozK2tdICsgMS4wKTtcbiAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICBmUm9vdCA9IDAuNSAvIGZSb290O1xuICAgIG91dFszXSA9IChtW2oqMytrXSAtIG1bayozK2pdKSAqIGZSb290O1xuICAgIG91dFtqXSA9IChtW2oqMytpXSArIG1baSozK2pdKSAqIGZSb290O1xuICAgIG91dFtrXSA9IChtW2sqMytpXSArIG1baSozK2tdKSAqIGZSb290O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiBldWxlciBhbmdsZSB4LCB5LCB6LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt4fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFggYXhpcyBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHt5fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFkgYXhpcyBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHt6fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFogYXhpcyBpbiBkZWdyZWVzLlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXVsZXIob3V0LCB4LCB5LCB6KSB7XG4gICAgbGV0IGhhbGZUb1JhZCA9IDAuNSAqIE1hdGguUEkgLyAxODAuMDtcbiAgICB4ICo9IGhhbGZUb1JhZDtcbiAgICB5ICo9IGhhbGZUb1JhZDtcbiAgICB6ICo9IGhhbGZUb1JhZDtcblxuICAgIGxldCBzeCA9IE1hdGguc2luKHgpO1xuICAgIGxldCBjeCA9IE1hdGguY29zKHgpO1xuICAgIGxldCBzeSA9IE1hdGguc2luKHkpO1xuICAgIGxldCBjeSA9IE1hdGguY29zKHkpO1xuICAgIGxldCBzeiA9IE1hdGguc2luKHopO1xuICAgIGxldCBjeiA9IE1hdGguY29zKHopO1xuXG4gICAgb3V0WzBdID0gc3ggKiBjeSAqIGN6IC0gY3ggKiBzeSAqIHN6O1xuICAgIG91dFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgICBvdXRbMl0gPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XG4gICAgb3V0WzNdID0gY3ggKiBjeSAqIGN6ICsgc3ggKiBzeSAqIHN6O1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgcXVhdGVuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZSA9IHZlYzQuY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgc291cmNlIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY29weSA9IHZlYzQuY29weTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNldCA9IHZlYzQuc2V0O1xuXG4vKipcbiAqIEFkZHMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRvdCA9IHZlYzQuZG90O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lmxlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbGVuID0gbGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBleGFjdEVxdWFscyA9IHZlYzQuZXhhY3RFcXVhbHM7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHtxdWF0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbHMgPSB2ZWM0LmVxdWFscztcblxuLyoqXG4gKiBTZXRzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cbiAqXG4gKiBCb3RoIHZlY3RvcnMgYXJlIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uLlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xuZXhwb3J0IGNvbnN0IHJvdGF0aW9uVG8gPSAoZnVuY3Rpb24oKSB7XG4gIGxldCB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgbGV0IHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XG4gIGxldCB5VW5pdFZlYzMgPSB2ZWMzLmZyb21WYWx1ZXMoMCwxLDApO1xuXG4gIHJldHVybiBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBsZXQgZG90ID0gdmVjMy5kb3QoYSwgYik7XG4gICAgaWYgKGRvdCA8IC0wLjk5OTk5OSkge1xuICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xuICAgICAgaWYgKHZlYzMubGVuKHRtcHZlYzMpIDwgMC4wMDAwMDEpXG4gICAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeVVuaXRWZWMzLCBhKTtcbiAgICAgIHZlYzMubm9ybWFsaXplKHRtcHZlYzMsIHRtcHZlYzMpO1xuICAgICAgc2V0QXhpc0FuZ2xlKG91dCwgdG1wdmVjMywgTWF0aC5QSSk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSBpZiAoZG90ID4gMC45OTk5OTkpIHtcbiAgICAgIG91dFswXSA9IDA7XG4gICAgICBvdXRbMV0gPSAwO1xuICAgICAgb3V0WzJdID0gMDtcbiAgICAgIG91dFszXSA9IDE7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIGEsIGIpO1xuICAgICAgb3V0WzBdID0gdG1wdmVjM1swXTtcbiAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XG4gICAgICBvdXRbMl0gPSB0bXB2ZWMzWzJdO1xuICAgICAgb3V0WzNdID0gMSArIGRvdDtcbiAgICAgIHJldHVybiBub3JtYWxpemUob3V0LCBvdXQpO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5leHBvcnQgY29uc3Qgc3FsZXJwID0gKGZ1bmN0aW9uICgpIHtcbiAgbGV0IHRlbXAxID0gY3JlYXRlKCk7XG4gIGxldCB0ZW1wMiA9IGNyZWF0ZSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgc2xlcnAodGVtcDEsIGEsIGQsIHQpO1xuICAgIHNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBzbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcblxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KCkpO1xuXG4vKipcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcbiAqIHBlcnBlbmRpY3VsYXIgdG8gYWxsIG90aGVyIHNwZWNpZmllZCBheGVzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmlldyAgdGhlIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHZpZXdpbmcgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBeGVzID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgbWF0ciA9IG1hdDMuY3JlYXRlKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgIG1hdHJbM10gPSByaWdodFsxXTtcbiAgICBtYXRyWzZdID0gcmlnaHRbMl07XG5cbiAgICBtYXRyWzFdID0gdXBbMF07XG4gICAgbWF0cls0XSA9IHVwWzFdO1xuICAgIG1hdHJbN10gPSB1cFsyXTtcblxuICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgbWF0cls4XSA9IC12aWV3WzJdO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIGZyb21NYXQzKG91dCwgbWF0cikpO1xuICB9O1xufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3F1YXQuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uXCI7XG5cbi8qKlxuICogMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjMlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgbGV0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSkge1xuICBsZXQgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSkge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZCAob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgeSA9IGFbMV07XG4gIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGggKGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgIHkgPSBhWzFdO1xuICByZXR1cm4geCp4ICsgeSp5O1xufTtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZTtcbiAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICBsZXQgeCA9IGFbMF07XG4gIGxldCB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgbGV0IGEwID0gYVswXSwgYTEgPSBhWzFdO1xuICBsZXQgYjAgPSBiWzBdLCBiMSA9IGJbMV07XG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkpO1xufVxuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGxlbiA9IGxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN1YiA9IHN1YnRyYWN0O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgbXVsID0gbXVsdGlwbHk7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGl2ID0gZGl2aWRlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGlzdCA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gIGxldCB2ZWMgPSBjcmVhdGUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgbGV0IGksIGw7XG4gICAgaWYoIXN0cmlkZSkge1xuICAgICAgc3RyaWRlID0gMjtcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdO1xuICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMi5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBWZXJ0ZXhBcnJheU9iamVjdC5qc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbmRBcHBseUV4dGVuc2lvbihnbCwgbmFtZSkge1xuXHRjb25zdCBleHQgPSBnbC5nZXRFeHRlbnNpb24obmFtZSk7XG5cdGlmICghZXh0KSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdGNvbnN0IHN1ZmZpeCA9IG5hbWUuc3BsaXQoJ18nKVswXTtcblx0Y29uc3Qgc3VmZml4UkUgPSBuZXcgUmVnRXhwKGAke3N1ZmZpeH0kYCk7XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gZXh0KSB7XG5cdFx0Y29uc3QgdmFsID0gZXh0W2tleV07XG5cdFx0aWYgKHR5cGVvZih2YWwpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjb25zdCB1bnN1ZmZpeGVkS2V5ID0ga2V5LnJlcGxhY2Uoc3VmZml4UkUsICcnKTtcblx0XHRcdGlmIChrZXkuc3Vic3RyaW5nKSB7XG5cdFx0XHRcdGdsW3Vuc3VmZml4ZWRLZXldID0gZXh0W2tleV0uYmluZChleHQpO1x0XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdSZXBsYWNpbmcgOicsIGtleSwgJz0+JywgdW5zdWZmaXhlZEtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0QW5kQXBwbHlFeHRlbnNpb24uanMiLCIvLyBleHBvc2VBdHRyaWJ1dGVzLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IFdlYmdsQ29uc3QgZnJvbSAnLi9XZWJnbENvbnN0JztcblxuY29uc3QgZXhwb3NlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gR0wuVkVSVEVYX1NIQURFUiAgICAgICAgID0gR0wuZ2wuVkVSVEVYX1NIQURFUjtcblx0Ly8gR0wuRlJBR01FTlRfU0hBREVSICAgICAgID0gR0wuZ2wuRlJBR01FTlRfU0hBREVSO1xuXHQvLyBHTC5DT01QSUxFX1NUQVRVUyAgICAgICAgPSBHTC5nbC5DT01QSUxFX1NUQVRVUztcblx0Ly8gR0wuREVQVEhfVEVTVCAgICAgICAgICAgID0gR0wuZ2wuREVQVEhfVEVTVDtcblx0Ly8gR0wuQ1VMTF9GQUNFICAgICAgICAgICAgID0gR0wuZ2wuQ1VMTF9GQUNFO1xuXHQvLyBHTC5CTEVORCAgICAgICAgICAgICAgICAgPSBHTC5nbC5CTEVORDtcblx0Ly8gR0wuUE9JTlRTICAgICAgICAgICAgICAgID0gR0wuZ2wuUE9JTlRTO1xuXHQvLyBHTC5MSU5FUyAgICAgICAgICAgICAgICAgPSBHTC5nbC5MSU5FUztcblx0Ly8gR0wuVFJJQU5HTEVTICAgICAgICAgICAgID0gR0wuZ2wuVFJJQU5HTEVTO1xuXHRcblx0Ly8gR0wuTElORUFSICAgICAgICAgICAgICAgIFx0PSBHTC5nbC5MSU5FQVI7XG5cdC8vIEdMLk5FQVJFU1QgICAgICAgICAgICAgICBcdD0gR0wuZ2wuTkVBUkVTVDtcblx0Ly8gR0wuTElORUFSX01JUE1BUF9ORUFSRVNUIFx0PSBHTC5nbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XG5cdC8vIEdMLk5FQVJFU1RfTUlQTUFQX0xJTkVBUiBcdD0gR0wuZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXHQvLyBHTC5MSU5FQVJfTUlQTUFQX0xJTkVBUiBcdD0gR0wuZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cdC8vIEdMLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QgXHQ9IEdMLmdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XG5cdC8vIEdMLk1JUlJPUkVEX1JFUEVBVCAgICAgICBcdD0gR0wuZ2wuTUlSUk9SRURfUkVQRUFUO1xuXHQvLyBHTC5DTEFNUF9UT19FREdFICAgICAgICAgXHQ9IEdMLmdsLkNMQU1QX1RPX0VER0U7XG5cdC8vIEdMLlNDSVNTT1JfVEVTVFx0XHQgICBcdCBcdD0gR0wuZ2wuU0NJU1NPUl9URVNUO1xuXHQvLyBHTC5VTlNJR05FRF9CWVRFXHRcdCBcdD0gR0wuZ2wuVU5TSUdORURfQllURTtcblx0Zm9yIChjb25zdCBzIGluIFdlYmdsQ29uc3QpIHtcblx0XHRpZighR0xbc10pIHtcblx0XHRcdEdMW3NdID0gV2ViZ2xDb25zdFtzXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5sb2coJ2FscmVhZHkgZXhpc3QgOiAnLCBzKTtcblx0XHR9XG5cdFx0XG5cdH1cbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgZXhwb3NlQXR0cmlidXRlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9leHBvc2VBdHRyaWJ1dGVzLmpzIiwiLy8gZ2V0RmxvYXQuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5cbmxldCBoYXNDaGVja2VkID0gZmFsc2U7XG5sZXQgX2Zsb2F0O1xuXG5cbmZ1bmN0aW9uIGNoZWNrRmxvYXQoKSB7XG5cdGlmKEdMLndlYmdsMikge1xuXHRcdHJldHVybiBHTC5nbC5GTE9BVDtcblx0fSBlbHNlIHtcblx0XHRjb25zdCBleHRGbG9hdCA9IEdMLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcblx0XHRpZihleHRGbG9hdCkge1xuXHRcdFx0cmV0dXJuIEdMLmdsLkZMT0FUO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1VTSU5HIEZMT0FUIEJVVCBPRVNfdGV4dHVyZV9mbG9hdCBOT1QgU1VQUE9SVEVEJyk7XG5cdFx0XHRyZXR1cm4gR0wuZ2wuVU5TSUdORURfQllURTtcblx0XHR9XG5cdH1cblxuXHRoYXNDaGVja2VkID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcblx0aWYoIWhhc0NoZWNrZWQpIHtcblx0XHRfZmxvYXQgPSBjaGVja0Zsb2F0KCk7XG5cdH1cblxuXG5cdHJldHVybiBfZmxvYXQ7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0RmxvYXQuanMiLCIvLyBnZXRIYWxmRmxvYXQuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5cbmxldCBoYXNDaGVja2VkID0gZmFsc2U7XG5sZXQgaGFsZkZsb2F0O1xuXG5mdW5jdGlvbiBjaGVja0hhbGZGbG9hdCgpIHtcblx0aWYoR0wud2ViZ2wyKSB7XG5cdFx0cmV0dXJuIEdMLmdsLkhBTEZfRkxPQVQ7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgZXh0SGFsZkZsb2F0ID0gR0wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG5cdFx0aWYoZXh0SGFsZkZsb2F0KSB7XG5cdFx0XHRyZXR1cm4gZXh0SGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1VTSU5HIEhBTEYgRkxPQVQgQlVUIE9FU190ZXh0dXJlX2hhbGZfZmxvYXQgTk9UIFNVUFBPUlRFRCcpO1xuXHRcdFx0cmV0dXJuIEdMLmdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0fVxuXHR9XG5cblx0aGFzQ2hlY2tlZCA9IHRydWU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG5cdGlmKCFoYXNDaGVja2VkKSB7XG5cdFx0aGFsZkZsb2F0ID0gY2hlY2tIYWxmRmxvYXQoKTtcblx0fVxuXG5cdHJldHVybiBoYWxmRmxvYXQ7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0SGFsZkZsb2F0LmpzIiwiLy8gRXh0ZW5zaW9uc0xpc3QuanNcblxuZXhwb3J0IGRlZmF1bHQgW1xuXHQnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcsIFxuXHQnRVhUX3NSR0InLCBcblx0J0VYVF9mcmFnX2RlcHRoJywgXG5cdCdPRVNfdGV4dHVyZV9mbG9hdCcsIFxuXHQnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcsIFxuXHQnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJywgXG5cdCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicsIFxuXHQnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJywgXG5cdCdXRUJHTF9kZXB0aF90ZXh0dXJlJywgXG5cdCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnLCBcblx0J09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JywgXG5cdCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgXG5cdCdXRUJHTF9kcmF3X2J1ZmZlcnMnXG5dO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL0V4dGVuc2lvbnNMaXN0LmpzIiwiLy8gZ2V0VGV4dHVyZVBhcmFtZXRlcnMuanNcblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byh4KSB7XHRcblx0cmV0dXJuICh4ICE9PSAwKSAmJiAoISh4ICYgKHggLSAxKSkpO1xufTtcblxuY29uc3QgZ2V0VGV4dHVyZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobVBhcmFtcywgbVNvdXJjZSwgbVdpZHRoLCBtSGVpZ2h0KSB7XG5cdGlmKCFtUGFyYW1zLm1pbkZpbHRlcikge1xuXHRcdGxldCBtaW5GaWx0ZXIgPSBHTC5MSU5FQVI7XG5cdFx0aWYobVdpZHRoICYmIG1XaWR0aCkge1xuXHRcdFx0aWYoaXNQb3dlck9mVHdvKG1XaWR0aCkgJiYgaXNQb3dlck9mVHdvKG1IZWlnaHQpKSB7XG5cdFx0XHRcdG1pbkZpbHRlciA9IEdMLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtUGFyYW1zLm1pbkZpbHRlciA9IG1pbkZpbHRlcjtcblx0fSBcblxuXG5cdG1QYXJhbXMubWlwbWFwID0gbVBhcmFtcy5taXBtYXAgfHwgdHJ1ZTtcblx0bVBhcmFtcy5tYWdGaWx0ZXIgPSBtUGFyYW1zLm1hZ0ZpbHRlciB8fCBHTC5MSU5FQVI7XG5cdG1QYXJhbXMud3JhcFMgPSBtUGFyYW1zLndyYXBTIHx8IEdMLkNMQU1QX1RPX0VER0U7XG5cdG1QYXJhbXMud3JhcFQgPSBtUGFyYW1zLndyYXBUIHx8IEdMLkNMQU1QX1RPX0VER0U7XG5cdG1QYXJhbXMuaW50ZXJuYWxGb3JtYXQgPSBtUGFyYW1zLmludGVybmFsRm9ybWF0IHx8IEdMLlJHQkE7XG5cdG1QYXJhbXMuZm9ybWF0ID0gbVBhcmFtcy5mb3JtYXQgfHwgR0wuUkdCQTtcblx0bVBhcmFtcy5wcmVtdWx0aXBseUFscGhhID0gbVBhcmFtcy5wcmVtdWx0aXBseUFscGhhIHx8IGZhbHNlO1xuXHRtUGFyYW1zLmxldmVsID0gbVBhcmFtcy5sZXZlbCB8fCAwO1xuXHRtUGFyYW1zLmFuaXNvdHJvcHkgPSBtUGFyYW1zLmFuaXNvdHJvcHkgfHwgMDtcblxuXHRyZXR1cm4gbVBhcmFtcztcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VGV4dHVyZVBhcmFtZXRlcnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvZ2V0VGV4dHVyZVBhcmFtZXRlcnMuanMiLCIvLyBBbGwgdmFsdWVzIGFuZCBzdHJ1Y3R1cmVzIHJlZmVyZW5jZWQgZnJvbTpcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9iYjk0Mzk5MS5hc3B4L1xuLy9cbi8vIERYMTAgQ3ViZW1hcCBzdXBwb3J0IGJhc2VkIG9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFyaW9tYW5lc2t1L2NtZnQvaXNzdWVzLzcjaXNzdWVjb21tZW50LTY5NTE2ODQ0XG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9iYjk0Mzk4Myh2PXZzLjg1KS5hc3B4XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcGxheWNhbnZhcy9lbmdpbmUvYmxvYi9tYXN0ZXIvc3JjL3Jlc291cmNlcy9yZXNvdXJjZXNfdGV4dHVyZS5qc1xuXG52YXIgRERTX01BR0lDID0gMHgyMDUzNDQ0NFxudmFyIEREU0RfTUlQTUFQQ09VTlQgPSAweDIwMDAwXG52YXIgRERQRl9GT1VSQ0MgPSAweDRcblxudmFyIEZPVVJDQ19EWFQxID0gZm91ckNDVG9JbnQzMignRFhUMScpXG52YXIgRk9VUkNDX0RYVDMgPSBmb3VyQ0NUb0ludDMyKCdEWFQzJylcbnZhciBGT1VSQ0NfRFhUNSA9IGZvdXJDQ1RvSW50MzIoJ0RYVDUnKVxudmFyIEZPVVJDQ19EWDEwID0gZm91ckNDVG9JbnQzMignRFgxMCcpXG52YXIgRk9VUkNDX0ZQMzJGID0gMTE2IC8vIERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVFxuXG52YXIgRERTQ0FQUzJfQ1VCRU1BUCA9IDB4MjAwXG52YXIgRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OX1RFWFRVUkUyRCA9IDNcbnZhciBEWEdJX0ZPUk1BVF9SMzJHMzJCMzJBMzJfRkxPQVQgPSAyXG5cbi8vIFRoZSBoZWFkZXIgbGVuZ3RoIGluIDMyIGJpdCBpbnRzXG52YXIgaGVhZGVyTGVuZ3RoSW50ID0gMzFcblxuLy8gT2Zmc2V0cyBpbnRvIHRoZSBoZWFkZXIgYXJyYXlcbnZhciBvZmZfbWFnaWMgPSAwXG52YXIgb2ZmX3NpemUgPSAxXG52YXIgb2ZmX2ZsYWdzID0gMlxudmFyIG9mZl9oZWlnaHQgPSAzXG52YXIgb2ZmX3dpZHRoID0gNFxudmFyIG9mZl9taXBtYXBDb3VudCA9IDdcbnZhciBvZmZfcGZGbGFncyA9IDIwXG52YXIgb2ZmX3BmRm91ckNDID0gMjFcbnZhciBvZmZfY2FwczIgPSAyOFxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlSGVhZGVyc1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKGFycmF5QnVmZmVyKSB7XG4gIHZhciBoZWFkZXIgPSBuZXcgSW50MzJBcnJheShhcnJheUJ1ZmZlciwgMCwgaGVhZGVyTGVuZ3RoSW50KVxuXG4gIGlmIChoZWFkZXJbb2ZmX21hZ2ljXSAhPT0gRERTX01BR0lDKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hZ2ljIG51bWJlciBpbiBERFMgaGVhZGVyJylcbiAgfVxuXG4gIGlmICghaGVhZGVyW29mZl9wZkZsYWdzXSAmIEREUEZfRk9VUkNDKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBmb3JtYXQsIG11c3QgY29udGFpbiBhIEZvdXJDQyBjb2RlJylcbiAgfVxuXG4gIHZhciBibG9ja0J5dGVzXG4gIHZhciBmb3JtYXRcbiAgdmFyIGZvdXJDQyA9IGhlYWRlcltvZmZfcGZGb3VyQ0NdXG4gIHN3aXRjaCAoZm91ckNDKSB7XG4gICAgY2FzZSBGT1VSQ0NfRFhUMTpcbiAgICAgIGJsb2NrQnl0ZXMgPSA4XG4gICAgICBmb3JtYXQgPSAnZHh0MSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBGT1VSQ0NfRFhUMzpcbiAgICAgIGJsb2NrQnl0ZXMgPSAxNlxuICAgICAgZm9ybWF0ID0gJ2R4dDMnXG4gICAgICBicmVha1xuICAgIGNhc2UgRk9VUkNDX0RYVDU6XG4gICAgICBibG9ja0J5dGVzID0gMTZcbiAgICAgIGZvcm1hdCA9ICdkeHQ1J1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEZPVVJDQ19GUDMyRjpcbiAgICAgIGZvcm1hdCA9ICdyZ2JhMzJmJ1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEZPVVJDQ19EWDEwOlxuICAgICAgdmFyIGR4MTBIZWFkZXIgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoMTI4LCAxMjggKyAyMCkpXG4gICAgICBmb3JtYXQgPSBkeDEwSGVhZGVyWzBdXG4gICAgICB2YXIgcmVzb3VyY2VEaW1lbnNpb24gPSBkeDEwSGVhZGVyWzFdXG4gICAgICB2YXIgbWlzY0ZsYWcgPSBkeDEwSGVhZGVyWzJdXG4gICAgICB2YXIgYXJyYXlTaXplID0gZHgxMEhlYWRlclszXVxuICAgICAgdmFyIG1pc2NGbGFnczIgPSBkeDEwSGVhZGVyWzRdXG5cbiAgICAgIGlmIChyZXNvdXJjZURpbWVuc2lvbiA9PT0gRDNEMTBfUkVTT1VSQ0VfRElNRU5TSU9OX1RFWFRVUkUyRCAmJiBmb3JtYXQgPT09IERYR0lfRk9STUFUX1IzMkczMkIzMkEzMl9GTE9BVCkge1xuICAgICAgICBmb3JtYXQgPSAncmdiYTMyZidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgRFgxMCB0ZXh0dXJlIGZvcm1hdCAnICsgZm9ybWF0KVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBGb3VyQ0MgY29kZTogJyArIGludDMyVG9Gb3VyQ0MoZm91ckNDKSlcbiAgfVxuXG4gIHZhciBmbGFncyA9IGhlYWRlcltvZmZfZmxhZ3NdXG4gIHZhciBtaXBtYXBDb3VudCA9IDFcblxuICBpZiAoZmxhZ3MgJiBERFNEX01JUE1BUENPVU5UKSB7XG4gICAgbWlwbWFwQ291bnQgPSBNYXRoLm1heCgxLCBoZWFkZXJbb2ZmX21pcG1hcENvdW50XSlcbiAgfVxuXG4gIHZhciBjdWJlbWFwID0gZmFsc2VcbiAgdmFyIGNhcHMyID0gaGVhZGVyW29mZl9jYXBzMl1cbiAgaWYgKGNhcHMyICYgRERTQ0FQUzJfQ1VCRU1BUCkge1xuICAgIGN1YmVtYXAgPSB0cnVlXG4gIH1cblxuICB2YXIgd2lkdGggPSBoZWFkZXJbb2ZmX3dpZHRoXVxuICB2YXIgaGVpZ2h0ID0gaGVhZGVyW29mZl9oZWlnaHRdXG4gIHZhciBkYXRhT2Zmc2V0ID0gaGVhZGVyW29mZl9zaXplXSArIDRcbiAgdmFyIHRleFdpZHRoID0gd2lkdGhcbiAgdmFyIHRleEhlaWdodCA9IGhlaWdodFxuICB2YXIgaW1hZ2VzID0gW11cbiAgdmFyIGRhdGFMZW5ndGhcblxuICBpZiAoZm91ckNDID09PSBGT1VSQ0NfRFgxMCkge1xuICAgIGRhdGFPZmZzZXQgKz0gMjBcbiAgfVxuXG4gIGlmIChjdWJlbWFwKSB7XG4gICAgZm9yICh2YXIgZiA9IDA7IGYgPCA2OyBmKyspIHtcbiAgICAgIGlmIChmb3JtYXQgIT09ICdyZ2JhMzJmJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgUkdCQTMyZiBjdWJlbWFwcyBhcmUgc3VwcG9ydGVkJylcbiAgICAgIH1cbiAgICAgIHZhciBicHAgPSA0ICogMzIgLyA4XG5cbiAgICAgIHdpZHRoID0gdGV4V2lkdGhcbiAgICAgIGhlaWdodCA9IHRleEhlaWdodFxuXG4gICAgICAvLyBjdWJlbWFwIHNob3VsZCBoYXZlIGFsbCBtaXBtYXAgbGV2ZWxzIGRlZmluZWRcbiAgICAgIC8vIE1hdGgubG9nMih3aWR0aCkgKyAxXG4gICAgICB2YXIgcmVxdWlyZWRNaXBMZXZlbHMgPSBNYXRoLmxvZyh3aWR0aCkgLyBNYXRoLmxvZygyKSArIDFcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXF1aXJlZE1pcExldmVsczsgaSsrKSB7XG4gICAgICAgIGRhdGFMZW5ndGggPSB3aWR0aCAqIGhlaWdodCAqIGJwcFxuICAgICAgICBpbWFnZXMucHVzaCh7XG4gICAgICAgICAgb2Zmc2V0OiBkYXRhT2Zmc2V0LFxuICAgICAgICAgIGxlbmd0aDogZGF0YUxlbmd0aCxcbiAgICAgICAgICBzaGFwZTogWyB3aWR0aCwgaGVpZ2h0IF1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gUmV1c2UgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyBsZXZlbCBpZiB3ZSBhcmUgYmV5b25kIG1pcG1hcENvdW50XG4gICAgICAgIC8vIFRoaXMgaXMgaGFjayBmb3IgQ01GVCBub3QgcHVibGlzaGluZyBmdWxsIG1pcG1hcCBjaGFpbiBodHRwczovL2dpdGh1Yi5jb20vZGFyaW9tYW5lc2t1L2NtZnQvaXNzdWVzLzEwXG4gICAgICAgIGlmIChpIDwgbWlwbWFwQ291bnQpIHtcbiAgICAgICAgICBkYXRhT2Zmc2V0ICs9IGRhdGFMZW5ndGhcbiAgICAgICAgfVxuICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKVxuICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAvIDIpXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlwbWFwQ291bnQ7IGkrKykge1xuICAgICAgZGF0YUxlbmd0aCA9IE1hdGgubWF4KDQsIHdpZHRoKSAvIDQgKiBNYXRoLm1heCg0LCBoZWlnaHQpIC8gNCAqIGJsb2NrQnl0ZXNcblxuICAgICAgaW1hZ2VzLnB1c2goe1xuICAgICAgICBvZmZzZXQ6IGRhdGFPZmZzZXQsXG4gICAgICAgIGxlbmd0aDogZGF0YUxlbmd0aCxcbiAgICAgICAgc2hhcGU6IFsgd2lkdGgsIGhlaWdodCBdXG4gICAgICB9KVxuICAgICAgZGF0YU9mZnNldCArPSBkYXRhTGVuZ3RoXG4gICAgICB3aWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKVxuICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgLyAyKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2hhcGU6IFsgdGV4V2lkdGgsIHRleEhlaWdodCBdLFxuICAgIGltYWdlczogaW1hZ2VzLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZsYWdzOiBmbGFncyxcbiAgICBjdWJlbWFwOiBjdWJlbWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gZm91ckNDVG9JbnQzMiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCkgK1xuICAgICh2YWx1ZS5jaGFyQ29kZUF0KDEpIDw8IDgpICtcbiAgICAodmFsdWUuY2hhckNvZGVBdCgyKSA8PCAxNikgK1xuICAgICh2YWx1ZS5jaGFyQ29kZUF0KDMpIDw8IDI0KVxufVxuXG5mdW5jdGlvbiBpbnQzMlRvRm91ckNDICh2YWx1ZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICB2YWx1ZSAmIDB4ZmYsXG4gICAgKHZhbHVlID4+IDgpICYgMHhmZixcbiAgICAodmFsdWUgPj4gMTYpICYgMHhmZixcbiAgICAodmFsdWUgPj4gMjQpICYgMHhmZlxuICApXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wYXJzZS1kZHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHJpbmdzKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5ncyA9PT0gJ3N0cmluZycpIHN0cmluZ3MgPSBbc3RyaW5nc11cbiAgdmFyIGV4cHJzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSlcbiAgdmFyIHBhcnRzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aC0xOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHN0cmluZ3NbaV0sIGV4cHJzW2ldIHx8ICcnKVxuICB9XG4gIHBhcnRzLnB1c2goc3RyaW5nc1tpXSlcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJhc2ljLmZyYWdcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJBU0lDX0ZSQUdNRU5UXFxuXFxucHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxuLy8gdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZUZXh0dXJlQ29vcmQsIHNpbih0aW1lKSAqIC41ICsgLjUsIDEuMCk7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2Jhc2ljLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQ3ViZUZyYW1lQnVmZmVyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEdMIGZyb20gJy4vR0xUb29sJztcbmltcG9ydCBHTEN1YmVUZXh0dXJlIGZyb20gJy4vR0xDdWJlVGV4dHVyZSc7XG5cbmxldCBnbDtcblxuXG5jbGFzcyBDdWJlRnJhbWVCdWZmZXIge1xuXG5cdGNvbnN0cnVjdG9yKHNpemUsIG1QYXJhbWV0ZXJzID0ge30pIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHRoaXMuX3NpemUgPSBzaXplO1xuXHRcdHRoaXMubWFnRmlsdGVyID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciB8fCBnbC5MSU5FQVI7XG5cdFx0dGhpcy53cmFwUyAgICAgPSBtUGFyYW1ldGVycy53cmFwUyB8fCBnbC5DTEFNUF9UT19FREdFO1xuXHRcdHRoaXMud3JhcFQgICAgID0gbVBhcmFtZXRlcnMud3JhcFQgfHwgZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0X2luaXQoKSB7XG5cdFx0dGhpcy50ZXh0dXJlICAgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0dGhpcy5nbFRleHR1cmUgPSBuZXcgR0xDdWJlVGV4dHVyZSh0aGlzLnRleHR1cmUsIHt9LCB0cnVlKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRoaXMudGV4dHVyZSk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5taW5GaWx0ZXIpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMud3JhcFQpO1xuXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IFtcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLCBcblx0XHRcdGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWiwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aIFxuXHRcdF07XG5cblx0XHRmb3IobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xuXHRcdFx0Z2wudGV4SW1hZ2UyRCh0YXJnZXRzW2ldLCAwLCBnbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy5fZnJhbWVCdWZmZXJzID0gW107XG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblx0XHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuXHRcdFx0Z2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0YXJnZXRzW2ldLCB0aGlzLnRleHR1cmUsIDApO1xuXG5cdFx0XHRjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcblx0XHRcdGlmIChzdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGAnZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cygpIHJldHVybmVkICcke3N0YXR1c31gKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZnJhbWVCdWZmZXJzLnB1c2goZnJhbWVCdWZmZXIpO1xuXHRcdH1cblxuXHRcdC8vIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwpO1xuXHR9XG5cblxuXHRiaW5kKG1UYXJnZXRJbmRleCkge1xuXG5cdFx0Ly8gaWYoTWF0aC5yYW5kb20oKSA+IC45OSkgY29uc29sZS5sb2coJ2JpbmQgOicsIG1UYXJnZXRJbmRleCwgdGhpcy5fZnJhbWVCdWZmZXJzW21UYXJnZXRJbmRleF0pO1xuXHRcdEdMLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lQnVmZmVyc1ttVGFyZ2V0SW5kZXhdKTtcblx0fVxuXG5cdHVuYmluZCgpIHtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXHRcdEdMLnZpZXdwb3J0KDAsIDAsIEdMLndpZHRoLCBHTC5oZWlnaHQpO1xuXHR9XG5cblx0Ly9cdFRFWFRVUkVTXG5cblx0Z2V0VGV4dHVyZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5nbFRleHR1cmU7XG5cdH1cblxuXHQvL1x0R0VUVEVSUyBBTkQgU0VUVEVSU1xuXG5cdGdldCB3aWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZTtcblx0fVxuXG5cdGdldCBoZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemU7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDdWJlRnJhbWVCdWZmZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvQ3ViZUZyYW1lQnVmZmVyLmpzIiwiLy8gTXVsdGlzYW1wbGVGcmFtZUJ1ZmZlci5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuL0dMVGV4dHVyZSc7XG5cbmxldCBnbDtcblxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpIHtcdFxuXHRyZXR1cm4gKHggIT09IDApICYmICghKHggJiAoeCAtIDEpKSk7XG59O1xuXG5jbGFzcyBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyIHtcblx0Y29uc3RydWN0b3IobVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1ldGVycyA9IHt9KSB7XG5cdFx0Z2wgPSBHTC5nbDtcblxuXHRcdHRoaXMud2lkdGggICAgICAgICAgICA9IG1XaWR0aDtcblx0XHR0aGlzLmhlaWdodCAgICAgICAgICAgPSBtSGVpZ2h0O1xuXG5cdFx0dGhpcy5tYWdGaWx0ZXIgID0gbVBhcmFtZXRlcnMubWFnRmlsdGVyIFx0fHwgZ2wuTElORUFSO1xuXHRcdHRoaXMubWluRmlsdGVyICA9IG1QYXJhbWV0ZXJzLm1pbkZpbHRlciBcdHx8IGdsLkxJTkVBUjtcblx0XHR0aGlzLndyYXBTICAgICAgPSBtUGFyYW1ldGVycy53cmFwUyBcdFx0fHwgZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHR0aGlzLndyYXBUICAgICAgPSBtUGFyYW1ldGVycy53cmFwVCBcdFx0fHwgZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHR0aGlzLnVzZURlcHRoICAgPSBtUGFyYW1ldGVycy51c2VEZXB0aCBcdFx0fHwgdHJ1ZTtcblx0XHR0aGlzLnVzZVN0ZW5jaWwgPSBtUGFyYW1ldGVycy51c2VTdGVuY2lsIFx0fHwgZmFsc2U7XG5cdFx0dGhpcy50ZXhlbFR5cGUgXHQ9IG1QYXJhbWV0ZXJzLnR5cGU7XG5cdFx0dGhpcy5fbnVtU2FtcGxlID0gbVBhcmFtZXRlcnMubnVtU2FtcGxlIFx0fHwgODtcblxuXHRcdGlmKCFpc1Bvd2VyT2ZUd28odGhpcy53aWR0aCkgfHwgIWlzUG93ZXJPZlR3byh0aGlzLmhlaWdodCkpIHtcblx0XHRcdHRoaXMud3JhcFMgPSB0aGlzLndyYXBUID0gZ2wuQ0xBTVBfVE9fRURHRTtcblxuXHRcdFx0aWYodGhpcy5taW5GaWx0ZXIgPT09IGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCkge1xuXHRcdFx0XHR0aGlzLm1pbkZpbHRlciA9IGdsLkxJTkVBUjtcblx0XHRcdH1cblx0XHR9IFxuXG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblx0X2luaXQoKSB7XG5cdFx0bGV0IHRleGVsVHlwZSA9IGdsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKHRoaXMudGV4ZWxUeXBlKSB7XG5cdFx0XHR0ZXhlbFR5cGUgPSB0aGlzLnRleGVsVHlwZTtcblx0XHR9XG5cblx0XHR0aGlzLnRleGVsVHlwZSA9IHRleGVsVHlwZTtcblxuXHRcdHRoaXMuZnJhbWVCdWZmZXIgICAgICAgID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcdFxuXHRcdHRoaXMuZnJhbWVCdWZmZXJDb2xvciAgID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcdFxuXHRcdHRoaXMucmVuZGVyQnVmZmVyQ29sb3IgID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0dGhpcy5yZW5kZXJCdWZmZXJEZXB0aCAgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHR0aGlzLmdsVGV4dHVyZSBcdFx0XHQ9IHRoaXMuX2NyZWF0ZVRleHR1cmUoKTtcblx0XHR0aGlzLmdsRGVwdGhUZXh0dXJlIFx0PSB0aGlzLl9jcmVhdGVUZXh0dXJlKGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBnbC5VTlNJR05FRF9TSE9SVCwgZ2wuREVQVEhfQ09NUE9ORU5ULCB0cnVlKTtcblxuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLnJlbmRlckJ1ZmZlckNvbG9yKTtcblx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9udW1TYW1wbGUsIGdsLlJHQkE4LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5fbnVtU2FtcGxlLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJDb2xvcik7XG5cdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5yZW5kZXJCdWZmZXJEZXB0aCk7XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlckNvbG9yKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xUZXh0dXJlLnRleHR1cmUsIDApO1xuXHRcdC8vIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5URVhUVVJFXzJELCB0aGlzLmdsRGVwdGhUZXh0dXJlLnRleHR1cmUsIDApO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXJEZXB0aCk7XG5cdFx0Ly8gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZ2xEZXB0aFRleHR1cmUudGV4dHVyZSwgMCk7XG5cdFx0Ly8gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblx0fVxuXG5cdF9jcmVhdGVUZXh0dXJlKG1JbnRlcm5hbGZvcm1hdCwgbVRleGVsVHlwZSwgbUZvcm1hdCwgZm9yY2VOZWFyZXN0ID0gZmFsc2UpIHtcblx0XHRpZihtSW50ZXJuYWxmb3JtYXQgPT09IHVuZGVmaW5lZCkge1x0bUludGVybmFsZm9ybWF0ID0gZ2wuUkdCQTtcdH1cblx0XHRpZihtVGV4ZWxUeXBlID09PSB1bmRlZmluZWQpIHtcdG1UZXhlbFR5cGUgPSB0aGlzLnRleGVsVHlwZTtcdH1cblx0XHRpZighbUZvcm1hdCkge1x0bUZvcm1hdCA9IG1JbnRlcm5hbGZvcm1hdDsgfVxuXG5cdFx0Y29uc3QgdCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRjb25zdCBnbHQgPSBuZXcgR0xUZXh0dXJlKHQsIHRydWUpO1xuXHRcdGNvbnN0IG1hZ0ZpbHRlciA9IGZvcmNlTmVhcmVzdCA/IEdMLk5FQVJFU1QgOiB0aGlzLm1hZ0ZpbHRlcjtcblx0XHRjb25zdCBtaW5GaWx0ZXIgPSBmb3JjZU5lYXJlc3QgPyBHTC5ORUFSRVNUIDogdGhpcy5taW5GaWx0ZXI7XG5cblx0XHRnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0KTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgbWFnRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgbWluRmlsdGVyKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLndyYXBTKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcblx0XHRnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIG1JbnRlcm5hbGZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIG1Gb3JtYXQsIG1UZXhlbFR5cGUsIG51bGwpO1x0XG5cdFx0Z2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG5cblx0XHRyZXR1cm4gZ2x0O1xuXHR9XG5cblxuXHRiaW5kKG1BdXRvU2V0Vmlld3BvcnQ9dHJ1ZSkge1xuXHRcdGlmKG1BdXRvU2V0Vmlld3BvcnQpIHtcblx0XHRcdEdMLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcdFxuXHRcdH1cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHR9XG5cblxuXHR1bmJpbmQobUF1dG9TZXRWaWV3cG9ydD10cnVlKSB7XG5cdFx0aWYobUF1dG9TZXRWaWV3cG9ydCkge1xuXHRcdFx0R0wudmlld3BvcnQoMCwgMCwgR0wud2lkdGgsIEdMLmhlaWdodCk7XHRcblx0XHR9XG5cblx0XHRjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG5cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKGdsLlJFQURfRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVCdWZmZXIpO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5EUkFXX0ZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyQ29sb3IpO1xuXHRcdGdsLmNsZWFyQnVmZmVyZnYoZ2wuQ09MT1IsIDAsIFswLjAsIDAuMCwgMC4wLCAwLjBdKTtcblx0XHRnbC5ibGl0RnJhbWVidWZmZXIoXG5cdFx0XHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHRcdGdsLkNPTE9SX0JVRkZFUl9CSVQsIEdMLk5FQVJFU1Rcblx0XHQpO1xuXHRcdC8vIGdsLmJsaXRGcmFtZWJ1ZmZlcihcblx0XHQvLyBcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0Ly8gXHQwLCAwLCB3aWR0aCwgaGVpZ2h0LFxuXHRcdC8vIFx0Z2wuQ09MT1JfQlVGRkVSX0JJVHxnbC5ERVBUSF9TVEVOQ0lMLCBHTC5ORUFSRVNUXG5cdFx0Ly8gKTtcblxuXHRcdC8vIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5SRUFEX0ZSQU1FQlVGRkVSLCB0aGlzLmZyYW1lQnVmZmVyKTtcblx0XHQvLyBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRFJBV19GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZUJ1ZmZlckRlcHRoKTtcblx0XHQvLyBnbC5jbGVhckJ1ZmZlcmZpKGdsLkRFUFRIX1NURU5DSUwsIDAsIDEuMCwgMCk7XG5cdFx0Ly8gZ2wuYmxpdEZyYW1lYnVmZmVyKFxuXHRcdC8vIFx0MCwgMCwgd2lkdGgsIGhlaWdodCxcblx0XHQvLyBcdDAsIDAsIHdpZHRoLCBoZWlnaHQsXG5cdFx0Ly8gXHRnbC5ERVBUSF9CVUZGRVJfQklULCBnbC5ORUFSRVNUXG5cdFx0Ly8gKTtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG5cdH1cblxuXG5cdGdldFRleHR1cmUobUluZGV4ID0gMCkge1xuXHRcdHJldHVybiB0aGlzLmdsVGV4dHVyZTtcblx0fVxuXG5cblx0Z2V0RGVwdGhUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLmdsRGVwdGhUZXh0dXJlO1xuXHR9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aXNhbXBsZUZyYW1lQnVmZmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL011bHRpc2FtcGxlRnJhbWVCdWZmZXIuanMiLCIvLyBUcmFuc2Zvcm1GZWVkYmFja09iamVjdC5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi9HTFRvb2wnO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4vR0xTaGFkZXInO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4vR2VvbWV0cnknO1xuXG5sZXQgZ2w7XG5cbmNsYXNzIFRyYW5zZm9ybUZlZWRiYWNrT2JqZWN0IHtcblxuXG5cdGNvbnN0cnVjdG9yKHN0clZlcnRleFNoYWRlciwgc3RyRnJhZ21lbnRTaGFkZXIpIHtcblx0XHRnbCA9IEdMLmdsO1xuXHRcdHRoaXMuX3ZzID0gc3RyVmVydGV4U2hhZGVyO1xuXHRcdHRoaXMuX2ZzID0gc3RyRnJhZ21lbnRTaGFkZXI7XG5cdFx0XG5cdFx0dGhpcy5faW5pdCgpO1xuXHR9XG5cblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLl9nZW9DdXJyZW50ID0gbmV3IEdlb21ldHJ5KCk7XG5cdFx0dGhpcy5fZ2VvVGFyZ2V0ID0gbmV3IEdlb21ldHJ5KCk7XG5cdFx0dGhpcy5fbnVtUG9pbnRzID0gLTE7XG5cblx0XHR0aGlzLl92YXJ5aW5ncyA9IFtdO1xuXHRcdHRoaXMudHJhbnNmb3JtRmVlZGJhY2sgPSBnbC5jcmVhdGVUcmFuc2Zvcm1GZWVkYmFjaygpO1xuXHR9XG5cblxuXHRidWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbVZhcnlpbmdOYW1lKSB7XG5cdFx0Y29uc3QgaXNUcmFuc2Zvcm1GZWVkYmFjayA9ICEhbVZhcnlpbmdOYW1lO1xuXHRcdGNvbnNvbGUubG9nKCdpcyBUcmFuc2Zvcm0gZmVlZGJhY2sgPycsIG1OYW1lLCBpc1RyYW5zZm9ybUZlZWRiYWNrKTtcblx0XHR0aGlzLl9nZW9DdXJyZW50LmJ1ZmZlckRhdGEobURhdGEsIG1OYW1lLCBudWxsLCBnbC5TVFJFQU1fQ09QWSwgZmFsc2UpO1xuXHRcdHRoaXMuX2dlb1RhcmdldC5idWZmZXJEYXRhKG1EYXRhLCBtTmFtZSwgbnVsbCwgZ2wuU1RSRUFNX0NPUFksIGZhbHNlKTtcblxuXHRcdGlmKGlzVHJhbnNmb3JtRmVlZGJhY2spIHtcblx0XHRcdHRoaXMuX3ZhcnlpbmdzLnB1c2gobVZhcnlpbmdOYW1lKTtcblxuXHRcdFx0aWYodGhpcy5fbnVtUG9pbnRzIDwgMCkge1xuXHRcdFx0XHR0aGlzLl9udW1Qb2ludHMgPSBtRGF0YS5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YnVmZmVySW5kZXgobUFycmF5SW5kaWNlcykge1xuXHRcdHRoaXMuX2dlb0N1cnJlbnQuYnVmZmVySW5kZXgobUFycmF5SW5kaWNlcyk7XG5cdFx0dGhpcy5fZ2VvVGFyZ2V0LmJ1ZmZlckluZGV4KG1BcnJheUluZGljZXMpO1xuXHR9XG5cblxuXHR1bmlmb3JtKG1OYW1lLCBtVHlwZSwgbVZhbHVlKSB7XG5cdFx0aWYodGhpcy5zaGFkZXIpIHtcblx0XHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0obU5hbWUsIG1UeXBlLCBtVmFsdWUpO1x0XG5cdFx0fVxuXHRcdFxuXHR9XG5cblx0Z2VuZXJhdGUoKSB7XG5cdFx0dGhpcy5zaGFkZXIgPSBuZXcgR0xTaGFkZXIodGhpcy5fdnMsIHRoaXMuX2ZzLCB0aGlzLl92YXJ5aW5ncyk7XG5cdH1cblxuXHRyZW5kZXIoKSB7XG5cdFx0aWYoIXRoaXMuc2hhZGVyKSB7XHR0aGlzLmdlbmVyYXRlKCk7XHR9XG5cblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0R0wuZHJhd1RyYW5zZm9ybUZlZWRiYWNrKHRoaXMpO1xuXG5cdFx0dGhpcy5fc3dhcCgpO1xuXHR9XG5cblx0X3N3YXAoKSB7XG5cdFx0Y29uc3QgdG1wICAgICAgICAgID0gdGhpcy5fZ2VvQ3VycmVudDtcblx0XHR0aGlzLl9nZW9DdXJyZW50ID0gdGhpcy5fZ2VvVGFyZ2V0O1xuXHRcdHRoaXMuX2dlb1RhcmdldCAgPSB0bXA7XG5cdH1cblxuXHRnZXQgbnVtUG9pbnRzKCkge1x0cmV0dXJuIHRoaXMuX251bVBvaW50cztcdH1cblx0Z2V0IGdlb0N1cnJlbnQoKSB7XHRyZXR1cm4gdGhpcy5fZ2VvQ3VycmVudDtcdH1cblx0Z2V0IGdlb1RhcmdldCgpIHtcdHJldHVybiB0aGlzLl9nZW9UYXJnZXQ7XHR9XG5cdGdldCBnZW9Tb3VyY2UoKSB7XHRyZXR1cm4gdGhpcy5fZ2VvQ3VycmVudDtcdH1cblx0Z2V0IGdlb0Rlc3RpbmF0aW9uKCkge1x0cmV0dXJuIHRoaXMuX2dlb1RhcmdldDtcdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBUcmFuc2Zvcm1GZWVkYmFja09iamVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9UcmFuc2Zvcm1GZWVkYmFja09iamVjdC5qcyIsIi8vIFR3ZWVuTnVtYmVyLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcblxuY29uc3QgRWFzaW5nID0ge1xuXHRMaW5lYXI6IHtcblx0XHROb25lKGspIHtcblx0XHRcdHJldHVybiBrO1xuXHRcdH1cblx0fSxcblx0UXVhZHJhdGljOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIGsgKiBrO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdHJldHVybiBrICogKDIgLSBrKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0gMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcblx0XHR9XG5cdH0sXG5cdEN1YmljOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIGsgKiBrICogaztcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gLS1rICogayAqIGsgKyAxO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG5cdFx0fVxuXHR9LFxuXHRRdWFydGljOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIGsgKiBrICogayAqIGs7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIDEgLSAoLS1rICogayAqIGsgKiBrKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLSAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcblx0XHR9XG5cdH0sXG5cdFF1aW50aWM6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG5cdFx0fSxcblx0XHRPdXQoaykge1xuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKiBrICogayArIDIpO1xuXHRcdH1cblx0fSxcblx0U2ludXNvaWRhbDoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG5cdFx0fVxuXHR9LFxuXHRFeHBvbmVudGlhbDoge1xuXHRcdEluKGspIHtcblx0XHRcdHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KDEwMjQsIGsgLSAxKTtcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLSAxMCAqIGspO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoLSBNYXRoLnBvdygyLCAtIDEwICogKGsgLSAxKSkgKyAyKTtcblx0XHR9XG5cdH0sXG5cdENpcmN1bGFyOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIGsgKiBrKTtcblx0XHR9LFxuXHRcdE91dChrKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuXHRcdH0sXG5cdFx0SW5PdXQoaykge1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gLSAwLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG5cdFx0fVxuXHR9LFxuXHRFbGFzdGljOiB7XG5cdFx0SW4oaykge1xuXHRcdFx0bGV0IHM7XG5cdFx0XHRsZXQgYSA9IDAuMTtcblx0XHRcdGNvbnN0IHAgPSAwLjQ7XG5cdFx0XHRpZiAoayA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmIChrID09PSAxKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFhIHx8IGEgPCAxKSB7XG5cdFx0XHRcdGEgPSAxO1xuXHRcdFx0XHRzID0gcCAvIDQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzID0gcCAqIE1hdGguYXNpbigxIC8gYSkgLyAoMiAqIE1hdGguUEkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0gKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdGxldCBzO1xuXHRcdFx0bGV0IGEgPSAwLjE7XG5cdFx0XHRjb25zdCBwID0gMC40O1xuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdGlmICghYSB8fCBhIDwgMSkge1xuXHRcdFx0XHRhID0gMTtcblx0XHRcdFx0cyA9IHAgLyA0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0gMTAgKiBrKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxKTtcblx0XHR9LFxuXHRcdEluT3V0KGspIHtcblx0XHRcdGxldCBzO1xuXHRcdFx0bGV0IGEgPSAwLjE7XG5cdFx0XHRjb25zdCBwID0gMC40O1xuXHRcdFx0aWYgKGsgPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAoayA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdGlmICghYSB8fCBhIDwgMSkge1xuXHRcdFx0XHRhID0gMTtcblx0XHRcdFx0cyA9IHAgLyA0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcblx0XHRcdH1cblx0XHRcdGlmICgoayAqPSAyKSA8IDEpIHtcblx0XHRcdFx0cmV0dXJuIC0gMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcblx0XHR9XG5cdH0sXG5cdEJhY2s6IHtcblx0XHRJbihrKSB7XG5cdFx0XHRjb25zdCBzID0gMS43MDE1ODtcblx0XHRcdHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuXHRcdH0sXG5cdFx0T3V0KGspIHtcblx0XHRcdGNvbnN0IHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG5cdFx0fSxcblx0XHRJbk91dChrKSB7XG5cdFx0XHRjb25zdCBzID0gMS43MDE1OCAqIDEuNTI1O1xuXHRcdFx0aWYgKChrICo9IDIpIDwgMSkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xuXHRcdH1cblx0fSxcblx0Qm91bmNlOiB7XG5cdFx0aW4oaykge1xuXHRcdFx0cmV0dXJuIDEgLSBFYXNpbmcuQm91bmNlLm91dCgxIC0gayk7XG5cdFx0fSxcblx0XHRvdXQoaykge1xuXHRcdFx0aWYgKGsgPCAoMSAvIDIuNzUpKSB7XG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiBrICogaztcblx0XHRcdH0gZWxzZSBpZiAoayA8ICgyIC8gMi43NSkpIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChrIC09ICgxLjUgLyAyLjc1KSkgKiBrICsgMC43NTtcblx0XHRcdH0gZWxzZSBpZiAoayA8ICgyLjUgLyAyLjc1KSkge1xuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuMjUgLyAyLjc1KSkgKiBrICsgMC45Mzc1O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjYyNSAvIDIuNzUpKSAqIGsgKyAwLjk4NDM3NTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGluT3V0KGspIHtcblx0XHRcdGlmIChrIDwgMC41KSB7XG5cdFx0XHRcdHJldHVybiBFYXNpbmcuQm91bmNlLmluKGsgKiAyKSAqIDAuNTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBFYXNpbmcuQm91bmNlLm91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuXHRcdH1cblx0fVxufTtcblxuZnVuY3Rpb24gZ2V0RnVuYyhtRWFzaW5nKSB7XG5cdHN3aXRjaCAobUVhc2luZykge1xuXHRkZWZhdWx0OlxuXHRjYXNlICdsaW5lYXInIDpcblx0XHRyZXR1cm4gRWFzaW5nLkxpbmVhci5Ob25lO1xuXHRjYXNlICdleHBJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuRXhwb25lbnRpYWwuSW47XG5cdGNhc2UgJ2V4cE91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuRXhwb25lbnRpYWwuT3V0O1xuXHRjYXNlICdleHBJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuRXhwb25lbnRpYWwuSW5PdXQ7XG5cblx0Y2FzZSAnY3ViaWNJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuQ3ViaWMuSW47XG5cdGNhc2UgJ2N1YmljT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DdWJpYy5PdXQ7XG5cdGNhc2UgJ2N1YmljSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkN1YmljLkluT3V0O1xuXG5cdGNhc2UgJ3F1YXJ0aWNJbicgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVhcnRpYy5Jbjtcblx0Y2FzZSAncXVhcnRpY091dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVhcnRpYy5PdXQ7XG5cdGNhc2UgJ3F1YXJ0aWNJbk91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuUXVhcnRpYy5Jbk91dDtcblxuXHRjYXNlICdxdWludGljSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLlF1aW50aWMuSW47XG5cdGNhc2UgJ3F1aW50aWNPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlF1aW50aWMuT3V0O1xuXHRjYXNlICdxdWludGljSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLlF1aW50aWMuSW5PdXQ7XG5cblx0Y2FzZSAnc2ludXNvaWRhbEluJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5TaW51c29pZGFsLkluO1xuXHRjYXNlICdzaW51c29pZGFsT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5TaW51c29pZGFsLk91dDtcblx0Y2FzZSAnc2ludXNvaWRhbEluT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5TaW51c29pZGFsLkluT3V0O1xuXG5cdGNhc2UgJ2NpcmN1bGFySW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkNpcmN1bGFyLkluO1xuXHRjYXNlICdjaXJjdWxhck91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQ2lyY3VsYXIuT3V0O1xuXHRjYXNlICdjaXJjdWxhckluT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5DaXJjdWxhci5Jbk91dDtcblxuXHRjYXNlICdlbGFzdGljSW4nIDpcblx0XHRyZXR1cm4gRWFzaW5nLkVsYXN0aWMuSW47XG5cdGNhc2UgJ2VsYXN0aWNPdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkVsYXN0aWMuT3V0O1xuXHRjYXNlICdlbGFzdGljSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkVsYXN0aWMuSW5PdXQ7XG5cblx0Y2FzZSAnYmFja0luJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5CYWNrLkluO1xuXHRjYXNlICdiYWNrT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5CYWNrLk91dDtcblx0Y2FzZSAnYmFja0luT3V0JyA6XG5cdFx0cmV0dXJuIEVhc2luZy5CYWNrLkluT3V0O1xuXG5cdGNhc2UgJ2JvdW5jZUluJyA6XG5cdFx0cmV0dXJuIEVhc2luZy5Cb3VuY2UuaW47XG5cdGNhc2UgJ2JvdW5jZU91dCcgOlxuXHRcdHJldHVybiBFYXNpbmcuQm91bmNlLm91dDtcblx0Y2FzZSAnYm91bmNlSW5PdXQnIDpcblx0XHRyZXR1cm4gRWFzaW5nLkJvdW5jZS5pbk91dDtcblx0fVxufVxuXG5jbGFzcyBUd2Vlbk51bWJlciB7XG5cdGNvbnN0cnVjdG9yKG1WYWx1ZSwgbUVhc2luZyA9ICdleHBPdXQnLCBtU3BlZWQgPSAwLjAxKSB7XG5cdFx0dGhpcy5fdmFsdWUgPSBtVmFsdWU7XG5cdFx0dGhpcy5fc3RhcnRWYWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9jb3VudGVyID0gMTtcblx0XHR0aGlzLnNwZWVkID0gbVNwZWVkO1xuXHRcdHRoaXMuZWFzaW5nID0gbUVhc2luZztcblx0XHR0aGlzLl9uZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMuX2VmSW5kZXggICAgID0gU2NoZWR1bGVyLmFkZEVGKCgpPT4gdGhpcy5fdXBkYXRlKCkpO1xuXHR9XG5cblxuXHRfdXBkYXRlKCkge1xuXHRcdGxldCBuZXdDb3VudGVyID0gdGhpcy5fY291bnRlciArIHRoaXMuc3BlZWQ7XG5cdFx0aWYobmV3Q291bnRlciA+IDEpIHsgbmV3Q291bnRlciA9IDE7IH1cblx0XHRpZih0aGlzLl9jb3VudGVyID09PSBuZXdDb3VudGVyKSB7XG5cdFx0XHR0aGlzLl9uZWVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fY291bnRlciA9IG5ld0NvdW50ZXI7XG5cdFx0dGhpcy5fbmVlZFVwZGF0ZSA9IHRydWU7XG5cdH1cblxuXG5cdGxpbWl0KG1NaW4sIG1NYXgpIHtcblx0XHRpZihtTWluID4gbU1heCkge1xuXHRcdFx0dGhpcy5saW1pdChtTWF4LCBtTWluKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9taW4gPSBtTWluO1xuXHRcdHRoaXMuX21heCA9IG1NYXg7XG5cblx0XHR0aGlzLl9jaGVja0xpbWl0KCk7XG5cdH1cblxuXHRzZXRUbyhtVmFsdWUpIHtcblx0XHR0aGlzLl92YWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl90YXJnZXRWYWx1ZSA9IG1WYWx1ZTtcblx0XHR0aGlzLl9jb3VudGVyID0gMTtcblx0fVxuXG5cblx0X2NoZWNrTGltaXQoKSB7XG5cdFx0aWYodGhpcy5fbWluICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdGFyZ2V0VmFsdWUgPCB0aGlzLl9taW4pIHtcblx0XHRcdHRoaXMuX3RhcmdldFZhbHVlID0gdGhpcy5fbWluO1xuXHRcdH0gXG5cblx0XHRpZih0aGlzLl9tYXggIT09IHVuZGVmaW5lZCAmJiB0aGlzLl90YXJnZXRWYWx1ZSA+IHRoaXMuX21heCkge1xuXHRcdFx0dGhpcy5fdGFyZ2V0VmFsdWUgPSB0aGlzLl9tYXg7XG5cdFx0fSBcblx0fVxuXG5cblx0ZGVzdHJveSgpIHtcblx0XHRTY2hlZHVsZXIucmVtb3ZlRUYodGhpcy5fZWZJbmRleCk7XG5cdH1cblxuXHQvL1x0R0VUVEVSUyAvIFNFVFRFUlNcblxuXHRzZXQgdmFsdWUobVZhbHVlKSB7XG5cdFx0dGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMuX3ZhbHVlO1xuXHRcdHRoaXMuX3RhcmdldFZhbHVlID0gbVZhbHVlO1xuXHRcdHRoaXMuX2NoZWNrTGltaXQoKTtcblx0XHR0aGlzLl9jb3VudGVyID0gMDtcblx0fVxuXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRpZih0aGlzLl9uZWVkVXBkYXRlKSB7XG5cdFx0XHRjb25zdCBmID0gZ2V0RnVuYyh0aGlzLmVhc2luZyk7XG5cdFx0XHRjb25zdCBwID0gZih0aGlzLl9jb3VudGVyKTtcblx0XHRcdHRoaXMuX3ZhbHVlID0gdGhpcy5fc3RhcnRWYWx1ZSArIHAgKiAodGhpcy5fdGFyZ2V0VmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKTtcblx0XHRcdHRoaXMuX25lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9XG5cblx0Z2V0IHRhcmdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLl90YXJnZXRWYWx1ZTtcblx0fVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFR3ZWVuTnVtYmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1R3ZWVuTnVtYmVyLmpzIiwiLy8gUXVhdFJvdGF0aW9uLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGdsbSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IEVhc2VOdW1iZXIgZnJvbSAnLi9FYXNlTnVtYmVyJztcbmltcG9ydCBTY2hlZHVsZXIgZnJvbSAnc2NoZWR1bGluZyc7XG5cbmNvbnN0IGdldE1vdXNlID0gZnVuY3Rpb24gKG1FdmVudCwgbVRhcmdldCkge1xuXG5cdGNvbnN0IG8gPSBtVGFyZ2V0IHx8IHt9O1xuXHRpZihtRXZlbnQudG91Y2hlcykge1xuXHRcdG8ueCA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdG8ueSA9IG1FdmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXHR9IGVsc2Uge1xuXHRcdG8ueCA9IG1FdmVudC5jbGllbnRYO1xuXHRcdG8ueSA9IG1FdmVudC5jbGllbnRZO1xuXHR9XG5cblx0cmV0dXJuIG87XG59O1xuXG5jbGFzcyBRdWF0Um90YXRpb24ge1xuXHRjb25zdHJ1Y3RvcihtVGFyZ2V0LCBtTGlzdGVuZXJUYXJnZXQgPSB3aW5kb3csIG1FYXNpbmcgPSAwLjEpIHtcblxuXHRcdHRoaXMuX3RhcmdldCAgICAgICAgID0gbVRhcmdldDtcblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldCA9IG1MaXN0ZW5lclRhcmdldDtcblx0XHRcblx0XHR0aGlzLm1hdHJpeCAgICAgICAgICA9IGdsbS5tYXQ0LmNyZWF0ZSgpO1xuXHRcdHRoaXMubSAgICAgICAgICAgICAgID0gZ2xtLm1hdDQuY3JlYXRlKCk7XG5cdFx0dGhpcy5fdlpheGlzICAgICAgICAgPSBnbG0udmVjMy5jbG9uZShbMCwgMCwgMF0pO1xuXHRcdHRoaXMuX3pBeGlzICAgICAgICAgID0gZ2xtLnZlYzMuY2xvbmUoWzAsIDAsIDFdKTtcblx0XHR0aGlzLnByZU1vdXNlICAgICAgICA9IHsgeDowLCB5OjAgfTtcblx0XHR0aGlzLm1vdXNlICAgICAgICAgICA9IHsgeDowLCB5OjAgfTtcblx0XHR0aGlzLl9pc01vdXNlRG93biAgICA9IGZhbHNlO1xuXHRcdHRoaXMuX3JvdGF0aW9uICAgICAgID0gZ2xtLnF1YXQuY3JlYXRlKCk7XG5cdFx0dGhpcy50ZW1wUm90YXRpb24gICAgPSBnbG0ucXVhdC5jcmVhdGUoKTtcblx0XHR0aGlzLl9yb3RhdGVaTWFyZ2luICA9IDA7XG5cdFx0dGhpcy5fb2Zmc2V0ICAgICAgICAgPSAwLjAwNDtcblx0XHR0aGlzLl9zbGVycCAgICAgICAgICA9IC0xO1xuXHRcdHRoaXMuX2lzTG9ja2VkICAgICAgID0gZmFsc2U7XG5cdFx0XG5cdFx0dGhpcy5fZGlmZlggICAgICAgICAgPSBuZXcgRWFzZU51bWJlcigwLCBtRWFzaW5nKTtcblx0XHR0aGlzLl9kaWZmWSAgICAgICAgICA9IG5ldyBFYXNlTnVtYmVyKDAsIG1FYXNpbmcpO1xuXG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHRoaXMuX29uRG93bihlKSk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIChlKSA9PiB0aGlzLl9vbkRvd24oZSkpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB0aGlzLl9vbk1vdmUoZSkpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIChlKSA9PiB0aGlzLl9vbk1vdmUoZSkpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsICgpID0+IHRoaXMuX29uVXAoKSk7XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB0aGlzLl9vblVwKCkpO1xuXG5cdFx0U2NoZWR1bGVyLmFkZEVGKCgpID0+IHRoaXMuX2xvb3AoKSk7XG5cdH1cblxuXHQvLyBcdFBVQkxJQyBNRVRIT0RTXG5cblx0aW52ZXJzZUNvbnRyb2woaXNJbnZlcnQgPSB0cnVlKSB7XG5cdFx0dGhpcy5faXNJbnZlcnQgPSBpc0ludmVydDtcblx0fVxuXG5cdGxvY2sobVZhbHVlID0gdHJ1ZSkge1xuXHRcdHRoaXMuX2lzTG9ja2VkID0gbVZhbHVlO1xuXHR9XHRcblxuXHRzZXRDYW1lcmFQb3MobVF1YXQsIHNwZWVkID0gMC4xKSB7XG5cdFx0dGhpcy5lYXNpbmcgPSBzcGVlZDtcblx0XHRpZih0aGlzLl9zbGVycCA+IDApIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0Y29uc3QgdGVtcFJvdGF0aW9uICA9IGdsbS5xdWF0LmNsb25lKHRoaXMuX3JvdGF0aW9uKTtcblx0XHR0aGlzLl91cGRhdGVSb3RhdGlvbih0ZW1wUm90YXRpb24pO1xuXHRcdHRoaXMuX3JvdGF0aW9uICAgID0gZ2xtLnF1YXQuY2xvbmUodGVtcFJvdGF0aW9uKTtcblx0XHR0aGlzLl9jdXJyRGlmZlggICA9IHRoaXMuZGlmZlggPSAwO1xuXHRcdHRoaXMuX2N1cnJEaWZmWSAgID0gdGhpcy5kaWZmWSA9IDA7XG5cdFx0XG5cdFx0dGhpcy5faXNNb3VzZURvd24gPSBmYWxzZTtcblx0XHR0aGlzLl9pc1JvdGF0ZVogICA9IDA7XG5cdFx0XG5cdFx0dGhpcy5fdGFyZ2V0UXVhdCAgPSBnbG0ucXVhdC5jbG9uZShtUXVhdCk7XG5cdFx0dGhpcy5fc2xlcnAgICAgICAgPSAxO1xuXHR9XG5cblx0cmVzZXRRdWF0KCkge1xuXHRcdHRoaXMuX3JvdGF0aW9uICAgID0gZ2xtLnF1YXQuY2xvbmUoWzAsIDAsIDEsIDBdKTtcblx0XHR0aGlzLnRlbXBSb3RhdGlvbiA9IGdsbS5xdWF0LmNsb25lKFswLCAwLCAwLCAwXSk7XG5cdFx0dGhpcy5fdGFyZ2V0UXVhdCAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5fc2xlcnAgICAgICAgPSAtMTtcblx0fVxuXG5cdC8vXHRFVkVOVCBIQU5ETEVSXG5cblx0X29uRG93bihtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tlZCkgeyByZXR1cm47IH1cblxuXHRcdGNvbnN0IG1vdXNlID0gZ2V0TW91c2UobUV2ZW50KTtcblx0XHRjb25zdCB0ZW1wUm90YXRpb24gPSBnbG0ucXVhdC5jbG9uZSh0aGlzLl9yb3RhdGlvbik7XG5cdFx0dGhpcy5fdXBkYXRlUm90YXRpb24odGVtcFJvdGF0aW9uKTtcblx0XHR0aGlzLl9yb3RhdGlvbiA9IHRlbXBSb3RhdGlvbjtcblxuXHRcdHRoaXMuX2lzTW91c2VEb3duID0gdHJ1ZTtcblx0XHR0aGlzLl9pc1JvdGF0ZVogPSAwO1xuXHRcdHRoaXMucHJlTW91c2UgPSB7IHg6bW91c2UueCwgeTptb3VzZS55IH07XG5cblx0XHRpZihtb3VzZS55IDwgdGhpcy5fcm90YXRlWk1hcmdpbiB8fCBtb3VzZS55ID4gKHdpbmRvdy5pbm5lckhlaWdodCAtIHRoaXMuX3JvdGF0ZVpNYXJnaW4pKSB7XHRcblx0XHRcdHRoaXMuX2lzUm90YXRlWiA9IDE7XHRcblx0XHR9IGVsc2UgaWYobW91c2UueCA8IHRoaXMuX3JvdGF0ZVpNYXJnaW4gfHwgbW91c2UueCA+ICh3aW5kb3cuaW5uZXJXaWR0aCAtIHRoaXMuX3JvdGF0ZVpNYXJnaW4pKSB7XHRcblx0XHRcdHRoaXMuX2lzUm90YXRlWiA9IDI7XHRcblx0XHR9XG5cblx0XHR0aGlzLl9kaWZmWC5zZXRUbygwKTtcblx0XHR0aGlzLl9kaWZmWS5zZXRUbygwKTtcblx0fVxuXG5cblx0X29uTW92ZShtRXZlbnQpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tlZCkgeyByZXR1cm47IH1cblx0XHRnZXRNb3VzZShtRXZlbnQsIHRoaXMubW91c2UpO1xuXHR9XG5cblxuXHRfb25VcCgpIHtcblx0XHRpZih0aGlzLl9pc0xvY2tlZCkgeyByZXR1cm47IH1cblx0XHR0aGlzLl9pc01vdXNlRG93biA9IGZhbHNlO1xuXHR9XG5cblxuXHQvL1x0UFJJVkFURSBNRVRIT0RTXG5cblx0X3VwZGF0ZVJvdGF0aW9uKG1UZW1wUm90YXRpb24pIHtcblx0XHRpZih0aGlzLl9pc01vdXNlRG93biAmJiAhdGhpcy5faXNMb2NrZWQpIHtcblx0XHRcdHRoaXMuX2RpZmZYLnZhbHVlID0gLSh0aGlzLm1vdXNlLnggLSB0aGlzLnByZU1vdXNlLngpO1xuXHRcdFx0dGhpcy5fZGlmZlkudmFsdWUgPSAgKHRoaXMubW91c2UueSAtIHRoaXMucHJlTW91c2UueSk7XG5cblx0XHRcdGlmKHRoaXMuX2lzSW52ZXJ0KSB7XG5cdFx0XHRcdHRoaXMuX2RpZmZYLnZhbHVlID0gLXRoaXMuX2RpZmZYLnRhcmdldFZhbHVlO1xuXHRcdFx0XHR0aGlzLl9kaWZmWS52YWx1ZSA9IC10aGlzLl9kaWZmWS50YXJnZXRWYWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0bGV0IGFuZ2xlLCBfcXVhdDtcblxuXHRcdGlmKHRoaXMuX2lzUm90YXRlWiA+IDApIHtcblx0XHRcdGlmKHRoaXMuX2lzUm90YXRlWiA9PT0gMSkge1xuXHRcdFx0XHRhbmdsZSA9IC10aGlzLl9kaWZmWC52YWx1ZSAqIHRoaXMuX29mZnNldDsgXG5cdFx0XHRcdGFuZ2xlICo9ICh0aGlzLnByZU1vdXNlLnkgPCB0aGlzLl9yb3RhdGVaTWFyZ2luKSA/IC0xIDogMTtcblx0XHRcdFx0X3F1YXQgPSBnbG0ucXVhdC5jbG9uZShbMCwgMCwgTWF0aC5zaW4oYW5nbGUpLCBNYXRoLmNvcyhhbmdsZSldKTtcblx0XHRcdFx0Z2xtLnF1YXQubXVsdGlwbHkoX3F1YXQsIG1UZW1wUm90YXRpb24sIF9xdWF0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuZ2xlID0gLXRoaXMuX2RpZmZZLnZhbHVlICogdGhpcy5fb2Zmc2V0OyBcblx0XHRcdFx0YW5nbGUgKj0gKHRoaXMucHJlTW91c2UueCA8IHRoaXMuX3JvdGF0ZVpNYXJnaW4pID8gMSA6IC0xO1xuXHRcdFx0XHRfcXVhdCA9IGdsbS5xdWF0LmNsb25lKFswLCAwLCBNYXRoLnNpbihhbmdsZSksIE1hdGguY29zKGFuZ2xlKV0pO1xuXHRcdFx0XHRnbG0ucXVhdC5tdWx0aXBseShfcXVhdCwgbVRlbXBSb3RhdGlvbiwgX3F1YXQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCB2ID0gZ2xtLnZlYzMuY2xvbmUoW3RoaXMuX2RpZmZYLnZhbHVlLCB0aGlzLl9kaWZmWS52YWx1ZSwgMF0pO1xuXHRcdFx0Y29uc3QgYXhpcyA9IGdsbS52ZWMzLmNyZWF0ZSgpO1xuXHRcdFx0Z2xtLnZlYzMuY3Jvc3MoYXhpcywgdiwgdGhpcy5fekF4aXMpO1xuXHRcdFx0Z2xtLnZlYzMubm9ybWFsaXplKGF4aXMsIGF4aXMpO1xuXHRcdFx0YW5nbGUgPSBnbG0udmVjMy5sZW5ndGgodikgKiB0aGlzLl9vZmZzZXQ7XG5cdFx0XHRfcXVhdCA9IGdsbS5xdWF0LmNsb25lKFtNYXRoLnNpbihhbmdsZSkgKiBheGlzWzBdLCBNYXRoLnNpbihhbmdsZSkgKiBheGlzWzFdLCBNYXRoLnNpbihhbmdsZSkgKiBheGlzWzJdLCBNYXRoLmNvcyhhbmdsZSldKTtcblx0XHRcdGdsbS5xdWF0Lm11bHRpcGx5KG1UZW1wUm90YXRpb24sIF9xdWF0LCBtVGVtcFJvdGF0aW9uKTtcblx0XHR9XG5cdH1cblxuXHRfbG9vcCgpIHtcblx0XHRnbG0ubWF0NC5pZGVudGl0eSh0aGlzLm0pO1xuXG5cdFx0aWYodGhpcy5fdGFyZ2V0UXVhdCA9PT0gdW5kZWZpbmVkKSB7IFxuXHRcdFx0Z2xtLnF1YXQuc2V0KHRoaXMudGVtcFJvdGF0aW9uLCB0aGlzLl9yb3RhdGlvblswXSwgdGhpcy5fcm90YXRpb25bMV0sIHRoaXMuX3JvdGF0aW9uWzJdLCB0aGlzLl9yb3RhdGlvblszXSk7XG5cdFx0XHR0aGlzLl91cGRhdGVSb3RhdGlvbih0aGlzLnRlbXBSb3RhdGlvbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NsZXJwICs9ICgwIC0gdGhpcy5fc2xlcnApICogMC4xO1xuXG5cdFx0XHRpZih0aGlzLl9zbGVycCA8IDAuMDAwNSkge1xuXHRcdFx0XHRnbG0ucXVhdC5jb3B5KHRoaXMuX3JvdGF0aW9uLCB0aGlzLl90YXJnZXRRdWF0KTtcblx0XHRcdFx0Z2xtLnF1YXQuY29weSh0aGlzLnRlbXBSb3RhdGlvbiwgdGhpcy5fdGFyZ2V0UXVhdCk7XG5cdFx0XHRcdHRoaXMuX3RhcmdldFF1YXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHRoaXMuX2RpZmZYLnNldFRvKDApO1xuXHRcdFx0XHR0aGlzLl9kaWZmWS5zZXRUbygwKTtcblx0XHRcdFx0dGhpcy5fc2xlcnAgPSAtMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGdsbS5xdWF0LnNldCh0aGlzLnRlbXBSb3RhdGlvbiwgMCwgMCwgMCwgMCk7XG5cdFx0XHRcdGdsbS5xdWF0LnNsZXJwKHRoaXMudGVtcFJvdGF0aW9uLCB0aGlzLl90YXJnZXRRdWF0LCB0aGlzLl9yb3RhdGlvbiwgdGhpcy5fc2xlcnApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGdsbS52ZWMzLnRyYW5zZm9ybVF1YXQodGhpcy5fdlpheGlzLCB0aGlzLl92WmF4aXMsIHRoaXMudGVtcFJvdGF0aW9uKTtcblxuXHRcdGdsbS5tYXQ0LmZyb21RdWF0KHRoaXMubWF0cml4LCB0aGlzLnRlbXBSb3RhdGlvbik7XG5cdH1cblxuXG5cdC8vXHRHRVRURVIgQU5EIFNFVFRFUlxuXG5cdHNldCBlYXNpbmcobVZhbHVlKSB7XG5cdFx0dGhpcy5fZGlmZlguZWFzaW5nID0gbVZhbHVlO1xuXHRcdHRoaXMuX2RpZmZZLmVhc2luZyA9IG1WYWx1ZTtcblx0fVxuXG5cdGdldCBlYXNpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RpZmZYLmVhc2luZztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBRdWF0Um90YXRpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvUXVhdFJvdGF0aW9uLmpzIiwiLy8gVG91Y2hEZXRlY3Rvci5qc1xuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgRXZlbnREaXNwYXRjaGVyIGZyb20gJy4vRXZlbnREaXNwYXRjaGVyJztcbmltcG9ydCBSYXkgZnJvbSAnLi4vbWF0aC9SYXknO1xuaW1wb3J0IGdldE1vdXNlIGZyb20gJy4vZ2V0TW91c2UnO1xuXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG5cdGNvbnN0IGR4ID0gYS54IC0gYi54O1xuXHRjb25zdCBkeSA9IGEueSAtIGIueTtcblx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5cbmNsYXNzIFRvdWNoRGV0ZWN0b3IgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuXHRjb25zdHJ1Y3RvcihtR2VvbWV0cnksIG1DYW1lcmEsIG1Ta2lwTW92ZUNoZWNrPWZhbHNlLCBtTGlzdGVuZXJUYXJnZXQ9d2luZG93KSB7XG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuX2dlb21ldHJ5ID0gbUdlb21ldHJ5O1xuXHRcdHRoaXMuX2dlb21ldHJ5LmdlbmVyYXRlRmFjZXMoKTtcblx0XHR0aGlzLl9jYW1lcmEgPSBtQ2FtZXJhO1xuXHRcdHRoaXMuZmFjZVZlcnRpY2VzID0gbUdlb21ldHJ5LmZhY2VzLm1hcCgoZmFjZSk9PihmYWNlLnZlcnRpY2VzKSk7XG5cdFx0dGhpcy5jbGlja1RvbGVyYW5jZSA9IDg7XG5cblx0XHR0aGlzLl9yYXkgPSBuZXcgUmF5KFswLCAwLCAwXSwgWzAsIDAsIC0xXSk7XG5cdFx0dGhpcy5faGl0ID0gdmVjMy5mcm9tVmFsdWVzKC05OTksIC05OTksIC05OTkpO1xuXHRcdHRoaXMuX2xhc3RQb3M7XG5cdFx0dGhpcy5fZmlyc3RQb3M7XG5cdFx0dGhpcy5tdHhNb2RlbCA9IG1hdDQuY3JlYXRlKCk7XG5cblx0XHR0aGlzLl9saXN0ZW5lclRhcmdldCA9IG1MaXN0ZW5lclRhcmdldDtcblx0XHR0aGlzLl9za2lwcGluZ01vdmUgPSBtU2tpcE1vdmVDaGVjaztcblxuXHRcdHRoaXMuX29uTW92ZUJpbmQgPSAoZSkgPT4gdGhpcy5fb25Nb3ZlKGUpO1xuXHRcdHRoaXMuX29uRG93bkJpbmQgPSAoZSkgPT4gdGhpcy5fb25Eb3duKGUpO1xuXHRcdHRoaXMuX29uVXBCaW5kID0gKCkgPT4gdGhpcy5fb25VcCgpO1xuXG5cdFx0dGhpcy5jb25uZWN0KCk7XG5cdH1cblxuXHRjb25uZWN0KCkge1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uRG93bkJpbmQpO1xuXHRcdHRoaXMuX2xpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW92ZUJpbmQpO1x0XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVXBCaW5kKTtcblx0fVxuXG5cdGRpc2Nvbm5lY3QoKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25Eb3duQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlQmluZCk7XG5cdFx0dGhpcy5fbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uVXBCaW5kKTtcblx0fVxuXG5cblx0X2NoZWNrSGl0KG1UeXBlPSdvbkhpdCcpIHtcblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG5cdFx0aWYoIWNhbWVyYSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXG5cdFx0Y29uc3QgbXggPSAodGhpcy5fbGFzdFBvcy54IC8gR0wud2lkdGgpICogMi4wIC0gMS4wO1xuXHRcdGNvbnN0IG15ID0gLSAodGhpcy5fbGFzdFBvcy55IC8gR0wuaGVpZ2h0KSAqIDIuMCArIDEuMDtcblxuXHRcdGNhbWVyYS5nZW5lcmF0ZVJheShbbXgsIG15LCAwXSwgdGhpcy5fcmF5KTtcblxuXHRcdGxldCBoaXQ7XG5cdFx0Y29uc3QgdjAgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdGNvbnN0IHYxID0gdmVjMy5jcmVhdGUoKTtcblx0XHRjb25zdCB2MiA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0bGV0IGRpc3QgPSAwO1xuXG5cdFx0Y29uc3QgZ2V0VmVjdG9yID0gKHYsIHRhcmdldCkgPT4ge1xuXHRcdFx0dmVjMy50cmFuc2Zvcm1NYXQ0KHRhcmdldCwgdiwgdGhpcy5tdHhNb2RlbCk7XG5cdFx0fTtcblxuXHRcdGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLmZhY2VWZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSB0aGlzLmZhY2VWZXJ0aWNlc1tpXTtcblx0XHRcdGdldFZlY3Rvcih2ZXJ0aWNlc1swXSwgdjApOyBcblx0XHRcdGdldFZlY3Rvcih2ZXJ0aWNlc1sxXSwgdjEpOyBcblx0XHRcdGdldFZlY3Rvcih2ZXJ0aWNlc1syXSwgdjIpOyBcblx0XHRcdGNvbnN0IHQgPSB0aGlzLl9yYXkuaW50ZXJzZWN0VHJpYW5nbGUodjAsIHYxLCB2Mik7XG5cblx0XHRcdGlmKHQpIHtcblx0XHRcdFx0aWYoaGl0KSB7XG5cdFx0XHRcdFx0Y29uc3QgZGlzdFRvQ2FtID0gdmVjMy5kaXN0KHQsIGNhbWVyYS5wb3NpdGlvbik7XG5cdFx0XHRcdFx0aWYoZGlzdFRvQ2FtIDwgZGlzdCkge1xuXHRcdFx0XHRcdFx0aGl0ID0gdmVjMy5jbG9uZSh0KTtcblx0XHRcdFx0XHRcdGRpc3QgPSBkaXN0VG9DYW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhpdCA9IHZlYzMuY2xvbmUodCk7XG5cdFx0XHRcdFx0ZGlzdCA9IHZlYzMuZGlzdChoaXQsIGNhbWVyYS5wb3NpdGlvbik7XG5cdFx0XHRcdH1cdFxuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0aWYoaGl0KSB7XG5cdFx0XHR0aGlzLl9oaXQgPSB2ZWMzLmNsb25lKGhpdCk7XG5cdFx0XHR0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQobVR5cGUsIHsgaGl0IH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQoJ29uVXAnKTtcblx0XHR9XG5cdH1cblxuXG5cdF9vbkRvd24oZSkge1xuXHRcdHRoaXMuX2ZpcnN0UG9zID0gZ2V0TW91c2UoZSk7XG5cdFx0dGhpcy5fbGFzdFBvcyA9IGdldE1vdXNlKGUpO1xuXHRcdHRoaXMuX2NoZWNrSGl0KCdvbkRvd24nKTtcblx0fVxuXG5cdF9vbk1vdmUoZSkge1xuXHRcdHRoaXMuX2xhc3RQb3MgPSBnZXRNb3VzZShlKTtcblx0XHRpZighdGhpcy5fc2tpcHBpbmdNb3ZlKSB7XG5cdFx0XHR0aGlzLl9jaGVja0hpdCgpO1xuXHRcdH1cblx0fVxuXG5cdF9vblVwKCkge1xuXHRcdGNvbnN0IGRpc3QgPSBkaXN0YW5jZSh0aGlzLl9maXJzdFBvcywgdGhpcy5fbGFzdFBvcyk7XG5cdFx0aWYoZGlzdCA8IHRoaXMuY2xpY2tUb2xlcmFuY2UpIHtcblx0XHRcdHRoaXMuX2NoZWNrSGl0KCk7XHRcblx0XHR9XG5cdFx0XG5cdH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBUb3VjaERldGVjdG9yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3V0aWxzL1RvdWNoRGV0ZWN0b3IuanMiLCIvLyBnZXRNb3VzZS5qc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoZSkge1xuXHRsZXQgeCwgeTtcblxuXHRpZihlLnRvdWNoZXMpIHtcblx0XHR4ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG5cdH0gZWxzZSB7XG5cdFx0eCA9IGUuY2xpZW50WDtcblx0XHR5ID0gZS5jbGllbnRZO1xuXHR9XG5cblxuXHRyZXR1cm4ge1xuXHRcdHgsIHlcblx0fTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC91dGlscy9nZXRNb3VzZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIjZGVmaW5lIFNIQURFUl9OQU1FIGdsdGZfdmVydFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5cXG4jaWZkZWYgSEFTX1VWXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX05PUk1BTFNcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdU5vcm1hbE1hdHJpeDtcXG51bmlmb3JtIG1hdDMgdU1vZGVsVmlld01hdHJpeEludmVyc2U7XFxuXFxuXFxudmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG5cXG4jaWZkZWYgSEFTX05PUk1BTFNcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdHZlYzQgcG9zaXRpb24gPSB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKTtcXG5cXHR2UG9zaXRpb24gICAgID0gcG9zaXRpb24ueHl6IC8gcG9zaXRpb24udztcXG5cXHRcXG5cXHQjaWZkZWYgSEFTX1VWXFxuXFx0dlRleHR1cmVDb29yZCA9IHZlYzIoYVRleHR1cmVDb29yZC54LCAxLjAgLSBhVGV4dHVyZUNvb3JkLnkpO1xcblxcdCNlbHNlXFxuXFx0dlRleHR1cmVDb29yZCA9IHZlYzIoMC4sMC4pO1xcblxcdCNlbmRpZlxcblxcblxcdCNpZmRlZiBIQVNfTk9STUFMU1xcblxcdHZOb3JtYWwgICAgICAgPSBub3JtYWxpemUodmVjMyh1TW9kZWxNYXRyaXggKiB2ZWM0KGFOb3JtYWwsIDAuMCkpKTtcXG5cXHQjZW5kaWZcXG5cXHRcXG5cXHRnbF9Qb3NpdGlvbiAgID0gdVByb2plY3Rpb25NYXRyaXggKiB1Vmlld01hdHJpeCAqIHBvc2l0aW9uO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9nbHRmLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIiNkZWZpbmUgU0hBREVSX05BTUUgZ2x0Zl9mcmFnXFxuXFxuI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kOiBlbmFibGVcXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIFxcdHVCUkRGTWFwO1xcbnVuaWZvcm0gc2FtcGxlckN1YmUgdVJhZGlhbmNlTWFwO1xcbnVuaWZvcm0gc2FtcGxlckN1YmUgdUlycmFkaWFuY2VNYXA7XFxuXFxuI2lmZGVmIEhBU19CQVNFQ09MT1JNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1Q29sb3JNYXA7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19NRVRBTFJPVUdITkVTU01BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVNZXRhbGxpY1JvdWdobmVzc01hcDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX09DQ0xVU0lPTk1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVBb01hcDtcXG51bmlmb3JtIGZsb2F0IHVPY2NsdXNpb25TdHJlbmd0aDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX05PUk1BTE1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVOb3JtYWxNYXA7XFxudW5pZm9ybSBmbG9hdCB1Tm9ybWFsU2NhbGU7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19FTUlTU0lWRU1BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHVFbWlzc2l2ZU1hcDtcXG51bmlmb3JtIHZlYzMgdUVtaXNzaXZlRmFjdG9yO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gdmVjMyB1TGlnaHREaXJlY3Rpb247XFxudW5pZm9ybSB2ZWMzIHVMaWdodENvbG9yO1xcbnVuaWZvcm0gdmVjMyB1Q2FtZXJhUG9zO1xcblxcbnVuaWZvcm0gdmVjNCB1U2NhbGVEaWZmQmFzZU1SO1xcbnVuaWZvcm0gdmVjNCB1U2NhbGVGR0RTcGVjO1xcbnVuaWZvcm0gdmVjNCB1U2NhbGVJQkxBbWJpZW50O1xcblxcbnVuaWZvcm0gdmVjMyB1QmFzZUNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgdVJvdWdobmVzcztcXG51bmlmb3JtIGZsb2F0IHVNZXRhbGxpYztcXG51bmlmb3JtIGZsb2F0IHVHYW1tYTtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xcblxcbiNpZmRlZiBIQVNfTk9STUFMU1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcblxcblxcbi8vXFx0RnJvbSBHTFRGIFdlYkdMIFBCUiA6XFxuLy9cXHRodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYtV2ViR0wtUEJSXFxuXFxuLy8gRW5jYXBzdWxhdGUgdGhlIHZhcmlvdXMgaW5wdXRzIHVzZWQgYnkgdGhlIHZhcmlvdXMgZnVuY3Rpb25zIGluIHRoZSBzaGFkaW5nIGVxdWF0aW9uXFxuLy8gV2Ugc3RvcmUgdmFsdWVzIGluIHRoaXMgc3RydWN0IHRvIHNpbXBsaWZ5IHRoZSBpbnRlZ3JhdGlvbiBvZiBhbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbnNcXG4vLyBvZiB0aGUgc2hhZGluZyB0ZXJtcywgb3V0bGluZWQgaW4gdGhlIFJlYWRtZS5NRCBBcHBlbmRpeC5cXG5zdHJ1Y3QgUEJSSW5mb1xcbntcXG5cXHRmbG9hdCBOZG90TDsgICAgICAgICAgICAgICAgICAvLyBjb3MgYW5nbGUgYmV0d2VlbiBub3JtYWwgYW5kIGxpZ2h0IGRpcmVjdGlvblxcblxcdGZsb2F0IE5kb3RWOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIG5vcm1hbCBhbmQgdmlldyBkaXJlY3Rpb25cXG5cXHRmbG9hdCBOZG90SDsgICAgICAgICAgICAgICAgICAvLyBjb3MgYW5nbGUgYmV0d2VlbiBub3JtYWwgYW5kIGhhbGYgdmVjdG9yXFxuXFx0ZmxvYXQgTGRvdEg7ICAgICAgICAgICAgICAgICAgLy8gY29zIGFuZ2xlIGJldHdlZW4gbGlnaHQgZGlyZWN0aW9uIGFuZCBoYWxmIHZlY3RvclxcblxcdGZsb2F0IFZkb3RIOyAgICAgICAgICAgICAgICAgIC8vIGNvcyBhbmdsZSBiZXR3ZWVuIHZpZXcgZGlyZWN0aW9uIGFuZCBoYWxmIHZlY3RvclxcblxcdGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3M7ICAgIC8vIHJvdWdobmVzcyB2YWx1ZSwgYXMgYXV0aG9yZWQgYnkgdGhlIG1vZGVsIGNyZWF0b3IgKGlucHV0IHRvIHNoYWRlcilcXG5cXHRmbG9hdCBtZXRhbG5lc3M7ICAgICAgICAgICAgICAvLyBtZXRhbGxpYyB2YWx1ZSBhdCB0aGUgc3VyZmFjZVxcblxcdHZlYzMgcmVmbGVjdGFuY2UwOyAgICAgICAgICAgIC8vIGZ1bGwgcmVmbGVjdGFuY2UgY29sb3IgKG5vcm1hbCBpbmNpZGVuY2UgYW5nbGUpXFxuXFx0dmVjMyByZWZsZWN0YW5jZTkwOyAgICAgICAgICAgLy8gcmVmbGVjdGFuY2UgY29sb3IgYXQgZ3JhemluZyBhbmdsZVxcblxcdGZsb2F0IGFscGhhUm91Z2huZXNzOyAgICAgICAgIC8vIHJvdWdobmVzcyBtYXBwZWQgdG8gYSBtb3JlIGxpbmVhciBjaGFuZ2UgaW4gdGhlIHJvdWdobmVzcyAocHJvcG9zZWQgYnkgWzJdKVxcblxcdHZlYzMgZGlmZnVzZUNvbG9yOyAgICAgICAgICAgIC8vIGNvbG9yIGNvbnRyaWJ1dGlvbiBmcm9tIGRpZmZ1c2UgbGlnaHRpbmdcXG5cXHR2ZWMzIHNwZWN1bGFyQ29sb3I7ICAgICAgICAgICAvLyBjb2xvciBjb250cmlidXRpb24gZnJvbSBzcGVjdWxhciBsaWdodGluZ1xcbn07XFxuXFxuXFxuY29uc3QgZmxvYXQgTV9QSSA9IDMuMTQxNTkyNjUzNTg5NzkzO1xcbmNvbnN0IGZsb2F0IGNfTWluUm91Z2huZXNzID0gMC4wNDtcXG5cXG5cXG52ZWM0IFNSR0J0b0xJTkVBUih2ZWM0IHNyZ2JJbilcXG57XFxuXFx0I2lmZGVmIE1BTlVBTF9TUkdCXFxuXFx0I2lmZGVmIFNSR0JfRkFTVF9BUFBST1hJTUFUSU9OXFxuXFx0dmVjMyBsaW5PdXQgPSBwb3coc3JnYkluLnh5eix2ZWMzKDIuMikpO1xcblxcdCNlbHNlIC8vU1JHQl9GQVNUX0FQUFJPWElNQVRJT05cXG5cXHR2ZWMzIGJMZXNzID0gc3RlcCh2ZWMzKDAuMDQwNDUpLHNyZ2JJbi54eXopO1xcblxcdHZlYzMgbGluT3V0ID0gbWl4KCBzcmdiSW4ueHl6L3ZlYzMoMTIuOTIpLCBwb3coKHNyZ2JJbi54eXordmVjMygwLjA1NSkpL3ZlYzMoMS4wNTUpLHZlYzMoMi40KSksIGJMZXNzICk7XFxuXFx0I2VuZGlmIC8vU1JHQl9GQVNUX0FQUFJPWElNQVRJT05cXG5cXHRyZXR1cm4gdmVjNChsaW5PdXQsc3JnYkluLncpOztcXG5cXHQjZWxzZSAvL01BTlVBTF9TUkdCXFxuXFx0cmV0dXJuIHNyZ2JJbjtcXG5cXHQjZW5kaWYgLy9NQU5VQUxfU1JHQlxcbn1cXG5cXG5cXG52ZWMzIGdldE5vcm1hbCgpIHtcXG5cXHR2ZWMzIHBvc19keCA9IGRGZHgodlBvc2l0aW9uKTtcXG5cXHR2ZWMzIHBvc19keSA9IGRGZHkodlBvc2l0aW9uKTtcXG5cXHR2ZWMzIHRleF9keCA9IGRGZHgodmVjMyh2VGV4dHVyZUNvb3JkLCAwLjApKTtcXG5cXHR2ZWMzIHRleF9keSA9IGRGZHkodmVjMyh2VGV4dHVyZUNvb3JkLCAwLjApKTtcXG5cXHR2ZWMzIHQgPSAodGV4X2R5LnQgKiBwb3NfZHggLSB0ZXhfZHgudCAqIHBvc19keSkgLyAodGV4X2R4LnMgKiB0ZXhfZHkudCAtIHRleF9keS5zICogdGV4X2R4LnQpO1xcblxcblxcdFxcbiNpZmRlZiBIQVNfTk9STUFMU1xcblxcdHZlYzMgbmcgPSBub3JtYWxpemUodk5vcm1hbCk7XFxuI2Vsc2VcXG5cXHR2ZWMzIG5nID0gY3Jvc3MocG9zX2R4LCBwb3NfZHkpO1xcbiNlbmRpZlxcblxcblxcdHQgPSBub3JtYWxpemUodCAtIG5nICogZG90KG5nLCB0KSk7XFxuXFx0dmVjMyBiID0gbm9ybWFsaXplKGNyb3NzKG5nLCB0KSk7XFxuXFx0bWF0MyB0Ym4gPSBtYXQzKHQsIGIsIG5nKTtcXG5cXG4jaWZkZWYgSEFTX05PUk1BTE1BUFxcblxcdHZlYzMgbiA9IHRleHR1cmUyRCh1Tm9ybWFsTWFwLCB2VGV4dHVyZUNvb3JkKS5yZ2I7XFxuXFx0biA9IG5vcm1hbGl6ZSh0Ym4gKiAoKDIuMCAqIG4gLSAxLjApICogdmVjMyh1Tm9ybWFsU2NhbGUsIHVOb3JtYWxTY2FsZSwgMS4wKSkpO1xcbiNlbHNlXFxuXFx0Ly8gVGhlIHRibiBtYXRyaXggaXMgbGluZWFybHkgaW50ZXJwb2xhdGVkLCBzbyB3ZSBuZWVkIHRvIHJlLW5vcm1hbGl6ZVxcblxcdHZlYzMgbiA9IG5vcm1hbGl6ZSh0Ym5bMl0ueHl6KTtcXG4jZW5kaWZcXG5cXG5cXHRyZXR1cm4gbjtcXG59XFxuXFxuXFxudmVjMyBnZXRJQkxDb250cmlidXRpb24oUEJSSW5mbyBwYnJJbnB1dHMsIHZlYzMgbiwgdmVjMyByZWZsZWN0aW9uKVxcbntcXG5cXHRmbG9hdCBtaXBDb3VudCA9IDcuMDsgLy8gcmVzb2x1dGlvbiBvZiA1MTJ4NTEyXFxuXFx0ZmxvYXQgbG9kID0gKHBicklucHV0cy5wZXJjZXB0dWFsUm91Z2huZXNzICogbWlwQ291bnQpO1xcblxcdC8vIHJldHJpZXZlIGEgc2NhbGUgYW5kIGJpYXMgdG8gRjAuIFNlZSBbMV0sIEZpZ3VyZSAzXFxuXFx0dmVjMyBicmRmID0gU1JHQnRvTElORUFSKHRleHR1cmUyRCh1QlJERk1hcCwgdmVjMihwYnJJbnB1dHMuTmRvdFYsIDEuMCAtIHBicklucHV0cy5wZXJjZXB0dWFsUm91Z2huZXNzKSkpLnJnYjtcXG5cXHR2ZWMzIGRpZmZ1c2VMaWdodCA9IFNSR0J0b0xJTkVBUih0ZXh0dXJlQ3ViZSh1SXJyYWRpYW5jZU1hcCwgbikpLnJnYjtcXG5cXG5cXHR2ZWMzIHNwZWN1bGFyTGlnaHQgPSBTUkdCdG9MSU5FQVIodGV4dHVyZUN1YmVMb2RFWFQodVJhZGlhbmNlTWFwLCByZWZsZWN0aW9uLCBsb2QpKS5yZ2I7XFxuXFxuXFx0dmVjMyBkaWZmdXNlID0gZGlmZnVzZUxpZ2h0ICogcGJySW5wdXRzLmRpZmZ1c2VDb2xvcjtcXG5cXHR2ZWMzIHNwZWN1bGFyID0gc3BlY3VsYXJMaWdodCAqIChwYnJJbnB1dHMuc3BlY3VsYXJDb2xvciAqIGJyZGYueCArIGJyZGYueSk7XFxuXFxuXFx0Ly8gRm9yIHByZXNlbnRhdGlvbiwgdGhpcyBhbGxvd3MgdXMgdG8gZGlzYWJsZSBJQkwgdGVybXNcXG5cXHRkaWZmdXNlICo9IHVTY2FsZUlCTEFtYmllbnQueDtcXG5cXHRzcGVjdWxhciAqPSB1U2NhbGVJQkxBbWJpZW50Lnk7XFxuXFxuXFx0cmV0dXJuIGRpZmZ1c2UgKyBzcGVjdWxhcjtcXG59XFxuXFxuXFxudmVjMyBkaWZmdXNlKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRyZXR1cm4gcGJySW5wdXRzLmRpZmZ1c2VDb2xvciAvIE1fUEk7XFxufVxcblxcblxcbnZlYzMgc3BlY3VsYXJSZWZsZWN0aW9uKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRyZXR1cm4gcGJySW5wdXRzLnJlZmxlY3RhbmNlMCArIChwYnJJbnB1dHMucmVmbGVjdGFuY2U5MCAtIHBicklucHV0cy5yZWZsZWN0YW5jZTApICogcG93KGNsYW1wKDEuMCAtIHBicklucHV0cy5WZG90SCwgMC4wLCAxLjApLCA1LjApO1xcbn1cXG5cXG5mbG9hdCBnZW9tZXRyaWNPY2NsdXNpb24oUEJSSW5mbyBwYnJJbnB1dHMpXFxue1xcblxcdGZsb2F0IE5kb3RMID0gcGJySW5wdXRzLk5kb3RMO1xcblxcdGZsb2F0IE5kb3RWID0gcGJySW5wdXRzLk5kb3RWO1xcblxcdGZsb2F0IHIgPSBwYnJJbnB1dHMuYWxwaGFSb3VnaG5lc3M7XFxuXFxuXFx0ZmxvYXQgYXR0ZW51YXRpb25MID0gMi4wICogTmRvdEwgLyAoTmRvdEwgKyBzcXJ0KHIgKiByICsgKDEuMCAtIHIgKiByKSAqIChOZG90TCAqIE5kb3RMKSkpO1xcblxcdGZsb2F0IGF0dGVudWF0aW9uViA9IDIuMCAqIE5kb3RWIC8gKE5kb3RWICsgc3FydChyICogciArICgxLjAgLSByICogcikgKiAoTmRvdFYgKiBOZG90VikpKTtcXG5cXHRyZXR1cm4gYXR0ZW51YXRpb25MICogYXR0ZW51YXRpb25WO1xcbn1cXG5cXG5cXG5mbG9hdCBtaWNyb2ZhY2V0RGlzdHJpYnV0aW9uKFBCUkluZm8gcGJySW5wdXRzKVxcbntcXG5cXHRmbG9hdCByb3VnaG5lc3NTcSA9IHBicklucHV0cy5hbHBoYVJvdWdobmVzcyAqIHBicklucHV0cy5hbHBoYVJvdWdobmVzcztcXG5cXHRmbG9hdCBmID0gKHBicklucHV0cy5OZG90SCAqIHJvdWdobmVzc1NxIC0gcGJySW5wdXRzLk5kb3RIKSAqIHBicklucHV0cy5OZG90SCArIDEuMDtcXG5cXHRyZXR1cm4gcm91Z2huZXNzU3EgLyAoTV9QSSAqIGYgKiBmKTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcblxcdGZsb2F0IHBlcmNlcHR1YWxSb3VnaG5lc3MgICA9IHVSb3VnaG5lc3M7XFxuXFx0ZmxvYXQgbWV0YWxsaWMgICAgICAgICAgICAgID0gdU1ldGFsbGljO1xcbiNpZmRlZiBIQVNfTUVUQUxST1VHSE5FU1NNQVBcXG5cXHQvLyBSb3VnaG5lc3MgaXMgc3RvcmVkIGluIHRoZSAnZycgY2hhbm5lbCwgbWV0YWxsaWMgaXMgc3RvcmVkIGluIHRoZSAnYicgY2hhbm5lbC5cXG5cXHQvLyBUaGlzIGxheW91dCBpbnRlbnRpb25hbGx5IHJlc2VydmVzIHRoZSAncicgY2hhbm5lbCBmb3IgKG9wdGlvbmFsKSBvY2NsdXNpb24gbWFwIGRhdGFcXG5cXHR2ZWM0IG1yU2FtcGxlID0gdGV4dHVyZTJEKHVNZXRhbGxpY1JvdWdobmVzc01hcCwgdlRleHR1cmVDb29yZCk7XFxuXFx0cGVyY2VwdHVhbFJvdWdobmVzcyA9IG1yU2FtcGxlLmcgKiBwZXJjZXB0dWFsUm91Z2huZXNzO1xcblxcdG1ldGFsbGljID0gbXJTYW1wbGUuYiAqIG1ldGFsbGljO1xcbiNlbmRpZlxcdFxcblxcdHBlcmNlcHR1YWxSb3VnaG5lc3MgICAgICAgICA9IGNsYW1wKHBlcmNlcHR1YWxSb3VnaG5lc3MsIGNfTWluUm91Z2huZXNzLCAxLjApO1xcblxcdG1ldGFsbGljICAgICAgICAgICAgICAgICAgICA9IGNsYW1wKG1ldGFsbGljLCAwLjAsIDEuMCk7XFxuXFx0ZmxvYXQgYWxwaGFSb3VnaG5lc3MgICAgICAgID0gcGVyY2VwdHVhbFJvdWdobmVzcyAqIHBlcmNlcHR1YWxSb3VnaG5lc3M7XFxuXFxuI2lmZGVmIEhBU19CQVNFQ09MT1JNQVBcXHRcXG5cXHR2ZWM0IGJhc2VDb2xvciA9IFNSR0J0b0xJTkVBUih0ZXh0dXJlMkQodUNvbG9yTWFwLCB2VGV4dHVyZUNvb3JkKSk7XFxuI2Vsc2VcXG5cXHR2ZWM0IGJhc2VDb2xvciAgICAgICAgICAgICAgPSB2ZWM0KHVCYXNlQ29sb3IsIDEuMCk7XFxuI2VuZGlmXFx0XFxuXFx0XFxuXFx0dmVjMyBmMCAgICAgICAgICAgICAgICAgICAgID0gdmVjMygwLjA0KTtcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvciAgICAgICAgICAgPSBiYXNlQ29sb3IucmdiICogKHZlYzMoMS4wKSAtIGYwKTtcXG5cXHRkaWZmdXNlQ29sb3IgICAgICAgICAgICAgICAgKj0gMS4wIC0gbWV0YWxsaWM7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yICAgICAgICAgID0gbWl4KGYwLCBiYXNlQ29sb3IucmdiLCBtZXRhbGxpYyk7XFxuXFx0XFxuXFx0Ly8gQ29tcHV0ZSByZWZsZWN0YW5jZS5cXG5cXHRmbG9hdCByZWZsZWN0YW5jZSAgICAgICAgICAgPSBtYXgobWF4KHNwZWN1bGFyQ29sb3Iuciwgc3BlY3VsYXJDb2xvci5nKSwgc3BlY3VsYXJDb2xvci5iKTtcXG5cXHRcXG5cXHQvLyBGb3IgdHlwaWNhbCBpbmNpZGVudCByZWZsZWN0YW5jZSByYW5nZSAoYmV0d2VlbiA0JSB0byAxMDAlKSBzZXQgdGhlIGdyYXppbmcgcmVmbGVjdGFuY2UgdG8gMTAwJSBmb3IgdHlwaWNhbCBmcmVzbmVsIGVmZmVjdC5cXG5cXHQvLyBGb3IgdmVyeSBsb3cgcmVmbGVjdGFuY2UgcmFuZ2Ugb24gaGlnaGx5IGRpZmZ1c2Ugb2JqZWN0cyAoYmVsb3cgNCUpLCBpbmNyZW1lbnRhbGx5IHJlZHVjZSBncmF6aW5nIHJlZmxlY2FuY2UgdG8gMCUuXFxuXFx0ZmxvYXQgcmVmbGVjdGFuY2U5MCAgICAgICAgID0gY2xhbXAocmVmbGVjdGFuY2UgKiAyNS4wLCAwLjAsIDEuMCk7XFxuXFx0dmVjMyBzcGVjdWxhckVudmlyb25tZW50UjAgID0gc3BlY3VsYXJDb2xvci5yZ2I7XFxuXFx0dmVjMyBzcGVjdWxhckVudmlyb25tZW50UjkwID0gdmVjMygxLjAsIDEuMCwgMS4wKSAqIHJlZmxlY3RhbmNlOTA7XFxuXFx0XFxuXFx0dmVjMyBuICAgICAgICAgICAgICAgICAgICAgID0gZ2V0Tm9ybWFsKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWwgYXQgc3VyZmFjZSBwb2ludFxcblxcdHZlYzMgdiAgICAgICAgICAgICAgICAgICAgICA9IG5vcm1hbGl6ZSh1Q2FtZXJhUG9zIC0gdlBvc2l0aW9uKTsgICAgICAgIC8vIFZlY3RvciBmcm9tIHN1cmZhY2UgcG9pbnQgdG8gY2FtZXJhXFxuXFx0dmVjMyBsICAgICAgICAgICAgICAgICAgICAgID0gbm9ybWFsaXplKHVMaWdodERpcmVjdGlvbik7ICAgICAgICAgICAgIC8vIFZlY3RvciBmcm9tIHN1cmZhY2UgcG9pbnQgdG8gbGlnaHRcXG5cXHR2ZWMzIGggICAgICAgICAgICAgICAgICAgICAgPSBub3JtYWxpemUobCt2KTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbGYgdmVjdG9yIGJldHdlZW4gYm90aCBsIGFuZCB2XFxuXFx0dmVjMyByZWZsZWN0aW9uICAgICAgICAgICAgID0gLW5vcm1hbGl6ZShyZWZsZWN0KHYsIG4pKTtcXG5cXHRcXG5cXHRmbG9hdCBOZG90TCAgICAgICAgICAgICAgICAgPSBjbGFtcChkb3QobiwgbCksIDAuMDAxLCAxLjApO1xcblxcdGZsb2F0IE5kb3RWICAgICAgICAgICAgICAgICA9IGFicyhkb3QobiwgdikpICsgMC4wMDE7XFxuXFx0ZmxvYXQgTmRvdEggICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KG4sIGgpLCAwLjAsIDEuMCk7XFxuXFx0ZmxvYXQgTGRvdEggICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KGwsIGgpLCAwLjAsIDEuMCk7XFxuXFx0ZmxvYXQgVmRvdEggICAgICAgICAgICAgICAgID0gY2xhbXAoZG90KHYsIGgpLCAwLjAsIDEuMCk7XFxuXFxuXFx0UEJSSW5mbyBwYnJJbnB1dHMgPSBQQlJJbmZvKFxcblxcdFxcdE5kb3RMLFxcblxcdFxcdE5kb3RWLFxcblxcdFxcdE5kb3RILFxcblxcdFxcdExkb3RILFxcblxcdFxcdFZkb3RILFxcblxcdFxcdHBlcmNlcHR1YWxSb3VnaG5lc3MsXFxuXFx0XFx0bWV0YWxsaWMsXFxuXFx0XFx0c3BlY3VsYXJFbnZpcm9ubWVudFIwLFxcblxcdFxcdHNwZWN1bGFyRW52aXJvbm1lbnRSOTAsXFxuXFx0XFx0YWxwaGFSb3VnaG5lc3MsXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLFxcblxcdFxcdHNwZWN1bGFyQ29sb3JcXG5cXHQpO1xcblxcblxcdC8vIENhbGN1bGF0ZSB0aGUgc2hhZGluZyB0ZXJtcyBmb3IgdGhlIG1pY3JvZmFjZXQgc3BlY3VsYXIgc2hhZGluZyBtb2RlbFxcblxcdHZlYzMgRiAgICAgICAgICAgICAgPSBzcGVjdWxhclJlZmxlY3Rpb24ocGJySW5wdXRzKTtcXG5cXHRmbG9hdCBHICAgICAgICAgICAgID0gZ2VvbWV0cmljT2NjbHVzaW9uKHBicklucHV0cyk7XFxuXFx0ZmxvYXQgRCAgICAgICAgICAgICA9IG1pY3JvZmFjZXREaXN0cmlidXRpb24ocGJySW5wdXRzKTtcXG5cXHRcXG5cXHQvLyBDYWxjdWxhdGlvbiBvZiBhbmFseXRpY2FsIGxpZ2h0aW5nIGNvbnRyaWJ1dGlvblxcblxcdHZlYzMgZGlmZnVzZUNvbnRyaWIgPSAoMS4wIC0gRikgKiBkaWZmdXNlKHBicklucHV0cyk7XFxuXFx0dmVjMyBzcGVjQ29udHJpYiAgICA9IEYgKiBHICogRCAvICg0LjAgKiBOZG90TCAqIE5kb3RWKTtcXG5cXHQvLyBPYnRhaW4gZmluYWwgaW50ZW5zaXR5IGFzIHJlZmxlY3RhbmNlIChCUkRGKSBzY2FsZWQgYnkgdGhlIGVuZXJneSBvZiB0aGUgbGlnaHQgKGNvc2luZSBsYXcpXFxuXFx0dmVjMyBjb2xvciAgICAgICAgICA9IE5kb3RMICogdUxpZ2h0Q29sb3IgKiAoZGlmZnVzZUNvbnRyaWIgKyBzcGVjQ29udHJpYik7XFxuXFx0XFxuI2lmZGVmIFVTRV9JQkxcXG5cXHRjb2xvciArPSBnZXRJQkxDb250cmlidXRpb24ocGJySW5wdXRzLCBuLCByZWZsZWN0aW9uKTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgSEFTX09DQ0xVU0lPTk1BUFxcdFxcblxcdGZsb2F0IGFvICAgICAgICAgICAgPSB0ZXh0dXJlMkQodUFvTWFwLCB2VGV4dHVyZUNvb3JkKS5yO1xcblxcdGNvbG9yICAgICAgICAgICAgICAgPSBtaXgoY29sb3IsIGNvbG9yICogYW8sIHVPY2NsdXNpb25TdHJlbmd0aCk7XFxuI2VuZGlmXFx0XFxuXFxuI2lmZGVmIEhBU19FTUlTU0lWRU1BUFxcblxcdHZlYzMgZW1pc3NpdmUgPSBTUkdCdG9MSU5FQVIodGV4dHVyZTJEKHVFbWlzc2l2ZU1hcCwgdlRleHR1cmVDb29yZCkpLnJnYiAqIHVFbWlzc2l2ZUZhY3RvcjtcXG5cXHRjb2xvciArPSBlbWlzc2l2ZTtcXG4jZW5kaWZcXG5cXHRcXG5cXHQvLyBUaGlzIHNlY3Rpb24gdXNlcyBtaXggdG8gb3ZlcnJpZGUgZmluYWwgY29sb3IgZm9yIHJlZmVyZW5jZSBhcHAgdmlzdWFsaXphdGlvblxcblxcdC8vIG9mIHZhcmlvdXMgcGFyYW1ldGVycyBpbiB0aGUgbGlnaHRpbmcgZXF1YXRpb24uXFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgRiwgdVNjYWxlRkdEU3BlYy54KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKEcpLCB1U2NhbGVGR0RTcGVjLnkpO1xcblxcdGNvbG9yICAgICAgICAgICAgICAgPSBtaXgoY29sb3IsIHZlYzMoRCksIHVTY2FsZUZHRFNwZWMueik7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgc3BlY0NvbnRyaWIsIHVTY2FsZUZHRFNwZWMudyk7XFxuXFx0XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgZGlmZnVzZUNvbnRyaWIsIHVTY2FsZURpZmZCYXNlTVIueCk7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgYmFzZUNvbG9yLnJnYiwgdVNjYWxlRGlmZkJhc2VNUi55KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKG1ldGFsbGljKSwgdVNjYWxlRGlmZkJhc2VNUi56KTtcXG5cXHRjb2xvciAgICAgICAgICAgICAgID0gbWl4KGNvbG9yLCB2ZWMzKHBlcmNlcHR1YWxSb3VnaG5lc3MpLCB1U2NhbGVEaWZmQmFzZU1SLncpO1xcblxcdFxcblxcdC8vIG91dHB1dCB0aGUgZnJhZ21lbnQgY29sb3JcXG5cXHRnbF9GcmFnQ29sb3IgICAgICAgID0gdmVjNChwb3coY29sb3IsdmVjMygxLjAvdUdhbW1hKSksIGJhc2VDb2xvci5hKTtcXG5cXHQvLyBnbF9GcmFnQ29sb3IgICAgICAgID0gdmVjNCh2ZWMzKG1ldGFsbGljKSwgMS4wKTtcXG5cXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvZ2x0Zi5mcmFnXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBkZWJ1Zy5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBkZWJ1Z19mcmFnXFxuI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kOiBlbmFibGVcXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMyB1RW1pc3NpdmVGYWN0b3I7XFxuXFxuI2lmZGVmIEhBU19CQVNFQ09MT1JNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1Q29sb3JNYXA7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIEhBU19OT1JNQUxNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCB1Tm9ybWFsTWFwO1xcbnVuaWZvcm0gZmxvYXQgdU5vcm1hbFNjYWxlO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfT0NDTFVTSU9OTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgdUFvTWFwO1xcbnVuaWZvcm0gZmxvYXQgdU9jY2x1c2lvblN0cmVuZ3RoO1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb247XFxuXFxudmVjMyBnZXROb3JtYWwoKSB7XFxuXFx0dmVjMyBwb3NfZHggPSBkRmR4KHZQb3NpdGlvbik7XFxuXFx0dmVjMyBwb3NfZHkgPSBkRmR5KHZQb3NpdGlvbik7XFxuXFx0dmVjMyB0ZXhfZHggPSBkRmR4KHZlYzModlRleHR1cmVDb29yZCwgMC4wKSk7XFxuXFx0dmVjMyB0ZXhfZHkgPSBkRmR5KHZlYzModlRleHR1cmVDb29yZCwgMC4wKSk7XFxuXFx0dmVjMyB0ID0gKHRleF9keS50ICogcG9zX2R4IC0gdGV4X2R4LnQgKiBwb3NfZHkpIC8gKHRleF9keC5zICogdGV4X2R5LnQgLSB0ZXhfZHkucyAqIHRleF9keC50KTtcXG5cXG5cXHR2ZWMzIG5nID0gbm9ybWFsaXplKHZOb3JtYWwpO1xcblxcblxcdHQgPSBub3JtYWxpemUodCAtIG5nICogZG90KG5nLCB0KSk7XFxuXFx0dmVjMyBiID0gbm9ybWFsaXplKGNyb3NzKG5nLCB0KSk7XFxuXFx0bWF0MyB0Ym4gPSBtYXQzKHQsIGIsIG5nKTtcXG5cXG4jaWZkZWYgSEFTX05PUk1BTE1BUFxcblxcdHZlYzMgbiA9IHRleHR1cmUyRCh1Tm9ybWFsTWFwLCB2VGV4dHVyZUNvb3JkKS5yZ2I7XFxuXFx0biA9IG5vcm1hbGl6ZSh0Ym4gKiAoKDIuMCAqIG4gLSAxLjApICogdmVjMyh1Tm9ybWFsU2NhbGUsIHVOb3JtYWxTY2FsZSwgMS4wKSkpO1xcbiNlbHNlXFxuXFx0Ly8gVGhlIHRibiBtYXRyaXggaXMgbGluZWFybHkgaW50ZXJwb2xhdGVkLCBzbyB3ZSBuZWVkIHRvIHJlLW5vcm1hbGl6ZVxcblxcdHZlYzMgbiA9IG5vcm1hbGl6ZSh0Ym5bMl0ueHl6KTtcXG4jZW5kaWZcXG5cXG5cXHRyZXR1cm4gbjtcXG59XFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgLy8gZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Tm9ybWFsICogLjUgKyAuNSwgMS4wKTtcXG5cXG4gICAgdmVjMyBjb2xvciA9IGdldE5vcm1hbCgpICogLjUgKyAuNTtcXG5cXG4jaWZkZWYgSEFTX0JBU0VDT0xPUk1BUFxcblxcdGNvbG9yID0gdGV4dHVyZTJEKHVDb2xvck1hcCwgdlRleHR1cmVDb29yZCkucmdiO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBIQVNfT0NDTFVTSU9OTUFQXFx0XFxuXFx0ZmxvYXQgYW8gICAgICAgICAgICA9IHRleHR1cmUyRCh1QW9NYXAsIHZUZXh0dXJlQ29vcmQpLnI7XFxuXFx0Y29sb3IgICAgICAgICAgICAgICA9IG1peChjb2xvciwgY29sb3IgKiBhbywgdU9jY2x1c2lvblN0cmVuZ3RoKTtcXG4jZW5kaWZcXHRcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvZGVidWcuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBDYW1lcmFDdWJlLmpzXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IENhbWVyYVBlcnNwZWN0aXZlIGZyb20gJy4vQ2FtZXJhUGVyc3BlY3RpdmUnO1xuaW1wb3J0IHsgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmNvbnN0IENBTUVSQV9TRVRUSU5HUyA9IFtcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDEsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgLTEsIDApXSxcdFx0XG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygtMSwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAtMSwgMCldLFxuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgIDEsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgIDEpXSxcblx0W3ZlYzMuZnJvbVZhbHVlcygwLCAwLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIC0xLCAwKSwgdmVjMy5mcm9tVmFsdWVzKDAsIDAsIC0xKV0sXG5cdFt2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgMCksIHZlYzMuZnJvbVZhbHVlcygwLCAwLCAgMSksIHZlYzMuZnJvbVZhbHVlcygwLCAtMSwgMCldLFxuXHRbdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApLCB2ZWMzLmZyb21WYWx1ZXMoMCwgMCwgLTEpLCB2ZWMzLmZyb21WYWx1ZXMoMCwgLTEsIDApXVxuXTtcblxuY2xhc3MgQ2FtZXJhQ3ViZSBleHRlbmRzIENhbWVyYVBlcnNwZWN0aXZlIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5zZXRQZXJzcGVjdGl2ZShNYXRoLlBJIC8gMiwgMSwgMC4xLCAxMDAwKTtcblx0fVxuXG5cblx0ZmFjZShtSW5kZXgpIHtcblx0XHRjb25zdCBvID0gQ0FNRVJBX1NFVFRJTkdTW21JbmRleF07XG5cdFx0dGhpcy5sb29rQXQob1swXSwgb1sxXSwgb1syXSk7XG5cdH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmFDdWJlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2NhbWVyYXMvQ2FtZXJhQ3ViZS5qcyIsIi8vIE9iakxvYWRlci5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBCaW5hcnlMb2FkZXIgZnJvbSAnLi9CaW5hcnlMb2FkZXInO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4uL0dlb21ldHJ5JztcblxuY2xhc3MgT2JqTG9hZGVyIGV4dGVuZHMgQmluYXJ5TG9hZGVyIHtcblxuXHRsb2FkKHVybCwgY2FsbGJhY2ssIGRyYXdUeXBlID0gNCkge1xuXHRcdHRoaXMuX2RyYXdUeXBlID0gZHJhd1R5cGU7XG5cdFx0c3VwZXIubG9hZCh1cmwsIGNhbGxiYWNrKTtcblx0fVxuXG5cdF9vbkxvYWRlZCgpIHtcblx0XHR0aGlzLnBhcnNlT2JqKHRoaXMuX3JlcS5yZXNwb25zZSk7XG5cdH1cblxuXHRwYXJzZU9iaihvYmpTdHIpIHtcblx0XHRjb25zdCBsaW5lcyA9IG9ialN0ci5zcGxpdCgnXFxuJyk7XG5cblx0XHRjb25zdCBwb3NpdGlvbnMgICAgPSBbXTtcblx0XHRjb25zdCBjb29yZHMgICAgICAgPSBbXTtcblx0XHRjb25zdCBmaW5hbE5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyAgICAgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzICAgICAgPSBbXTtcblx0XHRjb25zdCB1dnMgICAgICAgICAgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzICAgICAgPSBbXTtcblx0XHRsZXQgY291bnQgICAgICAgID0gMDtcblx0XHRsZXQgcmVzdWx0O1xuXG5cdFx0Ly8gdiBmbG9hdCBmbG9hdCBmbG9hdFxuXHRcdGNvbnN0IHZlcnRleFBhdHRlcm4gPSAvdiggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS87XG5cblx0XHQvLyB2biBmbG9hdCBmbG9hdCBmbG9hdFxuXHRcdGNvbnN0IG5vcm1hbFBhdHRlcm4gPSAvdm4oICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspKCArW1xcZHxcXC58XFwrfFxcLXxlfEVdKykvO1xuXG5cdFx0Ly8gdnQgZmxvYXQgZmxvYXRcblx0XHRjb25zdCB1dlBhdHRlcm4gPSAvdnQoICtbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKSggK1tcXGR8XFwufFxcK3xcXC18ZXxFXSspLztcblxuXHRcdC8vIGYgdmVydGV4IHZlcnRleCB2ZXJ0ZXggLi4uXG5cdFx0Y29uc3QgZmFjZVBhdHRlcm4xID0gL2YoICstP1xcZCspKCArLT9cXGQrKSggKy0/XFxkKykoICstP1xcZCspPy87XG5cblx0XHQvLyBmIHZlcnRleC91diB2ZXJ0ZXgvdXYgdmVydGV4L3V2IC4uLlxuXHRcdGNvbnN0IGZhY2VQYXR0ZXJuMiA9IC9mKCArKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKSk/LztcblxuXHRcdC8vIGYgdmVydGV4L3V2L25vcm1hbCB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWwgLi4uXG5cdFx0Y29uc3QgZmFjZVBhdHRlcm4zID0gL2YoICsoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC8oLT9cXGQrKVxcLygtP1xcZCspKSggKygtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcLygtP1xcZCspXFwvKC0/XFxkKykpPy87XG5cblx0XHQvLyBmIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIC4uLiBcblx0XHRjb25zdCBmYWNlUGF0dGVybjQgPSAvZiggKygtP1xcZCspXFwvXFwvKC0/XFxkKykpKCArKC0/XFxkKylcXC9cXC8oLT9cXGQrKSkoICsoLT9cXGQrKVxcL1xcLygtP1xcZCspKSggKygtP1xcZCspXFwvXFwvKC0/XFxkKykpPy87XG5cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVmVydGV4SW5kZXgodmFsdWUpIHtcblx0XHRcdGNvbnN0IGluZGV4ID0gcGFyc2VJbnQodmFsdWUpO1xuXHRcdFx0cmV0dXJuIChpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyB2ZXJ0aWNlcy5sZW5ndGggLyAzKSAqIDM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VOb3JtYWxJbmRleCh2YWx1ZSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gKGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIG5vcm1hbHMubGVuZ3RoIC8gMykgKiAzO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVVZJbmRleCh2YWx1ZSkge1xuXHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludCh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gKGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIHV2cy5sZW5ndGggLyAyKSAqIDI7XG5cdFx0fVxuXG5cblx0XHRmdW5jdGlvbiBhZGRWZXJ0ZXgoYSwgYiwgYykge1xuXHRcdFx0cG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2FdLCB2ZXJ0aWNlc1thICsgMV0sIHZlcnRpY2VzW2EgKyAyXV0pO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2JdLCB2ZXJ0aWNlc1tiICsgMV0sIHZlcnRpY2VzW2IgKyAyXV0pO1xuXHRcdFx0cG9zaXRpb25zLnB1c2goW3ZlcnRpY2VzW2NdLCB2ZXJ0aWNlc1tjICsgMV0sIHZlcnRpY2VzW2MgKyAyXV0pO1xuXG5cdFx0XHRpbmRpY2VzLnB1c2goY291bnQgKiAzICsgMCk7XG5cdFx0XHRpbmRpY2VzLnB1c2goY291bnQgKiAzICsgMSk7XG5cdFx0XHRpbmRpY2VzLnB1c2goY291bnQgKiAzICsgMik7XG5cblx0XHRcdGNvdW50ICsrO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gYWRkVVYoYSwgYiwgYykge1xuXHRcdFx0Y29vcmRzLnB1c2goW3V2c1thXSwgdXZzW2EgKyAxXV0pO1xuXHRcdFx0Y29vcmRzLnB1c2goW3V2c1tiXSwgdXZzW2IgKyAxXV0pO1xuXHRcdFx0Y29vcmRzLnB1c2goW3V2c1tjXSwgdXZzW2MgKyAxXV0pO1xuXHRcdH1cblxuXG5cdFx0ZnVuY3Rpb24gYWRkTm9ybWFsKGEsIGIsIGMpIHtcblx0XHRcdGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2FdLCBub3JtYWxzW2EgKyAxXSwgbm9ybWFsc1thICsgMl1dKTtcblx0XHRcdGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2JdLCBub3JtYWxzW2IgKyAxXSwgbm9ybWFsc1tiICsgMl1dKTtcblx0XHRcdGZpbmFsTm9ybWFscy5wdXNoKFtub3JtYWxzW2NdLCBub3JtYWxzW2MgKyAxXSwgbm9ybWFsc1tjICsgMl1dKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRGYWNlKGEsIGIsIGMsIGQsICB1YSwgdWIsIHVjLCB1ZCwgIG5hLCBuYiwgbmMsIG5kKSB7XG5cdFx0XHRsZXQgaWEgPSBwYXJzZVZlcnRleEluZGV4KGEpO1xuXHRcdFx0bGV0IGliID0gcGFyc2VWZXJ0ZXhJbmRleChiKTtcblx0XHRcdGxldCBpYyA9IHBhcnNlVmVydGV4SW5kZXgoYyk7XG5cdFx0XHRsZXQgaWQ7XG5cblx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoaWEsIGliLCBpYyk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aWQgPSBwYXJzZVZlcnRleEluZGV4KGQpO1xuXG5cdFx0XHRcdGFkZFZlcnRleChpYSwgaWIsIGlkKTtcblx0XHRcdFx0YWRkVmVydGV4KGliLCBpYywgaWQpO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKHVhICE9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRpYSA9IHBhcnNlVVZJbmRleCh1YSk7XG5cdFx0XHRcdGliID0gcGFyc2VVVkluZGV4KHViKTtcblx0XHRcdFx0aWMgPSBwYXJzZVVWSW5kZXgodWMpO1xuXG5cdFx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRcdGFkZFVWKGlhLCBpYiwgaWMpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZCA9IHBhcnNlVVZJbmRleCh1ZCk7XG5cblx0XHRcdFx0XHRhZGRVVihpYSwgaWIsIGlkKTtcblx0XHRcdFx0XHRhZGRVVihpYiwgaWMsIGlkKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5hICE9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRpYSA9IHBhcnNlTm9ybWFsSW5kZXgobmEpO1xuXHRcdFx0XHRpYiA9IHBhcnNlTm9ybWFsSW5kZXgobmIpO1xuXHRcdFx0XHRpYyA9IHBhcnNlTm9ybWFsSW5kZXgobmMpO1xuXG5cdFx0XHRcdGlmIChkID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRcdGFkZE5vcm1hbChpYSwgaWIsIGljKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWQgPSBwYXJzZU5vcm1hbEluZGV4KG5kKTtcblxuXHRcdFx0XHRcdGFkZE5vcm1hbChpYSwgaWIsIGlkKTtcblx0XHRcdFx0XHRhZGROb3JtYWwoaWIsIGljLCBpZCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKykge1xuXHRcdFx0bGV0IGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuXHRcdFx0aWYgKGxpbmUubGVuZ3RoID09PSAwIHx8IGxpbmUuY2hhckF0KDApID09PSAnIycpIHtcblxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gdmVydGV4UGF0dGVybi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMV0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzJdKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFszXSlcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICgocmVzdWx0ID0gbm9ybWFsUGF0dGVybi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsxXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMl0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQocmVzdWx0WzNdKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2UgaWYgKChyZXN1bHQgPSB1dlBhdHRlcm4uZXhlYyhsaW5lKSkgIT09IG51bGwpIHtcblxuXHRcdFx0XHR1dnMucHVzaChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KHJlc3VsdFsxXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChyZXN1bHRbMl0pXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuMS5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzFdLCByZXN1bHRbMl0sIHJlc3VsdFszXSwgcmVzdWx0WzRdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuMi5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WzJdLCByZXN1bHRbNV0sIHJlc3VsdFs4XSwgcmVzdWx0WzExXSxcblx0XHRcdFx0XHRyZXN1bHRbM10sIHJlc3VsdFs2XSwgcmVzdWx0WzldLCByZXN1bHRbMTJdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuMy5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRhZGRGYWNlKFxuXHRcdFx0XHRcdHJlc3VsdFsyXSwgcmVzdWx0WzZdLCByZXN1bHRbMTBdLCByZXN1bHRbMTRdLFxuXHRcdFx0XHRcdHJlc3VsdFszXSwgcmVzdWx0WzddLCByZXN1bHRbMTFdLCByZXN1bHRbMTVdLFxuXHRcdFx0XHRcdHJlc3VsdFs0XSwgcmVzdWx0WzhdLCByZXN1bHRbMTJdLCByZXN1bHRbMTZdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoKHJlc3VsdCA9IGZhY2VQYXR0ZXJuNC5leGVjKGxpbmUpKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRhZGRGYWNlKFxuXHRcdFx0XHRcdHJlc3VsdFsyXSwgcmVzdWx0WzVdLCByZXN1bHRbOF0sIHJlc3VsdFsxMV0sXG5cdFx0XHRcdFx0dW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHJlc3VsdFszXSwgcmVzdWx0WzZdLCByZXN1bHRbOV0sIHJlc3VsdFsxMl1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fZ2VuZXJhdGVHZW9tZXRyeSh7XHRcblx0XHRcdHBvc2l0aW9ucyxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdG5vcm1hbHM6ZmluYWxOb3JtYWxzLFxuXHRcdFx0aW5kaWNlc1xuXHRcdH0pO1xuXHRcdFxuXHR9XG5cblx0X2dlbmVyYXRlR2VvbWV0cnkobykge1xuXHRcdGNvbnN0IG1heE51bVZlcnRpY2VzID0gNjU1MzU7XG5cdFx0Y29uc3QgaGFzTm9ybWFscyA9IG8ubm9ybWFscy5sZW5ndGggPiAwO1xuXHRcdGNvbnN0IGhhc1VWcyA9IG8uY29vcmRzLmxlbmd0aCA+IDA7XG5cdFx0bGV0IGdlb21ldHJ5O1xuXG5cdFx0aWYoby5wb3NpdGlvbnMubGVuZ3RoID4gbWF4TnVtVmVydGljZXMpIHtcblx0XHRcdGNvbnN0IGdlb21ldHJpZXMgPSBbXTtcblx0XHRcdGxldCBsYXN0SW5kZXggPSAwO1xuXG5cdFx0XHRjb25zdCBvQ29weSAgICAgICA9IHt9O1xuXHRcdFx0b0NvcHkucG9zaXRpb25zID0gby5wb3NpdGlvbnMuY29uY2F0KCk7XG5cdFx0XHRvQ29weS5jb29yZHMgICAgPSBvLmNvb3Jkcy5jb25jYXQoKTtcblx0XHRcdG9Db3B5LmluZGljZXMgICA9IG8uaW5kaWNlcy5jb25jYXQoKTtcblx0XHRcdG9Db3B5Lm5vcm1hbHMgICA9IG8ubm9ybWFscy5jb25jYXQoKTtcblxuXHRcdFx0d2hpbGUoby5pbmRpY2VzLmxlbmd0aCA+IDApIHtcblxuXHRcdFx0XHRjb25zdCBzbGljZU51bSAgPSBNYXRoLm1pbihtYXhOdW1WZXJ0aWNlcywgby5wb3NpdGlvbnMubGVuZ3RoKTtcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyAgID0gby5pbmRpY2VzLnNwbGljZSgwLCBzbGljZU51bSk7XG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdFx0XHRjb25zdCBjb29yZHMgICAgPSBbXTtcblx0XHRcdFx0Y29uc3Qgbm9ybWFscyAgID0gW107XG5cdFx0XHRcdGxldCBpbmRleCwgdG1wSW5kZXggPSAwO1xuXG5cdFx0XHRcdGZvcihsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYoaW5kaWNlc1tpXSA+IHRtcEluZGV4KSB7XG5cdFx0XHRcdFx0XHR0bXBJbmRleCA9IGluZGljZXNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzW2ldO1xuXG5cdFx0XHRcdFx0cG9zaXRpb25zLnB1c2gob0NvcHkucG9zaXRpb25zW2luZGV4XSk7XG5cdFx0XHRcdFx0aWYoaGFzVVZzKSB7XG5cdFx0XHRcdFx0XHRjb29yZHMucHVzaChvQ29weS5jb29yZHNbaW5kZXhdKTtcdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihoYXNOb3JtYWxzKSB7XG5cdFx0XHRcdFx0XHRub3JtYWxzLnB1c2gob0NvcHkubm9ybWFsc1tpbmRleF0pO1x0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGluZGljZXNbaV0gLT0gbGFzdEluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGFzdEluZGV4ID0gdG1wSW5kZXggKyAxO1xuXG5cdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KHRoaXMuX2RyYXdUeXBlKTtcblx0XHRcdFx0Z2VvbWV0cnkuYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdFx0XHRcdGlmKGhhc1VWcykge1xuXHRcdFx0XHRcdGdlb21ldHJ5LmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XHRcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Z2VvbWV0cnkuYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cdFx0XHRcdGlmKGhhc05vcm1hbHMpIHtcblx0XHRcdFx0XHRnZW9tZXRyeS5idWZmZXJOb3JtYWwobm9ybWFscyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnZW9tZXRyaWVzLnB1c2goZ2VvbWV0cnkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0XHR0aGlzLl9jYWxsYmFjayhnZW9tZXRyaWVzLCBvQ29weSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZW9tZXRyaWVzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSh0aGlzLl9kcmF3VHlwZSk7XG5cdFx0XHRnZW9tZXRyeS5idWZmZXJWZXJ0ZXgoby5wb3NpdGlvbnMpO1xuXHRcdFx0aWYoaGFzVVZzKSB7XG5cdFx0XHRcdGdlb21ldHJ5LmJ1ZmZlclRleENvb3JkKG8uY29vcmRzKTtcdFxuXHRcdFx0fVxuXHRcdFx0Z2VvbWV0cnkuYnVmZmVySW5kZXgoby5pbmRpY2VzKTtcblx0XHRcdGlmKGhhc05vcm1hbHMpIHtcblx0XHRcdFx0Z2VvbWV0cnkuYnVmZmVyTm9ybWFsKG8ubm9ybWFscyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuX2NhbGxiYWNrKSB7XG5cdFx0XHRcdHRoaXMuX2NhbGxiYWNrKGdlb21ldHJ5LCBvKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufVxuXG5cbk9iakxvYWRlci5wYXJzZSA9IGZ1bmN0aW9uIChvYmpTdHIpIHtcblx0Y29uc3QgbG9hZGVyID0gbmV3IE9iakxvYWRlcigpO1xuXHRyZXR1cm4gbG9hZGVyLnBhcnNlT2JqKG9ialN0cik7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBPYmpMb2FkZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy9PYmpMb2FkZXIuanMiLCIvLyBIRFJMb2FkZXIuanNcblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQmluYXJ5TG9hZGVyIGZyb20gJy4vQmluYXJ5TG9hZGVyJztcbmltcG9ydCBoZHJQYXJzZXIgZnJvbSAnLi4vdXRpbHMvSERSUGFyc2VyJztcblxuY2xhc3MgSERSTG9hZGVyIGV4dGVuZHMgQmluYXJ5TG9hZGVyIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0c3VwZXIodHJ1ZSk7XG5cdH1cblxuXHRwYXJzZShtQXJyYXlCdWZmZXIpIHtcblx0XHRyZXR1cm4gaGRyUGFyc2VyKG1BcnJheUJ1ZmZlcik7XG5cdH1cblxuXHRfb25Mb2FkZWQoKSB7XG5cdFx0Y29uc3QgbyA9IHRoaXMucGFyc2UodGhpcy5fcmVxLnJlc3BvbnNlKTtcblx0XHRpZih0aGlzLl9jYWxsYmFjaykge1xuXHRcdFx0dGhpcy5fY2FsbGJhY2sobyk7XG5cdFx0fVxuXHR9XG5cbn1cblxuXG5IRFJMb2FkZXIucGFyc2UgPSBmdW5jdGlvbiAobUFycmF5QnVmZmVyKSB7XG5cdHJldHVybiBoZHJQYXJzZXIobUFycmF5QnVmZmVyKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhEUkxvYWRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0hEUkxvYWRlci5qcyIsIi8vIEhEUlBhcnNlci5qc1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIENvZGUgcG9ydGVkIGJ5IE1hcmNpbiBJZ25hYyAoMjAxNClcbi8vIEJhc2VkIG9uIEphdmEgaW1wbGVtZW50YXRpb24gZnJvbVxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vci9jeXMxMjM0NS1yZXNlYXJjaC9zb3VyY2UvYnJvd3NlL2hkci9pbWFnZV9wcm9jZXNzb3IvUkdCRS5qYXZhP3I9N2Q4NGU5ZmQ4NjZiMjQwNzlkYmU2MWZhMGE5NjZjZTgzNjVmNTcyNlxuY29uc3QgcmFkaWFuY2VQYXR0ZXJuID0gJyNcXFxcP1JBRElBTkNFJztcbmNvbnN0IGNvbW1lbnRQYXR0ZXJuID0gJyMuKic7XG4vLyBsZXQgZ2FtbWFQYXR0ZXJuID0gJ0dBTU1BPSc7XG5jb25zdCBleHBvc3VyZVBhdHRlcm4gPSAnRVhQT1NVUkU9XFxcXHMqKFswLTldKlsuXVswLTldKiknO1xuY29uc3QgZm9ybWF0UGF0dGVybiA9ICdGT1JNQVQ9MzItYml0X3JsZV9yZ2JlJztcbmNvbnN0IHdpZHRoSGVpZ2h0UGF0dGVybiA9ICctWSAoWzAtOV0rKSBcXFxcK1ggKFswLTldKyknO1xuXG4vLyBodHRwOi8vY3JvcXVldHdlYWsuYmxvZ3Nwb3QuY28udWsvMjAxNC8wOC9kZWNvbnN0cnVjdGluZy1mbG9hdHMtZnJleHAtYW5kLWxkZXhwLmh0bWxcbi8vIGZ1bmN0aW9uIGxkZXhwKG1hbnRpc3NhLCBleHBvbmVudCkge1xuLy8gICAgIHJldHVybiBleHBvbmVudCA+IDEwMjMgPyBtYW50aXNzYSAqIE1hdGgucG93KDIsIDEwMjMpICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDIzKSA6IGV4cG9uZW50IDwgLTEwNzQgPyBtYW50aXNzYSAqIE1hdGgucG93KDIsIC0xMDc0KSAqIE1hdGgucG93KDIsIGV4cG9uZW50ICsgMTA3NCkgOiBtYW50aXNzYSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcbi8vIH1cblxuZnVuY3Rpb24gcmVhZFBpeGVsc1Jhd1JMRShidWZmZXIsIGRhdGEsIG9mZnNldCwgZmlsZU9mZnNldCwgc2NhbmxpbmVXaWR0aCwgbnVtU2NhbmxpbmVzKSB7XG5cdGNvbnN0IHJnYmUgPSBuZXcgQXJyYXkoNCk7XG5cdGxldCBzY2FubGluZUJ1ZmZlciA9IG51bGw7XG5cdGxldCBwdHI7XG5cdGxldCBwdHJFbmQ7XG5cdGxldCBjb3VudDtcblx0Y29uc3QgYnVmID0gbmV3IEFycmF5KDIpO1xuXHRjb25zdCBidWZmZXJMZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuXG5cdGZ1bmN0aW9uIHJlYWRCdWYoYnVmKSB7XG5cdFx0bGV0IGJ5dGVzUmVhZCA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0YnVmW2J5dGVzUmVhZCsrXSA9IGJ1ZmZlcltmaWxlT2Zmc2V0XTtcblx0XHR9IHdoaWxlKCsrZmlsZU9mZnNldCA8IGJ1ZmZlckxlbmd0aCAmJiBieXRlc1JlYWQgPCBidWYubGVuZ3RoKTtcblx0XHRyZXR1cm4gYnl0ZXNSZWFkO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVhZEJ1Zk9mZnNldChidWYsIG9mZnNldCwgbGVuZ3RoKSB7XG5cdFx0bGV0IGJ5dGVzUmVhZCA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0YnVmW29mZnNldCArIGJ5dGVzUmVhZCsrXSA9IGJ1ZmZlcltmaWxlT2Zmc2V0XTtcblx0XHR9IHdoaWxlKCsrZmlsZU9mZnNldCA8IGJ1ZmZlckxlbmd0aCAmJiBieXRlc1JlYWQgPCBsZW5ndGgpO1xuXHRcdHJldHVybiBieXRlc1JlYWQ7XG5cdH1cblxuXHRmdW5jdGlvbiByZWFkUGl4ZWxzUmF3KGJ1ZmZlciwgZGF0YSwgb2Zmc2V0LCBudW1waXhlbHMpIHtcblx0XHRjb25zdCBudW1FeHBlY3RlZCA9IDQgKiBudW1waXhlbHM7XG5cdFx0Y29uc3QgbnVtUmVhZCA9IHJlYWRCdWZPZmZzZXQoZGF0YSwgb2Zmc2V0LCBudW1FeHBlY3RlZCk7XG5cdFx0aWYgKG51bVJlYWQgPCBudW1FeHBlY3RlZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFcnJvciByZWFkaW5nIHJhdyBwaXhlbHM6IGdvdCAke251bVJlYWR9IGJ5dGVzLCBleHBlY3RlZCAke251bUV4cGVjdGVkfWApO1xuXHRcdH1cblx0fVxuXG5cdHdoaWxlIChudW1TY2FubGluZXMgPiAwKSB7XG5cdFx0aWYgKHJlYWRCdWYocmdiZSkgPCByZ2JlLmxlbmd0aCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBFcnJvciByZWFkaW5nIGJ5dGVzOiBleHBlY3RlZCAke3JnYmUubGVuZ3RofWApO1xuXHRcdH1cblxuXHRcdGlmICgocmdiZVswXSAhPT0gMikgfHwgKHJnYmVbMV0gIT09IDIpIHx8ICgocmdiZVsyXSAmIDB4ODApICE9PSAwKSkge1xuXHRcdFx0Ly8gdGhpcyBmaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWRcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVswXTtcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVsxXTtcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVsyXTtcblx0XHRcdGRhdGFbb2Zmc2V0KytdID0gcmdiZVszXTtcblx0XHRcdHJlYWRQaXhlbHNSYXcoYnVmZmVyLCBkYXRhLCBvZmZzZXQsIHNjYW5saW5lV2lkdGggKiBudW1TY2FubGluZXMgLSAxKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoKCgocmdiZVsyXSAmIDB4RkYpIDw8IDgpIHwgKHJnYmVbM10gJiAweEZGKSkgIT09IHNjYW5saW5lV2lkdGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgV3Jvbmcgc2NhbmxpbmUgd2lkdGggJHsoKChyZ2JlWzJdICYgMHhGRikgPDwgOCkgfCAocmdiZVszXSAmIDB4RkYpKX0sIGV4cGVjdGVkICR7c2NhbmxpbmVXaWR0aH1gKTtcblx0XHR9XG5cblx0XHRpZiAoc2NhbmxpbmVCdWZmZXIgPT09IG51bGwpIHtcblx0XHRcdHNjYW5saW5lQnVmZmVyID0gbmV3IEFycmF5KDQgKiBzY2FubGluZVdpZHRoKTtcblx0XHR9XG5cblx0XHRwdHIgPSAwO1xuXHRcdC8qIHJlYWQgZWFjaCBvZiB0aGUgZm91ciBjaGFubmVscyBmb3IgdGhlIHNjYW5saW5lIGludG8gdGhlIGJ1ZmZlciAqL1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRwdHJFbmQgPSAoaSArIDEpICogc2NhbmxpbmVXaWR0aDtcblx0XHRcdHdoaWxlKHB0ciA8IHB0ckVuZCkge1xuXHRcdFx0XHRpZiAocmVhZEJ1ZihidWYpIDwgYnVmLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IgcmVhZGluZyAyLWJ5dGUgYnVmZmVyJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKChidWZbMF0gJiAweEZGKSA+IDEyOCkge1xuXHRcdFx0XHRcdC8qIGEgcnVuIG9mIHRoZSBzYW1lIHZhbHVlICovXG5cdFx0XHRcdFx0Y291bnQgPSAoYnVmWzBdICYgMHhGRikgLSAxMjg7XG5cdFx0XHRcdFx0aWYgKChjb3VudCA9PT0gMCkgfHwgKGNvdW50ID4gcHRyRW5kIC0gcHRyKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYWQgc2NhbmxpbmUgZGF0YScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZShjb3VudC0tID4gMCkge1xuXHRcdFx0XHRcdFx0c2NhbmxpbmVCdWZmZXJbcHRyKytdID0gYnVmWzFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBhIG5vbi1ydW4gKi9cblx0XHRcdFx0XHRjb3VudCA9IGJ1ZlswXSAmIDB4RkY7XG5cdFx0XHRcdFx0aWYgKChjb3VudCA9PT0gMCkgfHwgKGNvdW50ID4gcHRyRW5kIC0gcHRyKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdCYWQgc2NhbmxpbmUgZGF0YScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzY2FubGluZUJ1ZmZlcltwdHIrK10gPSBidWZbMV07XG5cdFx0XHRcdFx0aWYgKC0tY291bnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRpZiAocmVhZEJ1Zk9mZnNldChzY2FubGluZUJ1ZmZlciwgcHRyLCBjb3VudCkgPCBjb3VudCkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHJlYWRpbmcgbm9uLXJ1biBkYXRhJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwdHIgKz0gY291bnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyogY29weSBieXRlIGRhdGEgdG8gb3V0cHV0ICovXG5cdFx0Zm9yKGxldCBpID0gMDsgaSA8IHNjYW5saW5lV2lkdGg7IGkrKykge1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAwXSA9IHNjYW5saW5lQnVmZmVyW2ldO1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAxXSA9IHNjYW5saW5lQnVmZmVyW2kgKyBzY2FubGluZVdpZHRoXTtcblx0XHRcdGRhdGFbb2Zmc2V0ICsgMl0gPSBzY2FubGluZUJ1ZmZlcltpICsgMiAqIHNjYW5saW5lV2lkdGhdO1xuXHRcdFx0ZGF0YVtvZmZzZXQgKyAzXSA9IHNjYW5saW5lQnVmZmVyW2kgKyAzICogc2NhbmxpbmVXaWR0aF07XG5cdFx0XHRvZmZzZXQgKz0gNDtcblx0XHR9XG5cblx0XHRudW1TY2FubGluZXMtLTtcblx0fVxuXG59XG5cbi8vIFJldHVybnMgZGF0YSBhcyBmbG9hdHMgYW5kIGZsaXBwZWQgYWxvbmcgWSBieSBkZWZhdWx0XG5mdW5jdGlvbiBwYXJzZUhkcihidWZmZXIpIHtcblx0aWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0YnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblx0fVxuXG5cdGxldCBmaWxlT2Zmc2V0ID0gMDtcblx0Y29uc3QgYnVmZmVyTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcblxuXHRjb25zdCBORVdfTElORSA9IDEwO1xuXG5cdGZ1bmN0aW9uIHJlYWRMaW5lKCkge1xuXHRcdGxldCBidWYgPSAnJztcblx0XHRkbyB7XG5cdFx0XHRjb25zdCBiID0gYnVmZmVyW2ZpbGVPZmZzZXRdO1xuXHRcdFx0aWYgKGIgPT09IE5FV19MSU5FKSB7XG5cdFx0XHRcdCsrZmlsZU9mZnNldDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRidWYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcblx0XHR9IHdoaWxlKCsrZmlsZU9mZnNldCA8IGJ1ZmZlckxlbmd0aCk7XG5cdFx0cmV0dXJuIGJ1Zjtcblx0fVxuXG5cdGxldCB3aWR0aCA9IDA7XG5cdGxldCBoZWlnaHQgPSAwO1xuXHRsZXQgZXhwb3N1cmUgPSAxO1xuXHRjb25zdCBnYW1tYSA9IDE7XG5cdGxldCBybGUgPSBmYWxzZTtcblxuXHRmb3IobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuXHRcdGNvbnN0IGxpbmUgPSByZWFkTGluZSgpO1xuXHRcdGxldCBtYXRjaDtcblx0XHRpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKHJhZGlhbmNlUGF0dGVybikpIHtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaChmb3JtYXRQYXR0ZXJuKSkge1xuXHRcdFx0cmxlID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaChleHBvc3VyZVBhdHRlcm4pKSB7XG5cdFx0XHRleHBvc3VyZSA9IE51bWJlcihtYXRjaFsxXSk7XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goY29tbWVudFBhdHRlcm4pKSB7XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IGxpbmUubWF0Y2god2lkdGhIZWlnaHRQYXR0ZXJuKSkge1xuXHRcdFx0aGVpZ2h0ID0gTnVtYmVyKG1hdGNoWzFdKTtcblx0XHRcdHdpZHRoID0gTnVtYmVyKG1hdGNoWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdGlmICghcmxlKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdGaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWQhJyk7XG5cdH1cblxuXHRjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcblx0Y29uc3Qgc2NhbmxpbmVXaWR0aCA9IHdpZHRoO1xuXHRjb25zdCBudW1TY2FubGluZXMgPSBoZWlnaHQ7XG5cblx0cmVhZFBpeGVsc1Jhd1JMRShidWZmZXIsIGRhdGEsIDAsIGZpbGVPZmZzZXQsIHNjYW5saW5lV2lkdGgsIG51bVNjYW5saW5lcyk7XG5cblx0Ly8gVE9ETzogU2hvdWxkIGJlIEZsb2F0MTZcblx0Y29uc3QgZmxvYXREYXRhID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuXHRmb3IobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGRhdGEubGVuZ3RoOyBvZmZzZXQgKz0gNCkge1xuXHRcdGxldCByID0gZGF0YVtvZmZzZXQgKyAwXSAvIDI1NTtcblx0XHRsZXQgZyA9IGRhdGFbb2Zmc2V0ICsgMV0gLyAyNTU7XG5cdFx0bGV0IGIgPSBkYXRhW29mZnNldCArIDJdIC8gMjU1O1xuXHRcdGNvbnN0IGUgPSBkYXRhW29mZnNldCArIDNdO1xuXHRcdGNvbnN0IGYgPSBNYXRoLnBvdygyLjAsIGUgLSAxMjguMCk7XG5cblx0XHRyICo9IGY7XG5cdFx0ZyAqPSBmO1xuXHRcdGIgKj0gZjtcblxuXHRcdGNvbnN0IGZsb2F0T2Zmc2V0ID0gb2Zmc2V0O1xuXG5cdFx0ZmxvYXREYXRhW2Zsb2F0T2Zmc2V0ICsgMF0gPSByO1xuXHRcdGZsb2F0RGF0YVtmbG9hdE9mZnNldCArIDFdID0gZztcblx0XHRmbG9hdERhdGFbZmxvYXRPZmZzZXQgKyAyXSA9IGI7XG5cdFx0ZmxvYXREYXRhW2Zsb2F0T2Zmc2V0ICsgM10gPSAxLjA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHNoYXBlOiBbd2lkdGgsIGhlaWdodF0sXG5cdFx0ZXhwb3N1cmUsXG5cdFx0Z2FtbWEsXG5cdFx0ZGF0YTogZmxvYXREYXRhXG5cdH07XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2VIZHI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvdXRpbHMvSERSUGFyc2VyLmpzIiwiLy8gQ29sbGFkYVBhcnNlci5qc1xuXG5pbXBvcnQgcGFyc2VyIGZyb20gJ2NvbGxhZGEtcGFyc2VyJztcbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuLi9HZW9tZXRyeSc7XG5cblxuY29uc3QgZ2VuZXJhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uIChtZXNoZXMpIHtcblx0Y29uc3QgY2FjaGVzID0ge307XG5cblx0bWVzaGVzLmZvckVhY2goKG1lc2gpPT4ge1xuXHRcdGNvbnN0IHsgdmVydGljZXMsIG5vcm1hbHMsIGNvb3JkcywgdHJpYW5nbGVzLCBuYW1lIH0gPSBtZXNoLm1lc2g7XG5cdFx0aWYoIWNhY2hlc1tuYW1lXSkge1xuXHRcdFx0Y29uc3QgZ2xHZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpXG5cdFx0XHRcdC5idWZmZXJGbGF0dGVuRGF0YSh2ZXJ0aWNlcywgJ2FWZXJ0ZXhQb3NpdGlvbicsIDMpXG5cdFx0XHRcdC5idWZmZXJGbGF0dGVuRGF0YShjb29yZHMsICdhVGV4dHVyZUNvb3JkJywgMilcblx0XHRcdFx0LmJ1ZmZlckZsYXR0ZW5EYXRhKG5vcm1hbHMsICdhTm9ybWFsJywgMylcblx0XHRcdFx0LmJ1ZmZlckluZGV4KHRyaWFuZ2xlcyk7XG5cblx0XHRcdGNhY2hlc1tuYW1lXSA9IGdsR2VvbWV0cnk7XG5cdFx0fVxuXG5cdFx0bWVzaC5nbEdlb21ldHJ5ID0gY2FjaGVzW25hbWVdO1xuXHR9KTtcbn07XG5cbmNvbnN0IHBhcnNlID0gZnVuY3Rpb24gKG1EYXRhKSB7XG5cdGNvbnN0IG1lc2hlcyA9IHBhcnNlci5wYXJzZShtRGF0YSk7XG5cdGdlbmVyYXRlR2VvbWV0cnkobWVzaGVzKTtcblxuXHRyZXR1cm4gbWVzaGVzO1xufTtcblxuY29uc3QgbG9hZCA9IGZ1bmN0aW9uIChtUGF0aCwgbUNhbGxiYWNrKSB7XG5cdHBhcnNlci5sb2FkKG1QYXRoLCAobWVzaGVzKT0+IHtcblx0XHRnZW5lcmF0ZUdlb21ldHJ5KG1lc2hlcyk7XG5cdFx0bUNhbGxiYWNrKG1lc2hlcyk7XG5cdH0pO1xufTtcblxuY29uc3QgQ29sbGFkYVBhcnNlciA9IHtcblx0cGFyc2UsXG5cdGxvYWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQ29sbGFkYVBhcnNlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9sb2FkZXJzL0NvbGxhZGFQYXJzZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfQ29sbGFkYSA9IHJlcXVpcmUoJy4vQ29sbGFkYScpO1xuXG52YXIgX0NvbGxhZGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29sbGFkYSk7XG5cbnZhciBfZ2xNYXRyaXggPSByZXF1aXJlKCdnbC1tYXRyaXgnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gQ29sbGFkYVBhcnNlci5qc1xuXG52YXIgcGFyc2VEYXRhID0gZnVuY3Rpb24gcGFyc2VEYXRhKG1EYXRhKSB7XG5cdHZhciBtYXRlcmlhbHMgPSBtRGF0YS5tYXRlcmlhbHMsXG5cdCAgICBtZXNoZXMgPSBtRGF0YS5tZXNoZXM7XG5cblxuXHR2YXIgZmluYWxNZXNoZXMgPSBbXTtcblx0dmFyIG1lc2hPYmpzID0gW107XG5cdHZhciBhbGxNZXNoZXMgPSBbXTtcblxuXHQvL1x0Z2V0dGluZyBhbGwgbWVzaGVzJyBidWZmZXJzXG5cdGZvciAodmFyIHMgaW4gbWVzaGVzKSB7XG5cdFx0dmFyIG9NZXNoID0gbWVzaGVzW3NdO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IG9NZXNoLnZlcnRpY2VzLFxuXHRcdCAgICBub3JtYWxzID0gb01lc2gubm9ybWFscyxcblx0XHQgICAgY29vcmRzID0gb01lc2guY29vcmRzLFxuXHRcdCAgICB0cmlhbmdsZXMgPSBvTWVzaC50cmlhbmdsZXM7XG5cblx0XHR2YXIgYnVmZmVycyA9IHtcblx0XHRcdHZlcnRpY2VzOiB2ZXJ0aWNlcywgbm9ybWFsczogbm9ybWFscywgY29vcmRzOiBjb29yZHMsIHRyaWFuZ2xlczogdHJpYW5nbGVzXG5cdFx0fTtcblx0XHRhbGxNZXNoZXMucHVzaCh7XG5cdFx0XHRpZDogcyxcblx0XHRcdGJ1ZmZlcnM6IGJ1ZmZlcnNcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldE1hdGVyaWFsKGlkKSB7XG5cdFx0dmFyIG1hdCA9IHZvaWQgMDtcblx0XHRmb3IgKHZhciBfcyBpbiBtYXRlcmlhbHMpIHtcblx0XHRcdGlmIChfcyA9PT0gaWQpIHtcblx0XHRcdFx0bWF0ID0gbWF0ZXJpYWxzW19zXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgb01hdGVyaWFsID0ge307XG5cdFx0aWYgKG1hdC5kaWZmdXNlKSB7XG5cdFx0XHRvTWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gbWF0LmRpZmZ1c2U7XG5cdFx0fVxuXG5cdFx0b01hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IG1hdC5kaWZmdXNlIHx8IFswLCAwLCAwXTtcblx0XHRvTWF0ZXJpYWwuc2hpbmluZXNzID0gbWF0LnNoaW5pbmVzcyB8fCAwO1xuXHRcdGlmIChtYXQudGV4dHVyZXMpIHtcblx0XHRcdGlmIChtYXQudGV4dHVyZXMuZGlmZnVzZSkge1xuXHRcdFx0XHRvTWF0ZXJpYWwuZGlmZnVzZU1hcElEID0gbWF0LnRleHR1cmVzLmRpZmZ1c2UubWFwX2lkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobWF0LnRleHR1cmVzLm5vcm1hbCkge1xuXHRcdFx0XHRvTWF0ZXJpYWwubm9ybWFsTWFwSUQgPSBtYXQudGV4dHVyZXMubm9ybWFsLm1hcF9pZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb01hdGVyaWFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gd2Fsayhub2RlLCBtdHhQYXJlbnQpIHtcblx0XHR2YXIgbSA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdGlmIChub2RlLm1vZGVsKSB7XG5cdFx0XHRfZ2xNYXRyaXgubWF0NC5tdWx0aXBseShtLCBtdHhQYXJlbnQsIG5vZGUubW9kZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfZ2xNYXRyaXgubWF0NC5jb3B5KG0sIG10eFBhcmVudCk7XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0XHR3YWxrKGNoaWxkLCBtKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChub2RlLm1lc2gpIHtcblx0XHRcdHZhciBfb01lc2ggPSB7fTtcblx0XHRcdF9vTWVzaC5tb2RlbE1hdHJpeCA9IG07XG5cdFx0XHRfb01lc2gubWVzaCA9IG1lc2hlc1tub2RlLm1lc2hdO1xuXHRcdFx0X29NZXNoLmlkID0gbm9kZS5pZDtcblx0XHRcdF9vTWVzaC5uYW1lID0gbm9kZS5uYW1lO1xuXHRcdFx0X29NZXNoLm1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwobm9kZS5tYXRlcmlhbCk7XG5cdFx0XHRtZXNoT2Jqcy5wdXNoKF9vTWVzaCk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG10eCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHR3YWxrKG1EYXRhLnJvb3QsIG10eCk7XG5cblx0cmV0dXJuIG1lc2hPYmpzO1xufTtcblxudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UobUZpbGUpIHtcblx0dmFyIG8gPSBfQ29sbGFkYTIuZGVmYXVsdC5wYXJzZShtRmlsZSk7XG5cdHJldHVybiBwYXJzZURhdGEobyk7XG59O1xuXG52YXIgbG9hZCA9IGZ1bmN0aW9uIGxvYWQobVBhdGgsIG1DYWxsQmFjaykge1xuXHRfQ29sbGFkYTIuZGVmYXVsdC5sb2FkKG1QYXRoLCBmdW5jdGlvbiAobURhdGEpIHtcblx0XHRtQ2FsbEJhY2socGFyc2VEYXRhKG1EYXRhKSk7XG5cdH0pO1xufTtcblxudmFyIENvbGxhZGFQYXJzZXIgPSB7XG5cdGxvYWQ6IGxvYWQsXG5cdHBhcnNlOiBwYXJzZVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29sbGFkYVBhcnNlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sbGFkYVBhcnNlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb2xsYWRhLXBhcnNlci9saWIvQ29sbGFkYVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nbE1hdHJpeCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIik7XG5cbnZhciBpc1dvcmtlciA9IGdsb2JhbC5kb2N1bWVudCA9PT0gdW5kZWZpbmVkOyAvLyBDb2xsYWRhLmpzXG5cbnZhciBERUcyUkFEID0gTWF0aC5QSSAqIDIgLyAzNjA7XG5cbi8vZ2xvYmFsIHRlbXBvcmFsIHZhcmlhYmxlc1xudmFyIHRlbXBfbWF0NCA9IG51bGw7XG52YXIgdGVtcF92ZWMyID0gbnVsbDtcbnZhciB0ZW1wX3ZlYzMgPSBudWxsO1xudmFyIHRlbXBfdmVjNCA9IG51bGw7XG52YXIgdGVtcF9xdWF0ID0gbnVsbDtcblxuZnVuY3Rpb24gcmVxdWVzdCh1cmwsIGNhbGxiYWNrKSB7XG5cdHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0cmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlO1xuXHRcdGlmICh0aGlzLnN0YXR1cyAhPSAyMDApIHJldHVybjtcblx0XHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHRoaXMucmVzcG9uc2UpO1xuXHR9O1xuXHRyZXEub3BlbihcImdldFwiLCB1cmwsIHRydWUpO1xuXHRyZXEuc2VuZCgpO1xufVxuXG52YXIgQ29sbGFkYSA9IHtcblxuXHRsaWJzUGF0aDogXCIuL1wiLFxuXHR3b3JrZXJQYXRoOiBcIi4vXCIsXG5cdG5vX2ZsaXA6IHRydWUsXG5cdHVzZV90cmFuc2ZlcmFibGVzOiB0cnVlLCAvL2ZvciB3b3JrZXJzXG5cdG9uZXJyb3I6IG51bGwsXG5cdHZlcmJvc2U6IGZhbHNlLFxuXHRjb25maWc6IHsgZm9yY2VQYXJzZXI6IGZhbHNlIH0sXG5cblx0aW5pdDogZnVuY3Rpb24gaW5pdChjb25maWcpIHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0Zm9yICh2YXIgaSBpbiBjb25maWcpIHtcblx0XHRcdHRoaXNbaV0gPSBjb25maWdbaV07XG5cdFx0fXRoaXMuY29uZmlnID0gY29uZmlnO1xuXG5cdFx0aWYgKGlzV29ya2VyKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpbXBvcnRTY3JpcHRzKHRoaXMubGlic1BhdGggKyBcImdsLW1hdHJpeC1taW4uanNcIiwgdGhpcy5saWJzUGF0aCArIFwidGlueXhtbC5qc1wiKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRDb2xsYWRhLnRocm93RXhjZXB0aW9uKENvbGxhZGEuTElCTUlTU0lOR19FUlJPUik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9pbml0IGdsTWF0cml4XG5cdFx0dGVtcF9tYXQ0ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dGVtcF92ZWMyID0gdmVjMy5jcmVhdGUoKTtcblx0XHR0ZW1wX3ZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuXHRcdHRlbXBfdmVjNCA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dGVtcF9xdWF0ID0gX2dsTWF0cml4LnF1YXQuY3JlYXRlKCk7XG5cblx0XHRpZiAoaXNXb3JrZXIpIGNvbnNvbGUubG9nKFwiQ29sbGFkYSB3b3JrZXIgcmVhZHlcIik7XG5cdH0sXG5cblx0bG9hZDogZnVuY3Rpb24gbG9hZCh1cmwsIGNhbGxiYWNrKSB7XG5cdFx0cmVxdWVzdCh1cmwsIGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0XHRpZiAoIWRhdGEpIGNhbGxiYWNrKG51bGwpO2Vsc2UgY2FsbGJhY2soQ29sbGFkYS5wYXJzZShkYXRhKSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X3htbHJvb3Q6IG51bGwsXG5cdF9ub2Rlc19ieV9pZDogbnVsbCxcblx0X3RyYW5zZmVyYWJsZXM6IG51bGwsXG5cdF9jb250cm9sbGVyc19mb3VuZDogbnVsbCxcblx0X2dlb21ldHJpZXNfZm91bmQ6IG51bGwsXG5cblx0c2FmZVN0cmluZzogZnVuY3Rpb24gc2FmZVN0cmluZyhzdHIpIHtcblx0XHRpZiAoIXN0cikgcmV0dXJuIFwiXCI7XG5cblx0XHRpZiAodGhpcy5jb252ZXJ0SUQpIHJldHVybiB0aGlzLmNvbnZlcnRJRChzdHIpO1xuXG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8gL2csIFwiX1wiKTtcblx0fSxcblxuXHRMSUJNSVNTSU5HX0VSUk9SOiBcIkxpYnJhcmllcyBsb2FkaW5nIGVycm9yLCB3aGVuIHVzaW5nIHdvcmtlcnMgcmVtZW1iZXIgdG8gcGFzcyB0aGUgVVJMIHRvIHRoZSB0aW55eG1sLmpzIGluIHRoZSBvcHRpb25zLmxpYnNQYXRoXCIsXG5cdE5PWE1MUEFSU0VSX0VSUk9SOiBcIlRpbnlYTUwgbm90IGZvdW5kLCB3aGVuIHVzaW5nIHdvcmtlcnMgcmVtZW1iZXIgdG8gcGFzcyB0aGUgVVJMIHRvIHRoZSB0aW55eG1sLmpzIGluIHRoZSBvcHRpb25zLmxpYnNQYXRoIChXb3JrZXJzIGRvIG5vdCBhbGxvdyB0byBhY2Nlc3MgdGhlIG5hdGl2ZSBYTUwgRE9NUGFyc2VyKVwiLFxuXHR0aHJvd0V4Y2VwdGlvbjogZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24obXNnKSB7XG5cdFx0aWYgKGlzV29ya2VyKSBzZWxmLnBvc3RNZXNzYWdlKHsgYWN0aW9uOiBcImV4Y2VwdGlvblwiLCBtc2c6IG1zZyB9KTtlbHNlIGlmIChDb2xsYWRhLm9uZXJyb3IpIENvbGxhZGEub25lcnJvcihtc2cpO1xuXHRcdHRocm93IG1zZztcblx0fSxcblxuXHRnZXRGaWxlbmFtZTogZnVuY3Rpb24gZ2V0RmlsZW5hbWUoZmlsZW5hbWUpIHtcblx0XHR2YXIgcG9zID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCJcXFxcXCIpO1xuXHRcdGlmIChwb3MgIT0gLTEpIGZpbGVuYW1lID0gZmlsZW5hbWUuc3Vic3RyKHBvcyArIDEpO1xuXHRcdC8vc3RyaXAgdW5peCBzbGFzaGVzXG5cdFx0cG9zID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCIvXCIpO1xuXHRcdGlmIChwb3MgIT0gLTEpIGZpbGVuYW1lID0gZmlsZW5hbWUuc3Vic3RyKHBvcyArIDEpO1xuXHRcdHJldHVybiBmaWxlbmFtZTtcblx0fSxcblxuXHRsYXN0X25hbWU6IDAsXG5cblx0Z2VuZXJhdGVOYW1lOiBmdW5jdGlvbiBnZW5lcmF0ZU5hbWUodikge1xuXHRcdHYgPSB2IHx8IFwibmFtZV9cIjtcblx0XHR2YXIgbmFtZSA9IHYgKyB0aGlzLmxhc3RfbmFtZTtcblx0XHR0aGlzLmxhc3RfbmFtZSsrO1xuXHRcdHJldHVybiBuYW1lO1xuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiBwYXJzZShkYXRhLCBvcHRpb25zLCBmaWxlbmFtZSkge1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGZpbGVuYW1lID0gZmlsZW5hbWUgfHwgXCJfZGFlX1wiICsgRGF0ZS5ub3coKSArIFwiLmRhZVwiO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyhcIlBhcnNpbmcgY29sbGFkYVwiKTtcblx0XHR2YXIgZmxpcCA9IGZhbHNlO1xuXG5cdFx0dmFyIHhtbHBhcnNlciA9IG51bGw7XG5cdFx0dmFyIHJvb3QgPSBudWxsO1xuXHRcdHRoaXMuX3RyYW5zZmVyYWJsZXMgPSBbXTtcblxuXHRcdGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUubG9nKFwiIC0gWE1MIHBhcnNpbmcuLi5cIik7XG5cblx0XHRpZiAoZ2xvYmFsW1wiRE9NUGFyc2VyXCJdICYmICF0aGlzLmNvbmZpZy5mb3JjZVBhcnNlcikge1xuXHRcdFx0eG1scGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXHRcdFx0cm9vdCA9IHhtbHBhcnNlci5wYXJzZUZyb21TdHJpbmcoZGF0YSwgXCJ0ZXh0L3htbFwiKTtcblx0XHRcdGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUubG9nKFwiIC0gWE1MIHBhcnNlZFwiKTtcblx0XHR9IGVsc2UgLy9VU0lORyBKUyBYTUwgUEFSU0VSIElNUExFTUVOVEFUSU9OIChtdWNoIHNsb3dlcilcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFnbG9iYWxbXCJET01JbXBsZW1lbnRhdGlvblwiXSkgcmV0dXJuIENvbGxhZGEudGhyb3dFeGNlcHRpb24oQ29sbGFkYS5OT1hNTFBBUlNFUl9FUlJPUik7XG5cdFx0XHRcdC8vdXNlIHRpbnl4bWxwYXJzZXJcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR4bWxwYXJzZXIgPSBuZXcgRE9NSW1wbGVtZW50YXRpb24oKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIENvbGxhZGEudGhyb3dFeGNlcHRpb24oQ29sbGFkYS5OT1hNTFBBUlNFUl9FUlJPUik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyb290ID0geG1scGFyc2VyLmxvYWRYTUwoZGF0YSk7XG5cdFx0XHRcdGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUubG9nKFwiIC0gWE1MIHBhcnNlZFwiKTtcblxuXHRcdFx0XHQvL2ZvciBldmVyeSBub2RlLi4uXG5cdFx0XHRcdHZhciBieV9pZHMgPSByb290Ll9ub2Rlc19ieV9pZCA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJvb3QuYWxsLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRcdHZhciBub2RlID0gcm9vdC5hbGxbaV07XG5cdFx0XHRcdFx0YnlfaWRzW25vZGUuaWRdID0gbm9kZTtcblx0XHRcdFx0XHRpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJzaWRcIikpIGJ5X2lkc1tub2RlLmdldEF0dHJpYnV0ZShcInNpZFwiKV0gPSBub2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCF0aGlzLmV4dHJhX2Z1bmN0aW9ucykge1xuXHRcdFx0XHRcdHRoaXMuZXh0cmFfZnVuY3Rpb25zID0gdHJ1ZTtcblx0XHRcdFx0XHQvL3RoZXNlIG1ldGhvZHMgYXJlIG1pc3Npbmcgc28gaGVyZSBpcyBhIGxvdXN5IGltcGxlbWVudGF0aW9uXG5cdFx0XHRcdFx0RE9NRG9jdW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBET01FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGFncyA9IHNlbGVjdG9yLnNwbGl0KFwiIFwiKTtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50X2VsZW1lbnQgPSB0aGlzO1xuXG5cdFx0XHRcdFx0XHR3aGlsZSAodGFncy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0YWdzLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHRcdHZhciB0b2tlbnMgPSBjdXJyZW50LnNwbGl0KFwiI1wiKTtcblx0XHRcdFx0XHRcdFx0dmFyIHRhZ25hbWUgPSB0b2tlbnNbMF07XG5cdFx0XHRcdFx0XHRcdHZhciBpZCA9IHRva2Vuc1sxXTtcblx0XHRcdFx0XHRcdFx0dmFyIGVsZW1lbnRzID0gdGFnbmFtZSA/IGN1cnJlbnRfZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWduYW1lKSA6IGN1cnJlbnRfZWxlbWVudC5jaGlsZE5vZGVzO1xuXHRcdFx0XHRcdFx0XHRpZiAoIWlkKSAvL25vIGlkIGZpbHRlclxuXHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0YWdzLmxlbmd0aCA9PSAwKSByZXR1cm4gZWxlbWVudHMuaXRlbSgwKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfZWxlbWVudCA9IGVsZW1lbnRzLml0ZW0oMCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly9oYXMgaWQ/IGNoZWNrIGZvciBhbGwgdG8gc2VlIGlmIG9uZSBtYXRjaGVzIHRoZSBpZFxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnRzLml0ZW0oaSkuZ2V0QXR0cmlidXRlKFwiaWRcIikgPT0gaWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0YWdzLmxlbmd0aCA9PSAwKSByZXR1cm4gZWxlbWVudHMuaXRlbShpKTtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfZWxlbWVudCA9IGVsZW1lbnRzLml0ZW0oaSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRET01Eb2N1bWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IERPTUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcblx0XHRcdFx0XHRcdHZhciB0YWdzID0gc2VsZWN0b3Iuc3BsaXQoXCIgXCIpO1xuXHRcdFx0XHRcdFx0aWYgKHRhZ3MubGVuZ3RoID09IDEpIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKTtcblxuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRfZWxlbWVudCA9IHRoaXM7XG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRcdFx0XHRcdGlubmVyKHRoaXMsIHRhZ3MpO1xuXG5cdFx0XHRcdFx0XHRmdW5jdGlvbiBpbm5lcihyb290LCB0YWdzKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghdGFncykgcmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50ID0gdGFncy5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0XHR2YXIgZWxlbWVudHMgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKGN1cnJlbnQpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFncy5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKGVsZW1lbnRzLml0ZW0oaSkpO1xuXHRcdFx0XHRcdFx0XHRcdH1yZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5uZXIoZWxlbWVudHMuaXRlbShpKSwgdGFncy5jb25jYXQoKSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGxpc3QgPSBuZXcgRE9NTm9kZUxpc3QodGhpcy5kb2N1bWVudEVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0bGlzdC5fbm9kZXMgPSByZXN1bHQ7XG5cdFx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoRE9NRWxlbWVudC5wcm90b3R5cGUsIFwidGV4dENvbnRlbnRcIiwge1xuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBub2RlcyA9IHRoaXMuZ2V0Q2hpbGROb2RlcygpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZXMuaXRlbSgwKS50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHNldDogZnVuY3Rpb24gc2V0KCkge31cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdHRoaXMuX3htbHJvb3QgPSByb290O1xuXHRcdHZhciB4bWxjb2xsYWRhID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwiQ09MTEFEQVwiKTtcblx0XHRpZiAoeG1sY29sbGFkYSkge1xuXHRcdFx0dGhpcy5fY3VycmVudF9EQUVfdmVyc2lvbiA9IHhtbGNvbGxhZGEuZ2V0QXR0cmlidXRlKFwidmVyc2lvblwiKTtcblx0XHRcdGNvbnNvbGUubG9nKFwiREFFIFZlcnNpb246XCIgKyB0aGlzLl9jdXJyZW50X0RBRV92ZXJzaW9uKTtcblx0XHR9XG5cblx0XHQvL3ZhciB4bWx2aXN1YWxfc2NlbmUgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCJ2aXN1YWxfc2NlbmVcIik7XG5cdFx0dmFyIHhtbHZpc3VhbF9zY2VuZSA9IHJvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ2aXN1YWxfc2NlbmVcIikuaXRlbSgwKTtcblx0XHRpZiAoIXhtbHZpc3VhbF9zY2VuZSkgdGhyb3cgXCJ2aXN1YWxfc2NlbmUgWE1MIG5vZGUgbm90IGZvdW5kIGluIERBRVwiO1xuXG5cdFx0Ly9oYWNrIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggYm9uZXMgd2l0aCBzcGFjZXMgaW4gbmFtZXNcblx0XHR0aGlzLl9ub2Rlc19ieV9pZCA9IHt9OyAvL2NsZWFyXG5cdFx0dGhpcy5fY29udHJvbGxlcnNfZm91bmQgPSB7fTsgLy93ZSBuZWVkIHRvIGNoZWNrIHdoYXQgY29udHJvbGxlcnMgaGFkIGJlZW4gZm91bmQsIGluIGNhc2Ugd2UgbWlzcyBvbmUgYXQgdGhlIGVuZFxuXHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmQgPSB7fTtcblxuXHRcdC8vQ3JlYXRlIGEgc2NlbmUgdHJlZVxuXHRcdHZhciBzY2VuZSA9IHtcblx0XHRcdG9iamVjdF90eXBlOiBcIlNjZW5lVHJlZVwiLFxuXHRcdFx0bGlnaHQ6IG51bGwsXG5cdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0bWVzaGVzOiB7fSxcblx0XHRcdHJlc291cmNlczoge30sIC8vdXNlZCB0byBzdG9yZSBhbmltYXRpb24gdHJhY2tzXG5cdFx0XHRyb290OiB7IGNoaWxkcmVuOiBbXSB9LFxuXHRcdFx0ZXh0ZXJuYWxfZmlsZXM6IHt9IC8vc3RvcmUgaW5mbyBhYm91dCBleHRlcm5hbCBmaWxlcyBtZW50aW9uZWQgaW4gdGhpcyBcblx0XHR9O1xuXG5cdFx0Ly9zY2VuZSBtZXRhZGF0YSAobGlrZSBhdXRob3IsIHRvb2wsIHVwIHZlY3RvciwgZGF0ZXMsIGV0Yylcblx0XHR2YXIgeG1sYXNzZXQgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYXNzZXRcIilbMF07XG5cdFx0aWYgKHhtbGFzc2V0KSBzY2VuZS5tZXRhZGF0YSA9IHRoaXMucmVhZEFzc2V0KHhtbGFzc2V0KTtcblxuXHRcdC8vcGFyc2Ugbm9kZXMgdHJlZSB0byBleHRyYWN0IG5hbWVzIGFuZCBpZXJhcmNoeSBvbmx5XG5cdFx0dmFyIHhtbG5vZGVzID0geG1sdmlzdWFsX3NjZW5lLmNoaWxkTm9kZXM7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHhtbG5vZGVzLml0ZW0oaSkubG9jYWxOYW1lICE9IFwibm9kZVwiKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLnJlYWROb2RlVHJlZSh4bWxub2Rlcy5pdGVtKGkpLCBzY2VuZSwgMCwgZmxpcCk7XG5cdFx0XHRpZiAobm9kZSkgc2NlbmUucm9vdC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuXHRcdH1cblxuXHRcdC8vcGFyc2Ugbm9kZXMgY29udGVudCAodHdvIHN0ZXBzIHNvIHdlIGhhdmUgZmlyc3QgYWxsIHRoZSBzY2VuZSB0cmVlIGluZm8pXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxub2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHhtbG5vZGVzLml0ZW0oaSkubG9jYWxOYW1lICE9IFwibm9kZVwiKSBjb250aW51ZTtcblx0XHRcdHRoaXMucmVhZE5vZGVJbmZvKHhtbG5vZGVzLml0ZW0oaSksIHNjZW5lLCAwLCBmbGlwKTtcblx0XHR9XG5cblx0XHQvL3JlYWQgcmVtYWluaW5nIGNvbnRyb2xsZXJzIChpbiBzb21lIGNhc2VzIHNvbWUgY29udHJvbGxlcnMgYXJlIG5vdCBsaW5rZWQgZnJvbSB0aGUgbm9kZXMgb3IgdGhlIGdlb21ldHJpZXMpXG5cdFx0dGhpcy5yZWFkTGlicmFyeUNvbnRyb2xsZXJzKHNjZW5lKTtcblxuXHRcdC8vcmVhZCBhbmltYXRpb25zXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB0aGlzLnJlYWRBbmltYXRpb25zKHJvb3QsIHNjZW5lKTtcblx0XHRpZiAoYW5pbWF0aW9ucykge1xuXHRcdFx0dmFyIGFuaW1hdGlvbnNfbmFtZSA9IFwiI2FuaW1hdGlvbnNfXCIgKyBmaWxlbmFtZS5zdWJzdHIoMCwgZmlsZW5hbWUuaW5kZXhPZihcIi5cIikpO1xuXHRcdFx0c2NlbmUucmVzb3VyY2VzW2FuaW1hdGlvbnNfbmFtZV0gPSBhbmltYXRpb25zO1xuXHRcdFx0c2NlbmUucm9vdC5hbmltYXRpb25zID0gYW5pbWF0aW9uc19uYW1lO1xuXHRcdH1cblxuXHRcdC8vcmVhZCBleHRlcm5hbCBmaWxlcyAoaW1hZ2VzKVxuXHRcdHNjZW5lLmltYWdlcyA9IHRoaXMucmVhZEltYWdlcyhyb290KTtcblxuXHRcdC8vY2xlYXIgbWVtb3J5XG5cdFx0dGhpcy5fbm9kZXNfYnlfaWQgPSB7fTtcblx0XHR0aGlzLl9jb250cm9sbGVyc19mb3VuZCA9IHt9O1xuXHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmQgPSB7fTtcblx0XHR0aGlzLl94bWxyb290ID0gbnVsbDtcblxuXHRcdC8vY29uc29sZS5sb2coc2NlbmUpO1xuXHRcdHJldHVybiBzY2VuZTtcblx0fSxcblxuXHQvKiBDb2xsZWN0IG5vZGUgaWRzLCBpbiBjYXNlIHRoZXJlIGlzIGJvbmVzICh3aXRoIHNwYWNlcyBpbiBuYW1lKSBJIG5lZWQgdG8ga25vdyB0aGUgbm9kZW5hbWVzIGluIGFkdmFuY2UgKi9cblx0LypcbiByZWFkQWxsTm9kZU5hbWVzOiBmdW5jdGlvbih4bWxub2RlKVxuIHtcbiBcdHZhciBub2RlX2lkID0gdGhpcy5zYWZlU3RyaW5nKCB4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpICk7XG4gXHRpZihub2RlX2lkKVxuIFx0XHR0aGlzLl9ub2Rlc19ieV9pZFtub2RlX2lkXSA9IHRydWU7IC8vbm9kZSBmb3VuZFxuIFx0Ly9ub2RlcyBzZWVtIHRvIGhhdmUgdG8gcG9zc2libGUgaWRzLCBpZCBhbmQgc2lkLCBJIGd1ZXNzIG9uZSBpcyB1bmlxdWUsIHRoZSBvdGhlciB1c2VyLWRlZmluZWRcbiBcdHZhciBub2RlX3NpZCA9IHRoaXMuc2FmZVN0cmluZyggeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJzaWRcIikgKTtcbiBcdGlmKG5vZGVfc2lkKVxuIFx0XHR0aGlzLl9ub2Rlc19ieV9pZFtub2RlX3NpZF0gPSB0cnVlOyAvL25vZGUgZm91bmRcbiBcbiBcdGZvciggdmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrIClcbiBcdHtcbiBcdFx0dmFyIHhtbGNoaWxkID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG4gXHRcdFx0Ly9jaGlsZHJlblxuIFx0XHRpZih4bWxjaGlsZC5sb2NhbE5hbWUgIT0gXCJub2RlXCIpXG4gXHRcdFx0Y29udGludWU7XG4gXHRcdHRoaXMucmVhZEFsbE5vZGVOYW1lcyh4bWxjaGlsZCk7XG4gXHR9XG4gfSxcbiBcdCovXG5cblx0cmVhZEFzc2V0OiBmdW5jdGlvbiByZWFkQXNzZXQoeG1sYXNzZXQpIHtcblx0XHR2YXIgbWV0YWRhdGEgPSB7fTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sYXNzZXQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbGNoaWxkID0geG1sYXNzZXQuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKHhtbGNoaWxkLm5vZGVUeXBlICE9IDEpIC8vbm90IHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHN3aXRjaCAoeG1sY2hpbGQubG9jYWxOYW1lKSB7XG5cdFx0XHRcdGNhc2UgXCJjb250cmlidXRvclwiOlxuXHRcdFx0XHRcdHZhciB0b29sID0geG1sY2hpbGQucXVlcnlTZWxlY3RvcihcImF1dGhvcmluZ190b29sXCIpO1xuXHRcdFx0XHRcdGlmICh0b29sKSBtZXRhZGF0YVtcImF1dGhvcmluZ190b29sXCJdID0gdG9vbC50ZXh0Q29udGV4dDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInVuaXRcIjpcblx0XHRcdFx0XHRtZXRhZGF0YVtcInVuaXRcIl0gPSB4bWxjaGlsZC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpO2JyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdG1ldGFkYXRhW3htbGNoaWxkLmxvY2FsTmFtZV0gPSB4bWxjaGlsZC50ZXh0Q29udGVudDticmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWV0YWRhdGE7XG5cdH0sXG5cblx0cmVhZE5vZGVUcmVlOiBmdW5jdGlvbiByZWFkTm9kZVRyZWUoeG1sbm9kZSwgc2NlbmUsIGxldmVsLCBmbGlwKSB7XG5cdFx0dmFyIG5vZGVfaWQgPSB0aGlzLnNhZmVTdHJpbmcoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0dmFyIG5vZGVfc2lkID0gdGhpcy5zYWZlU3RyaW5nKHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwic2lkXCIpKTtcblxuXHRcdGlmICghbm9kZV9pZCAmJiAhbm9kZV9zaWQpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9oZXJlIHdlIGNyZWF0ZSB0aGUgbm9kZVxuXHRcdHZhciBub2RlID0ge1xuXHRcdFx0aWQ6IG5vZGVfc2lkIHx8IG5vZGVfaWQsXG5cdFx0XHRjaGlsZHJlbjogW10sXG5cdFx0XHRfZGVwdGg6IGxldmVsXG5cdFx0fTtcblxuXHRcdHZhciBub2RlX3R5cGUgPSB4bWxub2RlLmdldEF0dHJpYnV0ZShcInR5cGVcIik7XG5cdFx0aWYgKG5vZGVfdHlwZSkgbm9kZS50eXBlID0gbm9kZV90eXBlO1xuXG5cdFx0dmFyIG5vZGVfbmFtZSA9IHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcblx0XHRpZiAobm9kZV9uYW1lKSBub2RlLm5hbWUgPSBub2RlX25hbWU7XG5cdFx0dGhpcy5fbm9kZXNfYnlfaWRbbm9kZS5pZF0gPSBub2RlO1xuXHRcdGlmIChub2RlX2lkKSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlX2lkXSA9IG5vZGU7XG5cdFx0aWYgKG5vZGVfc2lkKSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlX3NpZF0gPSBub2RlO1xuXG5cdFx0Ly90cmFuc2Zvcm1cblx0XHRub2RlLm1vZGVsID0gdGhpcy5yZWFkVHJhbnNmb3JtKHhtbG5vZGUsIGxldmVsLCBmbGlwKTtcblxuXHRcdC8vbm9kZSBlbGVtZW50c1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sY2hpbGQgPSB4bWxub2RlLmNoaWxkTm9kZXMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxjaGlsZC5ub2RlVHlwZSAhPSAxKSAvL25vdCB0YWdcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vY2hpbGRyZW5cblx0XHRcdGlmICh4bWxjaGlsZC5sb2NhbE5hbWUgPT0gXCJub2RlXCIpIHtcblx0XHRcdFx0dmFyIGNoaWxkX25vZGUgPSB0aGlzLnJlYWROb2RlVHJlZSh4bWxjaGlsZCwgc2NlbmUsIGxldmVsICsgMSwgZmxpcCk7XG5cdFx0XHRcdGlmIChjaGlsZF9ub2RlKSBub2RlLmNoaWxkcmVuLnB1c2goY2hpbGRfbm9kZSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXG5cdHJlYWROb2RlSW5mbzogZnVuY3Rpb24gcmVhZE5vZGVJbmZvKHhtbG5vZGUsIHNjZW5lLCBsZXZlbCwgZmxpcCwgcGFyZW50KSB7XG5cdFx0dmFyIG5vZGVfaWQgPSB0aGlzLnNhZmVTdHJpbmcoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0dmFyIG5vZGVfc2lkID0gdGhpcy5zYWZlU3RyaW5nKHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwic2lkXCIpKTtcblxuXHRcdC8qXG4gIGlmKCFub2RlX2lkICYmICFub2RlX3NpZClcbiAge1xuICBcdGNvbnNvbGUud2FybihcIkNvbGxhZGE6IG5vZGUgd2l0aG91dCBpZCwgY3JlYXRpbmcgYSByYW5kb20gb25lXCIpO1xuICBcdG5vZGVfaWQgPSB0aGlzLmdlbmVyYXRlTmFtZShcIm5vZGVfXCIpO1xuICBcdHJldHVybiBudWxsO1xuICB9XG4gICovXG5cblx0XHR2YXIgbm9kZTtcblx0XHRpZiAoIW5vZGVfaWQgJiYgIW5vZGVfc2lkKSB7XG5cdFx0XHQvL2lmIHRoZXJlIGlzIG5vIGlkLCB0aGVuIGVpdGhlciBhbGwgb2YgdGhpcyBub2RlJ3MgcHJvcGVydGllcyBcblx0XHRcdC8vc2hvdWxkIGJlIGFzc2lnbmVkIGRpcmVjdGx5IHRvIGl0cyBwYXJlbnQgbm9kZSwgb3IgdGhlIG5vZGUgZG9lc24ndFxuXHRcdFx0Ly9oYXZlIGEgcGFyZW50IG5vZGUsIGluIHdoaWNoIGNhc2UgaXRzIGEgbGlnaHQgb3Igc29tZXRoaW5nLiBcblx0XHRcdC8vU28gd2UgZ2V0IHRoZSBwYXJlbnQgYnkgaXRzIGlkLCBhbmQgaWYgdGhlcmUgaXMgbm8gcGFyZW50LCB3ZSByZXR1cm4gbnVsbFxuXHRcdFx0aWYgKHBhcmVudCkgbm9kZSA9IHRoaXMuX25vZGVzX2J5X2lkW3BhcmVudC5pZCB8fCBwYXJlbnQuc2lkXTtlbHNlIHJldHVybiBudWxsO1xuXHRcdH0gZWxzZSBub2RlID0gdGhpcy5fbm9kZXNfYnlfaWRbbm9kZV9pZCB8fCBub2RlX3NpZF07XG5cblx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdGNvbnNvbGUud2FybihcIkNvbGxhZGE6IE5vZGUgbm90IGZvdW5kIGJ5IGlkOiBcIiArIChub2RlX2lkIHx8IG5vZGVfc2lkKSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL25vZGUgZWxlbWVudHNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbGNoaWxkID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cdFx0XHRpZiAoeG1sY2hpbGQubm9kZVR5cGUgIT0gMSkgLy9ub3QgdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvL2NoaWxkcmVuXG5cdFx0XHRpZiAoeG1sY2hpbGQubG9jYWxOYW1lID09IFwibm9kZVwiKSB7XG5cdFx0XHRcdC8vcGFzcyBwYXJlbnQgbm9kZSBpbiBjYXNlIGNoaWxkIG5vZGUgaXMgYSAnZGVhZCcgbm9kZSAoaGFzIG5vIGlkIG9yIHNpZClcblx0XHRcdFx0dGhpcy5yZWFkTm9kZUluZm8oeG1sY2hpbGQsIHNjZW5lLCBsZXZlbCArIDEsIGZsaXAsIHhtbG5vZGUpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9nZW9tZXRyeVxuXHRcdFx0aWYgKHhtbGNoaWxkLmxvY2FsTmFtZSA9PSBcImluc3RhbmNlX2dlb21ldHJ5XCIpIHtcblx0XHRcdFx0dmFyIHVybCA9IHhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKTtcblx0XHRcdFx0dmFyIG1lc2hfaWQgPSB1cmwudG9TdHJpbmcoKS5zdWJzdHIoMSk7XG5cdFx0XHRcdG5vZGUubWVzaCA9IG1lc2hfaWQ7XG5cblx0XHRcdFx0aWYgKCFzY2VuZS5tZXNoZXNbdXJsXSkge1xuXHRcdFx0XHRcdHZhciBtZXNoX2RhdGEgPSB0aGlzLnJlYWRHZW9tZXRyeSh1cmwsIGZsaXApO1xuXHRcdFx0XHRcdGlmIChtZXNoX2RhdGEpIHtcblx0XHRcdFx0XHRcdG1lc2hfZGF0YS5uYW1lID0gbWVzaF9pZDtcblx0XHRcdFx0XHRcdHNjZW5lLm1lc2hlc1ttZXNoX2lkXSA9IG1lc2hfZGF0YTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL2JpbmRlZCBtYXRlcmlhbFxuXHRcdFx0XHR2YXIgeG1sbWF0ZXJpYWxzID0geG1sY2hpbGQucXVlcnlTZWxlY3RvckFsbChcImluc3RhbmNlX21hdGVyaWFsXCIpO1xuXHRcdFx0XHRpZiAoeG1sbWF0ZXJpYWxzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaU1hdCA9IDA7IGlNYXQgPCB4bWxtYXRlcmlhbHMubGVuZ3RoOyArK2lNYXQpIHtcblx0XHRcdFx0XHRcdHZhciB4bWxtYXRlcmlhbCA9IHhtbG1hdGVyaWFscy5pdGVtKGlNYXQpO1xuXHRcdFx0XHRcdFx0aWYgKCF4bWxtYXRlcmlhbCkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJpbnN0YW5jZV9tYXRlcmlhbCBub3QgZm91bmQ6IFwiICsgaSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgbWF0bmFtZSA9IHhtbG1hdGVyaWFsLmdldEF0dHJpYnV0ZShcInRhcmdldFwiKS50b1N0cmluZygpLnN1YnN0cigxKTtcblx0XHRcdFx0XHRcdC8vbWF0bmFtZSA9IG1hdG5hbWUucmVwbGFjZSgvIC9nLFwiX1wiKTsgLy9uYW1lcyBjYW5ub3QgaGF2ZSBzcGFjZXNcblx0XHRcdFx0XHRcdGlmICghc2NlbmUubWF0ZXJpYWxzW21hdG5hbWVdKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5yZWFkTWF0ZXJpYWwobWF0bmFtZSk7XG5cdFx0XHRcdFx0XHRcdGlmIChtYXRlcmlhbCkge1xuXHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmlkID0gbWF0bmFtZTtcblx0XHRcdFx0XHRcdFx0XHRzY2VuZS5tYXRlcmlhbHNbbWF0ZXJpYWwuaWRdID0gbWF0ZXJpYWw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChpTWF0ID09IDApIG5vZGUubWF0ZXJpYWwgPSBtYXRuYW1lO2Vsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoIW5vZGUubWF0ZXJpYWxzKSBub2RlLm1hdGVyaWFscyA9IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlLm1hdGVyaWFscy5wdXNoKG1hdG5hbWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL3RoaXMgbm9kZSBoYXMgYSBjb250cm9sbGVyOiBza2lubmluZywgbW9ycGggdGFyZ2V0cyBvciBldmVuIG11bHRpbWF0ZXJpYWwgYXJlIGNvbnRyb2xsZXJzXG5cdFx0XHQvL3dhcm5pbmc6IEkgZGV0ZWN0ZWQgdGhhdCBzb21lIG5vZGVzIGNvdWxkIGhhdmUgYSBjb250cm9sbGVyIGJ1dCB0aGV5IGFyZSBub3QgcmVmZXJlbmNlZCBoZXJlLiAgPz9cblx0XHRcdGlmICh4bWxjaGlsZC5sb2NhbE5hbWUgPT0gXCJpbnN0YW5jZV9jb250cm9sbGVyXCIpIHtcblx0XHRcdFx0dmFyIHVybCA9IHhtbGNoaWxkLmdldEF0dHJpYnV0ZShcInVybFwiKTtcblx0XHRcdFx0dmFyIHhtbGNvbnRyb2xsZXIgPSB0aGlzLl94bWxyb290LnF1ZXJ5U2VsZWN0b3IoXCJjb250cm9sbGVyXCIgKyB1cmwpO1xuXG5cdFx0XHRcdGlmICh4bWxjb250cm9sbGVyKSB7XG5cblx0XHRcdFx0XHR2YXIgbWVzaF9kYXRhID0gdGhpcy5yZWFkQ29udHJvbGxlcih4bWxjb250cm9sbGVyLCBmbGlwLCBzY2VuZSk7XG5cblx0XHRcdFx0XHQvL2JpbmRlZCBtYXRlcmlhbHNcblx0XHRcdFx0XHR2YXIgeG1sYmluZF9tYXRlcmlhbCA9IHhtbGNoaWxkLnF1ZXJ5U2VsZWN0b3IoXCJiaW5kX21hdGVyaWFsXCIpO1xuXHRcdFx0XHRcdGlmICh4bWxiaW5kX21hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHQvL3JlbW92ZWQgcmVhZEJpbmRNYXRlcmlhbHMgdXAgaGVyZSBmb3IgY29uc2lzdGVuY3lcblx0XHRcdFx0XHRcdHZhciB4bWx0ZWNobmlxdWVzID0geG1sYmluZF9tYXRlcmlhbC5xdWVyeVNlbGVjdG9yQWxsKFwidGVjaG5pcXVlX2NvbW1vblwiKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGlUZWMgPSAwOyBpVGVjIDwgeG1sdGVjaG5pcXVlcy5sZW5ndGg7IGlUZWMrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgeG1sdGVjaG5pcXVlID0geG1sdGVjaG5pcXVlcy5pdGVtKGlUZWMpO1xuXHRcdFx0XHRcdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWxzID0geG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnN0YW5jZV9tYXRlcmlhbFwiKTtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaU1hdCA9IDA7IGlNYXQgPCB4bWxpbnN0YW5jZV9tYXRlcmlhbHMubGVuZ3RoOyBpTWF0KyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWwgPSB4bWxpbnN0YW5jZV9tYXRlcmlhbHMuaXRlbShpTWF0KTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIXhtbGluc3RhbmNlX21hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJpbnN0YW5jZV9tYXRlcmlhbCBmb3IgY29udHJvbGxlciBub3QgZm91bmQ6IFwiICsgeG1saW5zdGFuY2VfbWF0ZXJpYWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHZhciBtYXRuYW1lID0geG1saW5zdGFuY2VfbWF0ZXJpYWwuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpLnRvU3RyaW5nKCkuc3Vic3RyKDEpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghc2NlbmUubWF0ZXJpYWxzW21hdG5hbWVdKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IHRoaXMucmVhZE1hdGVyaWFsKG1hdG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG1hdGVyaWFsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1hdGVyaWFsLmlkID0gbWF0bmFtZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2NlbmUubWF0ZXJpYWxzW21hdGVyaWFsLmlkXSA9IG1hdGVyaWFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaU1hdCA9PSAwKSBub2RlLm1hdGVyaWFsID0gbWF0bmFtZTtlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghbm9kZS5tYXRlcmlhbHMpIG5vZGUubWF0ZXJpYWxzID0gW107XG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLm1hdGVyaWFscy5wdXNoKG1hdG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChtZXNoX2RhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBtZXNoID0gbWVzaF9kYXRhO1xuXHRcdFx0XHRcdFx0aWYgKG1lc2hfZGF0YS50eXBlID09IFwibW9ycGhcIikge1xuXHRcdFx0XHRcdFx0XHRtZXNoID0gbWVzaF9kYXRhLm1lc2g7XG5cdFx0XHRcdFx0XHRcdG5vZGUubW9ycGhfdGFyZ2V0cyA9IG1lc2hfZGF0YS5tb3JwaF90YXJnZXRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtZXNoLm5hbWUgPSB1cmwudG9TdHJpbmcoKTtcblx0XHRcdFx0XHRcdG5vZGUubWVzaCA9IHVybC50b1N0cmluZygpO1xuXHRcdFx0XHRcdFx0c2NlbmUubWVzaGVzW3VybF0gPSBtZXNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvL2xpZ2h0XG5cdFx0XHRpZiAoeG1sY2hpbGQubG9jYWxOYW1lID09IFwiaW5zdGFuY2VfbGlnaHRcIikge1xuXHRcdFx0XHR2YXIgdXJsID0geG1sY2hpbGQuZ2V0QXR0cmlidXRlKFwidXJsXCIpO1xuXHRcdFx0XHR0aGlzLnJlYWRMaWdodChub2RlLCB1cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL2NhbWVyYVxuXHRcdFx0aWYgKHhtbGNoaWxkLmxvY2FsTmFtZSA9PSBcImluc3RhbmNlX2NhbWVyYVwiKSB7XG5cdFx0XHRcdHZhciB1cmwgPSB4bWxjaGlsZC5nZXRBdHRyaWJ1dGUoXCJ1cmxcIik7XG5cdFx0XHRcdHRoaXMucmVhZENhbWVyYShub2RlLCB1cmwpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL290aGVyIHBvc3NpYmxlIHRhZ3M/XG5cdFx0fVxuXHR9LFxuXG5cdC8vaWYgeW91IHdhbnQgdG8gcmVuYW1lIHNvbWUgbWF0ZXJpYWwgbmFtZXNcblx0bWF0ZXJpYWxfdHJhbnNsYXRlX3RhYmxlOiB7XG5cdFx0LypcbiAgdHJhbnNwYXJlbmN5OiBcIm9wYWNpdHlcIixcbiAgcmVmbGVjdGl2aXR5OiBcInJlZmxlY3Rpb25fZmFjdG9yXCIsXG4gIHNwZWN1bGFyOiBcInNwZWN1bGFyX2ZhY3RvclwiLFxuICBzaGluaW5lc3M6IFwic3BlY3VsYXJfZ2xvc3NcIixcbiAgZW1pc3Npb246IFwiZW1pc3NpdmVcIixcbiAgZGlmZnVzZTogXCJjb2xvclwiXG4gICovXG5cdH0sXG5cblx0bGlnaHRfdHJhbnNsYXRlX3RhYmxlOiB7XG5cblx0XHRwb2ludDogXCJvbW5pXCIsXG5cdFx0ZGlyZWN0aW9uYWw6IFwiZGlyZWN0aW9uYWxcIixcblx0XHRzcG90OiBcInNwb3RcIlxuXHR9LFxuXG5cdGNhbWVyYV90cmFuc2xhdGVfdGFibGU6IHtcblx0XHR4Zm92OiBcImZvdlwiLFxuXHRcdGFzcGVjdF9yYXRpbzogXCJhc3BlY3RcIixcblx0XHR6bmVhcjogXCJuZWFyXCIsXG5cdFx0emZhcjogXCJmYXJcIlxuXHR9LFxuXG5cdC8vdXNlZCB3aGVuIGlkIGhhdmUgc3BhY2VzIChyZWd1bGFyIHNlbGVjdG9yIGRvIG5vdCBzdXBwb3J0IHNwYWNlcylcblx0cXVlcnlTZWxlY3RvckFuZElkOiBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQW5kSWQocm9vdCwgc2VsZWN0b3IsIGlkKSB7XG5cdFx0dmFyIG5vZGVzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXR0cl9pZCA9IG5vZGVzLml0ZW0oaSkuZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRpZiAoIWF0dHJfaWQpIGNvbnRpbnVlO1xuXHRcdFx0YXR0cl9pZCA9IGF0dHJfaWQudG9TdHJpbmcoKTtcblx0XHRcdGlmIChhdHRyX2lkID09IGlkKSByZXR1cm4gbm9kZXMuaXRlbShpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Ly9yZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyBhIHRhZyBuYW1lLCBpZiBub3QgdGFnbmFtZSBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgdGFnIGVsZW1lbnRcblx0Z2V0Rmlyc3RDaGlsZEVsZW1lbnQ6IGZ1bmN0aW9uIGdldEZpcnN0Q2hpbGRFbGVtZW50KHJvb3QsIGxvY2FsTmFtZSkge1xuXHRcdHZhciBjID0gcm9vdC5jaGlsZE5vZGVzO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYy5sZW5ndGg7ICsraSkge1xuXHRcdFx0dmFyIGl0ZW0gPSBjLml0ZW0oaSk7XG5cdFx0XHRpZiAoaXRlbS5sb2NhbE5hbWUgJiYgIWxvY2FsTmFtZSB8fCBsb2NhbE5hbWUgJiYgbG9jYWxOYW1lID09IGl0ZW0ubG9jYWxOYW1lKSByZXR1cm4gaXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0cmVhZE1hdGVyaWFsOiBmdW5jdGlvbiByZWFkTWF0ZXJpYWwodXJsKSB7XG5cdFx0dmFyIHhtbG1hdGVyaWFsID0gdGhpcy5xdWVyeVNlbGVjdG9yQW5kSWQodGhpcy5feG1scm9vdCwgXCJsaWJyYXJ5X21hdGVyaWFscyBtYXRlcmlhbFwiLCB1cmwpO1xuXG5cdFx0aWYgKCF4bWxtYXRlcmlhbCkgcmV0dXJuIG51bGw7XG5cblx0XHQvL2dldCBlZmZlY3QgbmFtZVxuXHRcdHZhciB4bWxlZmZlY3QgPSB4bWxtYXRlcmlhbC5xdWVyeVNlbGVjdG9yKFwiaW5zdGFuY2VfZWZmZWN0XCIpO1xuXHRcdGlmICgheG1sZWZmZWN0KSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBlZmZlY3RfdXJsID0geG1sZWZmZWN0LmdldEF0dHJpYnV0ZShcInVybFwiKS5zdWJzdHIoMSk7XG5cblx0XHQvL2dldCBlZmZlY3Rcblx0XHR2YXIgeG1sZWZmZWN0cyA9IHRoaXMucXVlcnlTZWxlY3RvckFuZElkKHRoaXMuX3htbHJvb3QsIFwibGlicmFyeV9lZmZlY3RzIGVmZmVjdFwiLCBlZmZlY3RfdXJsKTtcblxuXHRcdGlmICgheG1sZWZmZWN0cykgcmV0dXJuIG51bGw7XG5cblx0XHQvL2dldCBjb21tb25cblx0XHR2YXIgeG1sdGVjaG5pcXVlID0geG1sZWZmZWN0cy5xdWVyeVNlbGVjdG9yKFwidGVjaG5pcXVlXCIpO1xuXHRcdGlmICgheG1sdGVjaG5pcXVlKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vZ2V0IG5ld3BhcmFtcyBhbmQgY29udmVydCB0byBqcyBvYmplY3Rcblx0XHR2YXIgeG1sbmV3cGFyYW1zID0geG1sZWZmZWN0cy5xdWVyeVNlbGVjdG9yQWxsKFwibmV3cGFyYW1cIik7XG5cdFx0dmFyIG5ld3BhcmFtcyA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbmV3cGFyYW1zLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdHZhciBpbml0X2Zyb20gPSB4bWxuZXdwYXJhbXNbaV0ucXVlcnlTZWxlY3RvcihcImluaXRfZnJvbVwiKTtcblx0XHRcdHZhciBwYXJlbnQ7XG5cdFx0XHRpZiAoaW5pdF9mcm9tKSBwYXJlbnQgPSBpbml0X2Zyb20uaW5uZXJIVE1MO2Vsc2Uge1xuXHRcdFx0XHR2YXIgc291cmNlID0geG1sbmV3cGFyYW1zW2ldLnF1ZXJ5U2VsZWN0b3IoXCJzb3VyY2VcIik7XG5cdFx0XHRcdHBhcmVudCA9IHNvdXJjZS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdG5ld3BhcmFtc1t4bWxuZXdwYXJhbXNbaV0uZ2V0QXR0cmlidXRlKFwic2lkXCIpXSA9IHtcblx0XHRcdFx0cGFyZW50OiBwYXJlbnRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIG1hdGVyaWFsID0ge307XG5cblx0XHQvL3JlYWQgdGhlIGltYWdlcyBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBhY2Nlc3MgdGhlbSB0byBhc3NpZ24gdGV4dHVyZSBuYW1lc1xuXHRcdHZhciBpbWFnZXMgPSB0aGlzLnJlYWRJbWFnZXModGhpcy5feG1scm9vdCk7XG5cblx0XHR2YXIgeG1scGhvbmcgPSB4bWx0ZWNobmlxdWUucXVlcnlTZWxlY3RvcihcInBob25nXCIpO1xuXHRcdGlmICgheG1scGhvbmcpIHhtbHBob25nID0geG1sdGVjaG5pcXVlLnF1ZXJ5U2VsZWN0b3IoXCJibGlublwiKTtcblx0XHRpZiAoIXhtbHBob25nKSB4bWxwaG9uZyA9IHhtbHRlY2huaXF1ZS5xdWVyeVNlbGVjdG9yKFwibGFtYmVydFwiKTtcblx0XHRpZiAoIXhtbHBob25nKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vZm9yIGV2ZXJ5IHRhZyBvZiBwcm9wZXJ0aWVzXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxwaG9uZy5jaGlsZE5vZGVzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgeG1scGFyYW0gPSB4bWxwaG9uZy5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cblx0XHRcdGlmICgheG1scGFyYW0ubG9jYWxOYW1lKSAvL3RleHQgdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvL3RyYW5zbGF0ZSBuYW1lXG5cdFx0XHR2YXIgcGFyYW1fbmFtZSA9IHhtbHBhcmFtLmxvY2FsTmFtZS50b1N0cmluZygpO1xuXHRcdFx0aWYgKHRoaXMubWF0ZXJpYWxfdHJhbnNsYXRlX3RhYmxlW3BhcmFtX25hbWVdKSBwYXJhbV9uYW1lID0gdGhpcy5tYXRlcmlhbF90cmFuc2xhdGVfdGFibGVbcGFyYW1fbmFtZV07XG5cblx0XHRcdC8vdmFsdWVcblx0XHRcdHZhciB4bWxwYXJhbV92YWx1ZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZEVsZW1lbnQoeG1scGFyYW0pO1xuXHRcdFx0aWYgKCF4bWxwYXJhbV92YWx1ZSkgY29udGludWU7XG5cblx0XHRcdGlmICh4bWxwYXJhbV92YWx1ZS5sb2NhbE5hbWUudG9TdHJpbmcoKSA9PSBcImNvbG9yXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbHBhcmFtX3ZhbHVlKTtcblx0XHRcdFx0aWYgKHhtbHBhcmFtLmdldEF0dHJpYnV0ZShcIm9wYXF1ZVwiKSA9PSBcIlJHQl9aRVJPXCIpIG1hdGVyaWFsW3BhcmFtX25hbWVdID0gdmFsdWUuc3ViYXJyYXkoMCwgNCk7ZWxzZSBtYXRlcmlhbFtwYXJhbV9uYW1lXSA9IHZhbHVlLnN1YmFycmF5KDAsIDMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoeG1scGFyYW1fdmFsdWUubG9jYWxOYW1lLnRvU3RyaW5nKCkgPT0gXCJmbG9hdFwiKSB7XG5cdFx0XHRcdG1hdGVyaWFsW3BhcmFtX25hbWVdID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbHBhcmFtX3ZhbHVlKVswXTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKHhtbHBhcmFtX3ZhbHVlLmxvY2FsTmFtZS50b1N0cmluZygpID09IFwidGV4dHVyZVwiKSB7XG5cdFx0XHRcdGlmICghbWF0ZXJpYWwudGV4dHVyZXMpIG1hdGVyaWFsLnRleHR1cmVzID0ge307XG5cdFx0XHRcdHZhciBtYXBfaWQgPSB4bWxwYXJhbV92YWx1ZS5nZXRBdHRyaWJ1dGUoXCJ0ZXh0dXJlXCIpO1xuXHRcdFx0XHRpZiAoIW1hcF9pZCkgY29udGludWU7XG5cblx0XHRcdFx0Ly8gaWYgbWFwX2lkIGlzIG5vdCBhIGZpbGVuYW1lLCBsZXRzIGdvIGFuZCBsb29rIGZvciBpdC5cblx0XHRcdFx0aWYgKG1hcF9pZC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG5cdFx0XHRcdFx0Ly9jaGVjayBlZmZlY3QgcGFyZW50c1xuXHRcdFx0XHRcdG1hcF9pZCA9IHRoaXMuZ2V0UGFyZW50UGFyYW0obmV3cGFyYW1zLCBtYXBfaWQpO1xuXG5cdFx0XHRcdFx0aWYgKGltYWdlc1ttYXBfaWRdKSBtYXBfaWQgPSBpbWFnZXNbbWFwX2lkXS5wYXRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9ub3cgZ2V0IHRoZSB0ZXh0dXJlIGZpbGVuYW1lIGZyb20gaW1hZ2VzXG5cblx0XHRcdFx0dmFyIG1hcF9pbmZvID0geyBtYXBfaWQ6IG1hcF9pZCB9O1xuXHRcdFx0XHR2YXIgdXZzID0geG1scGFyYW1fdmFsdWUuZ2V0QXR0cmlidXRlKFwidGV4Y29vcmRcIik7XG5cdFx0XHRcdG1hcF9pbmZvLnV2cyA9IHV2cztcblx0XHRcdFx0bWF0ZXJpYWwudGV4dHVyZXNbcGFyYW1fbmFtZV0gPSBtYXBfaW5mbztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtYXRlcmlhbC5vYmplY3RfdHlwZSA9IFwiTWF0ZXJpYWxcIjtcblx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cdH0sXG5cblx0Z2V0UGFyZW50UGFyYW06IGZ1bmN0aW9uIGdldFBhcmVudFBhcmFtKG5ld3BhcmFtcywgcGFyYW0pIHtcblx0XHRpZiAoIW5ld3BhcmFtc1twYXJhbV0pIHJldHVybiBwYXJhbTtcblxuXHRcdGlmIChuZXdwYXJhbXNbcGFyYW1dLnBhcmVudCkgcmV0dXJuIHRoaXMuZ2V0UGFyZW50UGFyYW0obmV3cGFyYW1zLCBuZXdwYXJhbXNbcGFyYW1dLnBhcmVudCk7ZWxzZSByZXR1cm4gcGFyYW07XG5cdH0sXG5cblx0cmVhZExpZ2h0OiBmdW5jdGlvbiByZWFkTGlnaHQobm9kZSwgdXJsKSB7XG5cdFx0dmFyIGxpZ2h0ID0ge307XG5cblx0XHR2YXIgeG1sbm9kZSA9IG51bGw7XG5cblx0XHRpZiAodXJsLmxlbmd0aCA+IDEpIC8vd2VpcmQgY2FzZXMgd2l0aCBpZCA9PSAjXG5cdFx0XHR4bWxub2RlID0gdGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9saWdodHMgXCIgKyB1cmwpO2Vsc2Uge1xuXHRcdFx0dmFyIHhtbGxpYmxpZ2h0cyA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImxpYnJhcnlfbGlnaHRzXCIpO1xuXHRcdFx0eG1sbm9kZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZEVsZW1lbnQoeG1sbGlibGlnaHRzLCBcImxpZ2h0XCIpO1xuXHRcdH1cblxuXHRcdGlmICgheG1sbm9kZSkgcmV0dXJuIG51bGw7XG5cblx0XHQvL3BhY2tcblx0XHR2YXIgY2hpbGRyZW4gPSBbXTtcblx0XHR2YXIgeG1sID0geG1sbm9kZS5xdWVyeVNlbGVjdG9yKFwidGVjaG5pcXVlX2NvbW1vblwiKTtcblx0XHRpZiAoeG1sKSBmb3IgKHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoeG1sLmNoaWxkTm9kZXMuaXRlbShpKS5ub2RlVHlwZSA9PSAxKSAvL3RhZ1xuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkpO1xuXHRcdH12YXIgeG1scyA9IHhtbG5vZGUucXVlcnlTZWxlY3RvckFsbChcInRlY2huaXF1ZVwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB4bWwyID0geG1scy5pdGVtKGkpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB4bWwyLmNoaWxkTm9kZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKHhtbDIuY2hpbGROb2Rlcy5pdGVtKGopLm5vZGVUeXBlID09IDEpIC8vdGFnXG5cdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaCh4bWwyLmNoaWxkTm9kZXMuaXRlbShqKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9nZXRcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sID0gY2hpbGRyZW5baV07XG5cdFx0XHRzd2l0Y2ggKHhtbC5sb2NhbE5hbWUpIHtcblx0XHRcdFx0Y2FzZSBcInBvaW50XCI6XG5cdFx0XHRcdFx0bGlnaHQudHlwZSA9IHRoaXMubGlnaHRfdHJhbnNsYXRlX3RhYmxlW3htbC5sb2NhbE5hbWVdO1xuXHRcdFx0XHRcdHBhcnNlX3BhcmFtcyhsaWdodCwgeG1sKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRpcmVjdGlvbmFsXCI6XG5cdFx0XHRcdFx0bGlnaHQudHlwZSA9IHRoaXMubGlnaHRfdHJhbnNsYXRlX3RhYmxlW3htbC5sb2NhbE5hbWVdO1xuXHRcdFx0XHRcdHBhcnNlX3BhcmFtcyhsaWdodCwgeG1sKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInNwb3RcIjpcblx0XHRcdFx0XHRsaWdodC50eXBlID0gdGhpcy5saWdodF90cmFuc2xhdGVfdGFibGVbeG1sLmxvY2FsTmFtZV07XG5cdFx0XHRcdFx0cGFyc2VfcGFyYW1zKGxpZ2h0LCB4bWwpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJpbnRlbnNpdHlcIjpcblx0XHRcdFx0XHRsaWdodC5pbnRlbnNpdHkgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKVswXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZV9wYXJhbXMobGlnaHQsIHhtbCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSB4bWwuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0XHRpZiAoIWNoaWxkIHx8IGNoaWxkLm5vZGVUeXBlICE9IDEpIC8vdGFnXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoIChjaGlsZC5sb2NhbE5hbWUpIHtcblx0XHRcdFx0XHRjYXNlIFwiY29sb3JcIjpcblx0XHRcdFx0XHRcdGxpZ2h0LmNvbG9yID0gQ29sbGFkYS5yZWFkQ29udGVudEFzRmxvYXRzKGNoaWxkKTticmVhaztcblx0XHRcdFx0XHRjYXNlIFwiZmFsbG9mZl9hbmdsZVwiOlxuXHRcdFx0XHRcdFx0bGlnaHQuYW5nbGVfZW5kID0gQ29sbGFkYS5yZWFkQ29udGVudEFzRmxvYXRzKGNoaWxkKVswXTtcblx0XHRcdFx0XHRcdGxpZ2h0LmFuZ2xlID0gbGlnaHQuYW5nbGVfZW5kIC0gMTA7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChub2RlLm1vZGVsKSB7XG5cdFx0XHQvL2xpZ2h0IHBvc2l0aW9uIGlzIGZpbmFsIGNvbHVtbiBvZiBtb2RlbFxuXHRcdFx0bGlnaHQucG9zaXRpb24gPSBbbm9kZS5tb2RlbFsxMl0sIG5vZGUubW9kZWxbMTNdLCBub2RlLm1vZGVsWzE0XV07XG5cdFx0XHQvL2xpZ2h0IGZvcndhcmQgdmVjdG9yIGlzIHJldmVyc2Ugb2YgdGhpcmQgY29sdW1uIG9mIG1vZGVsXG5cdFx0XHR2YXIgZm9yd2FyZCA9IFstbm9kZS5tb2RlbFs4XSwgLW5vZGUubW9kZWxbOV0sIC1ub2RlLm1vZGVsWzEwXV07XG5cdFx0XHQvL3NvIGxpZ2h0IHRhcmdldCBpcyBwb3NpdGlvbiArIGZvcndhcmRcblx0XHRcdGxpZ2h0LnRhcmdldCA9IFtsaWdodC5wb3NpdGlvblswXSArIGZvcndhcmRbMF0sIGxpZ2h0LnBvc2l0aW9uWzFdICsgZm9yd2FyZFsxXSwgbGlnaHQucG9zaXRpb25bMl0gKyBmb3J3YXJkWzJdXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKFwiQ291bGQgbm90IHJlYWQgbGlnaHQgcG9zaXRpb24gZm9yIGxpZ2h0OiBcIiArIG5vZGUubmFtZSArIFwiLiBTZXR0aW5nIGRlZmF1bHRzLlwiKTtcblx0XHRcdGxpZ2h0LnBvc2l0aW9uID0gWzAsIDAsIDBdO1xuXHRcdFx0bGlnaHQudGFyZ2V0ID0gWzAsIC0xLCAwXTtcblx0XHR9XG5cblx0XHRub2RlLmxpZ2h0ID0gbGlnaHQ7XG5cdH0sXG5cblx0cmVhZENhbWVyYTogZnVuY3Rpb24gcmVhZENhbWVyYShub2RlLCB1cmwpIHtcblx0XHR2YXIgY2FtZXJhID0ge307XG5cblx0XHR2YXIgeG1sbm9kZSA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImxpYnJhcnlfY2FtZXJhcyBcIiArIHVybCk7XG5cdFx0aWYgKCF4bWxub2RlKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vcGFja1xuXHRcdHZhciBjaGlsZHJlbiA9IFtdO1xuXHRcdHZhciB4bWwgPSB4bWxub2RlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZWNobmlxdWVfY29tbW9uXCIpO1xuXHRcdGlmICh4bWwpIC8vZ3JhYiBhbGwgaW50ZXJuYWwgc3R1ZmZcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkubm9kZVR5cGUgPT0gMSkgLy90YWdcblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKHhtbC5jaGlsZE5vZGVzLml0ZW0oaSkpO1xuXHRcdFx0fSAvL1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB0YWcgPSBjaGlsZHJlbltpXTtcblx0XHRcdHBhcnNlX3BhcmFtcyhjYW1lcmEsIHRhZyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VfcGFyYW1zKGNhbWVyYSwgeG1sKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHhtbC5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cdFx0XHRcdGlmICghY2hpbGQgfHwgY2hpbGQubm9kZVR5cGUgIT0gMSkgLy90YWdcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIHRyYW5zbGF0ZWQgPSBDb2xsYWRhLmNhbWVyYV90cmFuc2xhdGVfdGFibGVbY2hpbGQubG9jYWxOYW1lXSB8fCBjaGlsZC5sb2NhbE5hbWU7XG5cdFx0XHRcdGNhbWVyYVt0cmFuc2xhdGVkXSA9IHBhcnNlRmxvYXQoY2hpbGQudGV4dENvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vcGFyc2UgdG8gY29udmVydCB5Zm92IHRvIHN0YW5kYXJkICh4KSBmb3Zcblx0XHRpZiAoY2FtZXJhLnlmb3YgJiYgIWNhbWVyYS5mb3YpIHtcblx0XHRcdGlmIChjYW1lcmEuYXNwZWN0KSB7XG5cdFx0XHRcdGNhbWVyYS5mb3YgPSBjYW1lcmEueWZvdiAqIGNhbWVyYS5hc3BlY3Q7XG5cdFx0XHR9IGVsc2UgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGNvbnZlcnQgY2FtZXJhIHlmb3YgdG8geGZvdiBiZWNhdXNlIGFzcGVjdCByYXRpbyBub3Qgc2V0XCIpO1xuXHRcdH1cblxuXHRcdG5vZGUuY2FtZXJhID0gY2FtZXJhO1xuXHR9LFxuXG5cdHJlYWRUcmFuc2Zvcm06IGZ1bmN0aW9uIHJlYWRUcmFuc2Zvcm0oeG1sbm9kZSwgbGV2ZWwsIGZsaXApIHtcblx0XHQvL2lkZW50aXR5XG5cdFx0dmFyIG1hdHJpeCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdHZhciB0ZW1wID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dmFyIHRtcHEgPSBfZ2xNYXRyaXgucXVhdC5jcmVhdGUoKTtcblxuXHRcdHZhciBmbGlwX2ZpeCA9IGZhbHNlO1xuXG5cdFx0Ly9zZWFyY2ggZm9yIHRoZSBtYXRyaXhcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbCA9IHhtbG5vZGUuY2hpbGROb2Rlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKCF4bWwgfHwgeG1sLm5vZGVUeXBlICE9IDEpIC8vdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcIm1hdHJpeFwiKSB7XG5cdFx0XHRcdHZhciBtYXRyaXggPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIk5vZGVuYW1lOiBcIiArIHhtbG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIikpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKG1hdHJpeCk7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgbGV2ZWwgPT0gMCk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2cobWF0cml4KTtcblx0XHRcdFx0cmV0dXJuIG1hdHJpeDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHhtbC5sb2NhbE5hbWUgPT0gXCJ0cmFuc2xhdGVcIikge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7XG5cdFx0XHRcdGlmIChmbGlwICYmIGxldmVsID4gMCkge1xuXHRcdFx0XHRcdHZhciB0bXAgPSB2YWx1ZXNbMV07XG5cdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdHZhbHVlc1syXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nbE1hdHJpeC5tYXQ0LnRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgdmFsdWVzKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vcm90YXRlXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInJvdGF0ZVwiKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPT0gNCkgLy94LHkseiwgYW5nbGVcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSB4bWwuZ2V0QXR0cmlidXRlKFwic2lkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKGlkID09IFwiam9pbnRPcmllbnRYXCIpIHtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzNdICs9IDkwO1xuXHRcdFx0XHRcdFx0XHRmbGlwX2ZpeCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvL3JvdGF0ZVggJiByb3RhdGVZICYgcm90YXRlWiBkb25lIGJlbG93XG5cblx0XHRcdFx0XHRcdGlmIChmbGlwKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0bXAgPSB2YWx1ZXNbMV07XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1sxXSA9IHZhbHVlc1syXTtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzJdID0gLXRtcDsgLy9zd2FwIGNvb3Jkc1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodmFsdWVzWzNdICE9IDAuMCkge1xuXHRcdFx0XHRcdFx0XHRfZ2xNYXRyaXgucXVhdC5zZXRBeGlzQW5nbGUodG1wcSwgdmFsdWVzLnN1YmFycmF5KDAsIDMpLCB2YWx1ZXNbM10gKiBERUcyUkFEKTtcblx0XHRcdFx0XHRcdFx0X2dsTWF0cml4Lm1hdDQuZnJvbVF1YXQodGVtcCwgdG1wcSk7XG5cdFx0XHRcdFx0XHRcdF9nbE1hdHJpeC5tYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0ZW1wKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL3NjYWxlXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInNjYWxlXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHRpZiAoZmxpcCkge1xuXHRcdFx0XHRcdHZhciB0bXAgPSB2YWx1ZXNbMV07XG5cdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdHZhbHVlc1syXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHRcdFx0fVxuXHRcdFx0XHRfZ2xNYXRyaXgubWF0NC5zY2FsZShtYXRyaXgsIG1hdHJpeCwgdmFsdWVzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9LFxuXG5cdHJlYWRUcmFuc2Zvcm0yOiBmdW5jdGlvbiByZWFkVHJhbnNmb3JtMih4bWxub2RlLCBsZXZlbCwgZmxpcCkge1xuXHRcdC8vaWRlbnRpdHlcblx0XHR2YXIgbWF0cml4ID0gX2dsTWF0cml4Lm1hdDQuY3JlYXRlKCk7XG5cdFx0dmFyIHJvdGF0aW9uID0gX2dsTWF0cml4LnF1YXQuY3JlYXRlKCk7XG5cdFx0dmFyIHRtcG1hdHJpeCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpO1xuXHRcdHZhciB0bXBxID0gX2dsTWF0cml4LnF1YXQuY3JlYXRlKCk7XG5cdFx0dmFyIHRyYW5zbGF0ZSA9IHZlYzMuY3JlYXRlKCk7XG5cdFx0dmFyIHNjYWxlID0gdmVjMy5mcm9tVmFsdWVzKDEsIDEsIDEpO1xuXG5cdFx0dmFyIGZsaXBfZml4ID0gZmFsc2U7XG5cblx0XHQvL3NlYXJjaCBmb3IgdGhlIG1hdHJpeFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sID0geG1sbm9kZS5jaGlsZE5vZGVzLml0ZW0oaSk7XG5cblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwibWF0cml4XCIpIHtcblx0XHRcdFx0dmFyIG1hdHJpeCA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiTm9kZW5hbWU6IFwiICsgeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSk7XG5cdFx0XHRcdC8vY29uc29sZS5sb2cobWF0cml4KTtcblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgobWF0cml4LCBsZXZlbCA9PSAwKTtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhtYXRyaXgpO1xuXHRcdFx0XHRyZXR1cm4gbWF0cml4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoeG1sLmxvY2FsTmFtZSA9PSBcInRyYW5zbGF0ZVwiKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sKTtcblx0XHRcdFx0dHJhbnNsYXRlLnNldCh2YWx1ZXMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9yb3RhdGVcblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwicm90YXRlXCIpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWwpO1xuXHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA9PSA0KSAvL3gseSx6LCBhbmdsZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHZhciBpZCA9IHhtbC5nZXRBdHRyaWJ1dGUoXCJzaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoaWQgPT0gXCJqb2ludE9yaWVudFhcIikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbM10gKz0gOTA7XG5cdFx0XHRcdFx0XHRcdGZsaXBfZml4ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vcm90YXRlWCAmIHJvdGF0ZVkgJiByb3RhdGVaIGRvbmUgYmVsb3dcblxuXHRcdFx0XHRcdFx0aWYgKGZsaXApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRtcCA9IHZhbHVlc1sxXTtcblx0XHRcdFx0XHRcdFx0dmFsdWVzWzFdID0gdmFsdWVzWzJdO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXNbMl0gPSAtdG1wOyAvL3N3YXAgY29vcmRzXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZXNbM10gIT0gMC4wKSB7XG5cdFx0XHRcdFx0XHRcdF9nbE1hdHJpeC5xdWF0LnNldEF4aXNBbmdsZSh0bXBxLCB2YWx1ZXMuc3ViYXJyYXkoMCwgMyksIHZhbHVlc1szXSAqIERFRzJSQUQpO1xuXHRcdFx0XHRcdFx0XHRfZ2xNYXRyaXgucXVhdC5tdWx0aXBseShyb3RhdGlvbiwgcm90YXRpb24sIHRtcHEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vc2NhbGVcblx0XHRcdGlmICh4bWwubG9jYWxOYW1lID09IFwic2NhbGVcIikge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbCk7XG5cdFx0XHRcdGlmIChmbGlwKSB7XG5cdFx0XHRcdFx0dmFyIHRtcCA9IHZhbHVlc1sxXTtcblx0XHRcdFx0XHR2YWx1ZXNbMV0gPSB2YWx1ZXNbMl07XG5cdFx0XHRcdFx0dmFsdWVzWzJdID0gLXRtcDsgLy9zd2FwIGNvb3Jkc1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjYWxlLnNldCh2YWx1ZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChmbGlwICYmIGxldmVsID4gMCkge1xuXHRcdFx0dmFyIHRtcCA9IHRyYW5zbGF0ZVsxXTtcblx0XHRcdHRyYW5zbGF0ZVsxXSA9IHRyYW5zbGF0ZVsyXTtcblx0XHRcdHRyYW5zbGF0ZVsyXSA9IC10bXA7IC8vc3dhcCBjb29yZHNcblx0XHR9XG5cdFx0X2dsTWF0cml4Lm1hdDQudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCB0cmFuc2xhdGUpO1xuXG5cdFx0X2dsTWF0cml4Lm1hdDQuZnJvbVF1YXQodG1wbWF0cml4LCByb3RhdGlvbik7XG5cdFx0Ly9tYXQ0LnJvdGF0ZVgodG1wbWF0cml4LCB0bXBtYXRyaXgsIE1hdGguUEkgKiAwLjUpO1xuXHRcdF9nbE1hdHJpeC5tYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0bXBtYXRyaXgpO1xuXHRcdF9nbE1hdHJpeC5tYXQ0LnNjYWxlKG1hdHJpeCwgbWF0cml4LCBzY2FsZSk7XG5cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9LFxuXG5cdC8vZm9yIGhlbHAgcmVhZCB0aGlzOiBodHRwczovL3d3dy5raHJvbm9zLm9yZy9jb2xsYWRhL3dpa2kvVXNpbmdfYWNjZXNzb3JzXG5cdHJlYWRHZW9tZXRyeTogZnVuY3Rpb24gcmVhZEdlb21ldHJ5KGlkLCBmbGlwLCBzY2VuZSkge1xuXHRcdC8vYWxyZWFkeSByZWFkLCBjb3VsZCBoYXBwZW5kIGlmIHNldmVyYWwgY29udHJvbGxlcnMgcG9pbnQgdG8gdGhlIHNhbWUgbWVzaFxuXHRcdGlmICh0aGlzLl9nZW9tZXRyaWVzX2ZvdW5kW2lkXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF07XG5cblx0XHQvL3ZhciB4bWxnZW9tZXRyeSA9IHRoaXMuX3htbHJvb3QucXVlcnlTZWxlY3RvcihcImdlb21ldHJ5XCIgKyBpZCk7XG5cdFx0dmFyIHhtbGdlb21ldHJ5ID0gdGhpcy5feG1scm9vdC5nZXRFbGVtZW50QnlJZChpZC5zdWJzdHIoMSkpO1xuXHRcdGlmICgheG1sZ2VvbWV0cnkpIHtcblx0XHRcdGNvbnNvbGUud2FybihcInJlYWRHZW9tZXRyeTogZ2VvbWV0cnkgbm90IGZvdW5kOiBcIiArIGlkKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vaWYgdGhlIGdlb21ldHJ5IGhhcyBtb3JwaCB0YXJnZXRzIHRoZW4gaW5zdGVhZCBvZiBzdG9yaW5nIGl0IGluIGEgZ2VvbWV0cnksIGl0IGlzIGluIGEgY29udHJvbGxlclxuXHRcdGlmICh4bWxnZW9tZXRyeS5sb2NhbE5hbWUgPT0gXCJjb250cm9sbGVyXCIpIHtcblx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMucmVhZENvbnRyb2xsZXIoeG1sZ2VvbWV0cnksIGZsaXAsIHNjZW5lKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gZ2VvbWV0cnk7XG5cdFx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cdFx0fVxuXG5cdFx0aWYgKHhtbGdlb21ldHJ5LmxvY2FsTmFtZSAhPSBcImdlb21ldHJ5XCIpIHtcblx0XHRcdGNvbnNvbGUud2FybihcInJlYWRHZW9tZXRyeTogdGFnIHNob3VsZCBiZSBnZW9tZXRyeSwgaW5zdGVhZCBpdCB3YXMgZm91bmQ6IFwiICsgeG1sZ2VvbWV0cnkubG9jYWxOYW1lKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciB4bWxtZXNoID0geG1sZ2VvbWV0cnkucXVlcnlTZWxlY3RvcihcIm1lc2hcIik7XG5cdFx0aWYgKCF4bWxtZXNoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJyZWFkR2VvbWV0cnk6IG1lc2ggbm90IGZvdW5kIGluIGdlb21ldHJ5OiBcIiArIGlkKTtcblx0XHRcdHRoaXMuX2dlb21ldHJpZXNfZm91bmRbaWRdID0gbnVsbDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vZ2V0IGRhdGEgc291cmNlc1xuXHRcdHZhciBzb3VyY2VzID0ge307XG5cdFx0dmFyIHhtbHNvdXJjZXMgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sc291cmNlID0geG1sc291cmNlcy5pdGVtKGkpO1xuXHRcdFx0aWYgKCF4bWxzb3VyY2UucXVlcnlTZWxlY3RvcikgY29udGludWU7XG5cdFx0XHR2YXIgZmxvYXRfYXJyYXkgPSB4bWxzb3VyY2UucXVlcnlTZWxlY3RvcihcImZsb2F0X2FycmF5XCIpO1xuXHRcdFx0aWYgKCFmbG9hdF9hcnJheSkgY29udGludWU7XG5cdFx0XHR2YXIgZmxvYXRzID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKGZsb2F0X2FycmF5KTtcblxuXHRcdFx0dmFyIHhtbGFjY2Vzc29yID0geG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IoXCJhY2Nlc3NvclwiKTtcblx0XHRcdHZhciBzdHJpZGUgPSBwYXJzZUludCh4bWxhY2Nlc3Nvci5nZXRBdHRyaWJ1dGUoXCJzdHJpZGVcIikpO1xuXG5cdFx0XHRzb3VyY2VzW3htbHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSB7IHN0cmlkZTogc3RyaWRlLCBkYXRhOiBmbG9hdHMgfTtcblx0XHR9XG5cblx0XHQvL2dldCBzdHJlYW1zXG5cdFx0dmFyIHhtbHZlcnRpY2VzID0geG1sbWVzaC5xdWVyeVNlbGVjdG9yKFwidmVydGljZXMgaW5wdXRcIik7XG5cdFx0dmFyIHZlcnRpY2VzX3NvdXJjZSA9IHNvdXJjZXNbeG1sdmVydGljZXMuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0c291cmNlc1t4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJ2ZXJ0aWNlc1wiKS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSB2ZXJ0aWNlc19zb3VyY2U7XG5cblx0XHR2YXIgbWVzaCA9IG51bGw7XG5cdFx0dmFyIHhtbHBvbHlnb25zID0geG1sbWVzaC5xdWVyeVNlbGVjdG9yKFwicG9seWdvbnNcIik7XG5cdFx0aWYgKHhtbHBvbHlnb25zKSBtZXNoID0gdGhpcy5yZWFkVHJpYW5nbGVzKHhtbHBvbHlnb25zLCBzb3VyY2VzKTtcblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0dmFyIHhtbHRyaWFuZ2xlcyA9IHhtbG1lc2gucXVlcnlTZWxlY3RvckFsbChcInRyaWFuZ2xlc1wiKTtcblx0XHRcdGlmICh4bWx0cmlhbmdsZXMgJiYgeG1sdHJpYW5nbGVzLmxlbmd0aCkgbWVzaCA9IHRoaXMucmVhZFRyaWFuZ2xlcyh4bWx0cmlhbmdsZXMsIHNvdXJjZXMpO1xuXHRcdH1cblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0Ly9wb2x5bGlzdCA9IHRydWU7XG5cdFx0XHQvL3ZhciB2Y291bnQgPSBudWxsO1xuXHRcdFx0Ly92YXIgeG1sdmNvdW50ID0geG1scG9seWdvbnMucXVlcnlTZWxlY3RvcihcInZjb3VudFwiKTtcblx0XHRcdC8vdmFyIHZjb3VudCA9IHRoaXMucmVhZENvbnRlbnRBc1VJbnQzMiggeG1sdmNvdW50ICk7XG5cdFx0XHR2YXIgeG1scG9seWxpc3QgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJwb2x5bGlzdFwiKTtcblx0XHRcdGlmICh4bWxwb2x5bGlzdCkgbWVzaCA9IHRoaXMucmVhZFBvbHlsaXN0KHhtbHBvbHlsaXN0LCBzb3VyY2VzKTtcblx0XHR9XG5cblx0XHRpZiAoIW1lc2gpIHtcblx0XHRcdHZhciB4bWxsaW5lc3RyaXAgPSB4bWxtZXNoLnF1ZXJ5U2VsZWN0b3IoXCJsaW5lc3RyaXBzXCIpO1xuXHRcdFx0aWYgKHhtbGxpbmVzdHJpcCkgbWVzaCA9IHRoaXMucmVhZExpbmVTdHJpcChzb3VyY2VzLCB4bWxsaW5lc3RyaXApO1xuXHRcdH1cblxuXHRcdGlmICghbWVzaCkge1xuXHRcdFx0Y29uc29sZS5sb2coXCJubyBwb2x5Z29ucyBvciB0cmlhbmdsZXMgaW4gbWVzaDogXCIgKyBpZCk7XG5cdFx0XHR0aGlzLl9nZW9tZXRyaWVzX2ZvdW5kW2lkXSA9IG51bGw7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL3N3YXAgY29vcmRzIChYLFksWikgLT4gKFgsWiwtWSlcblx0XHRpZiAoZmxpcCAmJiAhdGhpcy5ub19mbGlwKSB7XG5cdFx0XHR2YXIgdG1wID0gMDtcblx0XHRcdHZhciBhcnJheSA9IG1lc2gudmVydGljZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHR0bXAgPSBhcnJheVtpICsgMV07XG5cdFx0XHRcdGFycmF5W2kgKyAxXSA9IGFycmF5W2kgKyAyXTtcblx0XHRcdFx0YXJyYXlbaSArIDJdID0gLXRtcDtcblx0XHRcdH1cblxuXHRcdFx0YXJyYXkgPSBtZXNoLm5vcm1hbHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuXHRcdFx0XHR0bXAgPSBhcnJheVtpICsgMV07XG5cdFx0XHRcdGFycmF5W2kgKyAxXSA9IGFycmF5W2kgKyAyXTtcblx0XHRcdFx0YXJyYXlbaSArIDJdID0gLXRtcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL3RyYW5zZmVyYWJsZXMgZm9yIHdvcmtlclxuXHRcdGlmIChpc1dvcmtlciAmJiB0aGlzLnVzZV90cmFuc2ZlcmFibGVzKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG1lc2gpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBtZXNoW2ldO1xuXHRcdFx0XHRpZiAoZGF0YSAmJiBkYXRhLmJ1ZmZlciAmJiBkYXRhLmxlbmd0aCA+IDEwMCkge1xuXHRcdFx0XHRcdHRoaXMuX3RyYW5zZmVyYWJsZXMucHVzaChkYXRhLmJ1ZmZlcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvL2V4dHJhIGluZm9cblx0XHRtZXNoLmZpbGVuYW1lID0gaWQ7XG5cdFx0bWVzaC5vYmplY3RfdHlwZSA9IFwiTWVzaFwiO1xuXG5cdFx0dGhpcy5fZ2VvbWV0cmllc19mb3VuZFtpZF0gPSBtZXNoO1xuXHRcdHJldHVybiBtZXNoO1xuXHR9LFxuXG5cdHJlYWRUcmlhbmdsZXM6IGZ1bmN0aW9uIHJlYWRUcmlhbmdsZXMoeG1sdHJpYW5nbGVzLCBzb3VyY2VzKSB7XG5cdFx0dmFyIHVzZV9pbmRpY2VzID0gZmFsc2U7XG5cblx0XHR2YXIgZ3JvdXBzID0gW107XG5cdFx0dmFyIGJ1ZmZlcnMgPSBbXTtcblx0XHR2YXIgbGFzdF9pbmRleCA9IDA7XG5cdFx0dmFyIGZhY2VtYXAgPSB7fTtcblx0XHR2YXIgdmVydGV4X3JlbWFwID0gW107IC8vbWFwcyBEQUUgdmVydGV4IGluZGV4IHRvIE1lc2ggdmVydGV4IGluZGV4IChiZWNhdXNlIHdoZW4gbWVzaGVzIGFyZSB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBhcmUgY2hhbmdlZFxuXHRcdHZhciBpbmRpY2VzQXJyYXkgPSBbXTtcblx0XHR2YXIgbGFzdF9zdGFydCA9IDA7XG5cdFx0dmFyIGdyb3VwX25hbWUgPSBcIlwiO1xuXHRcdHZhciBtYXRlcmlhbF9uYW1lID0gXCJcIjtcblxuXHRcdC8vZm9yIGV2ZXJ5IHRyaWFuZ2xlcyBzZXQgKHdhcm5pbmcsIHNvbWUgdGltZXMgdGhleSBhcmUgcmVwZWF0ZWQuLi4pXG5cdFx0Zm9yICh2YXIgdHJpcyA9IDA7IHRyaXMgPCB4bWx0cmlhbmdsZXMubGVuZ3RoOyB0cmlzKyspIHtcblx0XHRcdHZhciB4bWxfc2hhcGVfcm9vdCA9IHhtbHRyaWFuZ2xlcy5pdGVtKHRyaXMpO1xuXHRcdFx0dmFyIHRyaWFuZ2xlcyA9IHhtbF9zaGFwZV9yb290LmxvY2FsTmFtZSA9PSBcInRyaWFuZ2xlc1wiO1xuXG5cdFx0XHRtYXRlcmlhbF9uYW1lID0geG1sX3NoYXBlX3Jvb3QuZ2V0QXR0cmlidXRlKFwibWF0ZXJpYWxcIik7XG5cblx0XHRcdC8vZm9yIGVhY2ggYnVmZmVyIChpbnB1dCkgYnVpbGQgdGhlIHN0cnVjdHVyZSBpbmZvXG5cdFx0XHRpZiAodHJpcyA9PSAwKSBidWZmZXJzID0gdGhpcy5yZWFkU2hhcGVJbnB1dHMoeG1sX3NoYXBlX3Jvb3QsIHNvdXJjZXMpO1xuXG5cdFx0XHQvL2Fzc3VtaW5nIGJ1ZmZlcnMgYXJlIG9yZGVyZWQgYnkgb2Zmc2V0XG5cblx0XHRcdC8vaXRlcmF0ZSBkYXRhXG5cdFx0XHR2YXIgeG1scHMgPSB4bWxfc2hhcGVfcm9vdC5xdWVyeVNlbGVjdG9yQWxsKFwicFwiKTtcblx0XHRcdHZhciBudW1fZGF0YV92ZXJ0ZXggPSBidWZmZXJzLmxlbmd0aDsgLy9vbmUgdmFsdWUgcGVyIGlucHV0IGJ1ZmZlclxuXG5cdFx0XHQvL2ZvciBldmVyeSBwb2x5Z29uIChjb3VsZCBiZSBvbmUgd2l0aCBhbGwgdGhlIGluZGljZXMsIGNvdWxkIGJlIHNldmVyYWwsIGRlcGVuZHMgb24gdGhlIHByb2dyYW0pXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciB4bWxwID0geG1scHMuaXRlbShpKTtcblx0XHRcdFx0aWYgKCF4bWxwIHx8ICF4bWxwLnRleHRDb250ZW50KSBicmVhaztcblxuXHRcdFx0XHR2YXIgZGF0YSA9IHhtbHAudGV4dENvbnRlbnQudHJpbSgpLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0XHQvL3VzZWQgZm9yIHRyaWFuZ3VsYXRlIHBvbHlzXG5cdFx0XHRcdHZhciBmaXJzdF9pbmRleCA9IC0xO1xuXHRcdFx0XHR2YXIgY3VycmVudF9pbmRleCA9IC0xO1xuXHRcdFx0XHR2YXIgcHJldl9pbmRleCA9IC0xO1xuXG5cdFx0XHRcdC8vZGlzY29tbWVudCB0byBmb3JjZSAxNmJpdHMgaW5kaWNlc1xuXHRcdFx0XHQvL2lmKHVzZV9pbmRpY2VzICYmIGxhc3RfaW5kZXggPj0gMjU2KjI1Nilcblx0XHRcdFx0Ly9cdGJyZWFrO1xuXG5cdFx0XHRcdHZhciBudW1fdmFsdWVzX3Blcl92ZXJ0ZXggPSAxO1xuXHRcdFx0XHRmb3IgKHZhciBiIGluIGJ1ZmZlcnMpIHtcblx0XHRcdFx0XHRudW1fdmFsdWVzX3Blcl92ZXJ0ZXggPSBNYXRoLm1heChudW1fdmFsdWVzX3Blcl92ZXJ0ZXgsIGJ1ZmZlcnNbYl1bNF0gKyAxKTtcblx0XHRcdFx0fSAvL2ZvciBldmVyeSBwYWNrIG9mIGluZGljZXMgaW4gdGhlIHBvbHlnb24gKHZlcnRleCwgbm9ybWFsLCB1diwgLi4uIClcblx0XHRcdFx0dmFyIGN1cnJlbnRfZGF0YV9wb3MgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBrID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBrIDwgbDsgayArPSBudW1fdmFsdWVzX3Blcl92ZXJ0ZXgpIHtcblx0XHRcdFx0XHR2YXIgdmVydGV4X2lkID0gZGF0YS5zbGljZShrLCBrICsgbnVtX3ZhbHVlc19wZXJfdmVydGV4KS5qb2luKFwiIFwiKTsgLy9nZW5lcmF0ZSB1bmlxdWUgaWRcblxuXHRcdFx0XHRcdHByZXZfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRcdGlmIChmYWNlbWFwLmhhc093blByb3BlcnR5KHZlcnRleF9pZCkpIC8vYWRkIHRvIGFycmF5cywga2VlcCB0aGUgaW5kZXhcblx0XHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBmYWNlbWFwW3ZlcnRleF9pZF07ZWxzZSB7XG5cdFx0XHRcdFx0XHQvL2ZvciBldmVyeSBkYXRhIGJ1ZmZlciBhc3NvY2lhdGVkIHRvIHRoaXMgdmVydGV4XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG5cdFx0XHRcdFx0XHRcdHZhciBhcnJheSA9IGJ1ZmZlclsxXTsgLy9hcnJheSB3aGVyZSB3ZSBhY2N1bXVsYXRlIHRoZSBmaW5hbCBkYXRhIGFzIHdlIGV4dHJhY3QgaWYgZnJvbSBzb3VyY2VzXG5cdFx0XHRcdFx0XHRcdHZhciBzb3VyY2UgPSBidWZmZXJbM107IC8vd2hlcmUgdG8gcmVhZCB0aGUgZGF0YSBmcm9tXG5cblx0XHRcdFx0XHRcdFx0Ly9jb21wdXRlIHRoZSBpbmRleCBpbnNpZGUgdGhlIGRhdGEgc291cmNlIGFycmF5XG5cdFx0XHRcdFx0XHRcdC8vdmFyIGluZGV4ID0gcGFyc2VJbnQoZGF0YVtrICsgal0pO1xuXHRcdFx0XHRcdFx0XHR2YXIgaW5kZXggPSBwYXJzZUludChkYXRhW2sgKyBidWZmZXJbNF1dKTtcblx0XHRcdFx0XHRcdFx0Ly9jdXJyZW50X2RhdGFfcG9zICs9IGJ1ZmZlcls0XTtcblxuXHRcdFx0XHRcdFx0XHQvL3JlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZSB3ZSBuZWVkIHRvIHJlbWFwXG5cdFx0XHRcdFx0XHRcdGlmIChqID09IDApIHZlcnRleF9yZW1hcFthcnJheS5sZW5ndGggLyBidWZmZXJbMl1dID0gaW5kZXg7IC8vbm90IHN1cmUgaWYgYnVmZmVyWzJdLCBpdCBzaG91bGQgYmUgbnVtYmVyIG9mIGZsb2F0cyBwZXIgdmVydGV4ICh1c3VhbGx5IDMpXG5cdFx0XHRcdFx0XHRcdC8vdmVydGV4X3JlbWFwWyBhcnJheS5sZW5ndGggLyBudW1fZGF0YV92ZXJ0ZXggXSA9IGluZGV4O1xuXG5cdFx0XHRcdFx0XHRcdC8vY29tcHV0ZSB0aGUgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2UgYnVmZmVyIHdoZXJlIHRoZSBmaW5hbCBkYXRhIGlzIGxvY2F0ZWRcblx0XHRcdFx0XHRcdFx0aW5kZXggKj0gYnVmZmVyWzJdOyAvL3RoaXMgd29ya3MgaW4gbW9zdCBEQUVzIChub3QgYWxsKVxuXHRcdFx0XHRcdFx0XHQvL2luZGV4ID0gaW5kZXggKiBidWZmZXJbMl0gKyBidWZmZXJbNF07IC8vc3RyaWRlKDIpIG9mZnNldCg0KVxuXHRcdFx0XHRcdFx0XHQvL2luZGV4ICs9IGJ1ZmZlcls0XTsgLy9zdHJpZGUoMikgb2Zmc2V0KDQpXG5cdFx0XHRcdFx0XHRcdC8vZXh0cmFjdCBldmVyeSB2YWx1ZSBvZiB0aGlzIGVsZW1lbnQgYW5kIHN0b3JlIGl0IGluIGl0cyBmaW5hbCBhcnJheSAoZXZlcnkgeCx5LHosIGV0Yylcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCBidWZmZXJbMl07ICsreCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChzb3VyY2VbaW5kZXggKyB4XSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBcIlVOREVGSU5FRCFcIjsgLy9ERUJVR1xuXHRcdFx0XHRcdFx0XHRcdGFycmF5LnB1c2goc291cmNlW2luZGV4ICsgeF0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBsYXN0X2luZGV4O1xuXHRcdFx0XHRcdFx0bGFzdF9pbmRleCArPSAxO1xuXHRcdFx0XHRcdFx0ZmFjZW1hcFt2ZXJ0ZXhfaWRdID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXRyaWFuZ2xlcykgLy90aGUgeG1sIGVsZW1lbnQgaXMgbm90IHRyaWFuZ2xlcz8gdGhlbiBzcGxpdCBwb2x5Z29ucyBpbiB0cmlhbmdsZXNcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKGsgPT0gMCkgZmlyc3RfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRcdFx0XHQvL2lmKGsgPiAyICogbnVtX2RhdGFfdmVydGV4KSAvL25vdCBzdXJlIGlmIHVzZSB0aGlzIG9yIHRoZSBuZXh0IGxpbmUsIHRoZSBuZXh0IG9uZSB3b3JrcyBpbiBzb21lIERBRXMgYnV0IG5vdCBzdXJlIGlmIGl0IHdvcmtzIGluIGFsbFxuXHRcdFx0XHRcdFx0XHRpZiAoayA+IDIpIC8vdHJpYW5ndWxhdGUgcG9seWdvbnM6IGVuc3VyZSB0aGlzIHdvcmtzXG5cdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goZmlyc3RfaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2gocHJldl9pbmRleCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goY3VycmVudF9pbmRleCk7XG5cdFx0XHRcdH0gLy9wZXIgdmVydGV4XG5cdFx0XHR9IC8vcGVyIHBvbHlnb25cblxuXHRcdFx0dmFyIGdyb3VwID0ge1xuXHRcdFx0XHRuYW1lOiBncm91cF9uYW1lIHx8IFwiZ3JvdXBcIiArIHRyaXMsXG5cdFx0XHRcdHN0YXJ0OiBsYXN0X3N0YXJ0LFxuXHRcdFx0XHRsZW5ndGg6IGluZGljZXNBcnJheS5sZW5ndGggLSBsYXN0X3N0YXJ0LFxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWxfbmFtZSB8fCBcIlwiXG5cdFx0XHR9O1xuXHRcdFx0bGFzdF9zdGFydCA9IGluZGljZXNBcnJheS5sZW5ndGg7XG5cdFx0XHRncm91cHMucHVzaChncm91cCk7XG5cdFx0fSAvL3BlciB0cmlhbmdsZXMgZ3JvdXBcblxuXHRcdHZhciBtZXNoID0ge1xuXHRcdFx0dmVydGljZXM6IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyc1swXVsxXSksXG5cdFx0XHRpbmZvOiB7IGdyb3VwczogZ3JvdXBzIH0sXG5cdFx0XHRfcmVtYXA6IG5ldyBVaW50MzJBcnJheSh2ZXJ0ZXhfcmVtYXApXG5cdFx0fTtcblxuXHRcdHRoaXMudHJhbnNmb3JtTWVzaEluZm8obWVzaCwgYnVmZmVycywgaW5kaWNlc0FycmF5KTtcblxuXHRcdHJldHVybiBtZXNoO1xuXHR9LFxuXG5cdHJlYWRQb2x5bGlzdDogZnVuY3Rpb24gcmVhZFBvbHlsaXN0KHhtbF9zaGFwZV9yb290LCBzb3VyY2VzKSB7XG5cdFx0dmFyIHVzZV9pbmRpY2VzID0gZmFsc2U7XG5cblx0XHR2YXIgZ3JvdXBzID0gW107XG5cdFx0dmFyIGJ1ZmZlcnMgPSBbXTtcblx0XHR2YXIgbGFzdF9pbmRleCA9IDA7XG5cdFx0dmFyIGZhY2VtYXAgPSB7fTtcblx0XHR2YXIgdmVydGV4X3JlbWFwID0gW107XG5cdFx0dmFyIGluZGljZXNBcnJheSA9IFtdO1xuXHRcdHZhciBsYXN0X3N0YXJ0ID0gMDtcblx0XHR2YXIgZ3JvdXBfbmFtZSA9IFwiXCI7XG5cdFx0dmFyIG1hdGVyaWFsX25hbWUgPSBcIlwiO1xuXG5cdFx0bWF0ZXJpYWxfbmFtZSA9IHhtbF9zaGFwZV9yb290LmdldEF0dHJpYnV0ZShcIm1hdGVyaWFsXCIpO1xuXHRcdGJ1ZmZlcnMgPSB0aGlzLnJlYWRTaGFwZUlucHV0cyh4bWxfc2hhcGVfcm9vdCwgc291cmNlcyk7XG5cblx0XHR2YXIgeG1sdmNvdW50ID0geG1sX3NoYXBlX3Jvb3QucXVlcnlTZWxlY3RvcihcInZjb3VudFwiKTtcblx0XHR2YXIgdmNvdW50ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHZjb3VudCk7XG5cblx0XHR2YXIgeG1scCA9IHhtbF9zaGFwZV9yb290LnF1ZXJ5U2VsZWN0b3IoXCJwXCIpO1xuXHRcdHZhciBkYXRhID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHApO1xuXG5cdFx0dmFyIG51bV9kYXRhX3ZlcnRleCA9IGJ1ZmZlcnMubGVuZ3RoO1xuXG5cdFx0dmFyIHBvcyA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB2Y291bnQubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG5cdFx0XHR2YXIgbnVtX3ZlcnRpY2VzID0gdmNvdW50W2ldO1xuXG5cdFx0XHR2YXIgZmlyc3RfaW5kZXggPSAtMTtcblx0XHRcdHZhciBjdXJyZW50X2luZGV4ID0gLTE7XG5cdFx0XHR2YXIgcHJldl9pbmRleCA9IC0xO1xuXG5cdFx0XHQvL2l0ZXJhdGUgdmVydGljZXMgb2YgdGhpcyBwb2x5Z29uXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IG51bV92ZXJ0aWNlczsgKytrKSB7XG5cdFx0XHRcdHZhciB2ZXJ0ZXhfaWQgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbnVtX2RhdGFfdmVydGV4KS5qb2luKFwiIFwiKTtcblxuXHRcdFx0XHRwcmV2X2luZGV4ID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0aWYgKGZhY2VtYXAuaGFzT3duUHJvcGVydHkodmVydGV4X2lkKSkgLy9hZGQgdG8gYXJyYXlzLCBrZWVwIHRoZSBpbmRleFxuXHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBmYWNlbWFwW3ZlcnRleF9pZF07ZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBidWZmZXJzLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdFx0XHR2YXIgYnVmZmVyID0gYnVmZmVyc1tqXTtcblx0XHRcdFx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KGRhdGFbcG9zICsgal0pOyAvL3Bcblx0XHRcdFx0XHRcdHZhciBhcnJheSA9IGJ1ZmZlclsxXTsgLy9hcnJheSB3aXRoIGFsbCB0aGUgZGF0YVxuXHRcdFx0XHRcdFx0dmFyIHNvdXJjZSA9IGJ1ZmZlclszXTsgLy93aGVyZSB0byByZWFkIHRoZSBkYXRhIGZyb21cblx0XHRcdFx0XHRcdGlmIChqID09IDApIHZlcnRleF9yZW1hcFthcnJheS5sZW5ndGggLyBudW1fZGF0YV92ZXJ0ZXhdID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRpbmRleCAqPSBidWZmZXJbMl07IC8vc3RyaWRlXG5cdFx0XHRcdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IGJ1ZmZlclsyXTsgKyt4KSB7XG5cdFx0XHRcdFx0XHRcdGFycmF5LnB1c2goc291cmNlW2luZGV4ICsgeF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGN1cnJlbnRfaW5kZXggPSBsYXN0X2luZGV4O1xuXHRcdFx0XHRcdGxhc3RfaW5kZXggKz0gMTtcblx0XHRcdFx0XHRmYWNlbWFwW3ZlcnRleF9pZF0gPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG51bV92ZXJ0aWNlcyA+IDMpIC8vc3BsaXQgcG9seWdvbnMgdGhlblxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChrID09IDApIGZpcnN0X2luZGV4ID0gY3VycmVudF9pbmRleDtcblx0XHRcdFx0XHRcdC8vaWYoayA+IDIgKiBudW1fZGF0YV92ZXJ0ZXgpIC8vbm90IHN1cmUgaWYgdXNlIHRoaXMgb3IgdGhlIG5leHQgbGluZSwgdGhlIG5leHQgb25lIHdvcmtzIGluIHNvbWUgREFFcyBidXQgbm90IHN1cmUgaWYgaXQgd29ya3MgaW4gYWxsXG5cdFx0XHRcdFx0XHRpZiAoayA+IDIpIC8vdHJpYW5ndWxhdGUgcG9seWdvbnM6IHRlc3RlZCwgdGhpcyB3b3Jrc1xuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNlc0FycmF5LnB1c2goZmlyc3RfaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHRcdGluZGljZXNBcnJheS5wdXNoKHByZXZfaW5kZXgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZGljZXNBcnJheS5wdXNoKGN1cnJlbnRfaW5kZXgpO1xuXHRcdFx0XHRwb3MgKz0gbnVtX2RhdGFfdmVydGV4O1xuXHRcdFx0fSAvL3BlciB2ZXJ0ZXhcblx0XHR9IC8vcGVyIHBvbHlnb25cblxuXHRcdHZhciBtZXNoID0ge1xuXHRcdFx0dmVydGljZXM6IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyc1swXVsxXSksXG5cdFx0XHRpbmZvOiB7fSxcblx0XHRcdF9yZW1hcDogbmV3IFVpbnQzMkFycmF5KHZlcnRleF9yZW1hcClcblx0XHR9O1xuXG5cdFx0dGhpcy50cmFuc2Zvcm1NZXNoSW5mbyhtZXNoLCBidWZmZXJzLCBpbmRpY2VzQXJyYXkpO1xuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0cmVhZFNoYXBlSW5wdXRzOiBmdW5jdGlvbiByZWFkU2hhcGVJbnB1dHMoeG1sX3NoYXBlX3Jvb3QsIHNvdXJjZXMpIHtcblx0XHR2YXIgYnVmZmVycyA9IFtdO1xuXG5cdFx0dmFyIHhtbGlucHV0cyA9IHhtbF9zaGFwZV9yb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbGlucHV0ID0geG1saW5wdXRzLml0ZW0oaSk7XG5cdFx0XHRpZiAoIXhtbGlucHV0LmdldEF0dHJpYnV0ZSkgY29udGludWU7XG5cdFx0XHR2YXIgc2VtYW50aWMgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0dmFyIHN0cmVhbV9zb3VyY2UgPSBzb3VyY2VzW3htbGlucHV0LmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKS5zdWJzdHIoMSldO1xuXHRcdFx0dmFyIG9mZnNldCA9IHBhcnNlSW50KHhtbGlucHV0LmdldEF0dHJpYnV0ZShcIm9mZnNldFwiKSk7XG5cdFx0XHR2YXIgZGF0YV9zZXQgPSAwO1xuXHRcdFx0aWYgKHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNldFwiKSkgZGF0YV9zZXQgPSBwYXJzZUludCh4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZXRcIikpO1xuXHRcdFx0YnVmZmVycy5wdXNoKFtzZW1hbnRpYywgW10sIHN0cmVhbV9zb3VyY2Uuc3RyaWRlLCBzdHJlYW1fc291cmNlLmRhdGEsIG9mZnNldCwgZGF0YV9zZXRdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYnVmZmVycztcblx0fSxcblxuXHR0cmFuc2Zvcm1NZXNoSW5mbzogZnVuY3Rpb24gdHJhbnNmb3JtTWVzaEluZm8obWVzaCwgYnVmZmVycywgaW5kaWNlc0FycmF5KSB7XG5cdFx0Ly9yZW5hbWUgYnVmZmVycyAoREFFIGhhcyBvdGhlciBuYW1lcylcblx0XHR2YXIgdHJhbnNsYXRvciA9IHtcblx0XHRcdFwibm9ybWFsXCI6IFwibm9ybWFsc1wiLFxuXHRcdFx0XCJ0ZXhjb29yZFwiOiBcImNvb3Jkc1wiXG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciBuYW1lID0gYnVmZmVyc1tpXVswXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIGRhdGEgPSBidWZmZXJzW2ldWzFdO1xuXHRcdFx0aWYgKCFkYXRhLmxlbmd0aCkgY29udGludWU7XG5cblx0XHRcdGlmICh0cmFuc2xhdG9yW25hbWVdKSBuYW1lID0gdHJhbnNsYXRvcltuYW1lXTtcblx0XHRcdGlmIChtZXNoW25hbWVdKSBuYW1lID0gbmFtZSArIGJ1ZmZlcnNbaV1bNV07XG5cdFx0XHRtZXNoW25hbWVdID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTsgLy9hcmUgdGhleSBhbHdheXMgZmxvYXQzMj8gSSB0aGluayBzb1xuXHRcdH1cblxuXHRcdGlmIChpbmRpY2VzQXJyYXkgJiYgaW5kaWNlc0FycmF5Lmxlbmd0aCkge1xuXHRcdFx0aWYgKG1lc2gudmVydGljZXMubGVuZ3RoID4gMjU2ICogMjU2KSBtZXNoLnRyaWFuZ2xlcyA9IG5ldyBVaW50MzJBcnJheShpbmRpY2VzQXJyYXkpO2Vsc2UgbWVzaC50cmlhbmdsZXMgPSBuZXcgVWludDE2QXJyYXkoaW5kaWNlc0FycmF5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWVzaDtcblx0fSxcblxuXHRyZWFkTGluZVN0cmlwOiBmdW5jdGlvbiByZWFkTGluZVN0cmlwKHNvdXJjZXMsIHhtbGxpbmVzdHJpcCkge1xuXHRcdHZhciB1c2VfaW5kaWNlcyA9IGZhbHNlO1xuXG5cdFx0dmFyIGJ1ZmZlcnMgPSBbXTtcblx0XHR2YXIgbGFzdF9pbmRleCA9IDA7XG5cdFx0dmFyIGZhY2VtYXAgPSB7fTtcblx0XHR2YXIgdmVydGV4X3JlbWFwID0gW107XG5cdFx0dmFyIGluZGljZXNBcnJheSA9IFtdO1xuXHRcdHZhciBsYXN0X3N0YXJ0ID0gMDtcblx0XHR2YXIgZ3JvdXBfbmFtZSA9IFwiXCI7XG5cdFx0dmFyIG1hdGVyaWFsX25hbWUgPSBcIlwiO1xuXG5cdFx0dmFyIHRyaXMgPSAwOyAvL3VzZWQgaW4gY2FzZSB0aGVyZSBhcmUgc2V2ZXJhbCBzdHJpcHNcblxuXHRcdC8vZm9yIGVhY2ggYnVmZmVyIChpbnB1dCkgYnVpbGQgdGhlIHN0cnVjdHVyZSBpbmZvXG5cdFx0dmFyIHhtbGlucHV0cyA9IHhtbGxpbmVzdHJpcC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cdFx0aWYgKHRyaXMgPT0gMCkgLy9maXJzdCBpdGVyYXRpb24sIGNyZWF0ZSBidWZmZXJzXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHMuaXRlbShpKTtcblx0XHRcdFx0aWYgKCF4bWxpbnB1dC5nZXRBdHRyaWJ1dGUpIGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgc2VtYW50aWMgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgc3RyZWFtX3NvdXJjZSA9IHNvdXJjZXNbeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0XHRcdHZhciBvZmZzZXQgPSBwYXJzZUludCh4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJvZmZzZXRcIikpO1xuXHRcdFx0XHR2YXIgZGF0YV9zZXQgPSAwO1xuXHRcdFx0XHRpZiAoeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2V0XCIpKSBkYXRhX3NldCA9IHBhcnNlSW50KHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNldFwiKSk7XG5cblx0XHRcdFx0YnVmZmVycy5wdXNoKFtzZW1hbnRpYywgW10sIHN0cmVhbV9zb3VyY2Uuc3RyaWRlLCBzdHJlYW1fc291cmNlLmRhdGEsIG9mZnNldCwgZGF0YV9zZXRdKTtcblx0XHRcdH1cblx0XHQvL2Fzc3VtaW5nIGJ1ZmZlcnMgYXJlIG9yZGVyZWQgYnkgb2Zmc2V0XG5cblx0XHQvL2l0ZXJhdGUgZGF0YVxuXHRcdHZhciB4bWxwcyA9IHhtbGxpbmVzdHJpcC5xdWVyeVNlbGVjdG9yQWxsKFwicFwiKTtcblx0XHR2YXIgbnVtX2RhdGFfdmVydGV4ID0gYnVmZmVycy5sZW5ndGg7IC8vb25lIHZhbHVlIHBlciBpbnB1dCBidWZmZXJcblxuXHRcdC8vZm9yIGV2ZXJ5IHBvbHlnb24gKGNvdWxkIGJlIG9uZSB3aXRoIGFsbCB0aGUgaW5kaWNlcywgY291bGQgYmUgc2V2ZXJhbCwgZGVwZW5kcyBvbiB0aGUgcHJvZ3JhbSlcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbHBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1scCA9IHhtbHBzLml0ZW0oaSk7XG5cdFx0XHRpZiAoIXhtbHAgfHwgIXhtbHAudGV4dENvbnRlbnQpIGJyZWFrO1xuXG5cdFx0XHR2YXIgZGF0YSA9IHhtbHAudGV4dENvbnRlbnQudHJpbSgpLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0Ly91c2VkIGZvciB0cmlhbmd1bGF0ZSBwb2x5c1xuXHRcdFx0dmFyIGZpcnN0X2luZGV4ID0gLTE7XG5cdFx0XHR2YXIgY3VycmVudF9pbmRleCA9IC0xO1xuXHRcdFx0dmFyIHByZXZfaW5kZXggPSAtMTtcblxuXHRcdFx0Ly9pZih1c2VfaW5kaWNlcyAmJiBsYXN0X2luZGV4ID49IDI1NioyNTYpXG5cdFx0XHQvL1x0YnJlYWs7XG5cblx0XHRcdC8vZm9yIGV2ZXJ5IHBhY2sgb2YgaW5kaWNlcyBpbiB0aGUgcG9seWdvbiAodmVydGV4LCBub3JtYWwsIHV2LCAuLi4gKVxuXHRcdFx0Zm9yICh2YXIgayA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgayA8IGw7IGsgKz0gbnVtX2RhdGFfdmVydGV4KSB7XG5cdFx0XHRcdHZhciB2ZXJ0ZXhfaWQgPSBkYXRhLnNsaWNlKGssIGsgKyBudW1fZGF0YV92ZXJ0ZXgpLmpvaW4oXCIgXCIpOyAvL2dlbmVyYXRlIHVuaXF1ZSBpZFxuXG5cdFx0XHRcdHByZXZfaW5kZXggPSBjdXJyZW50X2luZGV4O1xuXHRcdFx0XHRpZiAoZmFjZW1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhfaWQpKSAvL2FkZCB0byBhcnJheXMsIGtlZXAgdGhlIGluZGV4XG5cdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGZhY2VtYXBbdmVydGV4X2lkXTtlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdHZhciBidWZmZXIgPSBidWZmZXJzW2pdO1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoZGF0YVtrICsgal0pO1xuXHRcdFx0XHRcdFx0dmFyIGFycmF5ID0gYnVmZmVyWzFdOyAvL2FycmF5IHdpdGggYWxsIHRoZSBkYXRhXG5cdFx0XHRcdFx0XHR2YXIgc291cmNlID0gYnVmZmVyWzNdOyAvL3doZXJlIHRvIHJlYWQgdGhlIGRhdGEgZnJvbVxuXHRcdFx0XHRcdFx0aWYgKGogPT0gMCkgdmVydGV4X3JlbWFwW2FycmF5Lmxlbmd0aCAvIG51bV9kYXRhX3ZlcnRleF0gPSBpbmRleDtcblx0XHRcdFx0XHRcdGluZGV4ICo9IGJ1ZmZlclsyXTsgLy9zdHJpZGVcblx0XHRcdFx0XHRcdGZvciAodmFyIHggPSAwOyB4IDwgYnVmZmVyWzJdOyArK3gpIHtcblx0XHRcdFx0XHRcdFx0YXJyYXkucHVzaChzb3VyY2VbaW5kZXggKyB4XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y3VycmVudF9pbmRleCA9IGxhc3RfaW5kZXg7XG5cdFx0XHRcdFx0bGFzdF9pbmRleCArPSAxO1xuXHRcdFx0XHRcdGZhY2VtYXBbdmVydGV4X2lkXSA9IGN1cnJlbnRfaW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRpY2VzQXJyYXkucHVzaChjdXJyZW50X2luZGV4KTtcblx0XHRcdH0gLy9wZXIgdmVydGV4XG5cdFx0fSAvL3BlciBwb2x5Z29uXG5cblx0XHR2YXIgbWVzaCA9IHtcblx0XHRcdHByaW1pdGl2ZTogXCJsaW5lX3N0cmlwXCIsXG5cdFx0XHR2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheShidWZmZXJzWzBdWzFdKSxcblx0XHRcdGluZm86IHt9XG5cdFx0fTtcblxuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybU1lc2hJbmZvKG1lc2gsIGJ1ZmZlcnMsIGluZGljZXNBcnJheSk7XG5cdH0sXG5cblx0Ly9saWtlIHF1ZXJ5U2VsZWN0b3IgYnV0IGFsbG93cyBzcGFjZXMgaW4gbmFtZXMgYmVjYXVzZSBDT0xMQURBIGFsbG93cyBzcGFjZSBpbiBuYW1lc1xuXHRmaW5kWE1MTm9kZUJ5SWQ6IGZ1bmN0aW9uIGZpbmRYTUxOb2RlQnlJZChyb290LCBub2RlbmFtZSwgaWQpIHtcblx0XHQvL3ByZWNvbXB1dGVkXG5cdFx0aWYgKHRoaXMuX3htbHJvb3QuX25vZGVzX2J5X2lkKSB7XG5cdFx0XHR2YXIgbiA9IHRoaXMuX3htbHJvb3QuX25vZGVzX2J5X2lkW2lkXTtcblx0XHRcdGlmIChuICYmIG4ubG9jYWxOYW1lID09IG5vZGVuYW1lKSByZXR1cm4gbjtcblx0XHR9IGVsc2UgLy9mb3IgdGhlIG5hdGl2ZSBwYXJzZXJcblx0XHRcdHtcblx0XHRcdFx0dmFyIG4gPSB0aGlzLl94bWxyb290LmdldEVsZW1lbnRCeUlkKGlkKTtcblx0XHRcdFx0aWYgKG4pIHJldHVybiBuO1xuXHRcdFx0fVxuXG5cdFx0Ly9yZWN1cnNpdmU6IHNsb3dcblx0XHR2YXIgY2hpbGRzID0gcm9vdC5jaGlsZE5vZGVzO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgeG1sbm9kZSA9IGNoaWxkcy5pdGVtKGkpO1xuXHRcdFx0aWYgKHhtbG5vZGUubm9kZVR5cGUgIT0gMSkgLy9ubyB0YWdcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRpZiAoeG1sbm9kZS5sb2NhbE5hbWUgIT0gbm9kZW5hbWUpIGNvbnRpbnVlO1xuXHRcdFx0dmFyIG5vZGVfaWQgPSB4bWxub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpO1xuXHRcdFx0aWYgKG5vZGVfaWQgPT0gaWQpIHJldHVybiB4bWxub2RlO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRyZWFkSW1hZ2VzOiBmdW5jdGlvbiByZWFkSW1hZ2VzKHJvb3QpIHtcblx0XHR2YXIgeG1saW1hZ2VzID0gcm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9pbWFnZXNcIik7XG5cdFx0aWYgKCF4bWxpbWFnZXMpIHJldHVybiBudWxsO1xuXG5cdFx0dmFyIGltYWdlcyA9IHt9O1xuXG5cdFx0dmFyIHhtbGltYWdlc19jaGlsZHMgPSB4bWxpbWFnZXMuY2hpbGROb2Rlcztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGltYWdlc19jaGlsZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB4bWxpbWFnZSA9IHhtbGltYWdlc19jaGlsZHMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxpbWFnZS5ub2RlVHlwZSAhPSAxKSAvL25vIHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0dmFyIHhtbGluaXRmcm9tID0geG1saW1hZ2UucXVlcnlTZWxlY3RvcihcImluaXRfZnJvbVwiKTtcblx0XHRcdGlmICgheG1saW5pdGZyb20pIGNvbnRpbnVlO1xuXHRcdFx0aWYgKHhtbGluaXRmcm9tLnRleHRDb250ZW50KSB7XG5cdFx0XHRcdHZhciBmaWxlbmFtZSA9IHRoaXMuZ2V0RmlsZW5hbWUoeG1saW5pdGZyb20udGV4dENvbnRlbnQpO1xuXHRcdFx0XHR2YXIgaWQgPSB4bWxpbWFnZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdFx0aW1hZ2VzW2lkXSA9IHsgZmlsZW5hbWU6IGZpbGVuYW1lLCBtYXA6IGlkLCBuYW1lOiB4bWxpbWFnZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpLCBwYXRoOiB4bWxpbml0ZnJvbS50ZXh0Q29udGVudCB9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbWFnZXM7XG5cdH0sXG5cblx0cmVhZEFuaW1hdGlvbnM6IGZ1bmN0aW9uIHJlYWRBbmltYXRpb25zKHJvb3QsIHNjZW5lKSB7XG5cdFx0dmFyIHhtbGFuaW1hdGlvbnMgPSByb290LnF1ZXJ5U2VsZWN0b3IoXCJsaWJyYXJ5X2FuaW1hdGlvbnNcIik7XG5cdFx0aWYgKCF4bWxhbmltYXRpb25zKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciB4bWxhbmltYXRpb25fY2hpbGRzID0geG1sYW5pbWF0aW9ucy5jaGlsZE5vZGVzO1xuXG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB7XG5cdFx0XHRvYmplY3RfdHlwZTogXCJBbmltYXRpb25cIixcblx0XHRcdHRha2VzOiB7fVxuXHRcdH07XG5cblx0XHR2YXIgZGVmYXVsdF90YWtlID0geyB0cmFja3M6IFtdIH07XG5cdFx0dmFyIHRyYWNrcyA9IGRlZmF1bHRfdGFrZS50cmFja3M7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGFuaW1hdGlvbl9jaGlsZHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciB4bWxhbmltYXRpb24gPSB4bWxhbmltYXRpb25fY2hpbGRzLml0ZW0oaSk7XG5cdFx0XHRpZiAoeG1sYW5pbWF0aW9uLm5vZGVUeXBlICE9IDEgfHwgeG1sYW5pbWF0aW9uLmxvY2FsTmFtZSAhPSBcImFuaW1hdGlvblwiKSAvL25vIHRhZ1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0dmFyIGFuaW1faWQgPSB4bWxhbmltYXRpb24uZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cdFx0XHRpZiAoIWFuaW1faWQpIC8vbmVzdGVkIGFuaW1hdGlvbiAoREFFIDEuNSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciB4bWxhbmltYXRpb24yX2NoaWxkcyA9IHhtbGFuaW1hdGlvbi5xdWVyeVNlbGVjdG9yQWxsKFwiYW5pbWF0aW9uXCIpO1xuXHRcdFx0XHRcdGlmICh4bWxhbmltYXRpb24yX2NoaWxkcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgeG1sYW5pbWF0aW9uMl9jaGlsZHMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0XHRcdFx0dmFyIHhtbGFuaW1hdGlvbjIgPSB4bWxhbmltYXRpb24yX2NoaWxkcy5pdGVtKGopO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlYWRBbmltYXRpb24oeG1sYW5pbWF0aW9uMiwgdHJhY2tzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgLy9zb3VyY2UgdHJhY2tzP1xuXHRcdFx0XHRcdFx0dGhpcy5yZWFkQW5pbWF0aW9uKHhtbGFuaW1hdGlvbiwgdHJhY2tzKTtcblx0XHRcdFx0fSBlbHNlIC8vbm8gbmVzdGVkIChEQUUgMS40KVxuXHRcdFx0XHR0aGlzLnJlYWRBbmltYXRpb24oeG1sYW5pbWF0aW9uLCB0cmFja3MpO1xuXHRcdH1cblxuXHRcdGlmICghdHJhY2tzLmxlbmd0aCkgcmV0dXJuIG51bGw7IC8vZW1wdHkgYW5pbWF0aW9uXG5cblx0XHQvL2NvbXB1dGUgYW5pbWF0aW9uIGR1cmF0aW9uXG5cdFx0dmFyIG1heF90aW1lID0gMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0aWYgKG1heF90aW1lIDwgdHJhY2tzW2ldLmR1cmF0aW9uKSBtYXhfdGltZSA9IHRyYWNrc1tpXS5kdXJhdGlvbjtcblx0XHR9ZGVmYXVsdF90YWtlLm5hbWUgPSBcImRlZmF1bHRcIjtcblx0XHRkZWZhdWx0X3Rha2UuZHVyYXRpb24gPSBtYXhfdGltZTtcblx0XHRhbmltYXRpb25zLnRha2VzW2RlZmF1bHRfdGFrZS5uYW1lXSA9IGRlZmF1bHRfdGFrZTtcblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0fSxcblxuXHQvL2FuaW1hdGlvbiB4bWxcblx0cmVhZEFuaW1hdGlvbjogZnVuY3Rpb24gcmVhZEFuaW1hdGlvbih4bWxhbmltYXRpb24sIHJlc3VsdCkge1xuXHRcdGlmICh4bWxhbmltYXRpb24ubG9jYWxOYW1lICE9IFwiYW5pbWF0aW9uXCIpIHJldHVybiBudWxsO1xuXG5cdFx0Ly90aGlzIGNvdWxkIGJlIG1pc3Npbmcgd2hlbiB0aGVyZSBhcmUgbG90cyBvZiBhbmltcyBwYWNrZWQgaW4gb25lIDxhbmltYXRpb24+XG5cdFx0dmFyIGFuaW1faWQgPSB4bWxhbmltYXRpb24uZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cblx0XHQvL2NoYW5uZWxzIGFyZSBsaWtlIGFuaW1hdGVkIHByb3BlcnRpZXNcblx0XHR2YXIgeG1sY2hhbm5lbF9saXN0ID0geG1sYW5pbWF0aW9uLnF1ZXJ5U2VsZWN0b3JBbGwoXCJjaGFubmVsXCIpO1xuXHRcdGlmICgheG1sY2hhbm5lbF9saXN0Lmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgdHJhY2tzID0gcmVzdWx0IHx8IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxjaGFubmVsX2xpc3QubGVuZ3RoOyArK2kpIHtcblx0XHRcdHZhciBhbmltID0gdGhpcy5yZWFkQ2hhbm5lbCh4bWxjaGFubmVsX2xpc3QuaXRlbShpKSwgeG1sYW5pbWF0aW9uKTtcblx0XHRcdGlmIChhbmltKSB0cmFja3MucHVzaChhbmltKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJhY2tzO1xuXHR9LFxuXG5cdHJlYWRDaGFubmVsOiBmdW5jdGlvbiByZWFkQ2hhbm5lbCh4bWxjaGFubmVsLCB4bWxhbmltYXRpb24pIHtcblx0XHRpZiAoeG1sY2hhbm5lbC5sb2NhbE5hbWUgIT0gXCJjaGFubmVsXCIgfHwgeG1sYW5pbWF0aW9uLmxvY2FsTmFtZSAhPSBcImFuaW1hdGlvblwiKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzb3VyY2UgPSB4bWxjaGFubmVsLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKTtcblx0XHR2YXIgdGFyZ2V0ID0geG1sY2hhbm5lbC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG5cblx0XHQvL3NhbXBsZXIsIGlzIGluIGNoYXJnZSBvZiB0aGUgaW50ZXJwb2xhdGlvblxuXHRcdC8vdmFyIHhtbHNhbXBsZXIgPSB4bWxhbmltYXRpb24ucXVlcnlTZWxlY3RvcihcInNhbXBsZXJcIiArIHNvdXJjZSk7XG5cdFx0dmFyIHhtbHNhbXBsZXIgPSB0aGlzLmZpbmRYTUxOb2RlQnlJZCh4bWxhbmltYXRpb24sIFwic2FtcGxlclwiLCBzb3VyY2Uuc3Vic3RyKDEpKTtcblx0XHRpZiAoIXhtbHNhbXBsZXIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBEQUU6IFNhbXBsZXIgbm90IGZvdW5kIGluIFwiICsgc291cmNlKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBpbnB1dHMgPSB7fTtcblx0XHR2YXIgcGFyYW1zID0ge307XG5cdFx0dmFyIHNvdXJjZXMgPSB7fTtcblx0XHR2YXIgeG1saW5wdXRzID0geG1sc2FtcGxlci5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cblx0XHR2YXIgdGltZV9kYXRhID0gbnVsbDtcblxuXHRcdC8vaXRlcmF0ZSBpbnB1dHM6IGNvbGxhZGEgc2VwYXJhdGVzIHRoZSBrZXlmcmFtZSBpbmZvIGluIGluZGVwZW5kZW50IHN0cmVhbXMsIGxpa2UgdGltZSwgaW50ZXJwb2xhdGlvbiBtZXRob2QsIHZhbHVlIClcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHhtbGlucHV0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIHhtbGlucHV0ID0geG1saW5wdXRzLml0ZW0oaik7XG5cdFx0XHR2YXIgc291cmNlX25hbWUgPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIik7XG5cblx0XHRcdC8vdGhlcmUgYXJlIHRocmVlIFxuXHRcdFx0dmFyIHNlbWFudGljID0geG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIik7XG5cblx0XHRcdC8vU2VhcmNoIGZvciBzb3VyY2Vcblx0XHRcdHZhciB4bWxzb3VyY2UgPSB0aGlzLmZpbmRYTUxOb2RlQnlJZCh4bWxhbmltYXRpb24sIFwic291cmNlXCIsIHNvdXJjZV9uYW1lLnN1YnN0cigxKSk7XG5cdFx0XHRpZiAoIXhtbHNvdXJjZSkgY29udGludWU7XG5cblx0XHRcdHZhciB4bWxwYXJhbSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwicGFyYW1cIik7XG5cdFx0XHRpZiAoIXhtbHBhcmFtKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIHR5cGUgPSB4bWxwYXJhbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXHRcdFx0aW5wdXRzW3NlbWFudGljXSA9IHsgc291cmNlOiBzb3VyY2VfbmFtZSwgdHlwZTogdHlwZSB9O1xuXG5cdFx0XHR2YXIgZGF0YV9hcnJheSA9IG51bGw7XG5cblx0XHRcdGlmICh0eXBlID09IFwiZmxvYXRcIiB8fCB0eXBlID09IFwiZmxvYXQ0eDRcIikge1xuXHRcdFx0XHR2YXIgeG1sZmxvYXRhcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiZmxvYXRfYXJyYXlcIik7XG5cdFx0XHRcdHZhciBmbG9hdHMgPSB0aGlzLnJlYWRDb250ZW50QXNGbG9hdHMoeG1sZmxvYXRhcnJheSk7XG5cdFx0XHRcdHNvdXJjZXNbc291cmNlX25hbWVdID0gZmxvYXRzO1xuXHRcdFx0XHRkYXRhX2FycmF5ID0gZmxvYXRzO1xuXHRcdFx0fSBlbHNlIC8vb25seSBmbG9hdHMgYW5kIG1hdHJpY2VzIGFyZSBzdXBwb3J0ZWQgaW4gYW5pbWF0aW9uXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgcGFyYW1fbmFtZSA9IHhtbHBhcmFtLmdldEF0dHJpYnV0ZShcIm5hbWVcIik7XG5cdFx0XHRpZiAocGFyYW1fbmFtZSA9PSBcIlRJTUVcIikgdGltZV9kYXRhID0gZGF0YV9hcnJheTtcblx0XHRcdGlmIChzZW1hbnRpYyA9PSBcIk9VVFBVVFwiKSBwYXJhbV9uYW1lID0gc2VtYW50aWM7XG5cdFx0XHRpZiAocGFyYW1fbmFtZSkgcGFyYW1zW3BhcmFtX25hbWVdID0gdHlwZTtlbHNlIGNvbnNvbGUud2FybihcIkNvbGxhZGE6IDxwYXJhbT4gd2l0aG91dCBuYW1lIGF0dHJpYnV0ZSBpbiA8YW5pbWF0aW9uPlwiKTtcblx0XHR9XG5cblx0XHRpZiAoIXRpbWVfZGF0YSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIERBRTogbm8gVElNRSBpbmZvIGZvdW5kIGluIDxjaGFubmVsPjogXCIgKyB4bWxjaGFubmVsLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL2NvbnN0cnVjdCBhbmltYXRpb25cblx0XHR2YXIgcGF0aCA9IHRhcmdldC5zcGxpdChcIi9cIik7XG5cblx0XHR2YXIgYW5pbSA9IHt9O1xuXHRcdHZhciBub2RlbmFtZSA9IHBhdGhbMF07IC8vc2FmZVN0cmluZyA/XG5cdFx0dmFyIG5vZGUgPSB0aGlzLl9ub2Rlc19ieV9pZFtub2RlbmFtZV07XG5cdFx0dmFyIGxvY2F0b3IgPSBub2RlLmlkICsgXCIvXCIgKyBwYXRoWzFdO1xuXHRcdC8vYW5pbS5ub2RlbmFtZSA9IHRoaXMuc2FmZVN0cmluZyggcGF0aFswXSApOyAvL3doZXJlIGl0IGdvZXNcblx0XHRhbmltLm5hbWUgPSBwYXRoWzFdO1xuXHRcdGFuaW0ucHJvcGVydHkgPSBsb2NhdG9yO1xuXHRcdHZhciB0eXBlID0gXCJudW1iZXJcIjtcblx0XHR2YXIgZWxlbWVudF9zaXplID0gMTtcblx0XHR2YXIgcGFyYW1fdHlwZSA9IHBhcmFtc1tcIk9VVFBVVFwiXTtcblx0XHRzd2l0Y2ggKHBhcmFtX3R5cGUpIHtcblx0XHRcdGNhc2UgXCJmbG9hdFwiOlxuXHRcdFx0XHRlbGVtZW50X3NpemUgPSAxO2JyZWFrO1xuXHRcdFx0Y2FzZSBcImZsb2F0M3gzXCI6XG5cdFx0XHRcdGVsZW1lbnRfc2l6ZSA9IDk7dHlwZSA9IFwibWF0M1wiO2JyZWFrO1xuXHRcdFx0Y2FzZSBcImZsb2F0NHg0XCI6XG5cdFx0XHRcdGVsZW1lbnRfc2l6ZSA9IDE2O3R5cGUgPSBcIm1hdDRcIjticmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGFuaW0udHlwZSA9IHR5cGU7XG5cdFx0YW5pbS52YWx1ZV9zaXplID0gZWxlbWVudF9zaXplO1xuXHRcdGFuaW0uZHVyYXRpb24gPSB0aW1lX2RhdGFbdGltZV9kYXRhLmxlbmd0aCAtIDFdOyAvL2xhc3Qgc2FtcGxlXG5cblx0XHR2YXIgdmFsdWVfZGF0YSA9IHNvdXJjZXNbaW5wdXRzW1wiT1VUUFVUXCJdLnNvdXJjZV07XG5cdFx0aWYgKCF2YWx1ZV9kYXRhKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vUGFjayBkYXRhICoqKioqKioqKioqKioqKipcblx0XHR2YXIgbnVtX3NhbXBsZXMgPSB0aW1lX2RhdGEubGVuZ3RoO1xuXHRcdHZhciBzYW1wbGVfc2l6ZSA9IGVsZW1lbnRfc2l6ZSArIDE7XG5cdFx0dmFyIGFuaW1fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobnVtX3NhbXBsZXMgKiBzYW1wbGVfc2l6ZSk7XG5cdFx0Ly9mb3IgZXZlcnkgc2FtcGxlXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB0aW1lX2RhdGEubGVuZ3RoOyArK2opIHtcblx0XHRcdGFuaW1fZGF0YVtqICogc2FtcGxlX3NpemVdID0gdGltZV9kYXRhW2pdOyAvL3NldCB0aW1lXG5cdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZV9kYXRhLnN1YmFycmF5KGogKiBlbGVtZW50X3NpemUsIChqICsgMSkgKiBlbGVtZW50X3NpemUpO1xuXHRcdFx0aWYgKHBhcmFtX3R5cGUgPT0gXCJmbG9hdDR4NFwiKSB7XG5cdFx0XHRcdHRoaXMudHJhbnNmb3JtTWF0cml4KHZhbHVlLCBub2RlID8gbm9kZS5fZGVwdGggPT0gMCA6IDApO1xuXHRcdFx0XHQvL21hdDQudHJhbnNwb3NlKHZhbHVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRhbmltX2RhdGEuc2V0KHZhbHVlLCBqICogc2FtcGxlX3NpemUgKyAxKTsgLy9zZXQgZGF0YVxuXHRcdH1cblxuXHRcdGlmIChpc1dvcmtlciAmJiB0aGlzLnVzZV90cmFuc2ZlcmFibGVzKSB7XG5cdFx0XHR2YXIgZGF0YSA9IGFuaW1fZGF0YTtcblx0XHRcdGlmIChkYXRhICYmIGRhdGEuYnVmZmVyICYmIGRhdGEubGVuZ3RoID4gMTAwKSB0aGlzLl90cmFuc2ZlcmFibGVzLnB1c2goZGF0YS5idWZmZXIpO1xuXHRcdH1cblxuXHRcdGFuaW0uZGF0YSA9IGFuaW1fZGF0YTtcblx0XHRyZXR1cm4gYW5pbTtcblx0fSxcblxuXHRmaW5kTm9kZTogZnVuY3Rpb24gZmluZE5vZGUocm9vdCwgaWQpIHtcblx0XHRpZiAocm9vdC5pZCA9PSBpZCkgcmV0dXJuIHJvb3Q7XG5cdFx0aWYgKHJvb3QuY2hpbGRyZW4pIGZvciAodmFyIGkgaW4gcm9vdC5jaGlsZHJlbikge1xuXHRcdFx0dmFyIHJldCA9IHRoaXMuZmluZE5vZGUocm9vdC5jaGlsZHJlbltpXSwgaWQpO1xuXHRcdFx0aWYgKHJldCkgcmV0dXJuIHJldDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Ly9yZWFkcyBjb250cm9sbGVycyBhbmQgc3RvcmVzIHRoZW0gaW4gXG5cdHJlYWRMaWJyYXJ5Q29udHJvbGxlcnM6IGZ1bmN0aW9uIHJlYWRMaWJyYXJ5Q29udHJvbGxlcnMoc2NlbmUpIHtcblx0XHR2YXIgeG1sbGlicmFyeWNvbnRyb2xsZXJzID0gdGhpcy5feG1scm9vdC5xdWVyeVNlbGVjdG9yKFwibGlicmFyeV9jb250cm9sbGVyc1wiKTtcblx0XHRpZiAoIXhtbGxpYnJhcnljb250cm9sbGVycykgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgeG1sbGlicmFyeWNvbnRyb2xsZXJzX2NoaWxkcyA9IHhtbGxpYnJhcnljb250cm9sbGVycy5jaGlsZE5vZGVzO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWxsaWJyYXJ5Y29udHJvbGxlcnNfY2hpbGRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHR2YXIgeG1sY29udHJvbGxlciA9IHhtbGxpYnJhcnljb250cm9sbGVyc19jaGlsZHMuaXRlbShpKTtcblx0XHRcdGlmICh4bWxjb250cm9sbGVyLm5vZGVUeXBlICE9IDEgfHwgeG1sY29udHJvbGxlci5sb2NhbE5hbWUgIT0gXCJjb250cm9sbGVyXCIpIC8vbm8gdGFnXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIGlkID0geG1sY29udHJvbGxlci5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHRcdC8vd2UgaGF2ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGlzIGNvbnRyb2xsZXJcblx0XHRcdGlmICh0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF0pIGNvbnRpbnVlO1xuXG5cdFx0XHQvL3JlYWQgaXQgKHdlIHdvbnQgdXNlIHRoZSByZXR1cm5zLCB3ZSB3aWxsIGdldCBpdCBmcm9tIHRoaXMuX2NvbnRyb2xsZXJzX2ZvdW5kXG5cdFx0XHR0aGlzLnJlYWRDb250cm9sbGVyKHhtbGNvbnRyb2xsZXIsIG51bGwsIHNjZW5lKTtcblx0XHR9XG5cdH0sXG5cblx0Ly91c2VkIGZvciBza2lubmluZyBhbmQgbW9ycGhpbmdcblx0cmVhZENvbnRyb2xsZXI6IGZ1bmN0aW9uIHJlYWRDb250cm9sbGVyKHhtbGNvbnRyb2xsZXIsIGZsaXAsIHNjZW5lKSB7XG5cdFx0aWYgKCF4bWxjb250cm9sbGVyLmxvY2FsTmFtZSA9PSBcImNvbnRyb2xsZXJcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKFwicmVhZENvbnRyb2xsZXI6IG5vdCBhIGNvbnRyb2xsZXI6IFwiICsgeG1sY29udHJvbGxlci5sb2NhbE5hbWUpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0geG1sY29udHJvbGxlci5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtcblx0XHQvL3VzZSBjYWNoZWRcblx0XHRpZiAodGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdKSByZXR1cm4gdGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdO1xuXG5cdFx0Ly9BR1VJTEFcblx0XHQvL1RPRE86IGRvZXMgdGhpcyB3b3JrP1xuXHRcdC8vIGlmICh0aGlzLl9jb250cm9sbGVyc19mb3VuZFsgaWQgXSlcblx0XHQvLyBcdHJldHVybiB0aGlzLl9jb250cm9sbGVyc19mb3VuZFsgaWQgXTtcblxuXHRcdHZhciB1c2VfaW5kaWNlcyA9IGZhbHNlO1xuXHRcdHZhciBtZXNoID0gbnVsbDtcblx0XHR2YXIgeG1sc2tpbiA9IHhtbGNvbnRyb2xsZXIucXVlcnlTZWxlY3RvcihcInNraW5cIik7XG5cdFx0aWYgKHhtbHNraW4pIHtcblx0XHRcdG1lc2ggPSB0aGlzLnJlYWRTa2luQ29udHJvbGxlcih4bWxza2luLCBmbGlwLCBzY2VuZSk7XG5cdFx0fVxuXG5cdFx0dmFyIHhtbG1vcnBoID0geG1sY29udHJvbGxlci5xdWVyeVNlbGVjdG9yKFwibW9ycGhcIik7XG5cdFx0aWYgKHhtbG1vcnBoKSBtZXNoID0gdGhpcy5yZWFkTW9ycGhDb250cm9sbGVyKHhtbG1vcnBoLCBmbGlwLCBzY2VuZSwgbWVzaCk7XG5cblx0XHQvL2NhY2hlIGFuZCByZXR1cm5cblx0XHRpZiAodGhpcy5fY29udHJvbGxlcnNfZm91bmRbaWRdKSB7XG5cdFx0XHRpZCArPSBcIl8xYmxhaFwiOyAvLz8/PyB0aGlzIGRvZXNudCBkbyBhbnl0aGluZ1xuXHRcdH0gZWxzZSB0aGlzLl9jb250cm9sbGVyc19mb3VuZFtpZF0gPSBtZXNoO1xuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0Ly9yZWFkIHRoaXMgdG8gbW9yZSBpbmZvIGFib3V0IERBRSBhbmQgc2tpbm5pbmcgaHR0cHM6Ly9jb2xsYWRhLm9yZy9tZWRpYXdpa2kvaW5kZXgucGhwL1NraW5uaW5nXG5cdHJlYWRTa2luQ29udHJvbGxlcjogZnVuY3Rpb24gcmVhZFNraW5Db250cm9sbGVyKHhtbHNraW4sIGZsaXAsIHNjZW5lKSB7XG5cdFx0Ly9iYXNlIGdlb21ldHJ5XG5cdFx0dmFyIGlkX2dlb21ldHJ5ID0geG1sc2tpbi5nZXRBdHRyaWJ1dGUoXCJzb3VyY2VcIik7XG5cblx0XHR2YXIgbWVzaCA9IHRoaXMucmVhZEdlb21ldHJ5KGlkX2dlb21ldHJ5LCBmbGlwLCBzY2VuZSk7XG5cdFx0aWYgKCFtZXNoKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzb3VyY2VzID0gdGhpcy5yZWFkU291cmNlcyh4bWxza2luLCBmbGlwKTtcblx0XHRpZiAoIXNvdXJjZXMpIHJldHVybiBudWxsO1xuXG5cdFx0Ly9tYXRyaXhcblx0XHR2YXIgYmluZF9tYXRyaXggPSBudWxsO1xuXHRcdHZhciB4bWxiaW5kbWF0cml4ID0geG1sc2tpbi5xdWVyeVNlbGVjdG9yKFwiYmluZF9zaGFwZV9tYXRyaXhcIik7XG5cdFx0aWYgKHhtbGJpbmRtYXRyaXgpIHtcblx0XHRcdGJpbmRfbWF0cml4ID0gdGhpcy5yZWFkQ29udGVudEFzRmxvYXRzKHhtbGJpbmRtYXRyaXgpO1xuXHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgoYmluZF9tYXRyaXgsIHRydWUsIHRydWUpO1xuXHRcdH0gZWxzZSBiaW5kX21hdHJpeCA9IF9nbE1hdHJpeC5tYXQ0LmNyZWF0ZSgpOyAvL2lkZW50aXR5XG5cblx0XHQvL2pvaW50c1xuXHRcdHZhciBqb2ludHMgPSBbXTtcblx0XHR2YXIgeG1sam9pbnRzID0geG1sc2tpbi5xdWVyeVNlbGVjdG9yKFwiam9pbnRzXCIpO1xuXHRcdGlmICh4bWxqb2ludHMpIHtcblx0XHRcdHZhciBqb2ludHNfc291cmNlID0gbnVsbDsgLy93aGljaCBib25lc1xuXHRcdFx0dmFyIGludl9iaW5kX3NvdXJjZSA9IG51bGw7IC8vYmluZCBtYXRyaWNlc1xuXHRcdFx0dmFyIHhtbGlucHV0cyA9IHhtbGpvaW50cy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHhtbGlucHV0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHNbaV07XG5cdFx0XHRcdHZhciBzZW0gPSB4bWxpbnB1dC5nZXRBdHRyaWJ1dGUoXCJzZW1hbnRpY1wiKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR2YXIgc3JjID0geG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpO1xuXHRcdFx0XHR2YXIgc291cmNlID0gc291cmNlc1tzcmMuc3Vic3RyKDEpXTtcblx0XHRcdFx0aWYgKHNlbSA9PSBcIkpPSU5UXCIpIGpvaW50c19zb3VyY2UgPSBzb3VyY2U7ZWxzZSBpZiAoc2VtID09IFwiSU5WX0JJTkRfTUFUUklYXCIpIGludl9iaW5kX3NvdXJjZSA9IHNvdXJjZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9zYXZlIGJvbmUgbmFtZXMgYW5kIGludiBtYXRyaXhcblx0XHRcdGlmICghaW52X2JpbmRfc291cmNlIHx8ICFqb2ludHNfc291cmNlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBEQUU6IG5vIGpvaW50cyBvciBpbnZfYmluZCBzb3VyY2VzIGZvdW5kXCIpO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSBpbiBqb2ludHNfc291cmNlKSB7XG5cdFx0XHRcdC8vZ2V0IHRoZSBpbnZlcnNlIG9mIHRoZSBiaW5kIHBvc2Vcblx0XHRcdFx0dmFyIGludl9tYXQgPSBpbnZfYmluZF9zb3VyY2Uuc3ViYXJyYXkoaSAqIDE2LCBpICogMTYgKyAxNik7XG5cdFx0XHRcdHZhciBub2RlbmFtZSA9IGpvaW50c19zb3VyY2VbaV07XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5fbm9kZXNfYnlfaWRbbm9kZW5hbWVdO1xuXHRcdFx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oXCJOb2RlIFwiICsgbm9kZW5hbWUgKyBcIiBub3QgZm91bmRcIik7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXgoaW52X21hdCwgbm9kZS5fZGVwdGggPT0gMCwgdHJ1ZSk7XG5cdFx0XHRcdGpvaW50cy5wdXNoKFtub2RlbmFtZSwgaW52X21hdF0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vd2VpZ2h0c1xuXHRcdHZhciB4bWx2ZXJ0ZXh3ZWlnaHRzID0geG1sc2tpbi5xdWVyeVNlbGVjdG9yKFwidmVydGV4X3dlaWdodHNcIik7XG5cdFx0aWYgKHhtbHZlcnRleHdlaWdodHMpIHtcblxuXHRcdFx0Ly9oZXJlIHdlIHNlZSB0aGUgb3JkZXIgXG5cdFx0XHR2YXIgd2VpZ2h0c19pbmRleGVkX2FycmF5ID0gbnVsbDtcblx0XHRcdHZhciB4bWxpbnB1dHMgPSB4bWx2ZXJ0ZXh3ZWlnaHRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFwiKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICh4bWxpbnB1dHNbaV0uZ2V0QXR0cmlidXRlKFwic2VtYW50aWNcIikudG9VcHBlckNhc2UoKSA9PSBcIldFSUdIVFwiKSB3ZWlnaHRzX2luZGV4ZWRfYXJyYXkgPSBzb3VyY2VzW3htbGlucHV0cy5pdGVtKGkpLmdldEF0dHJpYnV0ZShcInNvdXJjZVwiKS5zdWJzdHIoMSldO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXdlaWdodHNfaW5kZXhlZF9hcnJheSkgdGhyb3cgXCJubyB3ZWlnaHRzIGZvdW5kXCI7XG5cblx0XHRcdHZhciB4bWx2Y291bnQgPSB4bWx2ZXJ0ZXh3ZWlnaHRzLnF1ZXJ5U2VsZWN0b3IoXCJ2Y291bnRcIik7XG5cdFx0XHR2YXIgdmNvdW50ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHZjb3VudCk7XG5cblx0XHRcdHZhciB4bWx2ID0geG1sdmVydGV4d2VpZ2h0cy5xdWVyeVNlbGVjdG9yKFwidlwiKTtcblx0XHRcdHZhciB2ID0gdGhpcy5yZWFkQ29udGVudEFzVUludDMyKHhtbHYpO1xuXG5cdFx0XHR2YXIgbnVtX3ZlcnRpY2VzID0gbWVzaC52ZXJ0aWNlcy5sZW5ndGggLyAzOyAvLzMgY29tcG9uZW50cyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgd2VpZ2h0c19hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgYm9uZV9pbmRleF9hcnJheSA9IG5ldyBVaW50OEFycmF5KDQgKiBudW1fdmVydGljZXMpOyAvLzQgYm9uZXMgcGVyIHZlcnRleFxuXG5cdFx0XHR2YXIgcG9zID0gMDtcblx0XHRcdHZhciByZW1hcCA9IG1lc2guX3JlbWFwO1xuXHRcdFx0dmFyIG1heF9ib25lID0gMDsgLy9tYXggYm9uZSBhZmZlY3RlZFxuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZjb3VudC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0XHRcdFx0dmFyIG51bV9ib25lcyA9IHZjb3VudFtpXTsgLy9udW0gYm9uZXMgaW5mbHVlbmNpbmcgdGhpcyB2ZXJ0ZXhcblxuXHRcdFx0XHQvL2ZpbmQgNCB3aXRoIG1vcmUgaW5mbHVlbmNlXG5cdFx0XHRcdC8vdmFyIHZfdHVwbGV0cyA9IHYuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBudW1fYm9uZXMqMik7XG5cblx0XHRcdFx0dmFyIG9mZnNldCA9IHBvcztcblx0XHRcdFx0dmFyIGIgPSBib25lX2luZGV4X2FycmF5LnN1YmFycmF5KGkgKiA0LCBpICogNCArIDQpO1xuXHRcdFx0XHR2YXIgdyA9IHdlaWdodHNfYXJyYXkuc3ViYXJyYXkoaSAqIDQsIGkgKiA0ICsgNCk7XG5cblx0XHRcdFx0dmFyIHN1bSA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbnVtX2JvbmVzICYmIGogPCA0OyArK2opIHtcblx0XHRcdFx0XHRiW2pdID0gdltvZmZzZXQgKyBqICogMl07XG5cdFx0XHRcdFx0aWYgKGJbal0gPiBtYXhfYm9uZSkgbWF4X2JvbmUgPSBiW2pdO1xuXG5cdFx0XHRcdFx0d1tqXSA9IHdlaWdodHNfaW5kZXhlZF9hcnJheVt2W29mZnNldCArIGogKiAyICsgMV1dO1xuXHRcdFx0XHRcdHN1bSArPSB3W2pdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9ub3JtYWxpemUgd2VpZ2h0c1xuXHRcdFx0XHRpZiAobnVtX2JvbmVzID4gNCAmJiBzdW0gPCAxLjApIHtcblx0XHRcdFx0XHR2YXIgaW52X3N1bSA9IDEgLyBzdW07XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA0OyArK2opIHtcblx0XHRcdFx0XHRcdHdbal0gKj0gaW52X3N1bTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwb3MgKz0gbnVtX2JvbmVzICogMjtcblx0XHRcdH1cblxuXHRcdFx0Ly9yZW1hcDogYmVjYXVzZSB2ZXJ0aWNlcyBvcmRlciBpcyBub3cgY2hhbmdlZCBhZnRlciBwYXJzaW5nIHRoZSBtZXNoXG5cdFx0XHR2YXIgZmluYWxfd2VpZ2h0cyA9IG5ldyBGbG9hdDMyQXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgZmluYWxfYm9uZV9pbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkoNCAqIG51bV92ZXJ0aWNlcyk7IC8vNCBib25lcyBwZXIgdmVydGV4XG5cdFx0XHR2YXIgdXNlZF9qb2ludHMgPSBbXTtcblxuXHRcdFx0Ly9mb3IgZXZlcnkgdmVydGV4IGluIHRoZSBtZXNoLCBwcm9jZXNzIGJvbmUgaW5kaWNlcyBhbmQgd2VpZ2h0c1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1fdmVydGljZXM7ICsraSkge1xuXHRcdFx0XHR2YXIgcCA9IHJlbWFwW2ldICogNDtcblx0XHRcdFx0dmFyIHcgPSB3ZWlnaHRzX2FycmF5LnN1YmFycmF5KHAsIHAgKyA0KTtcblx0XHRcdFx0dmFyIGIgPSBib25lX2luZGV4X2FycmF5LnN1YmFycmF5KHAsIHAgKyA0KTtcblxuXHRcdFx0XHQvL3NvcnQgYnkgd2VpZ2h0IHNvIHJlbGV2YW50IG9uZXMgZ29lcyBmaXJzdFxuXHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IDM7ICsraykge1xuXHRcdFx0XHRcdHZhciBtYXhfcG9zID0gaztcblx0XHRcdFx0XHR2YXIgbWF4X3ZhbHVlID0gd1trXTtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gayArIDE7IGogPCA0OyArK2opIHtcblx0XHRcdFx0XHRcdGlmICh3W2pdIDw9IG1heF92YWx1ZSkgY29udGludWU7XG5cdFx0XHRcdFx0XHRtYXhfcG9zID0gajtcblx0XHRcdFx0XHRcdG1heF92YWx1ZSA9IHdbal07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChtYXhfcG9zICE9IGspIHtcblx0XHRcdFx0XHRcdHZhciB0bXAgPSB3W2tdO1xuXHRcdFx0XHRcdFx0d1trXSA9IHdbbWF4X3Bvc107XG5cdFx0XHRcdFx0XHR3W21heF9wb3NdID0gdG1wO1xuXHRcdFx0XHRcdFx0dG1wID0gYltrXTtcblx0XHRcdFx0XHRcdGJba10gPSBiW21heF9wb3NdO1xuXHRcdFx0XHRcdFx0YlttYXhfcG9zXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL3N0b3JlXG5cdFx0XHRcdGZpbmFsX3dlaWdodHMuc2V0KHcsIGkgKiA0KTtcblx0XHRcdFx0ZmluYWxfYm9uZV9pbmRpY2VzLnNldChiLCBpICogNCk7XG5cblx0XHRcdFx0Ly9tYXJrIGJvbmVzIHVzZWRcblx0XHRcdFx0aWYgKHdbMF0pIHVzZWRfam9pbnRzW2JbMF1dID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdbMV0pIHVzZWRfam9pbnRzW2JbMV1dID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdbMl0pIHVzZWRfam9pbnRzW2JbMl1dID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHdbM10pIHVzZWRfam9pbnRzW2JbM11dID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1heF9ib25lID49IGpvaW50cy5sZW5ndGgpIGNvbnNvbGUud2FybihcIk1lc2ggdXNlcyBoaWdoZXIgYm9uZSBpbmRleCB0aGFuIGJvbmVzIGZvdW5kXCIpO1xuXG5cdFx0XHQvL3RyaW0gdW51c2VkIGJvbmVzIChjb2xsYWRhIGNvdWxkIGdpdmUgeW91IDEwMCBib25lcyBmb3IgYW4gb2JqZWN0IHRoYXQgb25seSB1c2VzIGEgZnJhY3Rpb24gb2YgdGhlbSlcblx0XHRcdGlmICgxKSB7XG5cdFx0XHRcdHZhciBuZXdfYm9uZXMgPSBbXTtcblx0XHRcdFx0dmFyIGJvbmVzX3RyYW5zbGF0aW9uID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdXNlZF9qb2ludHMubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRpZiAodXNlZF9qb2ludHNbaV0pIHtcblx0XHRcdFx0XHRcdGJvbmVzX3RyYW5zbGF0aW9uW2ldID0gbmV3X2JvbmVzLmxlbmd0aDtcblx0XHRcdFx0XHRcdG5ld19ib25lcy5wdXNoKGpvaW50c1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IC8vaW4gY2FzZSB0aGVyZSBhcmUgbGVzcyBib25lcyBpbiB1c2UuLi5cblx0XHRcdFx0aWYgKG5ld19ib25lcy5sZW5ndGggPCBqb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly9yZW1hcFxuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmluYWxfYm9uZV9pbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRmaW5hbF9ib25lX2luZGljZXNbaV0gPSBib25lc190cmFuc2xhdGlvbltmaW5hbF9ib25lX2luZGljZXNbaV1dO1xuXHRcdFx0XHRcdH1qb2ludHMgPSBuZXdfYm9uZXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIkJvbmVzOiBcIiwgam9pbnRzLmxlbmd0aCwgXCIgdXNlZDpcIiwgbnVtX3VzZWRfam9pbnRzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vY29uc29sZS5sb2coXCJCb25lczogXCIsIGpvaW50cy5sZW5ndGgsIFwiTWF4IGJvbmU6IFwiLCBtYXhfYm9uZSk7XG5cblx0XHRcdG1lc2gud2VpZ2h0cyA9IGZpbmFsX3dlaWdodHM7XG5cdFx0XHRtZXNoLmJvbmVfaW5kaWNlcyA9IGZpbmFsX2JvbmVfaW5kaWNlcztcblx0XHRcdG1lc2guYm9uZXMgPSBqb2ludHM7XG5cdFx0XHRtZXNoLmJpbmRfbWF0cml4ID0gYmluZF9tYXRyaXg7XG5cblx0XHRcdC8vZGVsZXRlIG1lc2hbXCJfcmVtYXBcIl07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lc2g7XG5cdH0sXG5cblx0Ly9OT1QgVEVTVEVEXG5cdHJlYWRNb3JwaENvbnRyb2xsZXI6IGZ1bmN0aW9uIHJlYWRNb3JwaENvbnRyb2xsZXIoeG1sbW9ycGgsIGZsaXAsIHNjZW5lLCBtZXNoKSB7XG5cdFx0dmFyIGlkX2dlb21ldHJ5ID0geG1sbW9ycGguZ2V0QXR0cmlidXRlKFwic291cmNlXCIpO1xuXHRcdHZhciBiYXNlX21lc2ggPSB0aGlzLnJlYWRHZW9tZXRyeShpZF9nZW9tZXRyeSwgZmxpcCwgc2NlbmUpO1xuXHRcdGlmICghYmFzZV9tZXNoKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vcmVhZCBzb3VyY2VzIHdpdGggYmxlbmQgc2hhcGVzIGluZm8gKHdoaWNoIG9uZXMsIGFuZCB0aGUgd2VpZ2h0KVxuXHRcdHZhciBzb3VyY2VzID0gdGhpcy5yZWFkU291cmNlcyh4bWxtb3JwaCwgZmxpcCk7XG5cblx0XHR2YXIgbW9ycGhzID0gW107XG5cblx0XHQvL3RhcmdldHNcblx0XHR2YXIgeG1sdGFyZ2V0cyA9IHhtbG1vcnBoLnF1ZXJ5U2VsZWN0b3IoXCJ0YXJnZXRzXCIpO1xuXHRcdGlmICgheG1sdGFyZ2V0cykgcmV0dXJuIG51bGw7XG5cblx0XHR2YXIgeG1saW5wdXRzID0geG1sdGFyZ2V0cy5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXRcIik7XG5cdFx0dmFyIHRhcmdldHMgPSBudWxsO1xuXHRcdHZhciB3ZWlnaHRzID0gbnVsbDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1saW5wdXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1saW5wdXQgPSB4bWxpbnB1dHMuaXRlbShpKTtcblx0XHRcdHZhciBzZW1hbnRpYyA9IHhtbGlucHV0LmdldEF0dHJpYnV0ZShcInNlbWFudGljXCIpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR2YXIgZGF0YSA9IHNvdXJjZXNbeG1saW5wdXQuZ2V0QXR0cmlidXRlKFwic291cmNlXCIpLnN1YnN0cigxKV07XG5cdFx0XHRpZiAoc2VtYW50aWMgPT0gXCJNT1JQSF9UQVJHRVRcIikgdGFyZ2V0cyA9IGRhdGE7ZWxzZSBpZiAoc2VtYW50aWMgPT0gXCJNT1JQSF9XRUlHSFRcIikgd2VpZ2h0cyA9IGRhdGE7XG5cdFx0fVxuXG5cdFx0aWYgKCF0YXJnZXRzIHx8ICF3ZWlnaHRzKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXCJNb3JwaCBjb250cm9sbGVyIHdpdGhvdXQgdGFyZ2V0cyBvciB3ZWlnaHRzLiBTa2lwcGluZyBpdC5cIik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvL2dldCB0YXJnZXRzXG5cdFx0Zm9yICh2YXIgaSBpbiB0YXJnZXRzKSB7XG5cdFx0XHR2YXIgaWQgPSBcIiNcIiArIHRhcmdldHNbaV07XG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLnJlYWRHZW9tZXRyeShpZCwgZmxpcCwgc2NlbmUpO1xuXHRcdFx0c2NlbmUubWVzaGVzW2lkXSA9IGdlb21ldHJ5O1xuXHRcdFx0bW9ycGhzLnB1c2goeyBtZXNoOiBpZCwgd2VpZ2h0OiB3ZWlnaHRzW2ldIH0pO1xuXHRcdH1cblxuXHRcdGJhc2VfbWVzaC5tb3JwaF90YXJnZXRzID0gbW9ycGhzO1xuXHRcdHJldHVybiBiYXNlX21lc2g7XG5cdH0sXG5cblx0cmVhZEJpbmRNYXRlcmlhbHM6IGZ1bmN0aW9uIHJlYWRCaW5kTWF0ZXJpYWxzKHhtbGJpbmRfbWF0ZXJpYWwsIG1lc2gpIHtcblx0XHR2YXIgbWF0ZXJpYWxzID0gW107XG5cblx0XHR2YXIgeG1sdGVjaG5pcXVlcyA9IHhtbGJpbmRfbWF0ZXJpYWwucXVlcnlTZWxlY3RvckFsbChcInRlY2huaXF1ZV9jb21tb25cIik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB4bWx0ZWNobmlxdWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgeG1sdGVjaG5pcXVlID0geG1sdGVjaG5pcXVlcy5pdGVtKGkpO1xuXHRcdFx0dmFyIHhtbGluc3RhbmNlX21hdGVyaWFscyA9IHhtbHRlY2huaXF1ZS5xdWVyeVNlbGVjdG9yQWxsKFwiaW5zdGFuY2VfbWF0ZXJpYWxcIik7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHhtbGluc3RhbmNlX21hdGVyaWFscy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHR2YXIgeG1saW5zdGFuY2VfbWF0ZXJpYWwgPSB4bWxpbnN0YW5jZV9tYXRlcmlhbHMuaXRlbShqKTtcblx0XHRcdFx0aWYgKHhtbGluc3RhbmNlX21hdGVyaWFsKSBtYXRlcmlhbHMucHVzaCh4bWxpbnN0YW5jZV9tYXRlcmlhbC5nZXRBdHRyaWJ1dGUoXCJzeW1ib2xcIikpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRlcmlhbHM7XG5cdH0sXG5cblx0cmVhZFNvdXJjZXM6IGZ1bmN0aW9uIHJlYWRTb3VyY2VzKHhtbG5vZGUsIGZsaXApIHtcblx0XHQvL2ZvciBkYXRhIHNvdXJjZXNcblx0XHR2YXIgc291cmNlcyA9IHt9O1xuXHRcdHZhciB4bWxzb3VyY2VzID0geG1sbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwic291cmNlXCIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgeG1sc291cmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHhtbHNvdXJjZSA9IHhtbHNvdXJjZXMuaXRlbShpKTtcblx0XHRcdGlmICgheG1sc291cmNlLnF1ZXJ5U2VsZWN0b3IpIC8vPz9cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdHZhciBmbG9hdF9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiZmxvYXRfYXJyYXlcIik7XG5cdFx0XHRpZiAoZmxvYXRfYXJyYXkpIHtcblx0XHRcdFx0dmFyIGZsb2F0cyA9IHRoaXMucmVhZENvbnRlbnRBc0Zsb2F0cyh4bWxzb3VyY2UpO1xuXHRcdFx0XHRzb3VyY2VzW3htbHNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKV0gPSBmbG9hdHM7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmFtZV9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiTmFtZV9hcnJheVwiKTtcblx0XHRcdGlmIChuYW1lX2FycmF5KSB7XG5cdFx0XHRcdHZhciBuYW1lcyA9IHRoaXMucmVhZENvbnRlbnRBc1N0cmluZ3NBcnJheShuYW1lX2FycmF5KTtcblx0XHRcdFx0aWYgKCFuYW1lcykgY29udGludWU7XG5cdFx0XHRcdHNvdXJjZXNbeG1sc291cmNlLmdldEF0dHJpYnV0ZShcImlkXCIpXSA9IG5hbWVzO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlZl9hcnJheSA9IHhtbHNvdXJjZS5xdWVyeVNlbGVjdG9yKFwiSURSRUZfYXJyYXlcIik7XG5cdFx0XHRpZiAocmVmX2FycmF5KSB7XG5cdFx0XHRcdHZhciBuYW1lcyA9IHRoaXMucmVhZENvbnRlbnRBc1N0cmluZ3NBcnJheShyZWZfYXJyYXkpO1xuXHRcdFx0XHRpZiAoIW5hbWVzKSBjb250aW51ZTtcblx0XHRcdFx0c291cmNlc1t4bWxzb3VyY2UuZ2V0QXR0cmlidXRlKFwiaWRcIildID0gbmFtZXM7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzb3VyY2VzO1xuXHR9LFxuXG5cdHJlYWRDb250ZW50QXNVSW50MzI6IGZ1bmN0aW9uIHJlYWRDb250ZW50QXNVSW50MzIoeG1sbm9kZSkge1xuXHRcdGlmICgheG1sbm9kZSkgcmV0dXJuIG51bGw7XG5cdFx0dmFyIHRleHQgPSB4bWxub2RlLnRleHRDb250ZW50O1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi9naSwgXCIgXCIpOyAvL3JlbW92ZSBsaW5lIGJyZWFrc1xuXHRcdHRleHQgPSB0ZXh0LnRyaW0oKTsgLy9yZW1vdmUgZW1wdHkgc3BhY2VzXG5cdFx0aWYgKHRleHQubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuXHRcdHZhciBudW1iZXJzID0gdGV4dC5zcGxpdChcIiBcIik7IC8vY3JlYXRlIGFycmF5XG5cdFx0dmFyIGZsb2F0cyA9IG5ldyBVaW50MzJBcnJheShudW1iZXJzLmxlbmd0aCk7XG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBudW1iZXJzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRmbG9hdHNba10gPSBwYXJzZUludChudW1iZXJzW2tdKTtcblx0XHR9cmV0dXJuIGZsb2F0cztcblx0fSxcblxuXHRyZWFkQ29udGVudEFzRmxvYXRzOiBmdW5jdGlvbiByZWFkQ29udGVudEFzRmxvYXRzKHhtbG5vZGUpIHtcblx0XHRpZiAoIXhtbG5vZGUpIHJldHVybiBudWxsO1xuXHRcdHZhciB0ZXh0ID0geG1sbm9kZS50ZXh0Q29udGVudDtcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZ2ksIFwiIFwiKTsgLy9yZW1vdmUgbGluZSBicmVha3Ncblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHNcXHMrL2dpLCBcIiBcIik7XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFx0L2dpLCBcIlwiKTtcblx0XHR0ZXh0ID0gdGV4dC50cmltKCk7IC8vcmVtb3ZlIGVtcHR5IHNwYWNlc1xuXHRcdHZhciBudW1iZXJzID0gdGV4dC5zcGxpdChcIiBcIik7IC8vY3JlYXRlIGFycmF5XG5cdFx0dmFyIGNvdW50ID0geG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb3VudFwiKTtcblx0XHR2YXIgbGVuZ3RoID0gY291bnQgPyBwYXJzZUludChjb3VudCkgOiBudW1iZXJzLmxlbmd0aDtcblx0XHR2YXIgZmxvYXRzID0gbmV3IEZsb2F0MzJBcnJheShsZW5ndGgpO1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbnVtYmVycy5sZW5ndGg7IGsrKykge1xuXHRcdFx0ZmxvYXRzW2tdID0gcGFyc2VGbG9hdChudW1iZXJzW2tdKTtcblx0XHR9cmV0dXJuIGZsb2F0cztcblx0fSxcblxuXHRyZWFkQ29udGVudEFzU3RyaW5nc0FycmF5OiBmdW5jdGlvbiByZWFkQ29udGVudEFzU3RyaW5nc0FycmF5KHhtbG5vZGUpIHtcblx0XHRpZiAoIXhtbG5vZGUpIHJldHVybiBudWxsO1xuXHRcdHZhciB0ZXh0ID0geG1sbm9kZS50ZXh0Q29udGVudDtcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vZ2ksIFwiIFwiKTsgLy9yZW1vdmUgbGluZSBicmVha3Ncblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHNcXHMvZ2ksIFwiIFwiKTtcblx0XHR0ZXh0ID0gdGV4dC50cmltKCk7IC8vcmVtb3ZlIGVtcHR5IHNwYWNlc1xuXHRcdHZhciB3b3JkcyA9IHRleHQuc3BsaXQoXCIgXCIpOyAvL2NyZWF0ZSBhcnJheVxuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgd29yZHMubGVuZ3RoOyBrKyspIHtcblx0XHRcdHdvcmRzW2tdID0gd29yZHNba10udHJpbSgpO1xuXHRcdH1pZiAoeG1sbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb3VudFwiKSAmJiBwYXJzZUludCh4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpKSAhPSB3b3Jkcy5sZW5ndGgpIHtcblx0XHRcdHZhciBtZXJnZWRfd29yZHMgPSBbXTtcblx0XHRcdHZhciBuYW1lID0gXCJcIjtcblx0XHRcdGZvciAodmFyIGkgaW4gd29yZHMpIHtcblx0XHRcdFx0aWYgKCFuYW1lKSBuYW1lID0gd29yZHNbaV07ZWxzZSBuYW1lICs9IFwiIFwiICsgd29yZHNbaV07XG5cdFx0XHRcdGlmICghdGhpcy5fbm9kZXNfYnlfaWRbdGhpcy5zYWZlU3RyaW5nKG5hbWUpXSkgY29udGludWU7XG5cdFx0XHRcdG1lcmdlZF93b3Jkcy5wdXNoKHRoaXMuc2FmZVN0cmluZyhuYW1lKSk7XG5cdFx0XHRcdG5hbWUgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY291bnQgPSBwYXJzZUludCh4bWxub2RlLmdldEF0dHJpYnV0ZShcImNvdW50XCIpKTtcblx0XHRcdGlmIChtZXJnZWRfd29yZHMubGVuZ3RoID09IGNvdW50KSByZXR1cm4gbWVyZ2VkX3dvcmRzO1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3I6IGJvbmUgbmFtZXMgaGF2ZSBzcGFjZXMsIGF2b2lkIHVzaW5nIHNwYWNlcyBpbiBuYW1lc1wiKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gd29yZHM7XG5cdH0sXG5cblx0bWF4M2RfbWF0cml4XzA6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIC0xLCAwLCAwLCAwLCAwLCAtMSwgMCwgMSwgMCwgMCwgLTAsIDAsIDAsIDAsIDFdKSxcblx0Ly9tYXgzZF9tYXRyaXhfb3RoZXI6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIC0xLCAwLCAwLCAwLCAwLCAtMSwgMCwgMSwgMCwgMCwgLTAsIDAsIDAsIDAsIDFdKSxcblxuXHR0cmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIGZpcnN0X2xldmVsLCBpbnZlcnRlZCkge1xuXHRcdF9nbE1hdHJpeC5tYXQ0LnRyYW5zcG9zZShtYXRyaXgsIG1hdHJpeCk7XG5cblx0XHRpZiAodGhpcy5ub19mbGlwKSByZXR1cm4gbWF0cml4O1xuXG5cdFx0Ly9XQVJOSU5HOiBETyBOT1QgQ0hBTkdFIFRISVMgRlVOQ1RJT04sIFRIRSBTS1kgV0lMTCBGQUxMXG5cdFx0aWYgKGZpcnN0X2xldmVsKSB7XG5cblx0XHRcdC8vZmxpcCByb3cgdHdvIGFuZCB0cmVlXG5cdFx0XHR2YXIgdGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkobWF0cml4LnN1YmFycmF5KDQsIDgpKTsgLy9zd2FwIHJvd3Ncblx0XHRcdG1hdHJpeC5zZXQobWF0cml4LnN1YmFycmF5KDgsIDEyKSwgNCk7XG5cdFx0XHRtYXRyaXguc2V0KHRlbXAsIDgpO1xuXG5cdFx0XHQvL3JldmVyc2UgWlxuXHRcdFx0dGVtcCA9IG1hdHJpeC5zdWJhcnJheSg4LCAxMik7XG5cdFx0XHR2ZWM0LnNjYWxlKHRlbXAsIHRlbXAsIC0xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIE0gPSBfZ2xNYXRyaXgubWF0NC5jcmVhdGUoKTtcblx0XHRcdHZhciBtID0gbWF0cml4O1xuXG5cdFx0XHQvL2lmKGludmVydGVkKSBtYXQ0LmludmVydChtLG0pO1xuXG5cdFx0XHQvKiBub24gdHJhc3Bvc2VkXG4gICBNLnNldChbbVswXSxtWzhdLC1tWzRdXSwgMCk7XG4gICBNLnNldChbbVsyXSxtWzEwXSwtbVs2XV0sIDQpO1xuICAgTS5zZXQoWy1tWzFdLC1tWzldLG1bNV1dLCA4KTtcbiAgIE0uc2V0KFttWzNdLG1bMTFdLC1tWzddXSwgMTIpO1xuICAgKi9cblxuXHRcdFx0TS5zZXQoW21bMF0sIG1bMl0sIC1tWzFdXSwgMCk7XG5cdFx0XHRNLnNldChbbVs4XSwgbVsxMF0sIC1tWzldXSwgNCk7XG5cdFx0XHRNLnNldChbLW1bNF0sIC1tWzZdLCBtWzVdXSwgOCk7XG5cdFx0XHRNLnNldChbbVsxMl0sIG1bMTRdLCAtbVsxM11dLCAxMik7XG5cblx0XHRcdG0uc2V0KE0pO1xuXG5cdFx0XHQvL2lmKGludmVydGVkKSBtYXQ0LmludmVydChtLG0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsYWRhO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2xsYWRhLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbGxhZGEtcGFyc2VyL2xpYi9Db2xsYWRhLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEdsdGZMb2FkZXIuanNcblxuaW1wb3J0IHhociBmcm9tICcuL3hocic7XG5pbXBvcnQgbG9hZEltYWdlcyBmcm9tICcuL2xvYWRJbWFnZXMnO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4uL0dlb21ldHJ5JztcbmltcG9ydCBNYXRlcmlhbCBmcm9tICcuLi9NYXRlcmlhbCc7XG5pbXBvcnQgTWVzaCBmcm9tICcuLi9NZXNoJztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgU2hhZGVyTGlicyBmcm9tICcuLi9zaGFkZXJzL1NoYWRlckxpYnMnO1xuaW1wb3J0IFNoYWRlcnMgZnJvbSAnLi4vc2hhZGVycy9TaGFkZXJzJztcblxuaW1wb3J0IEdMVGV4dHVyZSBmcm9tICcuLi9HTFRleHR1cmUnO1xuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4uL29iamVjdHMvT2JqZWN0M0QnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAncHJvbWlzZS1wb2x5ZmlsbCc7XG5pbXBvcnQgb2JqZWN0QXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nO1xuaW1wb3J0IFdlYmdsTnVtYmVyIGZyb20gJy4uL3V0aWxzL1dlYmdsTnVtYmVyJztcblxuXG5cbmNvbnN0IEFSUkFZX0NUT1JfTUFQID0ge1xuXHQ1MTIwOiBJbnQ4QXJyYXksXG5cdDUxMjE6IFVpbnQ4QXJyYXksXG5cdDUxMjI6IEludDE2QXJyYXksXG5cdDUxMjM6IFVpbnQxNkFycmF5LFxuXHQ1MTI1OiBVaW50MzJBcnJheSxcblx0NTEyNjogRmxvYXQzMkFycmF5XG59O1xuXG5jb25zdCBTSVpFX01BUCA9IHtcblx0U0NBTEFSOiAxLFxuXHRWRUMyOiAyLFxuXHRWRUMzOiAzLFxuXHRWRUM0OiA0LFxuXHRNQVQyOiA0LFxuXHRNQVQzOiA5LFxuXHRNQVQ0OiAxNlxufTtcblxuY29uc3Qgc2VtYW50aWNBdHRyaWJ1dGVNYXAgPSB7XG5cdE5PUk1BTDogJ2FOb3JtYWwnLFxuXHRQT1NJVElPTjogJ2FWZXJ0ZXhQb3NpdGlvbicsXG5cdC8vICdUQU5HRU5UJzogJ2FUYW5nZW50Jyxcblx0VEVYQ09PUkRfMDogJ2FUZXh0dXJlQ29vcmQnLFxuXHQvLyBURVhDT09SRF8xOiAnYVRleHR1cmVDb29yZDEnLFxuXHRXRUlHSFRTXzA6ICdhV2VpZ2h0Jyxcblx0Sk9JTlRTXzA6ICdhSm9pbnQnLFxuXHRDT0xPUjogJ2FDb2xvcidcbn07XG5cbmxldCBiYXNlO1xuXG5jb25zdCBsb2FkID0gKG1Tb3VyY2UpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0aWYoKHR5cGVvZiBtU291cmNlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRiYXNlID0gbVNvdXJjZS5zdWJzdHJpbmcoMCwgbVNvdXJjZS5sYXN0SW5kZXhPZignLycpKzEpO1xuXHR9IGVsc2Uge1xuXHRcdGJhc2UgPSAnJztcblx0fVxuXG5cdF9sb2FkR2x0ZihtU291cmNlKVxuXHRcdC50aGVuKF9sb2FkQmluKVxuXHRcdC50aGVuKF9sb2FkVGV4dHVyZXMpXG5cdFx0LnRoZW4oX2dldEJ1ZmZlclZpZXdEYXRhKVxuXHRcdC50aGVuKF9wYXJzZU1hdGVyaWFscylcblx0XHQudGhlbihfcGFyc2VNZXNoKVxuXHRcdC50aGVuKF9wYXJzZU5vZGVzKVxuXHRcdC50aGVuKChnbHRmSW5mbyk9Pntcblx0XHRcdHJlc29sdmUoZ2x0ZkluZm8pO1xuXHRcdH0pXG5cdFx0LmNhdGNoKGUgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coJ0Vycm9yOicsIGUpO1xuXHRcdH0pO1xufSk7XG5cblxuY29uc3QgX3BhcnNlTm9kZXMgPSAoZ2x0ZikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7IG5vZGVzLCBzY2VuZXMgfSA9IGdsdGY7XG5cblx0Y29uc3QgZ2V0VHJlZSA9IChub2RlSW5kZXgpID0+IHtcblx0XHRjb25zdCBub2RlID0gbm9kZXNbbm9kZUluZGV4XTtcblx0XHRjb25zdCBvYmozRCA9IG5vZGUubWVzaCA9PT0gdW5kZWZpbmVkID8gbmV3IE9iamVjdDNEKCkgOiBnbHRmLm91dHB1dC5tZXNoZXNbbm9kZS5tZXNoXTtcblxuXG5cdFx0aWYobm9kZS5zY2FsZSkge1xuXHRcdFx0b2JqM0Quc2NhbGVYID0gbm9kZS5zY2FsZVswXTtcblx0XHRcdG9iajNELnNjYWxlWSA9IG5vZGUuc2NhbGVbMV07XG5cdFx0XHRvYmozRC5zY2FsZVogPSBub2RlLnNjYWxlWzJdO1xuXHRcdH1cblxuXHRcdGlmKG5vZGUucm90YXRpb24pIHtcblx0XHRcdG9iajNELnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24obm9kZS5yb3RhdGlvbik7XG5cdFx0fVxuXG5cdFx0aWYobm9kZS50cmFuc2xhdGlvbikge1xuXHRcdFx0b2JqM0QueCA9IG5vZGUudHJhbnNsYXRpb25bMF07XG5cdFx0XHRvYmozRC55ID0gbm9kZS50cmFuc2xhdGlvblsxXTtcblx0XHRcdG9iajNELnogPSBub2RlLnRyYW5zbGF0aW9uWzJdO1xuXHRcdH1cblxuXHRcdGlmKG5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGNvbnN0IF9jaGlsZCA9IGdldFRyZWUoY2hpbGQpO1xuXHRcdFx0XHRvYmozRC5hZGRDaGlsZChfY2hpbGQpO1xuXHRcdFx0fSk7XHRcblx0XHR9XG5cdFx0XG5cblx0XHRyZXR1cm4gb2JqM0Q7XG5cdH07XG5cblx0Z2x0Zi5vdXRwdXQuc2NlbmVzID0gc2NlbmVzLm1hcChzY2VuZSA9PiB7XG5cdFx0Y29uc3QgY29udGFpbmVyID0gbmV3IE9iamVjdDNEKCk7XG5cdFx0c2NlbmUubm9kZXMuZm9yRWFjaChub2RlSW5kZXggPT4ge1xuXHRcdFx0Y29uc3QgY2hpbGRUcmVlID0gZ2V0VHJlZShub2RlSW5kZXgpO1xuXHRcdFx0Y29udGFpbmVyLmFkZENoaWxkKGNoaWxkVHJlZSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9KTtcblxuXHRyZXNvbHZlKGdsdGYpO1xufSk7XG5cblxuY29uc3QgX3BhcnNlTWVzaCA9IChnbHRmKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHsgbWVzaGVzIH0gPSBnbHRmO1xuXHRcblxuXHRtZXNoZXMuZm9yRWFjaCggbWVzaCA9PiB7XG5cdFx0Y29uc3QgeyBwcmltaXRpdmVzIH0gPSBtZXNoO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlJbmZvID0ge307XG5cblx0XHRwcmltaXRpdmVzLmZvckVhY2goIHByaW1pdGl2ZUluZm8gPT4ge1xuXHRcdFx0Y29uc3Qgc2VtYW50aWNzID0gT2JqZWN0LmtleXMocHJpbWl0aXZlSW5mby5hdHRyaWJ1dGVzKTtcblx0XHRcdGxldCBkZWZpbmVzID0ge307XG5cblx0XHRcdHNlbWFudGljcy5mb3JFYWNoKCBzZW1hbnRpYyA9PiB7XG5cdFx0XHRcdGNvbnN0IGFjY2Vzc29ySWR4ID0gcHJpbWl0aXZlSW5mby5hdHRyaWJ1dGVzW3NlbWFudGljXTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlSW5mbyA9IGdsdGYuYWNjZXNzb3JzW2FjY2Vzc29ySWR4XTtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlTmFtZSA9IHNlbWFudGljQXR0cmlidXRlTWFwW3NlbWFudGljXTtcblx0XHRcdFx0aWYoIWF0dHJpYnV0ZU5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoc2VtYW50aWMgPT09ICdOT1JNQUwnKSB7XG5cdFx0XHRcdFx0ZGVmaW5lcy5IQVNfTk9STUFMUyA9IDE7XG5cdFx0XHRcdH0gXG5cdFx0XHRcdGlmKHNlbWFudGljLmluZGV4T2YoJ1RFWENPT1JEJykgPiAtMSkge1xuXHRcdFx0XHRcdGRlZmluZXMuSEFTX1VWID0gMTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Y29uc3Qgc2l6ZSA9IFNJWkVfTUFQW2F0dHJpYnV0ZUluZm8udHlwZV07XG5cdFx0XHRcdGxldCBhdHRyaWJ1dGVBcnJheSA9IF9nZXRBY2Nlc3NvckRhdGEoZ2x0ZiwgYWNjZXNzb3JJZHgpO1xuXHRcdFx0XHRpZiAoYXR0cmlidXRlQXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShhdHRyaWJ1dGVBcnJheSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihzZW1hbnRpYyA9PT0gJ1RFWENPT1JEXzEnKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coc2l6ZSwgYXR0cmlidXRlQXJyYXkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z2VvbWV0cnlJbmZvW2F0dHJpYnV0ZU5hbWVdID0ge1xuXHRcdFx0XHRcdHZhbHVlOmF0dHJpYnV0ZUFycmF5LFxuXHRcdFx0XHRcdHNpemUsXG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdhdHRyaWJ1dGUnLCBhdHRyaWJ1dGVOYW1lLCBnZW9tZXRyeVthdHRyaWJ1dGVOYW1lXSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly9cdHBhcnNlIGluZGV4XG5cdFx0XHRpZiAocHJpbWl0aXZlSW5mby5pbmRpY2VzICE9IG51bGwpIHtcblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlQXJyYXkgPSBfZ2V0QWNjZXNzb3JEYXRhKGdsdGYsIHByaW1pdGl2ZUluZm8uaW5kaWNlcywgdHJ1ZSk7XG5cdFx0XHRcdGdlb21ldHJ5SW5mby5pbmRpY2VzID0ge1xuXHRcdFx0XHRcdHZhbHVlOmF0dHJpYnV0ZUFycmF5LFxuXHRcdFx0XHRcdHNpemU6MVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xuXG5cdFx0XHRmb3IoY29uc3QgcyBpbiBnZW9tZXRyeUluZm8pIHtcblx0XHRcdFx0Y29uc3QgZGF0YSA9IGdlb21ldHJ5SW5mb1tzXTtcblx0XHRcdFx0aWYocyAhPT0gJ2luZGljZXMnKSB7XG5cdFx0XHRcdFx0Z2VvbWV0cnkuYnVmZmVyRmxhdHRlbkRhdGEoZGF0YS52YWx1ZSwgcywgZGF0YS5zaXplKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRnZW9tZXRyeS5idWZmZXJJbmRleChkYXRhLnZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtYXRlcmlhbEluZm8gPSBnbHRmLm91dHB1dC5tYXRlcmlhbEluZm9bcHJpbWl0aXZlSW5mby5tYXRlcmlhbF07XG5cdFx0XHRkZWZpbmVzID0gb2JqZWN0QXNzaWduKGRlZmluZXMsIG1hdGVyaWFsSW5mby5kZWZpbmVzKTtcblx0XHRcdFxuXG5cdFx0XHRjb25zdCB7XG5cdFx0XHRcdGVtaXNzaXZlRmFjb3RyLFxuXHRcdFx0XHRub3JtYWxUZXh0dXJlLFxuXHRcdFx0XHRvY2NsdXNpb25UZXh0dXJlLFxuXHRcdFx0XHRwYnJNZXRhbGxpY1JvdWdobmVzcyxcblx0XHRcdH0gPSBtYXRlcmlhbEluZm87XG5cblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0YmFzZUNvbG9yVGV4dHVyZSxcblx0XHRcdFx0bWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlXG5cdFx0XHR9ID0gcGJyTWV0YWxsaWNSb3VnaG5lc3M7XG5cblx0XHRcdGNvbnN0IHVuaWZvcm1zID0ge1xuXHRcdFx0XHR1RW1pc3NpdmVGYWN0b3I6ZW1pc3NpdmVGYWNvdHIgfHwgWzAsIDAsIDBdLFxuXHRcdFx0XHR1QmFzZUNvbG9yOnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvciB8fCBbMSwgMSwgMSwgMV0sXG5cdFx0XHRcdHVSb3VnaG5lc3M6cGJyTWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yIHx8IDEsXG5cdFx0XHRcdHVNZXRhbGxpYzpwYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciB8fCAxLFxuXHRcdFx0XHR1U2NhbGVEaWZmQmFzZU1SOlswLCAwLCAwLCAwXSxcblx0XHRcdFx0dVNjYWxlRkdEU3BlYzpbMCwgMCwgMCwgMF0sXG5cdFx0XHRcdHVTY2FsZUlCTEFtYmllbnQ6WzEsIDEsIDEsIDFdLFxuXHRcdFx0XHR1TGlnaHREaXJlY3Rpb246WzEsIDEsIDFdLFxuXHRcdFx0XHR1TGlnaHRDb2xvcjpbMSwgMSwgMV0sXG5cdFx0XHRcdHVHYW1tYToxXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoYmFzZUNvbG9yVGV4dHVyZSkge1xuXHRcdFx0XHR1bmlmb3Jtcy51Q29sb3JNYXAgPSBiYXNlQ29sb3JUZXh0dXJlLmdsVGV4dHVyZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkge1xuXHRcdFx0XHR1bmlmb3Jtcy51TWV0YWxsaWNSb3VnaG5lc3NNYXAgPSBtZXRhbGxpY1JvdWdobmVzc1RleHR1cmUuZ2xUZXh0dXJlO1x0XG5cdFx0XHR9XG5cblx0XHRcdGlmIChub3JtYWxUZXh0dXJlKSB7XG5cdFx0XHRcdHVuaWZvcm1zLnVOb3JtYWxTY2FsZSA9IG5vcm1hbFRleHR1cmUuc2NhbGUgfHwgMTtcblx0XHRcdFx0dW5pZm9ybXMudU5vcm1hbE1hcCA9IG5vcm1hbFRleHR1cmUuZ2xUZXh0dXJlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2NjbHVzaW9uVGV4dHVyZSkge1xuXHRcdFx0XHR1bmlmb3Jtcy51QW9NYXAgPSBvY2NsdXNpb25UZXh0dXJlLmdsVGV4dHVyZTtcblx0XHRcdFx0dW5pZm9ybXMudU9jY2x1c2lvblN0cmVuZ3RoID0gb2NjbHVzaW9uVGV4dHVyZS5zdHJlbmd0aCB8fCAxO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBtYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChTaGFkZXJMaWJzLmdsdGZWZXJ0LCBTaGFkZXJMaWJzLmdsdGZGcmFnLCB1bmlmb3JtcywgZGVmaW5lcyk7XG5cdFx0XHRjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcblx0XHRcdGdsdGYub3V0cHV0Lm1lc2hlcy5wdXNoKG1lc2gpO1xuXHRcdH0pO1xuXHR9KTtcblxuXHRyZXNvbHZlKGdsdGYpO1xufSk7XG5cbmNvbnN0IF9nZXRCdWZmZXJWaWV3RGF0YSA9IChnbHRmSW5mbykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7IGJ1ZmZlclZpZXdzLCBidWZmZXJzIH0gPSBnbHRmSW5mbztcblxuXHRidWZmZXJWaWV3cy5mb3JFYWNoKChidWZmZXJWaWV3SW5mbywgaSkgPT4ge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbYnVmZmVyVmlld0luZm8uYnVmZmVyXS5kYXRhO1xuXHRcdGJ1ZmZlclZpZXdJbmZvLmRhdGEgPSBidWZmZXIuc2xpY2UoYnVmZmVyVmlld0luZm8uYnl0ZU9mZnNldCB8fCAwLCAoYnVmZmVyVmlld0luZm8uYnl0ZU9mZnNldCB8fCAwKSArIChidWZmZXJWaWV3SW5mby5ieXRlTGVuZ3RoIHx8IDApKTtcblx0fSk7XG5cdHJlc29sdmUoZ2x0ZkluZm8pO1xufSk7XG5cbmNvbnN0IF9sb2FkR2x0ZiA9IChtU291cmNlKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGlmKCh0eXBlb2YgbVNvdXJjZSkgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmVzb2x2ZShtU291cmNlKTtcblx0fSBlbHNlIHtcblx0XHR4aHIobVNvdXJjZSkudGhlbigobyk9Pntcblx0XHRcdGNvbnN0IGdsdGZJbmZvID0gSlNPTi5wYXJzZShvKTtcblx0XHRcdGdsdGZJbmZvLm91dHB1dCA9IHtcblx0XHRcdFx0bWVzaGVzOltdLFxuXHRcdFx0XHRzY2VuZXM6W10sXG5cdFx0XHRcdHRleHR1cmVzOltdLFxuXHRcdFx0XHRtYXRlcmlhbDpbXSxcblx0XHRcdFx0bWF0ZXJpYWxJbmZvOltdXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXNvbHZlKGdsdGZJbmZvKTtcblx0XHR9LCAoZSk9PiB7XG5cdFx0XHRyZWplY3QoZSk7XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5cbmNvbnN0IF9sb2FkQmluID0gKGdsdGZJbmZvKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFxuXHRpZihnbHRmSW5mby5idWZmZXJzKSB7XG5cdFx0bGV0IGNvdW50ID0gZ2x0ZkluZm8uYnVmZmVycy5sZW5ndGg7XG5cblx0XHRnbHRmSW5mby5idWZmZXJzLmZvckVhY2goYnVmZmVyID0+IHtcblxuXHRcdFx0Y29uc3QgdXJsQmluID0gYCR7YmFzZX0ke2dsdGZJbmZvLmJ1ZmZlcnNbMF0udXJpfWA7XG5cdFx0XHR4aHIodXJsQmluLCB0cnVlKS50aGVuKChvKT0+IHtcblx0XHRcdFx0YnVmZmVyLmRhdGEgPSBvO1xuXG5cdFx0XHRcdGNvdW50IC0tO1xuXHRcdFx0XHRpZihjb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc29sdmUoZ2x0ZkluZm8pO1x0XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHR9LCBlID0+IHtcblx0XHRcdFx0cmVqZWN0KGUpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0XG5cdH0gZWxzZSB7XG5cdFx0cmVzb2x2ZShnbHRmSW5mbyk7XHRcblx0fVxuXHRcbn0pO1xuXG5jb25zdCBfbG9hZFRleHR1cmVzID0gKGdsdGZJbmZvKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHsgdGV4dHVyZXMsIGltYWdlcywgc2FtcGxlcnMgfSA9IGdsdGZJbmZvO1xuXHRpZighaW1hZ2VzKSB7XG5cdFx0cmVzb2x2ZShnbHRmSW5mbyk7XG5cdH1cblxuXHRjb25zdCBpbWFnZXNUb0xvYWQgPSBpbWFnZXMubWFwKGltZyA9PiBgJHtiYXNlfSR7aW1nLnVyaX1gKTtcblxuXHRsb2FkSW1hZ2VzKGltYWdlc1RvTG9hZCkudGhlbigobykgPT4ge1xuXHRcdGdsdGZJbmZvLm91dHB1dC50ZXh0dXJlcyA9IG8ubWFwKChpbWcsIGkpID0+IHtcblx0XHRcdGNvbnN0IHNldHRpbmdzID0gb2JqZWN0QXNzaWduKHt9LCBzYW1wbGVycyA/IHNhbXBsZXJzW3RleHR1cmVzW2ldLnNhbXBsZXJdIDoge30pO1xuXHRcdFx0cmV0dXJuIG5ldyBHTFRleHR1cmUoaW1nLCBzZXR0aW5ncyk7XG5cdFx0fSk7XG5cdFx0cmVzb2x2ZShnbHRmSW5mbyk7XG5cdH0sIChlKT0+IHtcblx0XHRyZWplY3QoZSk7XG5cdH0pO1xufSk7XG5cbmNvbnN0IF9wYXJzZU1hdGVyaWFscyA9IChnbHRmSW5mbykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRjb25zdCB7IG1hdGVyaWFscyB9ID0gZ2x0ZkluZm87XG5cdGNvbnN0IHsgdGV4dHVyZXMgfSA9IGdsdGZJbmZvLm91dHB1dDtcblx0XG5cblx0Z2x0ZkluZm8ub3V0cHV0Lm1hdGVyaWFsSW5mbyA9IG1hdGVyaWFscy5tYXAobWF0ZXJpYWwgPT4ge1xuXHRcdG1hdGVyaWFsLmRlZmluZXMgPSB7XG5cdFx0XHRVU0VfSUJMOjFcblx0XHR9O1xuXG5cdFx0aWYobWF0ZXJpYWwubm9ybWFsVGV4dHVyZSkge1xuXHRcdFx0bWF0ZXJpYWwuZGVmaW5lcy5IQVNfTk9STUFMTUFQID0gMTtcblx0XHRcdG1hdGVyaWFsLm5vcm1hbFRleHR1cmUuZ2xUZXh0dXJlID0gdGV4dHVyZXNbbWF0ZXJpYWwubm9ybWFsVGV4dHVyZS5pbmRleF07XG5cdFx0fVxuXG5cdFx0aWYobWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZSkge1xuXHRcdFx0bWF0ZXJpYWwuZGVmaW5lcy5IQVNfT0NDTFVTSU9OTUFQID0gMTtcblx0XHRcdG1hdGVyaWFsLm9jY2x1c2lvblRleHR1cmUuZ2xUZXh0dXJlID0gdGV4dHVyZXNbbWF0ZXJpYWwub2NjbHVzaW9uVGV4dHVyZS5pbmRleF07XHRcblx0XHR9XG5cblxuXHRcdC8vIGlmKG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzKSB7XG5cdFx0aWYobWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSkge1xuXHRcdFx0bWF0ZXJpYWwuZGVmaW5lcy5IQVNfQkFTRUNPTE9STUFQID0gMTtcblx0XHRcdG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUuZ2xUZXh0dXJlID0gdGV4dHVyZXNbbWF0ZXJpYWwucGJyTWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZS5pbmRleF07XHRcblx0XHR9XG5cblx0XHRpZihtYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUpIHtcblx0XHRcdG1hdGVyaWFsLmRlZmluZXMuSEFTX01FVEFMUk9VR0hORVNTTUFQID0gMTtcblx0XHRcdG1hdGVyaWFsLnBick1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZS5nbFRleHR1cmUgPSB0ZXh0dXJlc1ttYXRlcmlhbC5wYnJNZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUuaW5kZXhdO1x0XG5cdFx0fVxuXG5cdFx0Ly8gfVxuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXHR9KTtcblxuXG5cdHJlc29sdmUoZ2x0ZkluZm8pO1xufSk7XG5cbmNvbnN0IHBhcnNlID0gKG1HbHRmSW5mbywgbUJpbikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRyZXNvbHZlKG1Tb3VyY2UpO1xufSk7XG5cblxuY29uc3QgX2dldEFjY2Vzc29yRGF0YSA9IChnbHRmLCBhY2Nlc3NvcklkeCwgaXNJbmRpY2VzID0gZmFsc2UpID0+IHtcblx0Y29uc3QgYWNjZXNzb3JJbmZvID0gZ2x0Zi5hY2Nlc3NvcnNbYWNjZXNzb3JJZHhdO1xuXHRjb25zdCBidWZmZXIgPSBnbHRmLmJ1ZmZlclZpZXdzW2FjY2Vzc29ySW5mby5idWZmZXJWaWV3XS5kYXRhO1xuXHRjb25zdCBieXRlT2Zmc2V0ID0gYWNjZXNzb3JJbmZvLmJ5dGVPZmZzZXQgfHwgMDtcblx0Y29uc3QgQXJyYXlDdG9yID0gQVJSQVlfQ1RPUl9NQVBbYWNjZXNzb3JJbmZvLmNvbXBvbmVudFR5cGVdIHx8IEZsb2F0MzJBcnJheTtcblx0bGV0IHNpemUgPSBTSVpFX01BUFthY2Nlc3NvckluZm8udHlwZV07XG5cdGlmIChzaXplID09IG51bGwgJiYgaXNJbmRpY2VzKSB7XG5cdFx0c2l6ZSA9IDE7XG5cdH1cblx0bGV0IGFyciA9IG5ldyBBcnJheUN0b3IoYnVmZmVyLCBieXRlT2Zmc2V0LCBzaXplICogYWNjZXNzb3JJbmZvLmNvdW50KTtcblx0Y29uc3QgcXVhbnRpemVFeHRlbnNpb24gPSBhY2Nlc3NvckluZm8uZXh0ZW5zaW9ucyAmJiBhY2Nlc3NvckluZm8uZXh0ZW5zaW9uc1snV0VCM0RfcXVhbnRpemVkX2F0dHJpYnV0ZXMnXTtcblx0aWYgKHF1YW50aXplRXh0ZW5zaW9uKSB7XG5cdFx0Y29uc3QgZGVjb2RlZEFyciA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIGFjY2Vzc29ySW5mby5jb3VudCk7XG5cdFx0Y29uc3QgZGVjb2RlTWF0cml4ID0gcXVhbnRpemVFeHRlbnNpb24uZGVjb2RlTWF0cml4O1xuXHRcdGNvbnN0IGRlY29kZU9mZnNldCA9IG5ldyBBcnJheShzaXplKTtcblx0XHRjb25zdCBkZWNvZGVTY2FsZSA9IG5ldyBBcnJheShzaXplKTtcblx0XHRmb3IgKGxldCBrID0gMDsgayA8IHNpemU7IGsrKykge1xuXHRcdFx0ZGVjb2RlT2Zmc2V0W2tdID0gZGVjb2RlTWF0cml4W3NpemUgKiAoc2l6ZSArIDEpICsga107XG5cdFx0XHRkZWNvZGVTY2FsZVtrXSA9IGRlY29kZU1hdHJpeFtrICogKHNpemUgKyAxKSArIGtdO1xuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFjY2Vzc29ySW5mby5jb3VudDsgaSsrKSB7XG5cdFx0XHRmb3IgKGxldCBrID0gMDsgayA8IHNpemU7IGsrKykge1xuXHRcdFx0XHRkZWNvZGVkQXJyW2kgKiBzaXplICsga10gPSBhcnJbaSAqIHNpemUgKyBrXSAqIGRlY29kZVNjYWxlW2tdICsgZGVjb2RlT2Zmc2V0W2tdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFyciA9IGRlY29kZWRBcnI7XG5cdH1cblxuXHQvLyBjb25zb2xlLmxvZyh7YnVmZmVyLCBieXRlT2Zmc2V0LCBBcnJheUN0b3IsIHNpemUsIGFycn0pO1xuXG5cdHJldHVybiBhcnI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGxvYWQsXG5cdHBhcnNlXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2xvYWRlcnMvR2x0ZkxvYWRlci5qcyIsIi8vIHhoci5qc1xuXG5jb25zdCBsb2FkID0gKG1QYXRoLCBpc0FycmF5QnVmZmVyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRyZXEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIChlKSA9PiB7XG5cdFx0cmVzb2x2ZShyZXEucmVzcG9uc2UpO1xuXHR9KTtcblxuXHRyZXEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZSkgPT4ge1xuXHRcdHJlamVjdChlKTtcblx0fSk7XG5cblx0aWYoaXNBcnJheUJ1ZmZlcikge1xuXHRcdHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHR9XG5cblx0cmVxLm9wZW4oJ0dFVCcsIG1QYXRoKTtcblx0cmVxLnNlbmQoKTtcblxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGxvYWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvbG9hZGVycy94aHIuanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIEVmZmVjdENvbXBvc2VyLmpzXG5cbmltcG9ydCBQYXNzIGZyb20gJy4vUGFzcyc7XG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEZyYW1lQnVmZmVyIGZyb20gJy4uL0ZyYW1lQnVmZmVyJztcblxuY2xhc3MgRWZmZWN0Q29tcG9zZXIge1xuXHRjb25zdHJ1Y3RvcihtV2lkdGgsIG1IZWlnaHQsIG1QYXJtYXMgPSB7fSkge1xuXHRcdHRoaXMuX3dpZHRoID0gbVdpZHRoIHx8IEdMLndpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IG1IZWlnaHQgfHwgR0wuaGVpZ2h0O1xuXG5cdFx0dGhpcy5fcGFyYW1zID0ge307XG5cdFx0dGhpcy5zZXRTaXplKG1XaWR0aCwgbUhlaWdodCk7XG5cdFx0dGhpcy5fZ2VvbWV0cnkgPSBHZW9tLmJpZ1RyaWFuZ2xlKCk7XG5cdFx0dGhpcy5fcGFzc2VzID0gW107XG5cdFx0dGhpcy5fcmV0dXJuVGV4dHVyZTtcblx0fVxuXG5cblx0YWRkUGFzcyhwYXNzKSB7XG5cdFx0aWYocGFzcy5wYXNzZXMpIHtcblx0XHRcdHRoaXMuYWRkUGFzcyhwYXNzLnBhc3Nlcyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChwYXNzLmxlbmd0aCkge1xuXHRcdFx0Zm9yKGxldCBpID0gMDsgaSA8IHBhc3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5fcGFzc2VzLnB1c2gocGFzc1tpXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3Bhc3Nlcy5wdXNoKHBhc3MpO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcihtU291cmNlKSB7XG5cdFx0bGV0IHNvdXJjZSA9IG1Tb3VyY2U7XG5cdFx0bGV0IGZib1RhcmdldDtcblxuXHRcdHRoaXMuX3Bhc3Nlcy5mb3JFYWNoKChwYXNzKSA9PiB7XG5cblx0XHRcdC8vXHRnZXQgdGFyZ2V0XG5cdFx0XHRpZihwYXNzLmhhc0Zibykge1xuXHRcdFx0XHRmYm9UYXJnZXQgPSBwYXNzLmZibztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZib1RhcmdldCA9IHRoaXMuX2Zib1RhcmdldDtcblx0XHRcdH1cblxuXHRcdFx0Ly9cdHJlbmRlclxuXHRcdFx0ZmJvVGFyZ2V0LmJpbmQoKTtcblx0XHRcdEdMLmNsZWFyKDAsIDAsIDAsIDApO1xuXHRcdFx0cGFzcy5yZW5kZXIoc291cmNlKTtcblx0XHRcdEdMLmRyYXcodGhpcy5fZ2VvbWV0cnkpO1xuXHRcdFx0ZmJvVGFyZ2V0LnVuYmluZCgpO1xuXG5cdFx0XHQvL1x0cmVzZXQgc291cmNlXG5cdFx0XHRpZihwYXNzLmhhc0Zibykge1xuXHRcdFx0XHRzb3VyY2UgPSBwYXNzLmZiby5nZXRUZXh0dXJlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zd2FwKCk7XHRcblx0XHRcdFx0c291cmNlID0gdGhpcy5fZmJvQ3VycmVudC5nZXRUZXh0dXJlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9yZXR1cm5UZXh0dXJlID0gc291cmNlO1xuXG5cdFx0cmV0dXJuIHNvdXJjZTtcblx0fVxuXG5cblx0X3N3YXAoKSB7XG5cdFx0Y29uc3QgdG1wID0gdGhpcy5fZmJvQ3VycmVudDtcblx0XHR0aGlzLl9mYm9DdXJyZW50ID0gdGhpcy5fZmJvVGFyZ2V0O1xuXHRcdHRoaXMuX2Zib1RhcmdldCA9IHRtcDtcblxuXHRcdHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9mYm9DdXJyZW50O1xuXHRcdHRoaXMuX3RhcmdldCA9IHRoaXMuX2Zib1RhcmdldDtcblx0fVxuXG5cdHNldFNpemUobVdpZHRoLCBtSGVpZ2h0KSB7XG5cdFx0dGhpcy5fd2lkdGggPSBtV2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gbUhlaWdodDtcblx0XHR0aGlzLl9mYm9DdXJyZW50ID0gbmV3IEZyYW1lQnVmZmVyKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHRoaXMuX3BhcmFtcyk7XG5cdFx0dGhpcy5fZmJvVGFyZ2V0ID0gbmV3IEZyYW1lQnVmZmVyKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHRoaXMuX3BhcmFtcyk7XG5cdH1cblxuXHRnZXQgcGFzc2VzKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXNzZXM7XG5cdH1cblxuXHRnZXRUZXh0dXJlKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZXR1cm5UZXh0dXJlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVmZmVjdENvbXBvc2VyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL3Bvc3QvRWZmZWN0Q29tcG9zZXIuanMiLCIvLyBQYXNzQmx1ci5qc1xuXG5pbXBvcnQgUGFzc1ZCbHVyIGZyb20gJy4vUGFzc1ZCbHVyJztcbmltcG9ydCBQYXNzSEJsdXIgZnJvbSAnLi9QYXNzSEJsdXInO1xuaW1wb3J0IFBhc3NNYWNybyBmcm9tICcuL1Bhc3NNYWNybyc7XG5cbmNsYXNzIFBhc3NCbHVyIGV4dGVuZHMgUGFzc01hY3JvIHtcblx0Y29uc3RydWN0b3IobVF1YWxpdHkgPSA5LCBtV2lkdGgsIG1IZWlnaHQsIG1QYXJhbXMpIHtcblx0XHRzdXBlcigpO1xuXHRcdGNvbnN0IHZCbHVyID0gbmV3IFBhc3NWQmx1cihtUXVhbGl0eSwgbVdpZHRoLCBtSGVpZ2h0LCBtUGFyYW1zKTtcblx0XHRjb25zdCBoQmx1ciA9IG5ldyBQYXNzSEJsdXIobVF1YWxpdHksIG1XaWR0aCwgbUhlaWdodCwgbVBhcmFtcyk7XG5cblx0XHR0aGlzLmFkZFBhc3ModkJsdXIpO1xuXHRcdHRoaXMuYWRkUGFzcyhoQmx1cik7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFzc0JsdXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NCbHVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJsdXI1LmZyYWdcXG4vLyBzb3VyY2UgIDogaHR0cHM6Ly9naXRodWIuY29tL0phbTMvZ2xzbC1mYXN0LWdhdXNzaWFuLWJsdXJcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJMVVJfNVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVEaXJlY3Rpb247XFxudW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xcblxcbnZlYzQgYmx1cjUoc2FtcGxlcjJEIGltYWdlLCB2ZWMyIHV2LCB2ZWMyIHJlc29sdXRpb24sIHZlYzIgZGlyZWN0aW9uKSB7XFxuXFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXHR2ZWMyIG9mZjEgPSB2ZWMyKDEuMzMzMzMzMzMzMzMzMzMzMykgKiBkaXJlY3Rpb247XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1dikgKiAwLjI5NDExNzY0NzA1ODgyMzU0O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzUyOTQxMTc2NDcwNTg4MjY7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zNTI5NDExNzY0NzA1ODgyNjtcXG5cXHRyZXR1cm4gY29sb3I7IFxcbn1cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSBibHVyNSh0ZXh0dXJlLCB2VGV4dHVyZUNvb3JkLCB1UmVzb2x1dGlvbiwgdURpcmVjdGlvbik7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2JsdXI1LmZyYWdcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vIGJsdXI5LmZyYWdcXG4vLyBzb3VyY2UgIDogaHR0cHM6Ly9naXRodWIuY29tL0phbTMvZ2xzbC1mYXN0LWdhdXNzaWFuLWJsdXJcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJMVVJfOVxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSB2ZWMyIHVEaXJlY3Rpb247XFxudW5pZm9ybSB2ZWMyIHVSZXNvbHV0aW9uO1xcblxcbnZlYzQgYmx1cjkoc2FtcGxlcjJEIGltYWdlLCB2ZWMyIHV2LCB2ZWMyIHJlc29sdXRpb24sIHZlYzIgZGlyZWN0aW9uKSB7XFxuXFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG5cXHR2ZWMyIG9mZjEgPSB2ZWMyKDEuMzg0NjE1Mzg0NikgKiBkaXJlY3Rpb247XFxuXFx0dmVjMiBvZmYyID0gdmVjMigzLjIzMDc2OTIzMDgpICogZGlyZWN0aW9uO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYpICogMC4yMjcwMjcwMjcwO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzE2MjE2MjE2MjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjMxNjIxNjIxNjI7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diArIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wNzAyNzAyNzAzO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDcwMjcwMjcwMztcXG5cXHRyZXR1cm4gY29sb3I7XFxufVxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGJsdXI5KHRleHR1cmUsIHZUZXh0dXJlQ29vcmQsIHVSZXNvbHV0aW9uLCB1RGlyZWN0aW9uKTtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvYmx1cjkuZnJhZ1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYmx1cjEzLmZyYWdcXG4vLyBzb3VyY2UgIDogaHR0cHM6Ly9naXRodWIuY29tL0phbTMvZ2xzbC1mYXN0LWdhdXNzaWFuLWJsdXJcXG5cXG4jZGVmaW5lIFNIQURFUl9OQU1FIEJMVVJfMTNcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcbnVuaWZvcm0gdmVjMiB1RGlyZWN0aW9uO1xcbnVuaWZvcm0gdmVjMiB1UmVzb2x1dGlvbjtcXG5cXG52ZWM0IGJsdXIxMyhzYW1wbGVyMkQgaW1hZ2UsIHZlYzIgdXYsIHZlYzIgcmVzb2x1dGlvbiwgdmVjMiBkaXJlY3Rpb24pIHtcXG5cXHR2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcblxcdHZlYzIgb2ZmMSA9IHZlYzIoMS40MTE3NjQ3MDU4ODIzNTMpICogZGlyZWN0aW9uO1xcblxcdHZlYzIgb2ZmMiA9IHZlYzIoMy4yOTQxMTc2NDcwNTg4MjM0KSAqIGRpcmVjdGlvbjtcXG5cXHR2ZWMyIG9mZjMgPSB2ZWMyKDUuMTc2NDcwNTg4MjM1Mjk0KSAqIGRpcmVjdGlvbjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2KSAqIDAuMTk2NDgyNTUwMTUxMTQwNDtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjI5NjkwNjk2NDY3MjgzNDQ7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4yOTY5MDY5NjQ2NzI4MzQ0O1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDk0NDcwMzk3ODUwNDQ3MzI7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYyIC8gcmVzb2x1dGlvbikpICogMC4wOTQ0NzAzOTc4NTA0NDczMjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjMgLyByZXNvbHV0aW9uKSkgKiAwLjAxMDM4MTM2MjQwMTE0ODA1NztcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjMgLyByZXNvbHV0aW9uKSkgKiAwLjAxMDM4MTM2MjQwMTE0ODA1NztcXG5cXHRyZXR1cm4gY29sb3I7XFxufVxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGJsdXIxMyh0ZXh0dXJlLCB2VGV4dHVyZUNvb3JkLCB1UmVzb2x1dGlvbiwgdURpcmVjdGlvbik7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2JsdXIxMy5mcmFnXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8vIFBhc3NGeGFhLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IFBhc3MgZnJvbSAnLi9QYXNzJztcbmltcG9ydCBmc0Z4YWEgZnJvbSAnLi4vZ2xzbC9meGFhLmZyYWcnO1xuXG5jbGFzcyBQYXNzRnhhYSBleHRlbmRzIFBhc3Mge1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihmc0Z4YWEpO1xuXHRcdHRoaXMudW5pZm9ybSgndVJlc29sdXRpb24nLCBbMS9HTC53aWR0aCwgMS9HTC5oZWlnaHRdKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXNzRnhhYTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9wb3N0L1Bhc3NGeGFhLmpzIiwiLy8gQmF0Y2hDb3B5LmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9iaWdUcmlhbmdsZS52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2dsc2wvY29weS5mcmFnJyk7XG5cbmNsYXNzIEJhdGNoQ29weSBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBtZXNoID0gR2VvbS5iaWdUcmlhbmdsZSgpO1xuXHRcdGNvbnN0IHNoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1xuXHRcdHN1cGVyKG1lc2gsIHNoYWRlcik7XG5cblx0XHRzaGFkZXIuYmluZCgpO1xuXHRcdHNoYWRlci51bmlmb3JtKCd0ZXh0dXJlJywgJ3VuaWZvcm0xaScsIDApO1xuXHR9XG5cblxuXHRkcmF3KHRleHR1cmUpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGV4dHVyZS5iaW5kKDApO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoQ29weTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoQ29weS5qcyIsIi8vIEJhdGNoQXhpcy5qc1xuXG5pbXBvcnQgR0wgZnJvbSAnLi4vR0xUb29sJztcbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuLi9HZW9tZXRyeSc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9nbHNsL2F4aXMudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9nbHNsL2F4aXMuZnJhZycpO1xuXG5cbmNsYXNzIEJhdGNoQXhpcyBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBwb3NpdGlvbnMgPSBbXTtcblx0XHRjb25zdCBjb2xvcnMgPSBbXTtcblx0XHRjb25zdCBpbmRpY2VzID0gWzAsIDEsIDIsIDMsIDQsIDVdO1xuXHRcdGNvbnN0IHIgPSA5OTk5O1xuXG5cdFx0cG9zaXRpb25zLnB1c2goWy1yLCAgMCwgIDBdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbciwgIDAsICAwXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsIC1yLCAgMF0pO1xuXHRcdHBvc2l0aW9ucy5wdXNoKFswLCAgciwgIDBdKTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgIDAsIC1yXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsICAwLCAgcl0pO1xuXG5cblx0XHRjb2xvcnMucHVzaChbMSwgMCwgMF0pO1xuXHRcdGNvbG9ycy5wdXNoKFsxLCAwLCAwXSk7XG5cdFx0Y29sb3JzLnB1c2goWzAsIDEsIDBdKTtcblx0XHRjb2xvcnMucHVzaChbMCwgMSwgMF0pO1xuXHRcdGNvbG9ycy5wdXNoKFswLCAwLCAxXSk7XG5cdFx0Y29sb3JzLnB1c2goWzAsIDAsIDFdKTtcblxuXHRcdGNvbnN0IG1lc2ggPSBuZXcgR2VvbWV0cnkoR0wuTElORVMpO1xuXHRcdG1lc2guYnVmZmVyVmVydGV4KHBvc2l0aW9ucyk7XG5cdFx0bWVzaC5idWZmZXJJbmRleChpbmRpY2VzKTtcblx0XHRtZXNoLmJ1ZmZlckRhdGEoY29sb3JzLCAnYUNvbG9yJywgMyk7XG5cblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblxuXHRcdHN1cGVyKG1lc2gsIHNoYWRlcik7XG5cblx0fVxuXG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBCYXRjaEF4aXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaEF4aXMuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYXhpcy52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBCQVNJQ19WRVJURVhcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzMgYUNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMzIGFOb3JtYWw7XFxuXFxudW5pZm9ybSBtYXQ0IHVNb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdVZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHVWaWV3TWF0cml4ICogdU1vZGVsTWF0cml4ICogdmVjNChhVmVydGV4UG9zaXRpb24sIDEuMCk7XFxuICAgIHZDb2xvciA9IGFDb2xvcjtcXG4gICAgdk5vcm1hbCA9IGFOb3JtYWw7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL2F4aXMudmVydFxuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gYXhpcy5mcmFnXFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBTSU1QTEVfVEVYVFVSRVxcblxcbnByZWNpc2lvbiBsb3dwIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMzIHZDb2xvcjtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdC8vIHZlYzMgY29sb3IgPSB2Tm9ybWFsO1xcblxcdHZlYzMgY29sb3IgPSB2Q29sb3IgKyB2Tm9ybWFsICogMC4wMDAxO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xcbn1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvZ2xzbC9heGlzLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQmF0Y2hCYWxsLmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9nZW5lcmFsLnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZ2xzbC9zaW1wbGVDb2xvci5mcmFnJyk7XG5cbmNsYXNzIEJhdGNoQmFsbCBleHRlbmRzIEJhdGNoIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRjb25zdCBnZW9tZXRyeSA9IEdlb20uc3BoZXJlKDEsIDI0KTtcblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblx0XHRzdXBlcihnZW9tZXRyeSwgc2hhZGVyKTtcblx0fVxuXG5cblx0ZHJhdyhwb3NpdGlvbiA9IFswLCAwLCAwXSwgc2NhbGUgPSBbMSwgMSwgMV0sIGNvbG9yID0gWzEsIDEsIDFdLCBvcGFjaXR5ID0gMSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdwb3NpdGlvbicsICd1bmlmb3JtM2Z2JywgcG9zaXRpb24pO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ3NjYWxlJywgJ3VuaWZvcm0zZnYnLCBzY2FsZSk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgnY29sb3InLCAndW5pZm9ybTNmdicsIGNvbG9yKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCdvcGFjaXR5JywgJ3VuaWZvcm0xZicsIG9wYWNpdHkpO1xuXHRcdHN1cGVyLmRyYXcoKTtcblx0fVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoQmFsbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoQmFsbC5qcyIsIi8vIEJhdGNoRG90c1BsYW5lLmpzXG5cbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IEdlb21ldHJ5IGZyb20gJy4uL0dlb21ldHJ5JztcbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5pbXBvcnQgQmF0Y2ggZnJvbSAnLi4vQmF0Y2gnO1xuXG5jb25zdCB2cyA9IHJlcXVpcmUoJy4uL2dsc2wvZG90c1BsYW5lLnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZ2xzbC9zaW1wbGVDb2xvci5mcmFnJyk7XG5cbmNsYXNzIEJhdGNoRG90c1BsYW5lIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgICA9IFtdO1xuXHRcdGxldCBpbmRleCAgICAgICA9IDA7XG5cdFx0Y29uc3Qgc2l6ZSAgICAgID0gMTAwO1xuXHRcdGxldCBpLCBqO1xuXG5cdFx0Zm9yKGkgPSAtc2l6ZTsgaSA8IHNpemU7IGkgKz0gMSkge1xuXHRcdFx0Zm9yKGogPSAtc2l6ZTsgaiA8IHNpemU7IGogKz0gMSkge1xuXHRcdFx0XHRwb3NpdGlvbnMucHVzaChbaSwgaiwgMF0pO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goaW5kZXgpO1xuXHRcdFx0XHRpbmRleCsrO1xuXG5cdFx0XHRcdHBvc2l0aW9ucy5wdXNoKFtpLCAwLCBqXSk7XG5cdFx0XHRcdGluZGljZXMucHVzaChpbmRleCk7XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGNvbnN0IGdlb21ldHJ5ICAgICA9IG5ldyBHZW9tZXRyeShHTC5QT0lOVFMpO1xuXHRcdGdlb21ldHJ5LmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRcdGdlb21ldHJ5LmJ1ZmZlckluZGV4KGluZGljZXMpO1xuXHRcdFxuXHRcdGNvbnN0IHNoYWRlciAgID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cdFx0XG5cdFx0c3VwZXIoZ2VvbWV0cnksIHNoYWRlcik7XG5cdFx0XG5cdFx0dGhpcy5jb2xvciAgID0gWzEsIDEsIDFdO1xuXHRcdHRoaXMub3BhY2l0eSA9IDAuNTtcblx0fVxuXG5cblx0ZHJhdygpIHtcblx0XHR0aGlzLnNoYWRlci5iaW5kKCk7XG5cdFx0dGhpcy5zaGFkZXIudW5pZm9ybSgnY29sb3InLCAndW5pZm9ybTNmdicsIHRoaXMuY29sb3IpO1xuXHRcdHRoaXMuc2hhZGVyLnVuaWZvcm0oJ29wYWNpdHknLCAndW5pZm9ybTFmJywgdGhpcy5vcGFjaXR5KTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hEb3RzUGxhbmU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaERvdHNQbGFuZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCIvLyBiYXNpYy52ZXJ0XFxuXFxuI2RlZmluZSBTSEFERVJfTkFNRSBET1RTX1BMQU5FX1ZFUlRFWFxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcbmF0dHJpYnV0ZSB2ZWMzIGFWZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogdVZpZXdNYXRyaXggKiB1TW9kZWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbiArIGFOb3JtYWwgKiAwLjAwMDAwMSwgMS4wKTtcXG4gICAgZ2xfUG9pbnRTaXplID0gMS4wO1xcbiAgICB2Tm9ybWFsID0gYU5vcm1hbDtcXG59XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2dsc2wvZG90c1BsYW5lLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDk3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gQmF0Y2hMaW5lLmpzXG5cblxuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5pbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi4vR2VvbWV0cnknO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9iYXNpYy52ZXJ0Jyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2dsc2wvc2ltcGxlQ29sb3IuZnJhZycpO1xuXG5cblxuY2xhc3MgQmF0Y2hBeGlzIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuXHRcdGNvbnN0IGluZGljZXMgPSBbMCwgMV07XG5cdFx0Y29uc3QgY29vcmRzID0gW1swLCAwXSwgWzEsIDFdXTtcblx0XHRwb3NpdGlvbnMucHVzaChbMCwgIDAsICAwXSk7XG5cdFx0cG9zaXRpb25zLnB1c2goWzAsICAwLCAgMF0pO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoR0wuTElORVMpO1xuXHRcdGdlb21ldHJ5LmJ1ZmZlclZlcnRleChwb3NpdGlvbnMpO1xuXHRcdGdlb21ldHJ5LmJ1ZmZlclRleENvb3JkKGNvb3Jkcyk7XG5cdFx0Z2VvbWV0cnkuYnVmZmVySW5kZXgoaW5kaWNlcyk7XG5cblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblxuXHRcdHN1cGVyKGdlb21ldHJ5LCBzaGFkZXIpO1xuXHR9XG5cblxuXHRkcmF3KG1Qb3NpdGlvbkEsIG1Qb3NpdGlvbkIsIGNvbG9yID0gWzEsIDEsIDFdLCBvcGFjaXR5ID0gMS4wKSB7XG5cdFx0dGhpcy5fZ2VvbWV0cnkuYnVmZmVyVmVydGV4KFttUG9zaXRpb25BLCBtUG9zaXRpb25CXSk7XG5cblx0XHR0aGlzLl9zaGFkZXIuYmluZCgpO1xuXHRcdHRoaXMuX3NoYWRlci51bmlmb3JtKCdjb2xvcicsICd2ZWMzJywgY29sb3IpO1xuXHRcdHRoaXMuX3NoYWRlci51bmlmb3JtKCdvcGFjaXR5JywgJ2Zsb2F0Jywgb3BhY2l0eSk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG5cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoQXhpcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9oZWxwZXJzL0JhdGNoTGluZS5qcyIsIi8vIEJhdGNoU2t5Ym94LmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9za3lib3gudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9nbHNsL3NreWJveC5mcmFnJyk7XG5cblxuY2xhc3MgQmF0Y2hTa3lib3ggZXh0ZW5kcyBCYXRjaCB7XG5cblx0Y29uc3RydWN0b3Ioc2l6ZSA9IDIwKSB7XG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBHZW9tLnNreWJveChzaXplKTtcblx0XHRjb25zdCBzaGFkZXIgPSBuZXcgR0xTaGFkZXIodnMsIGZzKTtcblxuXHRcdHN1cGVyKGdlb21ldHJ5LCBzaGFkZXIpO1xuXHR9XG5cblx0ZHJhdyh0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHRzdXBlci5kcmF3KCk7XG5cdH1cblxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hTa3lib3g7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2pzL2xpYi9hbGZyaWQvaGVscGVycy9CYXRjaFNreWJveC5qcyIsIi8vIEJhdGNoU2t5LmpzXG5cbmltcG9ydCBHZW9tIGZyb20gJy4uL0dlb20nO1xuaW1wb3J0IEdMU2hhZGVyIGZyb20gJy4uL0dMU2hhZGVyJztcbmltcG9ydCBCYXRjaCBmcm9tICcuLi9CYXRjaCc7XG5cbmNvbnN0IHZzID0gcmVxdWlyZSgnLi4vZ2xzbC9za3kudmVydCcpO1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9nbHNsL2NvcHkuZnJhZycpO1xuXG5cbmNsYXNzIEJhdGNoU2t5IGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKHNpemUgPSA1MCwgc2VnID0gMjQpIHtcblx0XHRjb25zdCBnZW9tZXRyeSA9IEdlb20uc3BoZXJlKHNpemUsIHNlZywgdHJ1ZSk7XG5cdFx0Y29uc3Qgc2hhZGVyID0gbmV3IEdMU2hhZGVyKHZzLCBmcyk7XG5cblx0XHRzdXBlcihnZW9tZXRyeSwgc2hhZGVyKTtcblx0fVxuXG5cdGRyYXcodGV4dHVyZSkge1xuXHRcdHRoaXMuc2hhZGVyLmJpbmQoKTtcblx0XHR0ZXh0dXJlLmJpbmQoMCk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhdGNoU2t5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hTa3kuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gc2t5LnZlcnRcXG5cXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjMyBhVmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhTm9ybWFsO1xcblxcbnVuaWZvcm0gbWF0NCB1TW9kZWxNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHVWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbk1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcdG1hdDQgbWF0VmlldyA9IHVWaWV3TWF0cml4O1xcblxcdG1hdFZpZXdbM11bMF0gPSAwLjA7XFxuXFx0bWF0Vmlld1szXVsxXSA9IDAuMDtcXG5cXHRtYXRWaWV3WzNdWzJdID0gMC4wO1xcblxcdFxcbiAgICBnbF9Qb3NpdGlvbiA9IHVQcm9qZWN0aW9uTWF0cml4ICogbWF0VmlldyAqIHVNb2RlbE1hdHJpeCAqIHZlYzQoYVZlcnRleFBvc2l0aW9uLCAxLjApO1xcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXG4gICAgdk5vcm1hbCA9IGFOb3JtYWw7XFxufVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvbGliL2FsZnJpZC9nbHNsL3NreS52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBCYXRjaEZYQUEuanNcbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IEdlb20gZnJvbSAnLi4vR2VvbSc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEJhdGNoIGZyb20gJy4uL0JhdGNoJztcblxuY29uc3QgdnMgPSByZXF1aXJlKCcuLi9nbHNsL2JpZ1RyaWFuZ2xlLnZlcnQnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZ2xzbC9meGFhLmZyYWcnKTtcblxuY2xhc3MgQmF0Y2hGWEFBIGV4dGVuZHMgQmF0Y2gge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gR2VvbS5iaWdUcmlhbmdsZSgpO1xuXHRcdGNvbnN0IHNoYWRlciA9IG5ldyBHTFNoYWRlcih2cywgZnMpO1xuXHRcdHN1cGVyKGdlb21ldHJ5LCBzaGFkZXIpO1xuXG5cdFx0c2hhZGVyLmJpbmQoKTtcblx0XHRzaGFkZXIudW5pZm9ybSgndGV4dHVyZScsICd1bmlmb3JtMWknLCAwKTtcblx0fVxuXG5cblx0ZHJhdyh0ZXh0dXJlKSB7XG5cdFx0dGhpcy5zaGFkZXIuYmluZCgpO1xuXHRcdHRleHR1cmUuYmluZCgwKTtcblx0XHR0aGlzLnNoYWRlci51bmlmb3JtKCd1UmVzb2x1dGlvbicsICd2ZWMyJywgWzEvR0wud2lkdGgsIDEvR0wuaGVpZ2h0XSk7XG5cdFx0c3VwZXIuZHJhdygpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQmF0Y2hGWEFBO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvQmF0Y2hGWEFBLmpzIiwiLy8gU2NlbmUuanNcblxuaW1wb3J0IFNjaGVkdWxlciBmcm9tICdzY2hlZHVsaW5nJztcbmltcG9ydCBHTCBmcm9tICcuLi9HTFRvb2wnO1xuaW1wb3J0IENhbWVyYVBlcnNwZWN0aXZlIGZyb20gJy4uL2NhbWVyYXMvQ2FtZXJhUGVyc3BlY3RpdmUnO1xuaW1wb3J0IENhbWVyYU9ydGhvIGZyb20gJy4uL2NhbWVyYXMvQ2FtZXJhT3J0aG8nO1xuaW1wb3J0IE9yYml0YWxDb250cm9sIGZyb20gJy4uL3V0aWxzL09yYml0YWxDb250cm9sJztcblxuXG5jbGFzcyBTY2VuZSB7XG5cblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX21hdHJpeElkZW50aXR5ID0gbWF0NC5jcmVhdGUoKTtcblx0XHRHTC5lbmFibGVBbHBoYUJsZW5kaW5nKCk7XG5cblx0XHR0aGlzLl9pbml0KCk7XG5cdFx0dGhpcy5faW5pdFRleHR1cmVzKCk7XG5cdFx0dGhpcy5faW5pdFZpZXdzKCk7XG5cblx0XHR0aGlzLl9lZkluZGV4ID0gU2NoZWR1bGVyLmFkZEVGKCgpPT50aGlzLl9sb29wKCkpO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKT0+dGhpcy5yZXNpemUoKSk7XG5cdH1cblxuXG5cdFxuXHQvL1x0UFVCTElDIE1FVEhPRFNcblxuXHR1cGRhdGUoKSB7XG5cblx0fVxuXG5cdHJlbmRlcigpIHtcblxuXHR9XG5cblxuXHRzdG9wKCkge1xuXHRcdGlmKHRoaXMuX2VmSW5kZXggPT09IC0xKSB7XHRyZXR1cm47IH1cblx0XHR0aGlzLl9lZkluZGV4ID0gU2NoZWR1bGVyLnJlbW92ZUVGKHRoaXMuX2VmSW5kZXgpO1xuXHR9XG5cblxuXHRzdGFydCgpIHtcblx0XHRpZih0aGlzLl9lZkluZGV4ICE9PSAtMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gXG5cblx0XHR0aGlzLl9lZkluZGV4ID0gU2NoZWR1bGVyLmFkZEVGKCgpPT50aGlzLl9sb29wKCkpO1xuXHR9XG5cblxuXHRyZXNpemUoKSB7XG5cdFx0R0wuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcblx0XHR0aGlzLmNhbWVyYS5zZXRBc3BlY3RSYXRpbyhHTC5hc3BlY3RSYXRpbyk7XG5cdH1cblxuXG5cdGFkZENoaWxkKG1DaGlsZCkge1xuXHRcdHRoaXMuX2NoaWxkcmVuLnB1c2gobUNoaWxkKTtcblx0fVxuXG5cdHJlbW92ZUNoaWxkKG1DaGlsZCkge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihtQ2hpbGQpO1xuXHRcdGlmKGluZGV4ID09IC0xKSB7XHRjb25zb2xlLndhcm4oJ0NoaWxkIG5vIGV4aXN0Jyk7IHJldHVybjtcdH1cblxuXHRcdHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXG5cdC8vXHRQUk9URUNURUQgTUVUSE9EUyBUTyBCRSBPVkVSUklERU4gQlkgQ0hJTERSRU5cblxuXHRfaW5pdFRleHR1cmVzKCkge1xuXG5cdH1cblxuXG5cdF9pbml0Vmlld3MoKSB7XG5cblx0fVxuXG5cblx0X3JlbmRlckNoaWxkcmVuKCkge1xuXHRcdGxldCBjaGlsZDtcblx0XHRmb3IobGV0IGk9MDsgaTx0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcblx0XHRcdGNoaWxkLnRvUmVuZGVyKCk7XG5cdFx0fVxuXG5cdFx0R0wucm90YXRlKHRoaXMuX21hdHJpeElkZW50aXR5KTtcblx0fVxuXG5cdC8vXHRQUklWQVRFIE1FVEhPRFNcblxuXHRfaW5pdCgpIHtcblx0XHR0aGlzLmNhbWVyYSAgICAgICAgICAgICAgICAgPSBuZXcgQ2FtZXJhUGVyc3BlY3RpdmUoKTtcblx0XHR0aGlzLmNhbWVyYS5zZXRQZXJzcGVjdGl2ZSg0NSAqIE1hdGguUEkgLyAxODAsIEdMLmFzcGVjdFJhdGlvLCAwLjEsIDEwMCk7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbCAgICAgICAgICA9IG5ldyBPcmJpdGFsQ29udHJvbCh0aGlzLmNhbWVyYSwgd2luZG93LCAxNSk7XG5cdFx0dGhpcy5vcmJpdGFsQ29udHJvbC5yYWRpdXMudmFsdWUgPSAxMDtcblx0XHRcblx0XHR0aGlzLmNhbWVyYU9ydGhvICAgICAgICAgICAgPSBuZXcgQ2FtZXJhT3J0aG8oKTtcblx0fVxuXG5cdF9sb29wKCkge1xuXG5cdFx0Ly9cdFJFU0VUIFZJRVdQT1JUXG5cdFx0R0wudmlld3BvcnQoMCwgMCwgR0wud2lkdGgsIEdMLmhlaWdodCk7XG5cblx0XHQvL1x0UkVTRVQgQ0FNRVJBXG5cdFx0R0wuc2V0TWF0cmljZXModGhpcy5jYW1lcmEpO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLl9yZW5kZXJDaGlsZHJlbigpO1xuXHRcdHRoaXMucmVuZGVyKCk7XG5cdH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFNjZW5lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvU2NlbmUuanMiLCIvLyBWaWV3LmpzXG5cbmltcG9ydCBHTFNoYWRlciBmcm9tICcuLi9HTFNoYWRlcic7XG5cbmNsYXNzIFZpZXcge1xuXHRjb25zdHJ1Y3RvcihtU3RyVmVydGV4LCBtU3RyRnJhZykge1xuXHRcdHRoaXMuc2hhZGVyID0gbmV3IEdMU2hhZGVyKG1TdHJWZXJ0ZXgsIG1TdHJGcmFnKTtcblxuXHRcdHRoaXMuX2luaXQoKTtcblx0fVxuXG5cblx0Ly9cdFBST1RFQ1RFRCBNRVRIT0RTXG5cblx0X2luaXQoKSB7XG5cblx0fVxuXG5cdC8vIFx0UFVCTElDIE1FVEhPRFNcblxuXHRyZW5kZXIoKSB7XG5cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBWaWV3O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvVmlldy5qcyIsIi8vIFZpZXczRC5qc1xuXG5pbXBvcnQgT2JqZWN0M0QgZnJvbSAnLi4vb2JqZWN0cy9PYmplY3QzRCc7XG5pbXBvcnQgR0xTaGFkZXIgZnJvbSAnLi4vR0xTaGFkZXInO1xuaW1wb3J0IEdMIGZyb20gJy4uL0dMVG9vbCc7XG5cbmNsYXNzIFZpZXczRCBleHRlbmRzIE9iamVjdDNEIHtcblx0Y29uc3RydWN0b3IobVN0clZlcnRleCwgbVN0ckZyYWcpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLnNoYWRlciA9IG5ldyBHTFNoYWRlcihtU3RyVmVydGV4LCBtU3RyRnJhZyk7XG5cdFx0dGhpcy5faW5pdCgpO1xuXHRcdHRoaXMuX21hdHJpeFRlbXAgPSBtYXQ0LmNyZWF0ZSgpO1xuXHR9XG5cblxuXHQvL1x0UFJPVEVDVEVEIE1FVEhPRFNcblxuXHRfaW5pdCgpIHtcblxuXHR9XG5cblx0Ly8gXHRQVUJMSUMgTUVUSE9EU1xuXG5cdGFkZENoaWxkKG1DaGlsZCkge1xuXHRcdHRoaXMuX2NoaWxkcmVuLnB1c2gobUNoaWxkKTtcblx0fVxuXG5cdHJlbW92ZUNoaWxkKG1DaGlsZCkge1xuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihtQ2hpbGQpO1xuXHRcdGlmKGluZGV4ID09IC0xKSB7XHRjb25zb2xlLndhcm4oJ0NoaWxkIG5vIGV4aXN0Jyk7IHJldHVybjtcdH1cblxuXHRcdHRoaXMuX2NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXG5cdHRvUmVuZGVyKG1hdHJpeCkge1xuXHRcdGlmKG1hdHJpeCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXHRcdH1cblx0XHRtYXQ0Lm11bCh0aGlzLl9tYXRyaXhUZW1wLCBtYXRyaXgsIHRoaXMubWF0cml4KTtcblx0XHRHTC5yb3RhdGUodGhpcy5fbWF0cml4VGVtcCk7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblxuXHRcdGZvcihsZXQgaT0wOyBpPHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0Y2hpbGQudG9SZW5kZXIodGhpcy5tYXRyaXgpO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcigpIHtcblxuXHR9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVmlldzNEO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9qcy9saWIvYWxmcmlkL2hlbHBlcnMvVmlldzNELmpzIiwiLy8gZGVidWcuanNcbmltcG9ydCBkYXQgZnJvbSAnZGF0LWd1aSc7XG5pbXBvcnQgU3RhdHMgZnJvbSAnc3RhdHMuanMnO1xuaW1wb3J0IGFsZnJpZCwgeyBHTCB9IGZyb20gJ2FsZnJpZCc7XG5cblxuLy9cdElOSVQgREFULUdVSVxud2luZG93Lmd1aSA9IG5ldyBkYXQuR1VJKHsgd2lkdGg6MzAwIH0pO1xuY29uc3QgZGl2ID0gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKCcuZGcuYWMnKTtcbmRpdi5zdHlsZS56SW5kZXggPSAnOTk5JztcblxuLy9cdFNUQVRTXG5jb25zdCBzdGF0cyA9IG5ldyBTdGF0cygpO1xuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0cy5kb21FbGVtZW50KTtcbmFsZnJpZC5TY2hlZHVsZXIuYWRkRUYoKCk9PnN0YXRzLnVwZGF0ZSgpKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvanMvZGVidWcvZGVidWcuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdmVuZG9yL2RhdC5ndWknKVxubW9kdWxlLmV4cG9ydHMuY29sb3IgPSByZXF1aXJlKCcuL3ZlbmRvci9kYXQuY29sb3InKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RhdC1ndWkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKipcbiAqIGRhdC1ndWkgSmF2YVNjcmlwdCBDb250cm9sbGVyIExpYnJhcnlcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9kYXQtZ3VpXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuLyoqIEBuYW1lc3BhY2UgKi9cbnZhciBkYXQgPSBtb2R1bGUuZXhwb3J0cyA9IGRhdCB8fCB7fTtcblxuLyoqIEBuYW1lc3BhY2UgKi9cbmRhdC5ndWkgPSBkYXQuZ3VpIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LnV0aWxzID0gZGF0LnV0aWxzIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmNvbnRyb2xsZXJzID0gZGF0LmNvbnRyb2xsZXJzIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmRvbSA9IGRhdC5kb20gfHwge307XG5cbi8qKiBAbmFtZXNwYWNlICovXG5kYXQuY29sb3IgPSBkYXQuY29sb3IgfHwge307XG5cbmRhdC51dGlscy5jc3MgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGxvYWQ6IGZ1bmN0aW9uICh1cmwsIGRvYykge1xuICAgICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgICAgdmFyIGxpbmsgPSBkb2MuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgbGluay50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQobGluayk7XG4gICAgfSxcbiAgICBpbmplY3Q6IGZ1bmN0aW9uKGNzcywgZG9jKSB7XG4gICAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgICB2YXIgaW5qZWN0ZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgaW5qZWN0ZWQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICBpbmplY3RlZC5pbm5lckhUTUwgPSBjc3M7XG4gICAgICBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChpbmplY3RlZCk7XG4gICAgfVxuICB9XG59KSgpO1xuXG5cbmRhdC51dGlscy5jb21tb24gPSAoZnVuY3Rpb24gKCkge1xuICBcbiAgdmFyIEFSUl9FQUNIID0gQXJyYXkucHJvdG90eXBlLmZvckVhY2g7XG4gIHZhciBBUlJfU0xJQ0UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIEJhbmQtYWlkIG1ldGhvZHMgZm9yIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBhIGxvdCBlYXNpZXIgaW4gSmF2YVNjcmlwdC5cbiAgICogSW1wbGVtZW50YXRpb24gYW5kIHN0cnVjdHVyZSBpbnNwaXJlZCBieSB1bmRlcnNjb3JlLmpzXG4gICAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAgICovXG5cbiAgcmV0dXJuIHsgXG4gICAgXG4gICAgQlJFQUs6IHt9LFxuICBcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICghdGhpcy5pc1VuZGVmaW5lZChvYmpba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmYXVsdHM6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgXG4gICAgICB0aGlzLmVhY2goQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzLCAxKSwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgIGlmICh0aGlzLmlzVW5kZWZpbmVkKHRhcmdldFtrZXldKSkgXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIFxuICAgIH0sXG4gICAgXG4gICAgY29tcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9DYWxsID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBUlJfU0xJQ0UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdG9DYWxsLmxlbmd0aCAtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gW3RvQ2FsbFtpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ciwgc2NvcGUpIHtcblxuICAgICAgXG4gICAgICBpZiAoQVJSX0VBQ0ggJiYgb2JqLmZvckVhY2ggPT09IEFSUl9FQUNIKSB7IFxuICAgICAgICBcbiAgICAgICAgb2JqLmZvckVhY2goaXRyLCBzY29wZSk7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSBvYmoubGVuZ3RoICsgMCkgeyAvLyBJcyBudW1iZXIgYnV0IG5vdCBOYU5cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGtleSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBrZXkgPCBsOyBrZXkrKylcbiAgICAgICAgICBpZiAoa2V5IGluIG9iaiAmJiBpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspIFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIFxuICAgICAgICAgIGlmIChpdHIuY2FsbChzY29wZSwgb2JqW2tleV0sIGtleSkgPT09IHRoaXMuQlJFQUspXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgZGVmZXI6IGZ1bmN0aW9uKGZuYykge1xuICAgICAgc2V0VGltZW91dChmbmMsIDApO1xuICAgIH0sXG4gICAgXG4gICAgdG9BcnJheTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqLnRvQXJyYXkpIHJldHVybiBvYmoudG9BcnJheSgpO1xuICAgICAgcmV0dXJuIEFSUl9TTElDRS5jYWxsKG9iaik7XG4gICAgfSxcblxuICAgIGlzVW5kZWZpbmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIFxuICAgIGlzTnVsbDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICAgIH0sXG4gICAgXG4gICAgaXNOYU46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqO1xuICAgIH0sXG4gICAgXG4gICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5O1xuICAgIH0sXG4gICAgXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG4gICAgfSxcbiAgICBcbiAgICBpc051bWJlcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorMDtcbiAgICB9LFxuICAgIFxuICAgIGlzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IG9iaisnJztcbiAgICB9LFxuICAgIFxuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBmYWxzZSB8fCBvYmogPT09IHRydWU7XG4gICAgfSxcbiAgICBcbiAgICBpc0Z1bmN0aW9uOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gIFxuICB9O1xuICAgIFxufSkoKTtcblxuXG5kYXQuY29udHJvbGxlcnMuQ29udHJvbGxlciA9IChmdW5jdGlvbiAoY29tbW9uKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzcyBBbiBcImFic3RyYWN0XCIgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2l2ZW4gcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIENvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAvKipcbiAgICAgKiBUaG9zZSB3aG8gZXh0ZW5kIHRoaXMgY2xhc3Mgd2lsbCBwdXQgdGhlaXIgRE9NIGVsZW1lbnRzIGluIGhlcmUuXG4gICAgICogQHR5cGUge0RPTUVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHRvIG1hbmlwdWxhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIG1hbmlwdWxhdGVcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gY2hhbmdlLlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX29uQ2hhbmdlID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBmaW5pc2hpbmcgY2hhbmdlLlxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlID0gdW5kZWZpbmVkO1xuXG4gIH07XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIC8qKiBAbGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIucHJvdG90eXBlICovXG4gICAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgdGhhdCBhIGZ1bmN0aW9uIGZpcmUgZXZlcnkgdGltZSBzb21lb25lIGNoYW5nZXMgdGhlIHZhbHVlIHdpdGhcbiAgICAgICAgICogdGhpcyBDb250cm9sbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbmMgVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWVcbiAgICAgICAgICogaXMgbW9kaWZpZWQgdmlhIHRoaXMgQ29udHJvbGxlci5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5Db250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24oZm5jKSB7XG4gICAgICAgICAgdGhpcy5fX29uQ2hhbmdlID0gZm5jO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IHRoYXQgYSBmdW5jdGlvbiBmaXJlIGV2ZXJ5IHRpbWUgc29tZW9uZSBcImZpbmlzaGVzXCIgY2hhbmdpbmdcbiAgICAgICAgICogdGhlIHZhbHVlIHdpaCB0aGlzIENvbnRyb2xsZXIuIFVzZWZ1bCBmb3IgdmFsdWVzIHRoYXQgY2hhbmdlXG4gICAgICAgICAqIGluY3JlbWVudGFsbHkgbGlrZSBudW1iZXJzIG9yIHN0cmluZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuYyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyXG4gICAgICAgICAqIHNvbWVvbmUgXCJmaW5pc2hlc1wiIGNoYW5naW5nIHRoZSB2YWx1ZSB2aWEgdGhpcyBDb250cm9sbGVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG9uRmluaXNoQ2hhbmdlOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgICAgICB0aGlzLl9fb25GaW5pc2hDaGFuZ2UgPSBmbmM7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZSB0aGUgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICovXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgIHRoaXMub2JqZWN0W3RoaXMucHJvcGVydHldID0gbmV3VmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uQ2hhbmdlLmNhbGwodGhpcywgbmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGN1cnJlbnQgdmFsdWUgb2YgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RbdGhpcy5wcm9wZXJ0eV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZnJlc2hlcyB0aGUgdmlzdWFsIGRpc3BsYXkgb2YgYSBDb250cm9sbGVyIGluIG9yZGVyIHRvIGtlZXAgc3luY1xuICAgICAgICAgKiB3aXRoIHRoZSBvYmplY3QncyBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZURpc3BsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdmFsdWUgaGFzIGRldmlhdGVkIGZyb20gaW5pdGlhbFZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBpc01vZGlmaWVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWUgIT09IHRoaXMuZ2V0VmFsdWUoKVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBDb250cm9sbGVyO1xuXG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5kb20uZG9tID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICB2YXIgRVZFTlRfTUFQID0ge1xuICAgICdIVE1MRXZlbnRzJzogWydjaGFuZ2UnXSxcbiAgICAnTW91c2VFdmVudHMnOiBbJ2NsaWNrJywnbW91c2Vtb3ZlJywnbW91c2Vkb3duJywnbW91c2V1cCcsICdtb3VzZW92ZXInXSxcbiAgICAnS2V5Ym9hcmRFdmVudHMnOiBbJ2tleWRvd24nXVxuICB9O1xuXG4gIHZhciBFVkVOVF9NQVBfSU5WID0ge307XG4gIGNvbW1vbi5lYWNoKEVWRU5UX01BUCwgZnVuY3Rpb24odiwgaykge1xuICAgIGNvbW1vbi5lYWNoKHYsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIEVWRU5UX01BUF9JTlZbZV0gPSBrO1xuICAgIH0pO1xuICB9KTtcblxuICB2YXIgQ1NTX1ZBTFVFX1BJWEVMUyA9IC8oXFxkKyhcXC5cXGQrKT8pcHgvO1xuXG4gIGZ1bmN0aW9uIGNzc1ZhbHVlVG9QaXhlbHModmFsKSB7XG5cbiAgICBpZiAodmFsID09PSAnMCcgfHwgY29tbW9uLmlzVW5kZWZpbmVkKHZhbCkpIHJldHVybiAwO1xuXG4gICAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKENTU19WQUxVRV9QSVhFTFMpO1xuXG4gICAgaWYgKCFjb21tb24uaXNOdWxsKG1hdGNoKSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgIH1cblxuICAgIC8vIFRPRE8gLi4uZW1zPyAlP1xuXG4gICAgcmV0dXJuIDA7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBtZW1iZXIgZGF0LmRvbVxuICAgKi9cbiAgdmFyIGRvbSA9IHtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIHNlbGVjdGFibGVcbiAgICAgKi9cbiAgICBtYWtlU2VsZWN0YWJsZTogZnVuY3Rpb24oZWxlbSwgc2VsZWN0YWJsZSkge1xuXG4gICAgICBpZiAoZWxlbSA9PT0gdW5kZWZpbmVkIHx8IGVsZW0uc3R5bGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICBlbGVtLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIH07XG5cbiAgICAgIGVsZW0uc3R5bGUuTW96VXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgICBlbGVtLnN0eWxlLktodG1sVXNlclNlbGVjdCA9IHNlbGVjdGFibGUgPyAnYXV0bycgOiAnbm9uZSc7XG4gICAgICBlbGVtLnVuc2VsZWN0YWJsZSA9IHNlbGVjdGFibGUgPyAnb24nIDogJ29mZic7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBob3Jpem9udGFsXG4gICAgICogQHBhcmFtIHZlcnRpY2FsXG4gICAgICovXG4gICAgbWFrZUZ1bGxzY3JlZW46IGZ1bmN0aW9uKGVsZW0sIGhvcml6b250YWwsIHZlcnRpY2FsKSB7XG5cbiAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQoaG9yaXpvbnRhbCkpIGhvcml6b250YWwgPSB0cnVlO1xuICAgICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZCh2ZXJ0aWNhbCkpIHZlcnRpY2FsID0gdHJ1ZTtcblxuICAgICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgIGVsZW0uc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIGVsZW0uc3R5bGUucmlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGVsZW0uc3R5bGUudG9wID0gMDtcbiAgICAgICAgZWxlbS5zdHlsZS5ib3R0b20gPSAwO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIGZha2VFdmVudDogZnVuY3Rpb24oZWxlbSwgZXZlbnRUeXBlLCBwYXJhbXMsIGF1eCkge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IEVWRU5UX01BUF9JTlZbZXZlbnRUeXBlXTtcbiAgICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgdHlwZSAnICsgZXZlbnRUeXBlICsgJyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgfVxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGNsYXNzTmFtZSk7XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlICdNb3VzZUV2ZW50cyc6XG4gICAgICAgICAgdmFyIGNsaWVudFggPSBwYXJhbXMueCB8fCBwYXJhbXMuY2xpZW50WCB8fCAwO1xuICAgICAgICAgIHZhciBjbGllbnRZID0gcGFyYW1zLnkgfHwgcGFyYW1zLmNsaWVudFkgfHwgMDtcbiAgICAgICAgICBldnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcyB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgcGFyYW1zLmNhbmNlbGFibGUgfHwgdHJ1ZSwgd2luZG93LCBwYXJhbXMuY2xpY2tDb3VudCB8fCAxLFxuICAgICAgICAgICAgICAwLCAvL3NjcmVlbiBYXG4gICAgICAgICAgICAgIDAsIC8vc2NyZWVuIFlcbiAgICAgICAgICAgICAgY2xpZW50WCwgLy9jbGllbnQgWFxuICAgICAgICAgICAgICBjbGllbnRZLCAvL2NsaWVudCBZXG4gICAgICAgICAgICAgIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS2V5Ym9hcmRFdmVudHMnOlxuICAgICAgICAgIHZhciBpbml0ID0gZXZ0LmluaXRLZXlib2FyZEV2ZW50IHx8IGV2dC5pbml0S2V5RXZlbnQ7IC8vIHdlYmtpdCB8fCBtb3pcbiAgICAgICAgICBjb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICAgICAgICBrZXlDb2RlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFyQ29kZTogdW5kZWZpbmVkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5pdChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJhbXMuY2FuY2VsYWJsZSwgd2luZG93LFxuICAgICAgICAgICAgICBwYXJhbXMuY3RybEtleSwgcGFyYW1zLmFsdEtleSxcbiAgICAgICAgICAgICAgcGFyYW1zLnNoaWZ0S2V5LCBwYXJhbXMubWV0YUtleSxcbiAgICAgICAgICAgICAgcGFyYW1zLmtleUNvZGUsIHBhcmFtcy5jaGFyQ29kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHBhcmFtcy5idWJibGVzIHx8IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJhbXMuY2FuY2VsYWJsZSB8fCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbW1vbi5kZWZhdWx0cyhldnQsIGF1eCk7XG4gICAgICBlbGVtLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICBiaW5kOiBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgYm9vbCkge1xuICAgICAgYm9vbCA9IGJvb2wgfHwgZmFsc2U7XG4gICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsIGJvb2wpO1xuICAgICAgZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudClcbiAgICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGZ1bmMpO1xuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50LCBmdW5jLCBib29sKSB7XG4gICAgICBib29sID0gYm9vbCB8fCBmYWxzZTtcbiAgICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpXG4gICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgYm9vbCk7XG4gICAgICBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KVxuICAgICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgICAqL1xuICAgIGFkZENsYXNzOiBmdW5jdGlvbihlbGVtLCBjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgfSBlbHNlIGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUuc3BsaXQoLyArLyk7XG4gICAgICAgIGlmIChjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJykucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lXG4gICAgICovXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoZWxlbS5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGVsZW0uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW0uY2xhc3NOYW1lID09PSBjbGFzc05hbWUpIHtcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2xhc3NlcyA9IGVsZW0uY2xhc3NOYW1lLnNwbGl0KC8gKy8pO1xuICAgICAgICAgIHZhciBpbmRleCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpO1xuICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uY2xhc3NOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsZW0sIGNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJyg/Ol58XFxcXHMrKScgKyBjbGFzc05hbWUgKyAnKD86XFxcXHMrfCQpJykudGVzdChlbGVtLmNsYXNzTmFtZSkgfHwgZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oZWxlbSkge1xuXG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuXG4gICAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWxlZnQtd2lkdGgnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ2JvcmRlci1yaWdodC13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy1sZWZ0J10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydwYWRkaW5nLXJpZ2h0J10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWyd3aWR0aCddKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbVxuICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24oZWxlbSkge1xuXG4gICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuXG4gICAgICByZXR1cm4gY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLXRvcC13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsnYm9yZGVyLWJvdHRvbS13aWR0aCddKSArXG4gICAgICAgICAgY3NzVmFsdWVUb1BpeGVscyhzdHlsZVsncGFkZGluZy10b3AnXSkgK1xuICAgICAgICAgIGNzc1ZhbHVlVG9QaXhlbHMoc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10pICtcbiAgICAgICAgICBjc3NWYWx1ZVRvUGl4ZWxzKHN0eWxlWydoZWlnaHQnXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1cbiAgICAgKi9cbiAgICBnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHZhciBvZmZzZXQgPSB7bGVmdDogMCwgdG9wOjB9O1xuICAgICAgaWYgKGVsZW0ub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvZmZzZXQubGVmdCArPSBlbGVtLm9mZnNldExlZnQ7XG4gICAgICAgICAgb2Zmc2V0LnRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICAgICAgfSB3aGlsZSAoZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9wb3N0cy8yNjg0NTYxL3JldmlzaW9uc1xuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBlbGVtXG4gICAgICovXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiApO1xuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBkb207XG5cbn0pKGRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5PcHRpb25Db250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSBzZWxlY3QgaW5wdXQgdG8gYWx0ZXIgdGhlIHByb3BlcnR5IG9mIGFuIG9iamVjdCwgdXNpbmcgYVxuICAgKiBsaXN0IG9mIGFjY2VwdGVkIHZhbHVlcy5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nW119IG9wdGlvbnMgQSBtYXAgb2YgbGFiZWxzIHRvIGFjY2VwdGFibGUgdmFsdWVzLCBvclxuICAgKiBhIGxpc3Qgb2YgYWNjZXB0YWJsZSBzdHJpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE9wdGlvbkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBvcHRpb25zKSB7XG5cbiAgICBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHJvcCBkb3duIG1lbnVcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdGhpcy5fX3NlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuXG4gICAgaWYgKGNvbW1vbi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbWFwID0ge307XG4gICAgICBjb21tb24uZWFjaChvcHRpb25zLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIG1hcFtlbGVtZW50XSA9IGVsZW1lbnQ7XG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnMgPSBtYXA7XG4gICAgfVxuXG4gICAgY29tbW9uLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXG4gICAgICB2YXIgb3B0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICBvcHQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgICBfdGhpcy5fX3NlbGVjdC5hcHBlbmRDaGlsZChvcHQpO1xuXG4gICAgfSk7XG5cbiAgICAvLyBBY2tub3dsZWRnZSBvcmlnaW5hbCB2YWx1ZVxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX3NlbGVjdCwgJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRlc2lyZWRWYWx1ZSA9IHRoaXMub3B0aW9uc1t0aGlzLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgX3RoaXMuc2V0VmFsdWUoZGVzaXJlZFZhbHVlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fc2VsZWN0KTtcblxuICB9O1xuXG4gIE9wdGlvbkNvbnRyb2xsZXIuc3VwZXJjbGFzcyA9IENvbnRyb2xsZXI7XG5cbiAgY29tbW9uLmV4dGVuZChcblxuICAgICAgT3B0aW9uQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICBDb250cm9sbGVyLnByb3RvdHlwZSxcblxuICAgICAge1xuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIHRvUmV0dXJuID0gT3B0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuICAgICAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0LnZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBPcHRpb25Db250cm9sbGVyLnN1cGVyY2xhc3MucHJvdG90eXBlLnVwZGF0ZURpc3BsYXkuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gT3B0aW9uQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jb21tb24pO1xuXG5cbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdGhhdCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogQGV4dGVuZHMgZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWluXSBNaW5pbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMubWF4XSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwYXJhbXMuc3RlcF0gSW5jcmVtZW50IGJ5IHdoaWNoIHRvIGNoYW5nZSB2YWx1ZVxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIE51bWJlckNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcblxuICAgIE51bWJlckNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgdGhpcy5fX21pbiA9IHBhcmFtcy5taW47XG4gICAgdGhpcy5fX21heCA9IHBhcmFtcy5tYXg7XG4gICAgdGhpcy5fX3N0ZXAgPSBwYXJhbXMuc3RlcDtcblxuICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQodGhpcy5fX3N0ZXApKSB7XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSA9PSAwKSB7XG4gICAgICAgIHRoaXMuX19pbXBsaWVkU3RlcCA9IDE7IC8vIFdoYXQgYXJlIHdlLCBwc3ljaGljcz9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhleSBEb3VnLCBjaGVjayB0aGlzIG91dC5cbiAgICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2codGhpcy5pbml0aWFsVmFsdWUpL01hdGguTE4xMCkpLzEwO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhpcy5fX2ltcGxpZWRTdGVwID0gdGhpcy5fX3N0ZXA7XG5cbiAgICB9XG5cbiAgICB0aGlzLl9fcHJlY2lzaW9uID0gbnVtRGVjaW1hbHModGhpcy5fX2ltcGxpZWRTdGVwKTtcblxuXG4gIH07XG5cbiAgTnVtYmVyQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBOdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICAvKiogQGxlbmRzIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyLnByb3RvdHlwZSAqL1xuICAgICAge1xuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5fX21pbiAhPT0gdW5kZWZpbmVkICYmIHYgPCB0aGlzLl9fbWluKSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5fX21pbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX19tYXggIT09IHVuZGVmaW5lZCAmJiB2ID4gdGhpcy5fX21heCkge1xuICAgICAgICAgICAgdiA9IHRoaXMuX19tYXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuX19zdGVwICE9PSB1bmRlZmluZWQgJiYgdiAlIHRoaXMuX19zdGVwICE9IDApIHtcbiAgICAgICAgICAgIHYgPSBNYXRoLnJvdW5kKHYgLyB0aGlzLl9fc3RlcCkgKiB0aGlzLl9fc3RlcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gTnVtYmVyQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgYSBtaW5pbXVtIHZhbHVlIGZvciA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pblZhbHVlIFRoZSBtaW5pbXVtIHZhbHVlIGZvclxuICAgICAgICAgKiA8Y29kZT5vYmplY3RbcHJvcGVydHldPC9jb2RlPlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJ9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIG1pbjogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX19taW4gPSB2O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGEgbWF4aW11bSB2YWx1ZSBmb3IgPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhWYWx1ZSBUaGUgbWF4aW11bSB2YWx1ZSBmb3JcbiAgICAgICAgICogPGNvZGU+b2JqZWN0W3Byb3BlcnR5XTwvY29kZT5cbiAgICAgICAgICogQHJldHVybnMge2RhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyfSB0aGlzXG4gICAgICAgICAqL1xuICAgICAgICBtYXg6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9fbWF4ID0gdjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmeSBhIHN0ZXAgdmFsdWUgdGhhdCBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgICAgICAgKiBpbmNyZW1lbnRzIGJ5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RlcFZhbHVlIFRoZSBzdGVwIHZhbHVlIGZvclxuICAgICAgICAgKiBkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclxuICAgICAgICAgKiBAZGVmYXVsdCBpZiBtaW5pbXVtIGFuZCBtYXhpbXVtIHNwZWNpZmllZCBpbmNyZW1lbnQgaXMgMSUgb2YgdGhlXG4gICAgICAgICAqIGRpZmZlcmVuY2Ugb3RoZXJ3aXNlIHN0ZXBWYWx1ZSBpcyAxXG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcn0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RlcDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX19zdGVwID0gdjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICBmdW5jdGlvbiBudW1EZWNpbWFscyh4KSB7XG4gICAgeCA9IHgudG9TdHJpbmcoKTtcbiAgICBpZiAoeC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcmV0dXJuIHgubGVuZ3RoIC0geC5pbmRleE9mKCcuJykgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTnVtYmVyQ29udHJvbGxlcjtcblxufSkoZGF0LmNvbnRyb2xsZXJzLkNvbnRyb2xsZXIsXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlckJveCA9IChmdW5jdGlvbiAoTnVtYmVyQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdGhhdCBpcyBhIG51bWJlciBhbmRcbiAgICogcHJvdmlkZXMgYW4gaW5wdXQgZWxlbWVudCB3aXRoIHdoaWNoIHRvIG1hbmlwdWxhdGUgaXQuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1pbl0gTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLm1heF0gTWF4aW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcGFyYW1zLnN0ZXBdIEluY3JlbWVudCBieSB3aGljaCB0byBjaGFuZ2UgdmFsdWVcbiAgICpcbiAgICogQG1lbWJlciBkYXQuY29udHJvbGxlcnNcbiAgICovXG4gIHZhciBOdW1iZXJDb250cm9sbGVyQm94ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKSB7XG5cbiAgICB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IGZhbHNlO1xuXG4gICAgTnVtYmVyQ29udHJvbGxlckJveC5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSwgcGFyYW1zKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiB7TnVtYmVyfSBQcmV2aW91cyBtb3VzZSB5IHBvc2l0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHZhciBwcmV2X3k7XG5cbiAgICB0aGlzLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXG4gICAgLy8gTWFrZXMgaXQgc28gbWFudWFsbHkgc3BlY2lmaWVkIHZhbHVlcyBhcmUgbm90IHRydW5jYXRlZC5cblxuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2NoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgLy8gV2hlbiBwcmVzc2luZyBlbnRpcmUsIHlvdSBjYW4gYmUgYXMgcHJlY2lzZSBhcyB5b3Ugd2FudC5cbiAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIF90aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICBfdGhpcy5fX3RydW5jYXRpb25TdXNwZW5kZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG4gICAgICB2YXIgYXR0ZW1wdGVkID0gcGFyc2VGbG9hdChfdGhpcy5fX2lucHV0LnZhbHVlKTtcbiAgICAgIGlmICghY29tbW9uLmlzTmFOKGF0dGVtcHRlZCkpIF90aGlzLnNldFZhbHVlKGF0dGVtcHRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIGlmIChfdGhpcy5fX29uRmluaXNoQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLl9fb25GaW5pc2hDaGFuZ2UuY2FsbChfdGhpcywgX3RoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBwcmV2X3kgPSBlLmNsaWVudFk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuXG4gICAgICB2YXIgZGlmZiA9IHByZXZfeSAtIGUuY2xpZW50WTtcbiAgICAgIF90aGlzLnNldFZhbHVlKF90aGlzLmdldFZhbHVlKCkgKyBkaWZmICogX3RoaXMuX19pbXBsaWVkU3RlcCk7XG5cbiAgICAgIHByZXZfeSA9IGUuY2xpZW50WTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VVcCgpIHtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2Vtb3ZlJywgb25Nb3VzZURyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9faW5wdXQpO1xuXG4gIH07XG5cbiAgTnVtYmVyQ29udHJvbGxlckJveC5zdXBlcmNsYXNzID0gTnVtYmVyQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBOdW1iZXJDb250cm9sbGVyQm94LnByb3RvdHlwZSxcbiAgICAgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB0aGlzLl9faW5wdXQudmFsdWUgPSB0aGlzLl9fdHJ1bmNhdGlvblN1c3BlbmRlZCA/IHRoaXMuZ2V0VmFsdWUoKSA6IHJvdW5kVG9EZWNpbWFsKHRoaXMuZ2V0VmFsdWUoKSwgdGhpcy5fX3ByZWNpc2lvbik7XG4gICAgICAgICAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJCb3guc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIGZ1bmN0aW9uIHJvdW5kVG9EZWNpbWFsKHZhbHVlLCBkZWNpbWFscykge1xuICAgIHZhciB0ZW5UbyA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiB0ZW5UbykgLyB0ZW5UbztcbiAgfVxuXG4gIHJldHVybiBOdW1iZXJDb250cm9sbGVyQm94O1xuXG59KShkYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJTbGlkZXIgPSAoZnVuY3Rpb24gKE51bWJlckNvbnRyb2xsZXIsIGRvbSwgY3NzLCBjb21tb24sIHN0eWxlU2hlZXQpIHtcblxuICAvKipcbiAgICogQGNsYXNzIFJlcHJlc2VudHMgYSBnaXZlbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgdGhhdCBpcyBhIG51bWJlciwgY29udGFpbnNcbiAgICogYSBtaW5pbXVtIGFuZCBtYXhpbXVtLCBhbmQgcHJvdmlkZXMgYSBzbGlkZXIgZWxlbWVudCB3aXRoIHdoaWNoIHRvXG4gICAqIG1hbmlwdWxhdGUgaXQuIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IHRoZSBzbGlkZXIgZWxlbWVudCBpcyBtYWRlIHVwIG9mXG4gICAqIDxjb2RlPiZsdDtkaXYmZ3Q7PC9jb2RlPiB0YWdzLCA8c3Ryb25nPm5vdDwvc3Ryb25nPiB0aGUgaHRtbDVcbiAgICogPGNvZGU+Jmx0O3NsaWRlciZndDs8L2NvZGU+IGVsZW1lbnQuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWluVmFsdWUgTWluaW11bSBhbGxvd2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhWYWx1ZSBNYXhpbXVtIGFsbG93ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBWYWx1ZSBJbmNyZW1lbnQgYnkgd2hpY2ggdG8gY2hhbmdlIHZhbHVlXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgTnVtYmVyQ29udHJvbGxlclNsaWRlciA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIG1pbiwgbWF4LCBzdGVwKSB7XG5cbiAgICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5LCB7IG1pbjogbWluLCBtYXg6IG1heCwgc3RlcDogc3RlcCB9KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9fYmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuX19mb3JlZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgXG5cblxuICAgIGRvbS5iaW5kKHRoaXMuX19iYWNrZ3JvdW5kLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIFxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fYmFja2dyb3VuZCwgJ3NsaWRlcicpO1xuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fZm9yZWdyb3VuZCwgJ3NsaWRlci1mZycpO1xuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xuXG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBvbk1vdXNlRHJhZyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgb25Nb3VzZVVwKTtcblxuICAgICAgb25Nb3VzZURyYWcoZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25Nb3VzZURyYWcoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBkb20uZ2V0T2Zmc2V0KF90aGlzLl9fYmFja2dyb3VuZCk7XG4gICAgICB2YXIgd2lkdGggPSBkb20uZ2V0V2lkdGgoX3RoaXMuX19iYWNrZ3JvdW5kKTtcbiAgICAgIFxuICAgICAgX3RoaXMuc2V0VmFsdWUoXG4gICAgICAgIG1hcChlLmNsaWVudFgsIG9mZnNldC5sZWZ0LCBvZmZzZXQubGVmdCArIHdpZHRoLCBfdGhpcy5fX21pbiwgX3RoaXMuX19tYXgpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vdXNlVXAoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIG9uTW91c2VEcmFnKTtcbiAgICAgIGRvbS51bmJpbmQod2luZG93LCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBpZiAoX3RoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICBfdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwoX3RoaXMsIF90aGlzLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuXG4gICAgdGhpcy5fX2JhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5fX2ZvcmVncm91bmQpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fYmFja2dyb3VuZCk7XG5cbiAgfTtcblxuICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnN1cGVyY2xhc3MgPSBOdW1iZXJDb250cm9sbGVyO1xuXG4gIC8qKlxuICAgKiBJbmplY3RzIGRlZmF1bHQgc3R5bGVzaGVldCBmb3Igc2xpZGVyIGVsZW1lbnRzLlxuICAgKi9cbiAgTnVtYmVyQ29udHJvbGxlclNsaWRlci51c2VEZWZhdWx0U3R5bGVzID0gZnVuY3Rpb24oKSB7XG4gICAgY3NzLmluamVjdChzdHlsZVNoZWV0KTtcbiAgfTtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBOdW1iZXJDb250cm9sbGVyU2xpZGVyLnByb3RvdHlwZSxcbiAgICAgIE51bWJlckNvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHBjdCA9ICh0aGlzLmdldFZhbHVlKCkgLSB0aGlzLl9fbWluKS8odGhpcy5fX21heCAtIHRoaXMuX19taW4pO1xuICAgICAgICAgIHRoaXMuX19mb3JlZ3JvdW5kLnN0eWxlLndpZHRoID0gcGN0KjEwMCsnJSc7XG4gICAgICAgICAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuXG5cbiAgKTtcblxuICBmdW5jdGlvbiBtYXAodiwgaTEsIGkyLCBvMSwgbzIpIHtcbiAgICByZXR1cm4gbzEgKyAobzIgLSBvMSkgKiAoKHYgLSBpMSkgLyAoaTIgLSBpMSkpO1xuICB9XG5cbiAgcmV0dXJuIE51bWJlckNvbnRyb2xsZXJTbGlkZXI7XG4gIFxufSkoZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXIsXG5kYXQuZG9tLmRvbSxcbmRhdC51dGlscy5jc3MsXG5kYXQudXRpbHMuY29tbW9uLFxuXCIuc2xpZGVyIHtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMTUpO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBib3JkZXItcmFkaXVzOiAxZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgcGFkZGluZzogMCAwLjVlbTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5zbGlkZXItZmcge1xcbiAgcGFkZGluZzogMXB4IDAgMnB4IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWFhO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBtYXJnaW4tbGVmdDogLTAuNWVtO1xcbiAgcGFkZGluZy1yaWdodDogMC41ZW07XFxuICBib3JkZXItcmFkaXVzOiAxZW0gMCAwIDFlbTtcXG59XFxuXFxuLnNsaWRlci1mZzphZnRlciB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBib3JkZXItcmFkaXVzOiAxZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyOiAgMXB4IHNvbGlkICNhYWE7XFxuICBjb250ZW50OiAnJztcXG4gIGZsb2F0OiByaWdodDtcXG4gIG1hcmdpbi1yaWdodDogLTFlbTtcXG4gIG1hcmdpbi10b3A6IC0xcHg7XFxuICBoZWlnaHQ6IDAuOWVtO1xcbiAgd2lkdGg6IDAuOWVtO1xcbn1cIik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLkZ1bmN0aW9uQ29udHJvbGxlciA9IChmdW5jdGlvbiAoQ29udHJvbGxlciwgZG9tLCBjb21tb24pIHtcblxuICAvKipcbiAgICogQGNsYXNzIFByb3ZpZGVzIGEgR1VJIGludGVyZmFjZSB0byBmaXJlIGEgc3BlY2lmaWVkIG1ldGhvZCwgYSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgRnVuY3Rpb25Db250cm9sbGVyID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgdGV4dCkge1xuXG4gICAgRnVuY3Rpb25Db250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9fYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2J1dHRvbi5pbm5lckhUTUwgPSB0ZXh0ID09PSB1bmRlZmluZWQgPyAnRmlyZScgOiB0ZXh0O1xuICAgIGRvbS5iaW5kKHRoaXMuX19idXR0b24sICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIF90aGlzLmZpcmUoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fYnV0dG9uLCAnYnV0dG9uJyk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2J1dHRvbik7XG5cblxuICB9O1xuXG4gIEZ1bmN0aW9uQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBGdW5jdGlvbkNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG4gICAgICB7XG4gICAgICAgIFxuICAgICAgICBmaXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5fX29uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9fb25DaGFuZ2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX19vbkZpbmlzaENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fX29uRmluaXNoQ2hhbmdlLmNhbGwodGhpcywgdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpLmNhbGwodGhpcy5vYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gRnVuY3Rpb25Db250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LmNvbnRyb2xsZXJzLkJvb2xlYW5Db250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSBjaGVja2JveCBpbnB1dCB0byBhbHRlciB0aGUgYm9vbGVhbiBwcm9wZXJ0eSBvZiBhbiBvYmplY3QuXG4gICAqIEBleHRlbmRzIGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiZSBtYW5pcHVsYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1hbmlwdWxhdGVkXG4gICAqXG4gICAqIEBtZW1iZXIgZGF0LmNvbnRyb2xsZXJzXG4gICAqL1xuICB2YXIgQm9vbGVhbkNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzLmNhbGwodGhpcywgb2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX19wcmV2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuXG4gICAgdGhpcy5fX2NoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB0aGlzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG5cblxuICAgIGRvbS5iaW5kKHRoaXMuX19jaGVja2JveCwgJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG5cbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fX2NoZWNrYm94KTtcblxuICAgIC8vIE1hdGNoIG9yaWdpbmFsIHZhbHVlXG4gICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIF90aGlzLnNldFZhbHVlKCFfdGhpcy5fX3ByZXYpO1xuICAgIH1cblxuICB9O1xuXG4gIEJvb2xlYW5Db250cm9sbGVyLnN1cGVyY2xhc3MgPSBDb250cm9sbGVyO1xuXG4gIGNvbW1vbi5leHRlbmQoXG5cbiAgICAgIEJvb2xlYW5Db250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgdG9SZXR1cm4gPSBCb29sZWFuQ29udHJvbGxlci5zdXBlcmNsYXNzLnByb3RvdHlwZS5zZXRWYWx1ZS5jYWxsKHRoaXMsIHYpO1xuICAgICAgICAgIGlmICh0aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKHRoaXMsIHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19wcmV2ID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodGhpcy5nZXRWYWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9fY2hlY2tib3guc2V0QXR0cmlidXRlKCdjaGVja2VkJywgJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgIHRoaXMuX19jaGVja2JveC5jaGVja2VkID0gdHJ1ZTsgICAgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fX2NoZWNrYm94LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIH1cblxuXG4gICAgICB9XG5cbiAgKTtcblxuICByZXR1cm4gQm9vbGVhbkNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29sb3IudG9TdHJpbmcgPSAoZnVuY3Rpb24gKGNvbW1vbikge1xuXG4gIHJldHVybiBmdW5jdGlvbihjb2xvcikge1xuXG4gICAgaWYgKGNvbG9yLmEgPT0gMSB8fCBjb21tb24uaXNVbmRlZmluZWQoY29sb3IuYSkpIHtcblxuICAgICAgdmFyIHMgPSBjb2xvci5oZXgudG9TdHJpbmcoMTYpO1xuICAgICAgd2hpbGUgKHMubGVuZ3RoIDwgNikge1xuICAgICAgICBzID0gJzAnICsgcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcjJyArIHM7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gJ3JnYmEoJyArIE1hdGgucm91bmQoY29sb3IucikgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yLmcpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5iKSArICcsJyArIGNvbG9yLmEgKyAnKSc7XG5cbiAgICB9XG5cbiAgfVxuXG59KShkYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuY29sb3IuaW50ZXJwcmV0ID0gKGZ1bmN0aW9uICh0b1N0cmluZywgY29tbW9uKSB7XG5cbiAgdmFyIHJlc3VsdCwgdG9SZXR1cm47XG5cbiAgdmFyIGludGVycHJldCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdG9SZXR1cm4gPSBmYWxzZTtcblxuICAgIHZhciBvcmlnaW5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gY29tbW9uLnRvQXJyYXkoYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXTtcblxuICAgIGNvbW1vbi5lYWNoKElOVEVSUFJFVEFUSU9OUywgZnVuY3Rpb24oZmFtaWx5KSB7XG5cbiAgICAgIGlmIChmYW1pbHkubGl0bXVzKG9yaWdpbmFsKSkge1xuXG4gICAgICAgIGNvbW1vbi5lYWNoKGZhbWlseS5jb252ZXJzaW9ucywgZnVuY3Rpb24oY29udmVyc2lvbiwgY29udmVyc2lvbk5hbWUpIHtcblxuICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnNpb24ucmVhZChvcmlnaW5hbCk7XG5cbiAgICAgICAgICBpZiAodG9SZXR1cm4gPT09IGZhbHNlICYmIHJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvUmV0dXJuID0gcmVzdWx0O1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb25OYW1lID0gY29udmVyc2lvbk5hbWU7XG4gICAgICAgICAgICByZXN1bHQuY29udmVyc2lvbiA9IGNvbnZlcnNpb247XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjb21tb24uQlJFQUs7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gIH07XG5cbiAgdmFyIElOVEVSUFJFVEFUSU9OUyA9IFtcblxuICAgIC8vIFN0cmluZ3NcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzU3RyaW5nLFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFRIUkVFX0NIQVJfSEVYOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9eIyhbQS1GMC05XSkoW0EtRjAtOV0pKFtBLUYwLTldKSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoXG4gICAgICAgICAgICAgICAgICAnMHgnICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzFdLnRvU3RyaW5nKCkgKyB0ZXN0WzFdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbMl0udG9TdHJpbmcoKSArIHRlc3RbMl0udG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFszXS50b1N0cmluZygpICsgdGVzdFszXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIFNJWF9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV17Nn0pJC9pKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBwYXJzZUludCgnMHgnICsgdGVzdFsxXS50b1N0cmluZygpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0I6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JcXChcXHMqKC4rKVxccyosXFxzKiguKylcXHMqLFxccyooLispXFxzKlxcKS8pO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBwYXJzZUZsb2F0KHRlc3RbMV0pLFxuICAgICAgICAgICAgICBnOiBwYXJzZUZsb2F0KHRlc3RbMl0pLFxuICAgICAgICAgICAgICBiOiBwYXJzZUZsb2F0KHRlc3RbM10pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiB0b1N0cmluZ1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgQ1NTX1JHQkE6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL15yZ2JhXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCxcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKSxcbiAgICAgICAgICAgICAgYTogcGFyc2VGbG9hdCh0ZXN0WzRdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBOdW1iZXJzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc051bWJlcixcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBIRVg6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IG9yaWdpbmFsLFxuICAgICAgICAgICAgICBjb252ZXJzaW9uTmFtZTogJ0hFWCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sb3IuaGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gQXJyYXlzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc0FycmF5LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQl9BUlJBWToge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubGVuZ3RoICE9IDMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogb3JpZ2luYWxbMF0sXG4gICAgICAgICAgICAgIGc6IG9yaWdpbmFsWzFdLFxuICAgICAgICAgICAgICBiOiBvcmlnaW5hbFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmJdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIFJHQkFfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSA0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl0sXG4gICAgICAgICAgICAgIGE6IG9yaWdpbmFsWzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgY29sb3IuYV07XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIE9iamVjdHNcbiAgICB7XG5cbiAgICAgIGxpdG11czogY29tbW9uLmlzT2JqZWN0LFxuXG4gICAgICBjb252ZXJzaW9uczoge1xuXG4gICAgICAgIFJHQkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmIsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuZykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgICAgcjogb3JpZ2luYWwucixcbiAgICAgICAgICAgICAgICBnOiBvcmlnaW5hbC5nLFxuICAgICAgICAgICAgICAgIGI6IG9yaWdpbmFsLmJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgSFNWQV9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5hKSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudixcbiAgICAgICAgICAgICAgICBhOiBvcmlnaW5hbC5hXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBoOiBjb2xvci5oLFxuICAgICAgICAgICAgICBzOiBjb2xvci5zLFxuICAgICAgICAgICAgICB2OiBjb2xvci52LFxuICAgICAgICAgICAgICBhOiBjb2xvci5hXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVl9PQko6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5oKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC5zKSAmJlxuICAgICAgICAgICAgICAgIGNvbW1vbi5pc051bWJlcihvcmlnaW5hbC52KSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiAnSFNWJyxcbiAgICAgICAgICAgICAgICBoOiBvcmlnaW5hbC5oLFxuICAgICAgICAgICAgICAgIHM6IG9yaWdpbmFsLnMsXG4gICAgICAgICAgICAgICAgdjogb3JpZ2luYWwudlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuXG4gIF07XG5cbiAgcmV0dXJuIGludGVycHJldDtcblxuXG59KShkYXQuY29sb3IudG9TdHJpbmcsXG5kYXQudXRpbHMuY29tbW9uKTtcblxuXG5kYXQuR1VJID0gZGF0Lmd1aS5HVUkgPSAoZnVuY3Rpb24gKGNzcywgc2F2ZURpYWxvZ3VlQ29udGVudHMsIHN0eWxlU2hlZXQsIGNvbnRyb2xsZXJGYWN0b3J5LCBDb250cm9sbGVyLCBCb29sZWFuQ29udHJvbGxlciwgRnVuY3Rpb25Db250cm9sbGVyLCBOdW1iZXJDb250cm9sbGVyQm94LCBOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBPcHRpb25Db250cm9sbGVyLCBDb2xvckNvbnRyb2xsZXIsIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgQ2VudGVyZWREaXYsIGRvbSwgY29tbW9uKSB7XG5cbiAgY3NzLmluamVjdChzdHlsZVNoZWV0KTtcblxuICAvKiogT3V0ZXItbW9zdCBjbGFzc05hbWUgZm9yIEdVSSdzICovXG4gIHZhciBDU1NfTkFNRVNQQUNFID0gJ2RnJztcblxuICB2YXIgSElERV9LRVlfQ09ERSA9IDcyO1xuXG4gIC8qKiBUaGUgb25seSB2YWx1ZSBzaGFyZWQgYmV0d2VlbiB0aGUgSlMgYW5kIFNDU1MuIFVzZSBjYXV0aW9uLiAqL1xuICB2YXIgQ0xPU0VfQlVUVE9OX0hFSUdIVCA9IDIwO1xuXG4gIHZhciBERUZBVUxUX0RFRkFVTFRfUFJFU0VUX05BTUUgPSAnRGVmYXVsdCc7XG5cbiAgdmFyIFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cgJiYgd2luZG93Wydsb2NhbFN0b3JhZ2UnXSAhPT0gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuXG4gIHZhciBTQVZFX0RJQUxPR1VFO1xuXG4gIC8qKiBIYXZlIHdlIHlldCB0byBjcmVhdGUgYW4gYXV0b1BsYWNlIEdVST8gKi9cbiAgdmFyIGF1dG9fcGxhY2VfdmlyZ2luID0gdHJ1ZTtcblxuICAvKiogRml4ZWQgcG9zaXRpb24gZGl2IHRoYXQgYXV0byBwbGFjZSBHVUkncyBnbyBpbnNpZGUgKi9cbiAgdmFyIGF1dG9fcGxhY2VfY29udGFpbmVyO1xuXG4gIC8qKiBBcmUgd2UgaGlkaW5nIHRoZSBHVUkncyA/ICovXG4gIHZhciBoaWRlID0gZmFsc2U7XG5cbiAgLyoqIEdVSSdzIHdoaWNoIHNob3VsZCBiZSBoaWRkZW4gKi9cbiAgdmFyIGhpZGVhYmxlX2d1aXMgPSBbXTtcblxuICAvKipcbiAgICogQSBsaWdodHdlaWdodCBjb250cm9sbGVyIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuIEl0IGFsbG93cyB5b3UgdG8gZWFzaWx5XG4gICAqIG1hbmlwdWxhdGUgdmFyaWFibGVzIGFuZCBmaXJlIGZ1bmN0aW9ucyBvbiB0aGUgZmx5LlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICogQG1lbWJlciBkYXQuZ3VpXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5uYW1lXSBUaGUgbmFtZSBvZiB0aGlzIEdVSS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXMubG9hZF0gSlNPTiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzYXZlZCBzdGF0ZSBvZlxuICAgKiB0aGlzIEdVSS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmF1dG89dHJ1ZV1cbiAgICogQHBhcmFtIHtkYXQuZ3VpLkdVSX0gW3BhcmFtcy5wYXJlbnRdIFRoZSBHVUkgSSdtIG5lc3RlZCBpbi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmNsb3NlZF0gSWYgdHJ1ZSwgc3RhcnRzIGNsb3NlZFxuICAgKi9cbiAgdmFyIEdVSSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIE91dGVybW9zdCBET00gRWxlbWVudFxuICAgICAqIEB0eXBlIERPTUVsZW1lbnRcbiAgICAgKi9cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fdWwpO1xuXG4gICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgQ1NTX05BTUVTUEFDRSk7XG5cbiAgICAvKipcbiAgICAgKiBOZXN0ZWQgR1VJJ3MgYnkgbmFtZVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fZm9sZGVycyA9IHt9O1xuXG4gICAgdGhpcy5fX2NvbnRyb2xsZXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIG9iamVjdHMgSSdtIHJlbWVtYmVyaW5nIGZvciBzYXZlLCBvbmx5IHVzZWQgaW4gdG9wIGxldmVsIEdVSVxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICB0aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgdGhlIGluZGV4IG9mIHJlbWVtYmVyZWQgb2JqZWN0cyB0byBhIG1hcCBvZiBjb250cm9sbGVycywgb25seSB1c2VkXG4gICAgICogaW4gdG9wIGxldmVsIEdVSS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGlnbm9yZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbXG4gICAgICogIHtcbiAgICAgKiAgICBwcm9wZXJ0eU5hbWU6IENvbnRyb2xsZXIsXG4gICAgICogICAgYW5vdGhlclByb3BlcnR5TmFtZTogQ29udHJvbGxlclxuICAgICAqICB9LFxuICAgICAqICB7XG4gICAgICogICAgcHJvcGVydHlOYW1lOiBDb250cm9sbGVyXG4gICAgICogIH1cbiAgICAgKiBdXG4gICAgICovXG4gICAgdGhpcy5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVycyA9IFtdO1xuXG4gICAgdGhpcy5fX2xpc3RlbmluZyA9IFtdO1xuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgLy8gRGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgcGFyYW1zID0gY29tbW9uLmRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgYXV0b1BsYWNlOiB0cnVlLFxuICAgICAgd2lkdGg6IEdVSS5ERUZBVUxUX1dJRFRIXG4gICAgfSk7XG5cbiAgICBwYXJhbXMgPSBjb21tb24uZGVmYXVsdHMocGFyYW1zLCB7XG4gICAgICByZXNpemFibGU6IHBhcmFtcy5hdXRvUGxhY2UsXG4gICAgICBoaWRlYWJsZTogcGFyYW1zLmF1dG9QbGFjZVxuICAgIH0pO1xuXG5cbiAgICBpZiAoIWNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMubG9hZCkpIHtcblxuICAgICAgLy8gRXhwbGljaXQgcHJlc2V0XG4gICAgICBpZiAocGFyYW1zLnByZXNldCkgcGFyYW1zLmxvYWQucHJlc2V0ID0gcGFyYW1zLnByZXNldDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHBhcmFtcy5sb2FkID0geyBwcmVzZXQ6IERFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRSB9O1xuXG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMuaGlkZWFibGUpIHtcbiAgICAgIGhpZGVhYmxlX2d1aXMucHVzaCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IHJvb3QgbGV2ZWwgR1VJJ3MgYXJlIHJlc2l6YWJsZS5cbiAgICBwYXJhbXMucmVzaXphYmxlID0gY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpICYmIHBhcmFtcy5yZXNpemFibGU7XG5cblxuICAgIGlmIChwYXJhbXMuYXV0b1BsYWNlICYmIGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMuc2Nyb2xsYWJsZSkpIHtcbiAgICAgIHBhcmFtcy5zY3JvbGxhYmxlID0gdHJ1ZTtcbiAgICB9XG4vLyAgICBwYXJhbXMuc2Nyb2xsYWJsZSA9IGNvbW1vbi5pc1VuZGVmaW5lZChwYXJhbXMucGFyZW50KSAmJiBwYXJhbXMuc2Nyb2xsYWJsZSA9PT0gdHJ1ZTtcblxuICAgIC8vIE5vdCBwYXJ0IG9mIHBhcmFtcyBiZWNhdXNlIEkgZG9uJ3Qgd2FudCBwZW9wbGUgcGFzc2luZyB0aGlzIGluIHZpYVxuICAgIC8vIGNvbnN0cnVjdG9yLiBTaG91bGQgYmUgYSAncmVtZW1iZXJlZCcgdmFsdWUuXG4gICAgdmFyIHVzZV9sb2NhbF9zdG9yYWdlID1cbiAgICAgICAgU1VQUE9SVFNfTE9DQUxfU1RPUkFHRSAmJlxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcyxcblxuICAgICAgICAvKiogQGxlbmRzIGRhdC5ndWkuR1VJLnByb3RvdHlwZSAqL1xuICAgICAgICB7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgcGFyZW50IDxjb2RlPkdVSTwvY29kZT5cbiAgICAgICAgICAgKiBAdHlwZSBkYXQuZ3VpLkdVSVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHNjcm9sbGFibGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuc2Nyb2xsYWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSGFuZGxlcyA8Y29kZT5HVUk8L2NvZGU+J3MgZWxlbWVudCBwbGFjZW1lbnQgZm9yIHlvdVxuICAgICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBhdXRvUGxhY2U6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwYXJhbXMuYXV0b1BsYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgaWRlbnRpZmllciBmb3IgYSBzZXQgb2Ygc2F2ZWQgdmFsdWVzXG4gICAgICAgICAgICogQHR5cGUgU3RyaW5nXG4gICAgICAgICAgICovXG4gICAgICAgICAgcHJlc2V0OiB7XG5cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0Um9vdCgpLnByZXNldDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLmxvYWQucHJlc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdldFJvb3QoKS5wcmVzZXQgPSB2O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5sb2FkLnByZXNldCA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0UHJlc2V0U2VsZWN0SW5kZXgodGhpcyk7XG4gICAgICAgICAgICAgIF90aGlzLnJldmVydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSB3aWR0aCBvZiA8Y29kZT5HVUk8L2NvZGU+IGVsZW1lbnRcbiAgICAgICAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy53aWR0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcGFyYW1zLndpZHRoID0gdjtcbiAgICAgICAgICAgICAgc2V0V2lkdGgoX3RoaXMsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgbmFtZSBvZiA8Y29kZT5HVUk8L2NvZGU+LiBVc2VkIGZvciBmb2xkZXJzLiBpLmVcbiAgICAgICAgICAgKiBhIGZvbGRlcidzIG5hbWVcbiAgICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zLm5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gQ2hlY2sgZm9yIGNvbGxpc2lvbnMgYW1vbmcgc2libGluZyBmb2xkZXJzXG4gICAgICAgICAgICAgIHBhcmFtcy5uYW1lID0gdjtcbiAgICAgICAgICAgICAgaWYgKHRpdGxlX3Jvd19uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGl0bGVfcm93X25hbWUuaW5uZXJIVE1MID0gcGFyYW1zLm5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hldGhlciB0aGUgPGNvZGU+R1VJPC9jb2RlPiBpcyBjb2xsYXBzZWQgb3Igbm90XG4gICAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNsb3NlZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5jbG9zZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgIHBhcmFtcy5jbG9zZWQgPSB2O1xuICAgICAgICAgICAgICBpZiAocGFyYW1zLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhfdGhpcy5fX3VsLCBHVUkuQ0xBU1NfQ0xPU0VEKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX191bCwgR1VJLkNMQVNTX0NMT1NFRCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgYXJlbid0IGdvaW5nIHRvIHJlc3BlY3QgdGhlIENTUyB0cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAvLyBMZXRzIGp1c3QgY2hlY2sgb3VyIGhlaWdodCBhZ2FpbnN0IHRoZSB3aW5kb3cgaGVpZ2h0IHJpZ2h0IG9mZlxuICAgICAgICAgICAgICAvLyB0aGUgYmF0LlxuICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG5cbiAgICAgICAgICAgICAgaWYgKF90aGlzLl9fY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fX2Nsb3NlQnV0dG9uLmlubmVySFRNTCA9IHYgPyBHVUkuVEVYVF9PUEVOIDogR1VJLlRFWFRfQ0xPU0VEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENvbnRhaW5zIGFsbCBwcmVzZXRzXG4gICAgICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgICAgICovXG4gICAgICAgICAgbG9hZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5sb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRvIHVzZSA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL1N0b3JhZ2UjbG9jYWxTdG9yYWdlXCI+bG9jYWxTdG9yYWdlPC9hPiBhcyB0aGUgbWVhbnMgZm9yXG4gICAgICAgICAgICogPGNvZGU+cmVtZW1iZXI8L2NvZGU+aW5nXG4gICAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgICAqL1xuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZToge1xuXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXNlX2xvY2FsX3N0b3JhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihib29sKSB7XG4gICAgICAgICAgICAgIGlmIChTVVBQT1JUU19MT0NBTF9TVE9SQUdFKSB7XG4gICAgICAgICAgICAgICAgdXNlX2xvY2FsX3N0b3JhZ2UgPSBib29sO1xuICAgICAgICAgICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAgICAgICBkb20uYmluZCh3aW5kb3csICd1bmxvYWQnLCBzYXZlVG9Mb2NhbFN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBkb20udW5iaW5kKHdpbmRvdywgJ3VubG9hZCcsIHNhdmVUb0xvY2FsU3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goX3RoaXMsICdpc0xvY2FsJyksIGJvb2wpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAvLyBBcmUgd2UgYSByb290IGxldmVsIEdVST9cbiAgICBpZiAoY29tbW9uLmlzVW5kZWZpbmVkKHBhcmFtcy5wYXJlbnQpKSB7XG5cbiAgICAgIHBhcmFtcy5jbG9zZWQgPSBmYWxzZTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZG9tRWxlbWVudCwgR1VJLkNMQVNTX01BSU4pO1xuICAgICAgZG9tLm1ha2VTZWxlY3RhYmxlKHRoaXMuZG9tRWxlbWVudCwgZmFsc2UpO1xuXG4gICAgICAvLyBBcmUgd2Ugc3VwcG9zZWQgdG8gYmUgbG9hZGluZyBsb2NhbGx5P1xuICAgICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcblxuICAgICAgICBpZiAodXNlX2xvY2FsX3N0b3JhZ2UpIHtcblxuICAgICAgICAgIF90aGlzLnVzZUxvY2FsU3RvcmFnZSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc2F2ZWRfZ3VpID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oZ2V0TG9jYWxTdG9yYWdlSGFzaCh0aGlzLCAnZ3VpJykpO1xuXG4gICAgICAgICAgaWYgKHNhdmVkX2d1aSkge1xuICAgICAgICAgICAgcGFyYW1zLmxvYWQgPSBKU09OLnBhcnNlKHNhdmVkX2d1aSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9fY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuX19jbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSBHVUkuVEVYVF9DTE9TRUQ7XG4gICAgICBkb20uYWRkQ2xhc3ModGhpcy5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfQ0xPU0VfQlVUVE9OKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9fY2xvc2VCdXR0b24pO1xuXG4gICAgICBkb20uYmluZCh0aGlzLl9fY2xvc2VCdXR0b24sICdjbGljaycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG5cblxuICAgICAgfSk7XG5cblxuICAgICAgLy8gT2gsIHlvdSdyZSBhIG5lc3RlZCBHVUkhXG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKHBhcmFtcy5jbG9zZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJhbXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpdGxlX3Jvd19uYW1lID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFyYW1zLm5hbWUpO1xuICAgICAgZG9tLmFkZENsYXNzKHRpdGxlX3Jvd19uYW1lLCAnY29udHJvbGxlci1uYW1lJyk7XG5cbiAgICAgIHZhciB0aXRsZV9yb3cgPSBhZGRSb3coX3RoaXMsIHRpdGxlX3Jvd19uYW1lKTtcblxuICAgICAgdmFyIG9uX2NsaWNrX3RpdGxlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLmNsb3NlZCA9ICFfdGhpcy5jbG9zZWQ7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLl9fdWwsIEdVSS5DTEFTU19DTE9TRUQpO1xuXG4gICAgICBkb20uYWRkQ2xhc3ModGl0bGVfcm93LCAndGl0bGUnKTtcbiAgICAgIGRvbS5iaW5kKHRpdGxlX3JvdywgJ2NsaWNrJywgb25fY2xpY2tfdGl0bGUpO1xuXG4gICAgICBpZiAoIXBhcmFtcy5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYXV0b1BsYWNlKSB7XG5cbiAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQocGFyYW1zLnBhcmVudCkpIHtcblxuICAgICAgICBpZiAoYXV0b19wbGFjZV92aXJnaW4pIHtcbiAgICAgICAgICBhdXRvX3BsYWNlX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhhdXRvX3BsYWNlX2NvbnRhaW5lciwgQ1NTX05BTUVTUEFDRSk7XG4gICAgICAgICAgZG9tLmFkZENsYXNzKGF1dG9fcGxhY2VfY29udGFpbmVyLCBHVUkuQ0xBU1NfQVVUT19QTEFDRV9DT05UQUlORVIpO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXV0b19wbGFjZV9jb250YWluZXIpO1xuICAgICAgICAgIGF1dG9fcGxhY2VfdmlyZ2luID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgaXQgaW4gdGhlIGRvbSBmb3IgeW91LlxuICAgICAgICBhdXRvX3BsYWNlX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRoZSBhdXRvIHN0eWxlc1xuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5kb21FbGVtZW50LCBHVUkuQ0xBU1NfQVVUT19QTEFDRSk7XG5cbiAgICAgIH1cblxuXG4gICAgICAvLyBNYWtlIGl0IG5vdCBlbGFzdGljLlxuICAgICAgaWYgKCF0aGlzLnBhcmVudCkgc2V0V2lkdGgoX3RoaXMsIHBhcmFtcy53aWR0aCk7XG5cbiAgICB9XG5cbiAgICBkb20uYmluZCh3aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKSB9KTtcbiAgICBkb20uYmluZCh0aGlzLl9fdWwsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24oKSB7IF90aGlzLm9uUmVzaXplKCk7IH0pO1xuICAgIGRvbS5iaW5kKHRoaXMuX191bCwgJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbigpIHsgX3RoaXMub25SZXNpemUoKSB9KTtcbiAgICBkb20uYmluZCh0aGlzLl9fdWwsICdvVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uKCkgeyBfdGhpcy5vblJlc2l6ZSgpIH0pO1xuICAgIHRoaXMub25SZXNpemUoKTtcblxuXG4gICAgaWYgKHBhcmFtcy5yZXNpemFibGUpIHtcbiAgICAgIGFkZFJlc2l6ZUhhbmRsZSh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYXZlVG9Mb2NhbFN0b3JhZ2UoKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShnZXRMb2NhbFN0b3JhZ2VIYXNoKF90aGlzLCAnZ3VpJyksIEpTT04uc3RyaW5naWZ5KF90aGlzLmdldFNhdmVPYmplY3QoKSkpO1xuICAgIH1cblxuICAgIHZhciByb290ID0gX3RoaXMuZ2V0Um9vdCgpO1xuICAgIGZ1bmN0aW9uIHJlc2V0V2lkdGgoKSB7XG4gICAgICAgIHZhciByb290ID0gX3RoaXMuZ2V0Um9vdCgpO1xuICAgICAgICByb290LndpZHRoICs9IDE7XG4gICAgICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICByb290LndpZHRoIC09IDE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmFtcy5wYXJlbnQpIHtcbiAgICAgICAgcmVzZXRXaWR0aCgpO1xuICAgICAgfVxuXG4gIH07XG5cbiAgR1VJLnRvZ2dsZUhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgIGhpZGUgPSAhaGlkZTtcbiAgICBjb21tb24uZWFjaChoaWRlYWJsZV9ndWlzLCBmdW5jdGlvbihndWkpIHtcbiAgICAgIGd1aS5kb21FbGVtZW50LnN0eWxlLnpJbmRleCA9IGhpZGUgPyAtOTk5IDogOTk5O1xuICAgICAgZ3VpLmRvbUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IGhpZGUgPyAwIDogMTtcbiAgICB9KTtcbiAgfTtcblxuICBHVUkuQ0xBU1NfQVVUT19QTEFDRSA9ICdhJztcbiAgR1VJLkNMQVNTX0FVVE9fUExBQ0VfQ09OVEFJTkVSID0gJ2FjJztcbiAgR1VJLkNMQVNTX01BSU4gPSAnbWFpbic7XG4gIEdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyA9ICdjcic7XG4gIEdVSS5DTEFTU19UT09fVEFMTCA9ICd0YWxsZXItdGhhbi13aW5kb3cnO1xuICBHVUkuQ0xBU1NfQ0xPU0VEID0gJ2Nsb3NlZCc7XG4gIEdVSS5DTEFTU19DTE9TRV9CVVRUT04gPSAnY2xvc2UtYnV0dG9uJztcbiAgR1VJLkNMQVNTX0RSQUcgPSAnZHJhZyc7XG5cbiAgR1VJLkRFRkFVTFRfV0lEVEggPSAyNDU7XG4gIEdVSS5URVhUX0NMT1NFRCA9ICdDbG9zZSBDb250cm9scyc7XG4gIEdVSS5URVhUX09QRU4gPSAnT3BlbiBDb250cm9scyc7XG5cbiAgZG9tLmJpbmQod2luZG93LCAna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50LnR5cGUgIT09ICd0ZXh0JyAmJlxuICAgICAgICAoZS53aGljaCA9PT0gSElERV9LRVlfQ09ERSB8fCBlLmtleUNvZGUgPT0gSElERV9LRVlfQ09ERSkpIHtcbiAgICAgIEdVSS50b2dnbGVIaWRlKCk7XG4gICAgfVxuXG4gIH0sIGZhbHNlKTtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBHVUkucHJvdG90eXBlLFxuXG4gICAgICAvKiogQGxlbmRzIGRhdC5ndWkuR1VJICovXG4gICAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcn0gVGhlIG5ldyBjb250cm9sbGVyIHRoYXQgd2FzIGFkZGVkLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZhY3RvcnlBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5XG4gICAgICAgICAqIEByZXR1cm5zIHtkYXQuY29udHJvbGxlcnMuQ29sb3JDb250cm9sbGVyfSBUaGUgbmV3IGNvbnRyb2xsZXIgdGhhdCB3YXMgYWRkZWQuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQ29sb3I6IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gY29udHJvbGxlclxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oY29udHJvbGxlcikge1xuXG4gICAgICAgICAgLy8gVE9ETyBsaXN0ZW5pbmc/XG4gICAgICAgICAgdGhpcy5fX3VsLnJlbW92ZUNoaWxkKGNvbnRyb2xsZXIuX19saSk7XG4gICAgICAgICAgdGhpcy5fX2NvbnRyb2xsZXJzLnNsaWNlKHRoaXMuX19jb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpLCAxKTtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmICh0aGlzLmF1dG9QbGFjZSkge1xuICAgICAgICAgICAgYXV0b19wbGFjZV9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG5hbWVcbiAgICAgICAgICogQHJldHVybnMge2RhdC5ndWkuR1VJfSBUaGUgbmV3IGZvbGRlci5cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoaXMgR1VJIGFscmVhZHkgaGFzIGEgZm9sZGVyIGJ5IHRoZSBzcGVjaWZpZWRcbiAgICAgICAgICogbmFtZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGFkZEZvbGRlcjogZnVuY3Rpb24obmFtZSkge1xuXG4gICAgICAgICAgLy8gV2UgaGF2ZSB0byBwcmV2ZW50IGNvbGxpc2lvbnMgb24gbmFtZXMgaW4gb3JkZXIgdG8gaGF2ZSBhIGtleVxuICAgICAgICAgIC8vIGJ5IHdoaWNoIHRvIHJlbWVtYmVyIHNhdmVkIHZhbHVlc1xuICAgICAgICAgIGlmICh0aGlzLl9fZm9sZGVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhbHJlYWR5IGhhdmUgYSBmb2xkZXIgaW4gdGhpcyBHVUkgYnkgdGhlJyArXG4gICAgICAgICAgICAgICAgJyBuYW1lIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV3X2d1aV9wYXJhbXMgPSB7IG5hbWU6IG5hbWUsIHBhcmVudDogdGhpcyB9O1xuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBwYXNzIGRvd24gdGhlIGF1dG9QbGFjZSB0cmFpdCBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgIC8vIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gb3Blbi9jbG9zZSBmb2xkZXIgYWN0aW9ucyB0b1xuICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IGEgc2Nyb2xsYmFyIGFwcGVhcnMgaWYgdGhlIHdpbmRvdyBpcyB0b28gc2hvcnQuXG4gICAgICAgICAgbmV3X2d1aV9wYXJhbXMuYXV0b1BsYWNlID0gdGhpcy5hdXRvUGxhY2U7XG5cbiAgICAgICAgICAvLyBEbyB3ZSBoYXZlIHNhdmVkIGFwcGVhcmFuY2UgZGF0YSBmb3IgdGhpcyBmb2xkZXI/XG5cbiAgICAgICAgICBpZiAodGhpcy5sb2FkICYmIC8vIEFueXRoaW5nIGxvYWRlZD9cbiAgICAgICAgICAgICAgdGhpcy5sb2FkLmZvbGRlcnMgJiYgLy8gV2FzIG15IHBhcmVudCBhIGRlYWQtZW5kP1xuICAgICAgICAgICAgICB0aGlzLmxvYWQuZm9sZGVyc1tuYW1lXSkgeyAvLyBEaWQgZGFkZHkgcmVtZW1iZXIgbWU/XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG1lIGNsb3NlZCBpZiBJIHdhcyBjbG9zZWRcbiAgICAgICAgICAgIG5ld19ndWlfcGFyYW1zLmNsb3NlZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdLmNsb3NlZDtcblxuICAgICAgICAgICAgLy8gUGFzcyBkb3duIHRoZSBsb2FkZWQgZGF0YVxuICAgICAgICAgICAgbmV3X2d1aV9wYXJhbXMubG9hZCA9IHRoaXMubG9hZC5mb2xkZXJzW25hbWVdO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGd1aSA9IG5ldyBHVUkobmV3X2d1aV9wYXJhbXMpO1xuICAgICAgICAgIHRoaXMuX19mb2xkZXJzW25hbWVdID0gZ3VpO1xuXG4gICAgICAgICAgdmFyIGxpID0gYWRkUm93KHRoaXMsIGd1aS5kb21FbGVtZW50KTtcbiAgICAgICAgICBkb20uYWRkQ2xhc3MobGksICdmb2xkZXInKTtcbiAgICAgICAgICByZXR1cm4gZ3VpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVzaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciByb290ID0gdGhpcy5nZXRSb290KCk7XG5cbiAgICAgICAgICBpZiAocm9vdC5zY3JvbGxhYmxlKSB7XG5cbiAgICAgICAgICAgIHZhciB0b3AgPSBkb20uZ2V0T2Zmc2V0KHJvb3QuX191bCkudG9wO1xuICAgICAgICAgICAgdmFyIGggPSAwO1xuXG4gICAgICAgICAgICBjb21tb24uZWFjaChyb290Ll9fdWwuY2hpbGROb2RlcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICBpZiAoISAocm9vdC5hdXRvUGxhY2UgJiYgbm9kZSA9PT0gcm9vdC5fX3NhdmVfcm93KSlcbiAgICAgICAgICAgICAgICBoICs9IGRvbS5nZXRIZWlnaHQobm9kZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcCAtIENMT1NFX0JVVFRPTl9IRUlHSFQgPCBoKSB7XG4gICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3AgLSBDTE9TRV9CVVRUT05fSEVJR0hUICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhyb290LmRvbUVsZW1lbnQsIEdVSS5DTEFTU19UT09fVEFMTCk7XG4gICAgICAgICAgICAgIHJvb3QuX191bC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm9vdC5fX3Jlc2l6ZV9oYW5kbGUpIHtcbiAgICAgICAgICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcm9vdC5fX3Jlc2l6ZV9oYW5kbGUuc3R5bGUuaGVpZ2h0ID0gcm9vdC5fX3VsLm9mZnNldEhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm9vdC5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICAgICAgICByb290Ll9fY2xvc2VCdXR0b24uc3R5bGUud2lkdGggPSByb290LndpZHRoICsgJ3B4JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFyayBvYmplY3RzIGZvciBzYXZpbmcuIFRoZSBvcmRlciBvZiB0aGVzZSBvYmplY3RzIGNhbm5vdCBjaGFuZ2UgYXNcbiAgICAgICAgICogdGhlIEdVSSBncm93cy4gV2hlbiByZW1lbWJlcmluZyBuZXcgb2JqZWN0cywgYXBwZW5kIHRoZW0gdG8gdGhlIGVuZFxuICAgICAgICAgKiBvZiB0aGUgbGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuLi59IG9iamVjdHNcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IGlmIG5vdCBjYWxsZWQgb24gYSB0b3AgbGV2ZWwgR1VJLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHJlbWVtYmVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGlmIChjb21tb24uaXNVbmRlZmluZWQoU0FWRV9ESUFMT0dVRSkpIHtcbiAgICAgICAgICAgIFNBVkVfRElBTE9HVUUgPSBuZXcgQ2VudGVyZWREaXYoKTtcbiAgICAgICAgICAgIFNBVkVfRElBTE9HVUUuZG9tRWxlbWVudC5pbm5lckhUTUwgPSBzYXZlRGlhbG9ndWVDb250ZW50cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4gb25seSBjYWxsIHJlbWVtYmVyIG9uIGEgdG9wIGxldmVsIEdVSS5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgIGNvbW1vbi5lYWNoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgYWRkU2F2ZU1lbnUoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09IC0xKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9fcmVtZW1iZXJlZE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMuYXV0b1BsYWNlKSB7XG4gICAgICAgICAgICAvLyBTZXQgc2F2ZSByb3cgd2lkdGhcbiAgICAgICAgICAgIHNldFdpZHRoKHRoaXMsIHRoaXMud2lkdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7ZGF0Lmd1aS5HVUl9IHRoZSB0b3Btb3N0IHBhcmVudCBHVUkgb2YgYSBuZXN0ZWQgR1VJLlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIGdldFJvb3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBndWkgPSB0aGlzO1xuICAgICAgICAgIHdoaWxlIChndWkucGFyZW50KSB7XG4gICAgICAgICAgICBndWkgPSBndWkucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ3VpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZSBvZlxuICAgICAgICAgKiB0aGlzIEdVSSBhcyB3ZWxsIGFzIGl0cyByZW1lbWJlcmVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2F2ZU9iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgdG9SZXR1cm4gPSB0aGlzLmxvYWQ7XG5cbiAgICAgICAgICB0b1JldHVybi5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcblxuICAgICAgICAgIC8vIEFtIEkgcmVtZW1iZXJpbmcgYW55IHZhbHVlcz9cbiAgICAgICAgICBpZiAodGhpcy5fX3JlbWVtYmVyZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgdG9SZXR1cm4ucHJlc2V0ID0gdGhpcy5wcmVzZXQ7XG5cbiAgICAgICAgICAgIGlmICghdG9SZXR1cm4ucmVtZW1iZXJlZCkge1xuICAgICAgICAgICAgICB0b1JldHVybi5yZW1lbWJlcmVkID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvUmV0dXJuLnJlbWVtYmVyZWRbdGhpcy5wcmVzZXRdID0gZ2V0Q3VycmVudFByZXNldCh0aGlzKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvUmV0dXJuLmZvbGRlcnMgPSB7fTtcbiAgICAgICAgICBjb21tb24uZWFjaCh0aGlzLl9fZm9sZGVycywgZnVuY3Rpb24oZWxlbWVudCwga2V5KSB7XG4gICAgICAgICAgICB0b1JldHVybi5mb2xkZXJzW2tleV0gPSBlbGVtZW50LmdldFNhdmVPYmplY3QoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiB0b1JldHVybjtcblxuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmxvYWQucmVtZW1iZXJlZFt0aGlzLnByZXNldF0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgICAgICAgIG1hcmtQcmVzZXRNb2RpZmllZCh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlQXM6IGZ1bmN0aW9uKHByZXNldE5hbWUpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5sb2FkLnJlbWVtYmVyZWQpIHtcblxuICAgICAgICAgICAgLy8gUmV0YWluIGRlZmF1bHQgdmFsdWVzIHVwb24gZmlyc3Qgc2F2ZVxuICAgICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWQgPSB7fTtcbiAgICAgICAgICAgIHRoaXMubG9hZC5yZW1lbWJlcmVkW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMsIHRydWUpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5sb2FkLnJlbWVtYmVyZWRbcHJlc2V0TmFtZV0gPSBnZXRDdXJyZW50UHJlc2V0KHRoaXMpO1xuICAgICAgICAgIHRoaXMucHJlc2V0ID0gcHJlc2V0TmFtZTtcbiAgICAgICAgICBhZGRQcmVzZXRPcHRpb24odGhpcywgcHJlc2V0TmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uKGd1aSkge1xuXG4gICAgICAgICAgY29tbW9uLmVhY2godGhpcy5fX2NvbnRyb2xsZXJzLCBmdW5jdGlvbihjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHJldmVydCB3b3JrIG9uIERlZmF1bHQuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0Um9vdCgpLmxvYWQucmVtZW1iZXJlZCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLnNldFZhbHVlKGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2FsbFNhdmVkVmFsdWUoZ3VpIHx8IHRoaXMuZ2V0Um9vdCgpLCBjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIGNvbW1vbi5lYWNoKHRoaXMuX19mb2xkZXJzLCBmdW5jdGlvbihmb2xkZXIpIHtcbiAgICAgICAgICAgIGZvbGRlci5yZXZlcnQoZm9sZGVyKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghZ3VpKSB7XG4gICAgICAgICAgICBtYXJrUHJlc2V0TW9kaWZpZWQodGhpcy5nZXRSb290KCksIGZhbHNlKTtcbiAgICAgICAgICB9XG5cblxuICAgICAgICB9LFxuXG4gICAgICAgIGxpc3RlbjogZnVuY3Rpb24oY29udHJvbGxlcikge1xuXG4gICAgICAgICAgdmFyIGluaXQgPSB0aGlzLl9fbGlzdGVuaW5nLmxlbmd0aCA9PSAwO1xuICAgICAgICAgIHRoaXMuX19saXN0ZW5pbmcucHVzaChjb250cm9sbGVyKTtcbiAgICAgICAgICBpZiAoaW5pdCkgdXBkYXRlRGlzcGxheXModGhpcy5fX2xpc3RlbmluZyk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgKTtcblxuICBmdW5jdGlvbiBhZGQoZ3VpLCBvYmplY3QsIHByb3BlcnR5LCBwYXJhbXMpIHtcblxuICAgIGlmIChvYmplY3RbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBcIiArIG9iamVjdCArIFwiIGhhcyBubyBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eSArIFwiXFxcIlwiKTtcbiAgICB9XG5cbiAgICB2YXIgY29udHJvbGxlcjtcblxuICAgIGlmIChwYXJhbXMuY29sb3IpIHtcblxuICAgICAgY29udHJvbGxlciA9IG5ldyBDb2xvckNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZmFjdG9yeUFyZ3MgPSBbb2JqZWN0LHByb3BlcnR5XS5jb25jYXQocGFyYW1zLmZhY3RvcnlBcmdzKTtcbiAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyRmFjdG9yeS5hcHBseShndWksIGZhY3RvcnlBcmdzKTtcblxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYmVmb3JlIGluc3RhbmNlb2YgQ29udHJvbGxlcikge1xuICAgICAgcGFyYW1zLmJlZm9yZSA9IHBhcmFtcy5iZWZvcmUuX19saTtcbiAgICB9XG5cbiAgICByZWNhbGxTYXZlZFZhbHVlKGd1aSwgY29udHJvbGxlcik7XG5cbiAgICBkb20uYWRkQ2xhc3MoY29udHJvbGxlci5kb21FbGVtZW50LCAnYycpO1xuXG4gICAgdmFyIG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZG9tLmFkZENsYXNzKG5hbWUsICdwcm9wZXJ0eS1uYW1lJyk7XG4gICAgbmFtZS5pbm5lckhUTUwgPSBjb250cm9sbGVyLnByb3BlcnR5O1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChuYW1lKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udHJvbGxlci5kb21FbGVtZW50KTtcblxuICAgIHZhciBsaSA9IGFkZFJvdyhndWksIGNvbnRhaW5lciwgcGFyYW1zLmJlZm9yZSk7XG5cbiAgICBkb20uYWRkQ2xhc3MobGksIEdVSS5DTEFTU19DT05UUk9MTEVSX1JPVyk7XG4gICAgZG9tLmFkZENsYXNzKGxpLCB0eXBlb2YgY29udHJvbGxlci5nZXRWYWx1ZSgpKTtcblxuICAgIGF1Z21lbnRDb250cm9sbGVyKGd1aSwgbGksIGNvbnRyb2xsZXIpO1xuXG4gICAgZ3VpLl9fY29udHJvbGxlcnMucHVzaChjb250cm9sbGVyKTtcblxuICAgIHJldHVybiBjb250cm9sbGVyO1xuXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcm93IHRvIHRoZSBlbmQgb2YgdGhlIEdVSSBvciBiZWZvcmUgYW5vdGhlciByb3cuXG4gICAqXG4gICAqIEBwYXJhbSBndWlcbiAgICogQHBhcmFtIFtkb21dIElmIHNwZWNpZmllZCwgaW5zZXJ0cyB0aGUgZG9tIGNvbnRlbnQgaW4gdGhlIG5ldyByb3dcbiAgICogQHBhcmFtIFtsaUJlZm9yZV0gSWYgc3BlY2lmaWVkLCBwbGFjZXMgdGhlIG5ldyByb3cgYmVmb3JlIGFub3RoZXIgcm93XG4gICAqL1xuICBmdW5jdGlvbiBhZGRSb3coZ3VpLCBkb20sIGxpQmVmb3JlKSB7XG4gICAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBpZiAoZG9tKSBsaS5hcHBlbmRDaGlsZChkb20pO1xuICAgIGlmIChsaUJlZm9yZSkge1xuICAgICAgZ3VpLl9fdWwuaW5zZXJ0QmVmb3JlKGxpLCBwYXJhbXMuYmVmb3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3VpLl9fdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgIH1cbiAgICBndWkub25SZXNpemUoKTtcbiAgICByZXR1cm4gbGk7XG4gIH1cblxuICBmdW5jdGlvbiBhdWdtZW50Q29udHJvbGxlcihndWksIGxpLCBjb250cm9sbGVyKSB7XG5cbiAgICBjb250cm9sbGVyLl9fbGkgPSBsaTtcbiAgICBjb250cm9sbGVyLl9fZ3VpID0gZ3VpO1xuXG4gICAgY29tbW9uLmV4dGVuZChjb250cm9sbGVyLCB7XG5cbiAgICAgIG9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGFkZChcbiAgICAgICAgICAgICAgZ3VpLFxuICAgICAgICAgICAgICBjb250cm9sbGVyLm9iamVjdCxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udHJvbGxlci5fX2xpLm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICAgICAgICBmYWN0b3J5QXJnczogW2NvbW1vbi50b0FycmF5KGFyZ3VtZW50cyldXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzQXJyYXkob3B0aW9ucykgfHwgY29tbW9uLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgY29udHJvbGxlci5yZW1vdmUoKTtcblxuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIGd1aSxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5vYmplY3QsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IFtvcHRpb25zXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIG5hbWU6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgY29udHJvbGxlci5fX2xpLmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLmlubmVySFRNTCA9IHY7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgfSxcblxuICAgICAgbGlzdGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udHJvbGxlci5fX2d1aS5saXN0ZW4oY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udHJvbGxlci5fX2d1aS5yZW1vdmUoY29udHJvbGxlcik7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyBBbGwgc2xpZGVycyBzaG91bGQgYmUgYWNjb21wYW5pZWQgYnkgYSBib3guXG4gICAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBOdW1iZXJDb250cm9sbGVyU2xpZGVyKSB7XG5cbiAgICAgIHZhciBib3ggPSBuZXcgTnVtYmVyQ29udHJvbGxlckJveChjb250cm9sbGVyLm9iamVjdCwgY29udHJvbGxlci5wcm9wZXJ0eSxcbiAgICAgICAgICB7IG1pbjogY29udHJvbGxlci5fX21pbiwgbWF4OiBjb250cm9sbGVyLl9fbWF4LCBzdGVwOiBjb250cm9sbGVyLl9fc3RlcCB9KTtcblxuICAgICAgY29tbW9uLmVhY2goWyd1cGRhdGVEaXNwbGF5JywgJ29uQ2hhbmdlJywgJ29uRmluaXNoQ2hhbmdlJ10sIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICB2YXIgcGMgPSBjb250cm9sbGVyW21ldGhvZF07XG4gICAgICAgIHZhciBwYiA9IGJveFttZXRob2RdO1xuICAgICAgICBjb250cm9sbGVyW21ldGhvZF0gPSBib3hbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICBwYy5hcHBseShjb250cm9sbGVyLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gcGIuYXBwbHkoYm94LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRvbS5hZGRDbGFzcyhsaSwgJ2hhcy1zbGlkZXInKTtcbiAgICAgIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5pbnNlcnRCZWZvcmUoYm94LmRvbUVsZW1lbnQsIGNvbnRyb2xsZXIuZG9tRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIE51bWJlckNvbnRyb2xsZXJCb3gpIHtcblxuICAgICAgdmFyIHIgPSBmdW5jdGlvbihyZXR1cm5lZCkge1xuXG4gICAgICAgIC8vIEhhdmUgd2UgZGVmaW5lZCBib3RoIGJvdW5kYXJpZXM/XG4gICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIoY29udHJvbGxlci5fX21pbikgJiYgY29tbW9uLmlzTnVtYmVyKGNvbnRyb2xsZXIuX19tYXgpKSB7XG5cbiAgICAgICAgICAvLyBXZWxsLCB0aGVuIGxldHMganVzdCByZXBsYWNlIHRoaXMgd2l0aCBhIHNsaWRlci5cbiAgICAgICAgICBjb250cm9sbGVyLnJlbW92ZSgpO1xuICAgICAgICAgIHJldHVybiBhZGQoXG4gICAgICAgICAgICAgIGd1aSxcbiAgICAgICAgICAgICAgY29udHJvbGxlci5vYmplY3QsXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIucHJvcGVydHksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRyb2xsZXIuX19saS5uZXh0RWxlbWVudFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgZmFjdG9yeUFyZ3M6IFtjb250cm9sbGVyLl9fbWluLCBjb250cm9sbGVyLl9fbWF4LCBjb250cm9sbGVyLl9fc3RlcF1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5lZDtcblxuICAgICAgfTtcblxuICAgICAgY29udHJvbGxlci5taW4gPSBjb21tb24uY29tcG9zZShyLCBjb250cm9sbGVyLm1pbik7XG4gICAgICBjb250cm9sbGVyLm1heCA9IGNvbW1vbi5jb21wb3NlKHIsIGNvbnRyb2xsZXIubWF4KTtcblxuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgQm9vbGVhbkNvbnRyb2xsZXIpIHtcblxuICAgICAgZG9tLmJpbmQobGksICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkb20uZmFrZUV2ZW50KGNvbnRyb2xsZXIuX19jaGVja2JveCwgJ2NsaWNrJyk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmJpbmQoY29udHJvbGxlci5fX2NoZWNrYm94LCAnY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFByZXZlbnRzIGRvdWJsZS10b2dnbGVcbiAgICAgIH0pXG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIEZ1bmN0aW9uQ29udHJvbGxlcikge1xuXG4gICAgICBkb20uYmluZChsaSwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvbS5mYWtlRXZlbnQoY29udHJvbGxlci5fX2J1dHRvbiwgJ2NsaWNrJyk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmJpbmQobGksICdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLmFkZENsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgICAgfSk7XG5cbiAgICAgIGRvbS5iaW5kKGxpLCAnbW91c2VvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbnRyb2xsZXIuX19idXR0b24sICdob3ZlcicpO1xuICAgICAgfSk7XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIENvbG9yQ29udHJvbGxlcikge1xuXG4gICAgICBkb20uYWRkQ2xhc3MobGksICdjb2xvcicpO1xuICAgICAgY29udHJvbGxlci51cGRhdGVEaXNwbGF5ID0gY29tbW9uLmNvbXBvc2UoZnVuY3Rpb24ocikge1xuICAgICAgICBsaS5zdHlsZS5ib3JkZXJMZWZ0Q29sb3IgPSBjb250cm9sbGVyLl9fY29sb3IudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9LCBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkpO1xuXG4gICAgICBjb250cm9sbGVyLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIH1cblxuICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUgPSBjb21tb24uY29tcG9zZShmdW5jdGlvbihyKSB7XG4gICAgICBpZiAoZ3VpLmdldFJvb3QoKS5fX3ByZXNldF9zZWxlY3QgJiYgY29udHJvbGxlci5pc01vZGlmaWVkKCkpIHtcbiAgICAgICAgbWFya1ByZXNldE1vZGlmaWVkKGd1aS5nZXRSb290KCksIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSwgY29udHJvbGxlci5zZXRWYWx1ZSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsbFNhdmVkVmFsdWUoZ3VpLCBjb250cm9sbGVyKSB7XG5cbiAgICAvLyBGaW5kIHRoZSB0b3Btb3N0IEdVSSwgdGhhdCdzIHdoZXJlIHJlbWVtYmVyZWQgb2JqZWN0cyBsaXZlLlxuICAgIHZhciByb290ID0gZ3VpLmdldFJvb3QoKTtcblxuICAgIC8vIERvZXMgdGhlIG9iamVjdCB3ZSdyZSBjb250cm9sbGluZyBtYXRjaCBhbnl0aGluZyB3ZSd2ZSBiZWVuIHRvbGQgdG9cbiAgICAvLyByZW1lbWJlcj9cbiAgICB2YXIgbWF0Y2hlZF9pbmRleCA9IHJvb3QuX19yZW1lbWJlcmVkT2JqZWN0cy5pbmRleE9mKGNvbnRyb2xsZXIub2JqZWN0KTtcblxuICAgIC8vIFdoeSB5ZXMsIGl0IGRvZXMhXG4gICAgaWYgKG1hdGNoZWRfaW5kZXggIT0gLTEpIHtcblxuICAgICAgLy8gTGV0IG1lIGZldGNoIGEgbWFwIG9mIGNvbnRyb2xsZXJzIGZvciB0aGNvbW1vbi5pc09iamVjdC5cbiAgICAgIHZhciBjb250cm9sbGVyX21hcCA9XG4gICAgICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkX2luZGV4XTtcblxuICAgICAgLy8gT2hwLCBJIGJlbGlldmUgdGhpcyBpcyB0aGUgZmlyc3QgY29udHJvbGxlciB3ZSd2ZSBjcmVhdGVkIGZvciB0aGlzXG4gICAgICAvLyBvYmplY3QuIExldHMgbWFrZSB0aGUgbWFwIGZyZXNoLlxuICAgICAgaWYgKGNvbnRyb2xsZXJfbWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udHJvbGxlcl9tYXAgPSB7fTtcbiAgICAgICAgcm9vdC5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1ttYXRjaGVkX2luZGV4XSA9XG4gICAgICAgICAgICBjb250cm9sbGVyX21hcDtcbiAgICAgIH1cblxuICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgIGNvbnRyb2xsZXJfbWFwW2NvbnRyb2xsZXIucHJvcGVydHldID0gY29udHJvbGxlcjtcblxuICAgICAgLy8gT2theSwgbm93IGhhdmUgd2Ugc2F2ZWQgYW55IHZhbHVlcyBmb3IgdGhpcyBjb250cm9sbGVyP1xuICAgICAgaWYgKHJvb3QubG9hZCAmJiByb290LmxvYWQucmVtZW1iZXJlZCkge1xuXG4gICAgICAgIHZhciBwcmVzZXRfbWFwID0gcm9vdC5sb2FkLnJlbWVtYmVyZWQ7XG5cbiAgICAgICAgLy8gV2hpY2ggcHJlc2V0IGFyZSB3ZSB0cnlpbmcgdG8gbG9hZD9cbiAgICAgICAgdmFyIHByZXNldDtcblxuICAgICAgICBpZiAocHJlc2V0X21hcFtndWkucHJlc2V0XSkge1xuXG4gICAgICAgICAgcHJlc2V0ID0gcHJlc2V0X21hcFtndWkucHJlc2V0XTtcblxuICAgICAgICB9IGVsc2UgaWYgKHByZXNldF9tYXBbREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FXSkge1xuXG4gICAgICAgICAgLy8gVWhoLCB5b3UgY2FuIGhhdmUgdGhlIGRlZmF1bHQgaW5zdGVhZD9cbiAgICAgICAgICBwcmVzZXQgPSBwcmVzZXRfbWFwW0RFRkFVTFRfREVGQVVMVF9QUkVTRVRfTkFNRV07XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIE5hZGEuXG5cbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRGlkIHRoZSBsb2FkZWQgb2JqZWN0IHJlbWVtYmVyIHRoY29tbW9uLmlzT2JqZWN0P1xuICAgICAgICBpZiAocHJlc2V0W21hdGNoZWRfaW5kZXhdICYmXG5cbiAgICAgICAgICAvLyBEaWQgd2UgcmVtZW1iZXIgdGhpcyBwYXJ0aWN1bGFyIHByb3BlcnR5P1xuICAgICAgICAgICAgcHJlc2V0W21hdGNoZWRfaW5kZXhdW2NvbnRyb2xsZXIucHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgIC8vIFdlIGRpZCByZW1lbWJlciBzb21ldGhpbmcgZm9yIHRoaXMgZ3V5IC4uLlxuICAgICAgICAgIHZhciB2YWx1ZSA9IHByZXNldFttYXRjaGVkX2luZGV4XVtjb250cm9sbGVyLnByb3BlcnR5XTtcblxuICAgICAgICAgIC8vIEFuZCB0aGF0J3Mgd2hhdCBpdCBpcy5cbiAgICAgICAgICBjb250cm9sbGVyLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGNvbnRyb2xsZXIuc2V0VmFsdWUodmFsdWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRMb2NhbFN0b3JhZ2VIYXNoKGd1aSwga2V5KSB7XG4gICAgLy8gVE9ETyBob3cgZG9lcyB0aGlzIGRlYWwgd2l0aCBtdWx0aXBsZSBHVUkncz9cbiAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiArICcuJyArIGtleTtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkU2F2ZU1lbnUoZ3VpKSB7XG5cbiAgICB2YXIgZGl2ID0gZ3VpLl9fc2F2ZV9yb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXG4gICAgZG9tLmFkZENsYXNzKGd1aS5kb21FbGVtZW50LCAnaGFzLXNhdmUnKTtcblxuICAgIGd1aS5fX3VsLmluc2VydEJlZm9yZShkaXYsIGd1aS5fX3VsLmZpcnN0Q2hpbGQpO1xuXG4gICAgZG9tLmFkZENsYXNzKGRpdiwgJ3NhdmUtcm93Jyk7XG5cbiAgICB2YXIgZ2VhcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgZ2VhcnMuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgZG9tLmFkZENsYXNzKGdlYXJzLCAnYnV0dG9uIGdlYXJzJyk7XG5cbiAgICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBGdW5jdGlvbkNvbnRyb2xsZXJcbiAgICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnU2F2ZSc7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbiwgJ2J1dHRvbicpO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24sICdzYXZlJyk7XG5cbiAgICB2YXIgYnV0dG9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidXR0b24yLmlubmVySFRNTCA9ICdOZXcnO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24yLCAnYnV0dG9uJyk7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjIsICdzYXZlLWFzJyk7XG5cbiAgICB2YXIgYnV0dG9uMyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBidXR0b24zLmlubmVySFRNTCA9ICdSZXZlcnQnO1xuICAgIGRvbS5hZGRDbGFzcyhidXR0b24zLCAnYnV0dG9uJyk7XG4gICAgZG9tLmFkZENsYXNzKGJ1dHRvbjMsICdyZXZlcnQnKTtcblxuICAgIHZhciBzZWxlY3QgPSBndWkuX19wcmVzZXRfc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG5cbiAgICBpZiAoZ3VpLmxvYWQgJiYgZ3VpLmxvYWQucmVtZW1iZXJlZCkge1xuXG4gICAgICBjb21tb24uZWFjaChndWkubG9hZC5yZW1lbWJlcmVkLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGFkZFByZXNldE9wdGlvbihndWksIGtleSwga2V5ID09IGd1aS5wcmVzZXQpO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkUHJlc2V0T3B0aW9uKGd1aSwgREVGQVVMVF9ERUZBVUxUX1BSRVNFVF9OQU1FLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZG9tLmJpbmQoc2VsZWN0LCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG5cblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLmlubmVySFRNTCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbaW5kZXhdLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBndWkucHJlc2V0ID0gdGhpcy52YWx1ZTtcblxuICAgIH0pO1xuXG4gICAgZGl2LmFwcGVuZENoaWxkKHNlbGVjdCk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGdlYXJzKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJ1dHRvbjMpO1xuXG4gICAgaWYgKFNVUFBPUlRTX0xPQ0FMX1NUT1JBR0UpIHtcblxuICAgICAgdmFyIHNhdmVMb2NhbGx5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLXNhdmUtbG9jYWxseScpO1xuICAgICAgdmFyIGV4cGxhaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGctbG9jYWwtZXhwbGFpbicpO1xuXG4gICAgICBzYXZlTG9jYWxseS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgdmFyIGxvY2FsU3RvcmFnZUNoZWNrQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RnLWxvY2FsLXN0b3JhZ2UnKTtcblxuICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldExvY2FsU3RvcmFnZUhhc2goZ3VpLCAnaXNMb2NhbCcpKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZUNoZWNrQm94LnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICdjaGVja2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3dIaWRlRXhwbGFpbigpIHtcbiAgICAgICAgZXhwbGFpbi5zdHlsZS5kaXNwbGF5ID0gZ3VpLnVzZUxvY2FsU3RvcmFnZSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHNob3dIaWRlRXhwbGFpbigpO1xuXG4gICAgICAvLyBUT0RPOiBVc2UgYSBib29sZWFuIGNvbnRyb2xsZXIsIGZvb2whXG4gICAgICBkb20uYmluZChsb2NhbFN0b3JhZ2VDaGVja0JveCwgJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBndWkudXNlTG9jYWxTdG9yYWdlID0gIWd1aS51c2VMb2NhbFN0b3JhZ2U7XG4gICAgICAgIHNob3dIaWRlRXhwbGFpbigpO1xuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICB2YXIgbmV3Q29uc3RydWN0b3JUZXh0QXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZy1uZXctY29uc3RydWN0b3InKTtcblxuICAgIGRvbS5iaW5kKG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUubWV0YUtleSAmJiAoZS53aGljaCA9PT0gNjcgfHwgZS5rZXlDb2RlID09IDY3KSkge1xuICAgICAgICBTQVZFX0RJQUxPR1VFLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGdlYXJzLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIG5ld0NvbnN0cnVjdG9yVGV4dEFyZWEuaW5uZXJIVE1MID0gSlNPTi5zdHJpbmdpZnkoZ3VpLmdldFNhdmVPYmplY3QoKSwgdW5kZWZpbmVkLCAyKTtcbiAgICAgIFNBVkVfRElBTE9HVUUuc2hvdygpO1xuICAgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5mb2N1cygpO1xuICAgICAgbmV3Q29uc3RydWN0b3JUZXh0QXJlYS5zZWxlY3QoKTtcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGJ1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBndWkuc2F2ZSgpO1xuICAgIH0pO1xuXG4gICAgZG9tLmJpbmQoYnV0dG9uMiwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJlc2V0TmFtZSA9IHByb21wdCgnRW50ZXIgYSBuZXcgcHJlc2V0IG5hbWUuJyk7XG4gICAgICBpZiAocHJlc2V0TmFtZSkgZ3VpLnNhdmVBcyhwcmVzZXROYW1lKTtcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKGJ1dHRvbjMsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgZ3VpLnJldmVydCgpO1xuICAgIH0pO1xuXG4vLyAgICBkaXYuYXBwZW5kQ2hpbGQoYnV0dG9uMik7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJlc2l6ZUhhbmRsZShndWkpIHtcblxuICAgIGd1aS5fX3Jlc2l6ZV9oYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbW1vbi5leHRlbmQoZ3VpLl9fcmVzaXplX2hhbmRsZS5zdHlsZSwge1xuXG4gICAgICB3aWR0aDogJzZweCcsXG4gICAgICBtYXJnaW5MZWZ0OiAnLTNweCcsXG4gICAgICBoZWlnaHQ6ICcyMDBweCcsXG4gICAgICBjdXJzb3I6ICdldy1yZXNpemUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbi8vICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIGJsdWUnXG5cbiAgICB9KTtcblxuICAgIHZhciBwbW91c2VYO1xuXG4gICAgZG9tLmJpbmQoZ3VpLl9fcmVzaXplX2hhbmRsZSwgJ21vdXNlZG93bicsIGRyYWdTdGFydCk7XG4gICAgZG9tLmJpbmQoZ3VpLl9fY2xvc2VCdXR0b24sICdtb3VzZWRvd24nLCBkcmFnU3RhcnQpO1xuXG4gICAgZ3VpLmRvbUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGd1aS5fX3Jlc2l6ZV9oYW5kbGUsIGd1aS5kb21FbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKTtcblxuICAgIGZ1bmN0aW9uIGRyYWdTdGFydChlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgcG1vdXNlWCA9IGUuY2xpZW50WDtcblxuICAgICAgZG9tLmFkZENsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBkcmFnKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBkcmFnU3RvcCk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYWcoZSkge1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGd1aS53aWR0aCArPSBwbW91c2VYIC0gZS5jbGllbnRYO1xuICAgICAgZ3VpLm9uUmVzaXplKCk7XG4gICAgICBwbW91c2VYID0gZS5jbGllbnRYO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmFnU3RvcCgpIHtcblxuICAgICAgZG9tLnJlbW92ZUNsYXNzKGd1aS5fX2Nsb3NlQnV0dG9uLCBHVUkuQ0xBU1NfRFJBRyk7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIGRyYWcpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgZHJhZ1N0b3ApO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRXaWR0aChndWksIHcpIHtcbiAgICBndWkuZG9tRWxlbWVudC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIC8vIEF1dG8gcGxhY2VkIHNhdmUtcm93cyBhcmUgcG9zaXRpb24gZml4ZWQsIHNvIHdlIGhhdmUgdG9cbiAgICAvLyBzZXQgdGhlIHdpZHRoIG1hbnVhbGx5IGlmIHdlIHdhbnQgaXQgdG8gYmxlZWQgdG8gdGhlIGVkZ2VcbiAgICBpZiAoZ3VpLl9fc2F2ZV9yb3cgJiYgZ3VpLmF1dG9QbGFjZSkge1xuICAgICAgZ3VpLl9fc2F2ZV9yb3cuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICB9aWYgKGd1aS5fX2Nsb3NlQnV0dG9uKSB7XG4gICAgICBndWkuX19jbG9zZUJ1dHRvbi5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRQcmVzZXQoZ3VpLCB1c2VJbml0aWFsVmFsdWVzKSB7XG5cbiAgICB2YXIgdG9SZXR1cm4gPSB7fTtcblxuICAgIC8vIEZvciBlYWNoIG9iamVjdCBJJ20gcmVtZW1iZXJpbmdcbiAgICBjb21tb24uZWFjaChndWkuX19yZW1lbWJlcmVkT2JqZWN0cywgZnVuY3Rpb24odmFsLCBpbmRleCkge1xuXG4gICAgICB2YXIgc2F2ZWRfdmFsdWVzID0ge307XG5cbiAgICAgIC8vIFRoZSBjb250cm9sbGVycyBJJ3ZlIG1hZGUgZm9yIHRoY29tbW9uLmlzT2JqZWN0IGJ5IHByb3BlcnR5XG4gICAgICB2YXIgY29udHJvbGxlcl9tYXAgPVxuICAgICAgICAgIGd1aS5fX3JlbWVtYmVyZWRPYmplY3RJbmRlY2VzVG9Db250cm9sbGVyc1tpbmRleF07XG5cbiAgICAgIC8vIFJlbWVtYmVyIGVhY2ggdmFsdWUgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgIGNvbW1vbi5lYWNoKGNvbnRyb2xsZXJfbWFwLCBmdW5jdGlvbihjb250cm9sbGVyLCBwcm9wZXJ0eSkge1xuICAgICAgICBzYXZlZF92YWx1ZXNbcHJvcGVydHldID0gdXNlSW5pdGlhbFZhbHVlcyA/IGNvbnRyb2xsZXIuaW5pdGlhbFZhbHVlIDogY29udHJvbGxlci5nZXRWYWx1ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNhdmUgdGhlIHZhbHVlcyBmb3IgdGhjb21tb24uaXNPYmplY3RcbiAgICAgIHRvUmV0dXJuW2luZGV4XSA9IHNhdmVkX3ZhbHVlcztcblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvUmV0dXJuO1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRQcmVzZXRPcHRpb24oZ3VpLCBuYW1lLCBzZXRTZWxlY3RlZCkge1xuICAgIHZhciBvcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICBvcHQuaW5uZXJIVE1MID0gbmFtZTtcbiAgICBvcHQudmFsdWUgPSBuYW1lO1xuICAgIGd1aS5fX3ByZXNldF9zZWxlY3QuYXBwZW5kQ2hpbGQob3B0KTtcbiAgICBpZiAoc2V0U2VsZWN0ZWQpIHtcbiAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGd1aS5fX3ByZXNldF9zZWxlY3QubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcmVzZXRTZWxlY3RJbmRleChndWkpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ3VpLl9fcHJlc2V0X3NlbGVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChndWkuX19wcmVzZXRfc2VsZWN0W2luZGV4XS52YWx1ZSA9PSBndWkucHJlc2V0KSB7XG4gICAgICAgIGd1aS5fX3ByZXNldF9zZWxlY3Quc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtQcmVzZXRNb2RpZmllZChndWksIG1vZGlmaWVkKSB7XG4gICAgdmFyIG9wdCA9IGd1aS5fX3ByZXNldF9zZWxlY3RbZ3VpLl9fcHJlc2V0X3NlbGVjdC5zZWxlY3RlZEluZGV4XTtcbi8vICAgIGNvbnNvbGUubG9nKCdtYXJrJywgbW9kaWZpZWQsIG9wdCk7XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICBvcHQuaW5uZXJIVE1MID0gb3B0LnZhbHVlICsgXCIqXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdC5pbm5lckhUTUwgPSBvcHQudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheXMoY29udHJvbGxlckFycmF5KSB7XG5cblxuICAgIGlmIChjb250cm9sbGVyQXJyYXkubGVuZ3RoICE9IDApIHtcblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICB1cGRhdGVEaXNwbGF5cyhjb250cm9sbGVyQXJyYXkpO1xuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBjb21tb24uZWFjaChjb250cm9sbGVyQXJyYXksIGZ1bmN0aW9uKGMpIHtcbiAgICAgIGMudXBkYXRlRGlzcGxheSgpO1xuICAgIH0pO1xuXG4gIH1cblxuICByZXR1cm4gR1VJO1xuXG59KShkYXQudXRpbHMuY3NzLFxuXCI8ZGl2IGlkPVxcXCJkZy1zYXZlXFxcIiBjbGFzcz1cXFwiZGcgZGlhbG9ndWVcXFwiPlxcblxcbiAgSGVyZSdzIHRoZSBuZXcgbG9hZCBwYXJhbWV0ZXIgZm9yIHlvdXIgPGNvZGU+R1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yOlxcblxcbiAgPHRleHRhcmVhIGlkPVxcXCJkZy1uZXctY29uc3RydWN0b3JcXFwiPjwvdGV4dGFyZWE+XFxuXFxuICA8ZGl2IGlkPVxcXCJkZy1zYXZlLWxvY2FsbHlcXFwiPlxcblxcbiAgICA8aW5wdXQgaWQ9XFxcImRnLWxvY2FsLXN0b3JhZ2VcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIi8+IEF1dG9tYXRpY2FsbHkgc2F2ZVxcbiAgICB2YWx1ZXMgdG8gPGNvZGU+bG9jYWxTdG9yYWdlPC9jb2RlPiBvbiBleGl0LlxcblxcbiAgICA8ZGl2IGlkPVxcXCJkZy1sb2NhbC1leHBsYWluXFxcIj5UaGUgdmFsdWVzIHNhdmVkIHRvIDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gd2lsbFxcbiAgICAgIG92ZXJyaWRlIHRob3NlIHBhc3NlZCB0byA8Y29kZT5kYXQuR1VJPC9jb2RlPidzIGNvbnN0cnVjdG9yLiBUaGlzIG1ha2VzIGl0XFxuICAgICAgZWFzaWVyIHRvIHdvcmsgaW5jcmVtZW50YWxseSwgYnV0IDxjb2RlPmxvY2FsU3RvcmFnZTwvY29kZT4gaXMgZnJhZ2lsZSxcXG4gICAgICBhbmQgeW91ciBmcmllbmRzIG1heSBub3Qgc2VlIHRoZSBzYW1lIHZhbHVlcyB5b3UgZG8uXFxuICAgICAgXFxuICAgIDwvZGl2PlxcbiAgICBcXG4gIDwvZGl2PlxcblxcbjwvZGl2PlwiLFxuXCIuZGcgdWx7bGlzdC1zdHlsZTpub25lO21hcmdpbjowO3BhZGRpbmc6MDt3aWR0aDoxMDAlO2NsZWFyOmJvdGh9LmRnLmFje3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtyaWdodDowO2hlaWdodDowO3otaW5kZXg6MH0uZGc6bm90KC5hYykgLm1haW57b3ZlcmZsb3c6aGlkZGVufS5kZy5tYWluey13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1vLXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjstbW96LXRyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjt0cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXJ9LmRnLm1haW4udGFsbGVyLXRoYW4td2luZG93e292ZXJmbG93LXk6YXV0b30uZGcubWFpbi50YWxsZXItdGhhbi13aW5kb3cgLmNsb3NlLWJ1dHRvbntvcGFjaXR5OjE7bWFyZ2luLXRvcDotMXB4O2JvcmRlci10b3A6MXB4IHNvbGlkICMyYzJjMmN9LmRnLm1haW4gdWwuY2xvc2VkIC5jbG9zZS1idXR0b257b3BhY2l0eToxICFpbXBvcnRhbnR9LmRnLm1haW46aG92ZXIgLmNsb3NlLWJ1dHRvbiwuZGcubWFpbiAuY2xvc2UtYnV0dG9uLmRyYWd7b3BhY2l0eToxfS5kZy5tYWluIC5jbG9zZS1idXR0b257LXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMC4xcyBsaW5lYXI7LW8tdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyOy1tb3otdHJhbnNpdGlvbjpvcGFjaXR5IDAuMXMgbGluZWFyO3RyYW5zaXRpb246b3BhY2l0eSAwLjFzIGxpbmVhcjtib3JkZXI6MDtwb3NpdGlvbjphYnNvbHV0ZTtsaW5lLWhlaWdodDoxOXB4O2hlaWdodDoyMHB4O2N1cnNvcjpwb2ludGVyO3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6IzAwMH0uZGcubWFpbiAuY2xvc2UtYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzExMX0uZGcuYXtmbG9hdDpyaWdodDttYXJnaW4tcmlnaHQ6MTVweDtvdmVyZmxvdy14OmhpZGRlbn0uZGcuYS5oYXMtc2F2ZSB1bHttYXJnaW4tdG9wOjI3cHh9LmRnLmEuaGFzLXNhdmUgdWwuY2xvc2Vke21hcmdpbi10b3A6MH0uZGcuYSAuc2F2ZS1yb3d7cG9zaXRpb246Zml4ZWQ7dG9wOjA7ei1pbmRleDoxMDAyfS5kZyBsaXstd2Via2l0LXRyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXQ7LW8tdHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dDstbW96LXRyYW5zaXRpb246aGVpZ2h0IDAuMXMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpoZWlnaHQgMC4xcyBlYXNlLW91dH0uZGcgbGk6bm90KC5mb2xkZXIpe2N1cnNvcjphdXRvO2hlaWdodDoyN3B4O2xpbmUtaGVpZ2h0OjI3cHg7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MCA0cHggMCA1cHh9LmRnIGxpLmZvbGRlcntwYWRkaW5nOjA7Ym9yZGVyLWxlZnQ6NHB4IHNvbGlkIHJnYmEoMCwwLDAsMCl9LmRnIGxpLnRpdGxle2N1cnNvcjpwb2ludGVyO21hcmdpbi1sZWZ0Oi00cHh9LmRnIC5jbG9zZWQgbGk6bm90KC50aXRsZSksLmRnIC5jbG9zZWQgdWwgbGksLmRnIC5jbG9zZWQgdWwgbGkgPiAqe2hlaWdodDowO292ZXJmbG93OmhpZGRlbjtib3JkZXI6MH0uZGcgLmNye2NsZWFyOmJvdGg7cGFkZGluZy1sZWZ0OjNweDtoZWlnaHQ6MjdweH0uZGcgLnByb3BlcnR5LW5hbWV7Y3Vyc29yOmRlZmF1bHQ7ZmxvYXQ6bGVmdDtjbGVhcjpsZWZ0O3dpZHRoOjQwJTtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uZGcgLmN7ZmxvYXQ6bGVmdDt3aWR0aDo2MCV9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17Ym9yZGVyOjA7bWFyZ2luLXRvcDo0cHg7cGFkZGluZzozcHg7d2lkdGg6MTAwJTtmbG9hdDpyaWdodH0uZGcgLmhhcy1zbGlkZXIgaW5wdXRbdHlwZT10ZXh0XXt3aWR0aDozMCU7bWFyZ2luLWxlZnQ6MH0uZGcgLnNsaWRlcntmbG9hdDpsZWZ0O3dpZHRoOjY2JTttYXJnaW4tbGVmdDotNXB4O21hcmdpbi1yaWdodDowO2hlaWdodDoxOXB4O21hcmdpbi10b3A6NHB4fS5kZyAuc2xpZGVyLWZne2hlaWdodDoxMDAlfS5kZyAuYyBpbnB1dFt0eXBlPWNoZWNrYm94XXttYXJnaW4tdG9wOjlweH0uZGcgLmMgc2VsZWN0e21hcmdpbi10b3A6NXB4fS5kZyAuY3IuZnVuY3Rpb24sLmRnIC5jci5mdW5jdGlvbiAucHJvcGVydHktbmFtZSwuZGcgLmNyLmZ1bmN0aW9uICosLmRnIC5jci5ib29sZWFuLC5kZyAuY3IuYm9vbGVhbiAqe2N1cnNvcjpwb2ludGVyfS5kZyAuc2VsZWN0b3J7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbi1sZWZ0Oi05cHg7bWFyZ2luLXRvcDoyM3B4O3otaW5kZXg6MTB9LmRnIC5jOmhvdmVyIC5zZWxlY3RvciwuZGcgLnNlbGVjdG9yLmRyYWd7ZGlzcGxheTpibG9ja30uZGcgbGkuc2F2ZS1yb3d7cGFkZGluZzowfS5kZyBsaS5zYXZlLXJvdyAuYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MHB4IDZweH0uZGcuZGlhbG9ndWV7YmFja2dyb3VuZC1jb2xvcjojMjIyO3dpZHRoOjQ2MHB4O3BhZGRpbmc6MTVweDtmb250LXNpemU6MTNweDtsaW5lLWhlaWdodDoxNXB4fSNkZy1uZXctY29uc3RydWN0b3J7cGFkZGluZzoxMHB4O2NvbG9yOiMyMjI7Zm9udC1mYW1pbHk6TW9uYWNvLCBtb25vc3BhY2U7Zm9udC1zaXplOjEwcHg7Ym9yZGVyOjA7cmVzaXplOm5vbmU7Ym94LXNoYWRvdzppbnNldCAxcHggMXB4IDFweCAjODg4O3dvcmQtd3JhcDpicmVhay13b3JkO21hcmdpbjoxMnB4IDA7ZGlzcGxheTpibG9jazt3aWR0aDo0NDBweDtvdmVyZmxvdy15OnNjcm9sbDtoZWlnaHQ6MTAwcHg7cG9zaXRpb246cmVsYXRpdmV9I2RnLWxvY2FsLWV4cGxhaW57ZGlzcGxheTpub25lO2ZvbnQtc2l6ZToxMXB4O2xpbmUtaGVpZ2h0OjE3cHg7Ym9yZGVyLXJhZGl1czozcHg7YmFja2dyb3VuZC1jb2xvcjojMzMzO3BhZGRpbmc6OHB4O21hcmdpbi10b3A6MTBweH0jZGctbG9jYWwtZXhwbGFpbiBjb2Rle2ZvbnQtc2l6ZToxMHB4fSNkYXQtZ3VpLXNhdmUtbG9jYWxseXtkaXNwbGF5Om5vbmV9LmRne2NvbG9yOiNlZWU7Zm9udDoxMXB4ICdMdWNpZGEgR3JhbmRlJywgc2Fucy1zZXJpZjt0ZXh0LXNoYWRvdzowIC0xcHggMCAjMTExfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhcnt3aWR0aDo1cHg7YmFja2dyb3VuZDojMWExYTFhfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXJ7aGVpZ2h0OjA7ZGlzcGxheTpub25lfS5kZy5tYWluOjotd2Via2l0LXNjcm9sbGJhci10aHVtYntib3JkZXItcmFkaXVzOjVweDtiYWNrZ3JvdW5kOiM2NzY3Njd9LmRnIGxpOm5vdCguZm9sZGVyKXtiYWNrZ3JvdW5kOiMxYTFhMWE7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgIzJjMmMyY30uZGcgbGkuc2F2ZS1yb3d7bGluZS1oZWlnaHQ6MjVweDtiYWNrZ3JvdW5kOiNkYWQ1Y2I7Ym9yZGVyOjB9LmRnIGxpLnNhdmUtcm93IHNlbGVjdHttYXJnaW4tbGVmdDo1cHg7d2lkdGg6MTA4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b257bWFyZ2luLWxlZnQ6NXB4O21hcmdpbi10b3A6MXB4O2JvcmRlci1yYWRpdXM6MnB4O2ZvbnQtc2l6ZTo5cHg7bGluZS1oZWlnaHQ6N3B4O3BhZGRpbmc6NHB4IDRweCA1cHggNHB4O2JhY2tncm91bmQ6I2M1YmRhZDtjb2xvcjojZmZmO3RleHQtc2hhZG93OjAgMXB4IDAgI2IwYTU4Zjtib3gtc2hhZG93OjAgLTFweCAwICNiMGE1OGY7Y3Vyc29yOnBvaW50ZXJ9LmRnIGxpLnNhdmUtcm93IC5idXR0b24uZ2VhcnN7YmFja2dyb3VuZDojYzViZGFkIHVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFzQUFBQU5DQVlBQUFCLzlaUTdBQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQVFKSlJFRlVlTnBpWUtBVS9QLy9Qd0dJQy9BcENBQmlCU0FXK0k4QUNsQWNnS3hRNFQ5aG9NQUVVcnh4MlFTR042K2VnRFgrL3ZXVDRlN044MkFNWW9QQXgvZXZ3V29Zb1NZYkFDWDJzN0t4Q3h6Y3NlekRoM2V2Rm9ERUJZVEVFcXljZ2dXQXpBOUF1VVNRUWdlWVBhOWZQdjYvWVdtL0FjeDVJUGI3dHkvZncrUVpibHc2N3ZEczhSMFlIeVFoZ09ieCt5QUprQnFtRzVkUFBEaDFhUE9HUi9ldWdXMEc0dmxJb1RJZnlGY0ErUWVraGhISmhQZFF4YmlBSWd1TUJUUVpyUEQ3MTA4TTZyb1dZREZRaUlBQXY2QW93LzFiRndYZ2lzK2YyTFVBeW53b0lhTmN6OFhOeDNEbDdNRUpVREdRcHg5Z3RROFlDdWVCK0QyNk9FQ0FBUURhZHQ3ZTQ2RDQyUUFBQUFCSlJVNUVya0pnZ2c9PSkgMnB4IDFweCBuby1yZXBlYXQ7aGVpZ2h0OjdweDt3aWR0aDo4cHh9LmRnIGxpLnNhdmUtcm93IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojYmFiMTllO2JveC1zaGFkb3c6MCAtMXB4IDAgI2IwYTU4Zn0uZGcgbGkuZm9sZGVye2JvcmRlci1ib3R0b206MH0uZGcgbGkudGl0bGV7cGFkZGluZy1sZWZ0OjE2cHg7YmFja2dyb3VuZDojMDAwIHVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEkraEtnRnhvQ2dBT3c9PSkgNnB4IDEwcHggbm8tcmVwZWF0O2N1cnNvcjpwb2ludGVyO2JvcmRlci1ib3R0b206MXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKX0uZGcgLmNsb3NlZCBsaS50aXRsZXtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhCUUFGQUpFQUFQLy8vL1B6OC8vLy8vLy8veUg1QkFFQUFBSUFMQUFBQUFBRkFBVUFBQUlJbEdJV3FNQ2JXQUVBT3c9PSl9LmRnIC5jci5ib29sZWFue2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjODA2Nzg3fS5kZyAuY3IuZnVuY3Rpb257Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICNlNjFkNWZ9LmRnIC5jci5udW1iZXJ7Ym9yZGVyLWxlZnQ6M3B4IHNvbGlkICMyZmExZDZ9LmRnIC5jci5udW1iZXIgaW5wdXRbdHlwZT10ZXh0XXtjb2xvcjojMmZhMWQ2fS5kZyAuY3Iuc3RyaW5ne2JvcmRlci1sZWZ0OjNweCBzb2xpZCAjMWVkMzZmfS5kZyAuY3Iuc3RyaW5nIGlucHV0W3R5cGU9dGV4dF17Y29sb3I6IzFlZDM2Zn0uZGcgLmNyLmZ1bmN0aW9uOmhvdmVyLC5kZyAuY3IuYm9vbGVhbjpob3ZlcntiYWNrZ3JvdW5kOiMxMTF9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF17YmFja2dyb3VuZDojMzAzMDMwO291dGxpbmU6bm9uZX0uZGcgLmMgaW5wdXRbdHlwZT10ZXh0XTpob3ZlcntiYWNrZ3JvdW5kOiMzYzNjM2N9LmRnIC5jIGlucHV0W3R5cGU9dGV4dF06Zm9jdXN7YmFja2dyb3VuZDojNDk0OTQ5O2NvbG9yOiNmZmZ9LmRnIC5jIC5zbGlkZXJ7YmFja2dyb3VuZDojMzAzMDMwO2N1cnNvcjpldy1yZXNpemV9LmRnIC5jIC5zbGlkZXItZmd7YmFja2dyb3VuZDojMmZhMWQ2fS5kZyAuYyAuc2xpZGVyOmhvdmVye2JhY2tncm91bmQ6IzNjM2MzY30uZGcgLmMgLnNsaWRlcjpob3ZlciAuc2xpZGVyLWZne2JhY2tncm91bmQ6IzQ0YWJkYX1cXG5cIixcbmRhdC5jb250cm9sbGVycy5mYWN0b3J5ID0gKGZ1bmN0aW9uIChPcHRpb25Db250cm9sbGVyLCBOdW1iZXJDb250cm9sbGVyQm94LCBOdW1iZXJDb250cm9sbGVyU2xpZGVyLCBTdHJpbmdDb250cm9sbGVyLCBGdW5jdGlvbkNvbnRyb2xsZXIsIEJvb2xlYW5Db250cm9sbGVyLCBjb21tb24pIHtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcblxuICAgICAgICB2YXIgaW5pdGlhbFZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAvLyBQcm92aWRpbmcgb3B0aW9ucz9cbiAgICAgICAgaWYgKGNvbW1vbi5pc0FycmF5KGFyZ3VtZW50c1syXSkgfHwgY29tbW9uLmlzT2JqZWN0KGFyZ3VtZW50c1syXSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE9wdGlvbkNvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb3ZpZGluZyBhIG1hcD9cblxuICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKGluaXRpYWxWYWx1ZSkpIHtcblxuICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzJdKSAmJiBjb21tb24uaXNOdW1iZXIoYXJndW1lbnRzWzNdKSkge1xuXG4gICAgICAgICAgICAvLyBIYXMgbWluIGFuZCBtYXguXG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWJlckNvbnRyb2xsZXJTbGlkZXIob2JqZWN0LCBwcm9wZXJ0eSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb250cm9sbGVyQm94KG9iamVjdCwgcHJvcGVydHksIHsgbWluOiBhcmd1bWVudHNbMl0sIG1heDogYXJndW1lbnRzWzNdIH0pO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzU3RyaW5nKGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0NvbnRyb2xsZXIob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbW9uLmlzRnVuY3Rpb24oaW5pdGlhbFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHksICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tb24uaXNCb29sZWFuKGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db250cm9sbGVyKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0pKGRhdC5jb250cm9sbGVycy5PcHRpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLk51bWJlckNvbnRyb2xsZXJCb3gsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlclNsaWRlcixcbmRhdC5jb250cm9sbGVycy5TdHJpbmdDb250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIGNvbW1vbikge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgUHJvdmlkZXMgYSB0ZXh0IGlucHV0IHRvIGFsdGVyIHRoZSBzdHJpbmcgcHJvcGVydHkgb2YgYW4gb2JqZWN0LlxuICAgKlxuICAgKiBAZXh0ZW5kcyBkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmUgbWFuaXB1bGF0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBtYW5pcHVsYXRlZFxuICAgKlxuICAgKiBAbWVtYmVyIGRhdC5jb250cm9sbGVyc1xuICAgKi9cbiAgdmFyIFN0cmluZ0NvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICBTdHJpbmdDb250cm9sbGVyLnN1cGVyY2xhc3MuY2FsbCh0aGlzLCBvYmplY3QsIHByb3BlcnR5KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuX19pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAna2V5dXAnLCBvbkNoYW5nZSk7XG4gICAgZG9tLmJpbmQodGhpcy5fX2lucHV0LCAnY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2JsdXInLCBvbkJsdXIpO1xuICAgIGRvbS5iaW5kKHRoaXMuX19pbnB1dCwgJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgICAgX3RoaXMuc2V0VmFsdWUoX3RoaXMuX19pbnB1dC52YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKF90aGlzLl9fb25GaW5pc2hDaGFuZ2UpIHtcbiAgICAgICAgX3RoaXMuX19vbkZpbmlzaENoYW5nZS5jYWxsKF90aGlzLCBfdGhpcy5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIHRoaXMuZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9faW5wdXQpO1xuXG4gIH07XG5cbiAgU3RyaW5nQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBTdHJpbmdDb250cm9sbGVyLnByb3RvdHlwZSxcbiAgICAgIENvbnRyb2xsZXIucHJvdG90eXBlLFxuXG4gICAgICB7XG5cbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gU3RvcHMgdGhlIGNhcmV0IGZyb20gbW92aW5nIG9uIGFjY291bnQgb2Y6XG4gICAgICAgICAgLy8ga2V5dXAgLT4gc2V0VmFsdWUgLT4gdXBkYXRlRGlzcGxheVxuICAgICAgICAgIGlmICghZG9tLmlzQWN0aXZlKHRoaXMuX19pbnB1dCkpIHtcbiAgICAgICAgICAgIHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFN0cmluZ0NvbnRyb2xsZXIuc3VwZXJjbGFzcy5wcm90b3R5cGUudXBkYXRlRGlzcGxheS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuXG4gIHJldHVybiBTdHJpbmdDb250cm9sbGVyO1xuXG59KShkYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29udHJvbGxlcnMuRnVuY3Rpb25Db250cm9sbGVyLFxuZGF0LmNvbnRyb2xsZXJzLkJvb2xlYW5Db250cm9sbGVyLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29udHJvbGxlcnMuQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5Cb29sZWFuQ29udHJvbGxlcixcbmRhdC5jb250cm9sbGVycy5GdW5jdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuTnVtYmVyQ29udHJvbGxlckJveCxcbmRhdC5jb250cm9sbGVycy5OdW1iZXJDb250cm9sbGVyU2xpZGVyLFxuZGF0LmNvbnRyb2xsZXJzLk9wdGlvbkNvbnRyb2xsZXIsXG5kYXQuY29udHJvbGxlcnMuQ29sb3JDb250cm9sbGVyID0gKGZ1bmN0aW9uIChDb250cm9sbGVyLCBkb20sIENvbG9yLCBpbnRlcnByZXQsIGNvbW1vbikge1xuXG4gIHZhciBDb2xvckNvbnRyb2xsZXIgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG5cbiAgICBDb2xvckNvbnRyb2xsZXIuc3VwZXJjbGFzcy5jYWxsKHRoaXMsIG9iamVjdCwgcHJvcGVydHkpO1xuXG4gICAgdGhpcy5fX2NvbG9yID0gbmV3IENvbG9yKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgdGhpcy5fX3RlbXAgPSBuZXcgQ29sb3IoMCk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBkb20ubWFrZVNlbGVjdGFibGUodGhpcy5kb21FbGVtZW50LCBmYWxzZSk7XG5cbiAgICB0aGlzLl9fc2VsZWN0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuY2xhc3NOYW1lID0gJ3NlbGVjdG9yJztcblxuICAgIHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX3NhdHVyYXRpb25fZmllbGQuY2xhc3NOYW1lID0gJ3NhdHVyYXRpb24tZmllbGQnO1xuXG4gICAgdGhpcy5fX2ZpZWxkX2tub2IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLl9fZmllbGRfa25vYi5jbGFzc05hbWUgPSAnZmllbGQta25vYic7XG4gICAgdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyID0gJzJweCBzb2xpZCAnO1xuXG4gICAgdGhpcy5fX2h1ZV9rbm9iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2h1ZV9rbm9iLmNsYXNzTmFtZSA9ICdodWUta25vYic7XG5cbiAgICB0aGlzLl9faHVlX2ZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fX2h1ZV9maWVsZC5jbGFzc05hbWUgPSAnaHVlLWZpZWxkJztcblxuICAgIHRoaXMuX19pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdGhpcy5fX2lucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgPSAnMCAxcHggMXB4ICc7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMTMpIHsgLy8gb24gZW50ZXJcbiAgICAgICAgb25CbHVyLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faW5wdXQsICdibHVyJywgb25CbHVyKTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19zZWxlY3RvciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgZG9tXG4gICAgICAgIC5hZGRDbGFzcyh0aGlzLCAnZHJhZycpXG4gICAgICAgIC5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKF90aGlzLl9fc2VsZWN0b3IsICdkcmFnJyk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICB2YXIgdmFsdWVfZmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX3NlbGVjdG9yLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEyMnB4JyxcbiAgICAgIGhlaWdodDogJzEwMnB4JyxcbiAgICAgIHBhZGRpbmc6ICczcHgnLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzIyMicsXG4gICAgICBib3hTaGFkb3c6ICcwcHggMXB4IDNweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgfSk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19maWVsZF9rbm9iLnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiAnMTJweCcsXG4gICAgICBoZWlnaHQ6ICcxMnB4JyxcbiAgICAgIGJvcmRlcjogdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyICsgKHRoaXMuX19jb2xvci52IDwgLjUgPyAnI2ZmZicgOiAnIzAwMCcpLFxuICAgICAgYm94U2hhZG93OiAnMHB4IDFweCAzcHggcmdiYSgwLDAsMCwwLjUpJyxcbiAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgekluZGV4OiAxXG4gICAgfSk7XG4gICAgXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9faHVlX2tub2Iuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzJweCcsXG4gICAgICBib3JkZXJSaWdodDogJzRweCBzb2xpZCAjZmZmJyxcbiAgICAgIHpJbmRleDogMVxuICAgIH0pO1xuXG4gICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fc2F0dXJhdGlvbl9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxMDBweCcsXG4gICAgICBoZWlnaHQ6ICcxMDBweCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgIzU1NScsXG4gICAgICBtYXJnaW5SaWdodDogJzNweCcsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgfSk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHZhbHVlX2ZpZWxkLnN0eWxlLCB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBiYWNrZ3JvdW5kOiAnbm9uZSdcbiAgICB9KTtcbiAgICBcbiAgICBsaW5lYXJHcmFkaWVudCh2YWx1ZV9maWVsZCwgJ3RvcCcsICdyZ2JhKDAsMCwwLDApJywgJyMwMDAnKTtcblxuICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2h1ZV9maWVsZC5zdHlsZSwge1xuICAgICAgd2lkdGg6ICcxNXB4JyxcbiAgICAgIGhlaWdodDogJzEwMHB4JyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICM1NTUnLFxuICAgICAgY3Vyc29yOiAnbnMtcmVzaXplJ1xuICAgIH0pO1xuXG4gICAgaHVlR3JhZGllbnQodGhpcy5fX2h1ZV9maWVsZCk7XG5cbiAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19pbnB1dC5zdHlsZSwge1xuICAgICAgb3V0bGluZTogJ25vbmUnLFxuLy8gICAgICB3aWR0aDogJzEyMHB4JyxcbiAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4vLyAgICAgIHBhZGRpbmc6ICc0cHgnLFxuLy8gICAgICBtYXJnaW5Cb3R0b206ICc2cHgnLFxuICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgIGJvcmRlcjogMCxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIHRleHRTaGFkb3c6IHRoaXMuX19pbnB1dF90ZXh0U2hhZG93ICsgJ3JnYmEoMCwwLDAsMC43KSdcbiAgICB9KTtcblxuICAgIGRvbS5iaW5kKHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkLCAnbW91c2Vkb3duJywgZmllbGREb3duKTtcbiAgICBkb20uYmluZCh0aGlzLl9fZmllbGRfa25vYiwgJ21vdXNlZG93bicsIGZpZWxkRG93bik7XG5cbiAgICBkb20uYmluZCh0aGlzLl9faHVlX2ZpZWxkLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgc2V0SChlKTtcbiAgICAgIGRvbS5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLmJpbmQod2luZG93LCAnbW91c2V1cCcsIHVuYmluZEgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmllbGREb3duKGUpIHtcbiAgICAgIHNldFNWKGUpO1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnbm9uZSc7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20uYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kU1YpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuYmluZFNWKCkge1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZW1vdmUnLCBzZXRTVik7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNldXAnLCB1bmJpbmRTVik7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICB2YXIgaSA9IGludGVycHJldCh0aGlzLnZhbHVlKTtcbiAgICAgIGlmIChpICE9PSBmYWxzZSkge1xuICAgICAgICBfdGhpcy5fX2NvbG9yLl9fc3RhdGUgPSBpO1xuICAgICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gX3RoaXMuX19jb2xvci50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuYmluZEgoKSB7XG4gICAgICBkb20udW5iaW5kKHdpbmRvdywgJ21vdXNlbW92ZScsIHNldEgpO1xuICAgICAgZG9tLnVuYmluZCh3aW5kb3csICdtb3VzZXVwJywgdW5iaW5kSCk7XG4gICAgfVxuXG4gICAgdGhpcy5fX3NhdHVyYXRpb25fZmllbGQuYXBwZW5kQ2hpbGQodmFsdWVfZmllbGQpO1xuICAgIHRoaXMuX19zZWxlY3Rvci5hcHBlbmRDaGlsZCh0aGlzLl9fZmllbGRfa25vYik7XG4gICAgdGhpcy5fX3NlbGVjdG9yLmFwcGVuZENoaWxkKHRoaXMuX19zYXR1cmF0aW9uX2ZpZWxkKTtcbiAgICB0aGlzLl9fc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5fX2h1ZV9maWVsZCk7XG4gICAgdGhpcy5fX2h1ZV9maWVsZC5hcHBlbmRDaGlsZCh0aGlzLl9faHVlX2tub2IpO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19pbnB1dCk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX19zZWxlY3Rvcik7XG5cbiAgICB0aGlzLnVwZGF0ZURpc3BsYXkoKTtcblxuICAgIGZ1bmN0aW9uIHNldFNWKGUpIHtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgdyA9IGRvbS5nZXRXaWR0aChfdGhpcy5fX3NhdHVyYXRpb25fZmllbGQpO1xuICAgICAgdmFyIG8gPSBkb20uZ2V0T2Zmc2V0KF90aGlzLl9fc2F0dXJhdGlvbl9maWVsZCk7XG4gICAgICB2YXIgcyA9IChlLmNsaWVudFggLSBvLmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpIC8gdztcbiAgICAgIHZhciB2ID0gMSAtIChlLmNsaWVudFkgLSBvLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSAvIHc7XG5cbiAgICAgIGlmICh2ID4gMSkgdiA9IDE7XG4gICAgICBlbHNlIGlmICh2IDwgMCkgdiA9IDA7XG5cbiAgICAgIGlmIChzID4gMSkgcyA9IDE7XG4gICAgICBlbHNlIGlmIChzIDwgMCkgcyA9IDA7XG5cbiAgICAgIF90aGlzLl9fY29sb3IudiA9IHY7XG4gICAgICBfdGhpcy5fX2NvbG9yLnMgPSBzO1xuXG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG5cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SChlKSB7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIHMgPSBkb20uZ2V0SGVpZ2h0KF90aGlzLl9faHVlX2ZpZWxkKTtcbiAgICAgIHZhciBvID0gZG9tLmdldE9mZnNldChfdGhpcy5fX2h1ZV9maWVsZCk7XG4gICAgICB2YXIgaCA9IDEgLSAoZS5jbGllbnRZIC0gby50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCkgLyBzO1xuXG4gICAgICBpZiAoaCA+IDEpIGggPSAxO1xuICAgICAgZWxzZSBpZiAoaCA8IDApIGggPSAwO1xuXG4gICAgICBfdGhpcy5fX2NvbG9yLmggPSBoICogMzYwO1xuXG4gICAgICBfdGhpcy5zZXRWYWx1ZShfdGhpcy5fX2NvbG9yLnRvT3JpZ2luYWwoKSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICB9O1xuXG4gIENvbG9yQ29udHJvbGxlci5zdXBlcmNsYXNzID0gQ29udHJvbGxlcjtcblxuICBjb21tb24uZXh0ZW5kKFxuXG4gICAgICBDb2xvckNvbnRyb2xsZXIucHJvdG90eXBlLFxuICAgICAgQ29udHJvbGxlci5wcm90b3R5cGUsXG5cbiAgICAgIHtcblxuICAgICAgICB1cGRhdGVEaXNwbGF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIHZhciBpID0gaW50ZXJwcmV0KHRoaXMuZ2V0VmFsdWUoKSk7XG5cbiAgICAgICAgICBpZiAoaSAhPT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgdmFyIG1pc21hdGNoID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBtaXNtYXRjaCBvbiB0aGUgaW50ZXJwcmV0ZWQgdmFsdWUuXG5cbiAgICAgICAgICAgIGNvbW1vbi5lYWNoKENvbG9yLkNPTVBPTkVOVFMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICBpZiAoIWNvbW1vbi5pc1VuZGVmaW5lZChpW2NvbXBvbmVudF0pICYmXG4gICAgICAgICAgICAgICAgICAhY29tbW9uLmlzVW5kZWZpbmVkKHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pICYmXG4gICAgICAgICAgICAgICAgICBpW2NvbXBvbmVudF0gIT09IHRoaXMuX19jb2xvci5fX3N0YXRlW2NvbXBvbmVudF0pIHtcbiAgICAgICAgICAgICAgICBtaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9OyAvLyBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gSWYgbm90aGluZyBkaXZlcmdlcywgd2Uga2VlcCBvdXIgcHJldmlvdXMgdmFsdWVzXG4gICAgICAgICAgICAvLyBmb3Igc3RhdGVmdWxuZXNzLCBvdGhlcndpc2Ugd2UgcmVjYWxjdWxhdGUgZnJlc2hcbiAgICAgICAgICAgIGlmIChtaXNtYXRjaCkge1xuICAgICAgICAgICAgICBjb21tb24uZXh0ZW5kKHRoaXMuX19jb2xvci5fX3N0YXRlLCBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX3RlbXAuX19zdGF0ZSwgdGhpcy5fX2NvbG9yLl9fc3RhdGUpO1xuXG4gICAgICAgICAgdGhpcy5fX3RlbXAuYSA9IDE7XG5cbiAgICAgICAgICB2YXIgZmxpcCA9ICh0aGlzLl9fY29sb3IudiA8IC41IHx8IHRoaXMuX19jb2xvci5zID4gLjUpID8gMjU1IDogMDtcbiAgICAgICAgICB2YXIgX2ZsaXAgPSAyNTUgLSBmbGlwO1xuXG4gICAgICAgICAgY29tbW9uLmV4dGVuZCh0aGlzLl9fZmllbGRfa25vYi5zdHlsZSwge1xuICAgICAgICAgICAgbWFyZ2luTGVmdDogMTAwICogdGhpcy5fX2NvbG9yLnMgLSA3ICsgJ3B4JyxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMTAwICogKDEgLSB0aGlzLl9fY29sb3IudikgLSA3ICsgJ3B4JyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fX3RlbXAudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGJvcmRlcjogdGhpcy5fX2ZpZWxkX2tub2JfYm9yZGVyICsgJ3JnYignICsgZmxpcCArICcsJyArIGZsaXAgKyAnLCcgKyBmbGlwICsnKSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuX19odWVfa25vYi5zdHlsZS5tYXJnaW5Ub3AgPSAoMSAtIHRoaXMuX19jb2xvci5oIC8gMzYwKSAqIDEwMCArICdweCdcblxuICAgICAgICAgIHRoaXMuX190ZW1wLnMgPSAxO1xuICAgICAgICAgIHRoaXMuX190ZW1wLnYgPSAxO1xuXG4gICAgICAgICAgbGluZWFyR3JhZGllbnQodGhpcy5fX3NhdHVyYXRpb25fZmllbGQsICdsZWZ0JywgJyNmZmYnLCB0aGlzLl9fdGVtcC50b1N0cmluZygpKTtcblxuICAgICAgICAgIGNvbW1vbi5leHRlbmQodGhpcy5fX2lucHV0LnN0eWxlLCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX19pbnB1dC52YWx1ZSA9IHRoaXMuX19jb2xvci50b1N0cmluZygpLFxuICAgICAgICAgICAgY29sb3I6ICdyZ2IoJyArIGZsaXAgKyAnLCcgKyBmbGlwICsgJywnICsgZmxpcCArJyknLFxuICAgICAgICAgICAgdGV4dFNoYWRvdzogdGhpcy5fX2lucHV0X3RleHRTaGFkb3cgKyAncmdiYSgnICsgX2ZsaXAgKyAnLCcgKyBfZmxpcCArICcsJyArIF9mbGlwICsnLC43KSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICApO1xuICBcbiAgdmFyIHZlbmRvcnMgPSBbJy1tb3otJywnLW8tJywnLXdlYmtpdC0nLCctbXMtJywnJ107XG4gIFxuICBmdW5jdGlvbiBsaW5lYXJHcmFkaWVudChlbGVtLCB4LCBhLCBiKSB7XG4gICAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gICAgY29tbW9uLmVhY2godmVuZG9ycywgZnVuY3Rpb24odmVuZG9yKSB7XG4gICAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6ICcgKyB2ZW5kb3IgKyAnbGluZWFyLWdyYWRpZW50KCcreCsnLCAnK2ErJyAwJSwgJyArIGIgKyAnIDEwMCUpOyAnO1xuICAgIH0pO1xuICB9XG4gIFxuICBmdW5jdGlvbiBodWVHcmFkaWVudChlbGVtKSB7XG4gICAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kID0gJyc7XG4gICAgZWxlbS5zdHlsZS5jc3NUZXh0ICs9ICdiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCAjZmYwMGZmIDE3JSwgIzAwMDBmZiAzNCUsICMwMGZmZmYgNTAlLCAjMDBmZjAwIDY3JSwgI2ZmZmYwMCA4NCUsICNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAgI2ZmMDAwMCAwJSwjZmYwMGZmIDE3JSwjMDAwMGZmIDM0JSwjMDBmZmZmIDUwJSwjMDBmZjAwIDY3JSwjZmZmZjAwIDg0JSwjZmYwMDAwIDEwMCUpOydcbiAgICBlbGVtLnN0eWxlLmNzc1RleHQgKz0gJ2JhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICAjZmYwMDAwIDAlLCNmZjAwZmYgMTclLCMwMDAwZmYgMzQlLCMwMGZmZmYgNTAlLCMwMGZmMDAgNjclLCNmZmZmMDAgODQlLCNmZjAwMDAgMTAwJSk7J1xuICAgIGVsZW0uc3R5bGUuY3NzVGV4dCArPSAnYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvcCwgICNmZjAwMDAgMCUsI2ZmMDBmZiAxNyUsIzAwMDBmZiAzNCUsIzAwZmZmZiA1MCUsIzAwZmYwMCA2NyUsI2ZmZmYwMCA4NCUsI2ZmMDAwMCAxMDAlKTsnXG4gIH1cblxuXG4gIHJldHVybiBDb2xvckNvbnRyb2xsZXI7XG5cbn0pKGRhdC5jb250cm9sbGVycy5Db250cm9sbGVyLFxuZGF0LmRvbS5kb20sXG5kYXQuY29sb3IuQ29sb3IgPSAoZnVuY3Rpb24gKGludGVycHJldCwgbWF0aCwgdG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5fX3N0YXRlID0gaW50ZXJwcmV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGhpcy5fX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgJ0ZhaWxlZCB0byBpbnRlcnByZXQgY29sb3IgYXJndW1lbnRzJztcbiAgICB9XG5cbiAgICB0aGlzLl9fc3RhdGUuYSA9IHRoaXMuX19zdGF0ZS5hIHx8IDE7XG5cblxuICB9O1xuXG4gIENvbG9yLkNPTVBPTkVOVFMgPSBbJ3InLCdnJywnYicsJ2gnLCdzJywndicsJ2hleCcsJ2EnXTtcblxuICBjb21tb24uZXh0ZW5kKENvbG9yLnByb3RvdHlwZSwge1xuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b09yaWdpbmFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuY29udmVyc2lvbi53cml0ZSh0aGlzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3InLCAyKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2cnLCAxKTtcbiAgZGVmaW5lUkdCQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2InLCAwKTtcblxuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAnaCcpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAncycpO1xuICBkZWZpbmVIU1ZDb21wb25lbnQoQ29sb3IucHJvdG90eXBlLCAndicpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdhJywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuYTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLl9fc3RhdGUuYSA9IHY7XG4gICAgfVxuXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvci5wcm90b3R5cGUsICdoZXgnLCB7XG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoIXRoaXMuX19zdGF0ZS5zcGFjZSAhPT0gJ0hFWCcpIHtcbiAgICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IG1hdGgucmdiX3RvX2hleCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZS5oZXg7XG5cbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIRVgnO1xuICAgICAgdGhpcy5fX3N0YXRlLmhleCA9IHY7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lUkdCQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29tcG9uZW50LCB7XG5cbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zdGF0ZS5zcGFjZSA9PT0gJ1JHQicpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG4gICAgICAgIH1cblxuICAgICAgICByZWNhbGN1bGF0ZVJHQih0aGlzLCBjb21wb25lbnQsIGNvbXBvbmVudEhleEluZGV4KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdSR0InKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ1JHQic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVIU1ZDb21wb25lbnQodGFyZ2V0LCBjb21wb25lbnQpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGVbY29tcG9uZW50XTtcblxuICAgICAgICByZWNhbGN1bGF0ZUhTVih0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgIH0sXG5cbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIU1YnKSB7XG4gICAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG4gICAgICAgICAgdGhpcy5fX3N0YXRlLnNwYWNlID0gJ0hTVic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3RhdGVbY29tcG9uZW50XSA9IHY7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZVJHQihjb2xvciwgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCkge1xuXG4gICAgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIRVgnKSB7XG5cbiAgICAgIGNvbG9yLl9fc3RhdGVbY29tcG9uZW50XSA9IG1hdGguY29tcG9uZW50X2Zyb21faGV4KGNvbG9yLl9fc3RhdGUuaGV4LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICB9IGVsc2UgaWYgKGNvbG9yLl9fc3RhdGUuc3BhY2UgPT09ICdIU1YnKSB7XG5cbiAgICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSwgbWF0aC5oc3ZfdG9fcmdiKGNvbG9yLl9fc3RhdGUuaCwgY29sb3IuX19zdGF0ZS5zLCBjb2xvci5fX3N0YXRlLnYpKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRocm93ICdDb3JydXB0ZWQgY29sb3Igc3RhdGUnO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZUhTVihjb2xvcikge1xuXG4gICAgdmFyIHJlc3VsdCA9IG1hdGgucmdiX3RvX2hzdihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcblxuICAgIGNvbW1vbi5leHRlbmQoY29sb3IuX19zdGF0ZSxcbiAgICAgICAge1xuICAgICAgICAgIHM6IHJlc3VsdC5zLFxuICAgICAgICAgIHY6IHJlc3VsdC52XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFjb21tb24uaXNOYU4ocmVzdWx0LmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSByZXN1bHQuaDtcbiAgICB9IGVsc2UgaWYgKGNvbW1vbi5pc1VuZGVmaW5lZChjb2xvci5fX3N0YXRlLmgpKSB7XG4gICAgICBjb2xvci5fX3N0YXRlLmggPSAwO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIENvbG9yO1xuXG59KShkYXQuY29sb3IuaW50ZXJwcmV0LFxuZGF0LmNvbG9yLm1hdGggPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciB0bXBDb21wb25lbnQ7XG5cbiAgcmV0dXJuIHtcblxuICAgIGhzdl90b19yZ2I6IGZ1bmN0aW9uKGgsIHMsIHYpIHtcblxuICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcihoIC8gNjApICUgNjtcblxuICAgICAgdmFyIGYgPSBoIC8gNjAgLSBNYXRoLmZsb29yKGggLyA2MCk7XG4gICAgICB2YXIgcCA9IHYgKiAoMS4wIC0gcyk7XG4gICAgICB2YXIgcSA9IHYgKiAoMS4wIC0gKGYgKiBzKSk7XG4gICAgICB2YXIgdCA9IHYgKiAoMS4wIC0gKCgxLjAgLSBmKSAqIHMpKTtcbiAgICAgIHZhciBjID0gW1xuICAgICAgICBbdiwgdCwgcF0sXG4gICAgICAgIFtxLCB2LCBwXSxcbiAgICAgICAgW3AsIHYsIHRdLFxuICAgICAgICBbcCwgcSwgdl0sXG4gICAgICAgIFt0LCBwLCB2XSxcbiAgICAgICAgW3YsIHAsIHFdXG4gICAgICBdW2hpXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcjogY1swXSAqIDI1NSxcbiAgICAgICAgZzogY1sxXSAqIDI1NSxcbiAgICAgICAgYjogY1syXSAqIDI1NVxuICAgICAgfTtcblxuICAgIH0sXG5cbiAgICByZ2JfdG9faHN2OiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgICAgICBoLCBzO1xuXG4gICAgICBpZiAobWF4ICE9IDApIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoOiBOYU4sXG4gICAgICAgICAgczogMCxcbiAgICAgICAgICB2OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChyID09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09IG1heCkge1xuICAgICAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgICAgfVxuICAgICAgaCAvPSA2O1xuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogaCAqIDM2MCxcbiAgICAgICAgczogcyxcbiAgICAgICAgdjogbWF4IC8gMjU1XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICByZ2JfdG9faGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICB2YXIgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoMCwgMiwgcik7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDEsIGcpO1xuICAgICAgaGV4ID0gdGhpcy5oZXhfd2l0aF9jb21wb25lbnQoaGV4LCAwLCBiKTtcbiAgICAgIHJldHVybiBoZXg7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudF9mcm9tX2hleDogZnVuY3Rpb24oaGV4LCBjb21wb25lbnRJbmRleCkge1xuICAgICAgcmV0dXJuIChoZXggPj4gKGNvbXBvbmVudEluZGV4ICogOCkpICYgMHhGRjtcbiAgICB9LFxuXG4gICAgaGV4X3dpdGhfY29tcG9uZW50OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDw8ICh0bXBDb21wb25lbnQgPSBjb21wb25lbnRJbmRleCAqIDgpIHwgKGhleCAmIH4gKDB4RkYgPDwgdG1wQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gIH1cblxufSkoKSxcbmRhdC5jb2xvci50b1N0cmluZyxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LmNvbG9yLmludGVycHJldCxcbmRhdC51dGlscy5jb21tb24pLFxuZGF0LnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIHJlcXVpcmVqcyB2ZXJzaW9uIG9mIFBhdWwgSXJpc2gncyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICogaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAgICovXG5cbiAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG5cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG5cbiAgICAgIH07XG59KSgpLFxuZGF0LmRvbS5DZW50ZXJlZERpdiA9IChmdW5jdGlvbiAoZG9tLCBjb21tb24pIHtcblxuXG4gIHZhciBDZW50ZXJlZERpdiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbW1vbi5leHRlbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudC5zdHlsZSwge1xuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICB6SW5kZXg6ICcxMDAwJyxcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICBXZWJraXRUcmFuc2l0aW9uOiAnb3BhY2l0eSAwLjJzIGxpbmVhcidcbiAgICB9KTtcblxuICAgIGRvbS5tYWtlRnVsbHNjcmVlbih0aGlzLmJhY2tncm91bmRFbGVtZW50KTtcbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcblxuICAgIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbW1vbi5leHRlbmQodGhpcy5kb21FbGVtZW50LnN0eWxlLCB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIHpJbmRleDogJzEwMDEnLFxuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIFdlYmtpdFRyYW5zaXRpb246ICctd2Via2l0LXRyYW5zZm9ybSAwLjJzIGVhc2Utb3V0LCBvcGFjaXR5IDAuMnMgbGluZWFyJ1xuICAgIH0pO1xuXG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZEVsZW1lbnQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kb21FbGVtZW50KTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZG9tLmJpbmQodGhpcy5iYWNrZ3JvdW5kRWxlbWVudCwgJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICBfdGhpcy5oaWRlKCk7XG4gICAgfSk7XG5cblxuICB9O1xuXG4gIENlbnRlcmVkRGl2LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIFxuXG5cbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbi8vICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS50b3AgPSAnNTIlJztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuXG4gICAgdGhpcy5sYXlvdXQoKTtcblxuICAgIGNvbW1vbi5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgIF90aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcbiAgICB9KTtcblxuICB9O1xuXG4gIENlbnRlcmVkRGl2LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgX3RoaXMuZG9tRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgX3RoaXMuYmFja2dyb3VuZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnd2Via2l0VHJhbnNpdGlvbkVuZCcsIGhpZGUpO1xuICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgICAgZG9tLnVuYmluZChfdGhpcy5kb21FbGVtZW50LCAnb1RyYW5zaXRpb25FbmQnLCBoaWRlKTtcblxuICAgIH07XG5cbiAgICBkb20uYmluZCh0aGlzLmRvbUVsZW1lbnQsICd3ZWJraXRUcmFuc2l0aW9uRW5kJywgaGlkZSk7XG4gICAgZG9tLmJpbmQodGhpcy5kb21FbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGhpZGUpO1xuICAgIGRvbS5iaW5kKHRoaXMuZG9tRWxlbWVudCwgJ29UcmFuc2l0aW9uRW5kJywgaGlkZSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuLy8gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9ICc0OCUnO1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEuMSknO1xuXG4gIH07XG5cbiAgQ2VudGVyZWREaXYucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGgvMiAtIGRvbS5nZXRXaWR0aCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLnRvcCA9IHdpbmRvdy5pbm5lckhlaWdodC8yIC0gZG9tLmdldEhlaWdodCh0aGlzLmRvbUVsZW1lbnQpIC8gMiArICdweCc7XG4gIH07XG4gIFxuICBmdW5jdGlvbiBsb2NrU2Nyb2xsKGUpIHtcbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgfVxuXG4gIHJldHVybiBDZW50ZXJlZERpdjtcblxufSkoZGF0LmRvbS5kb20sXG5kYXQudXRpbHMuY29tbW9uKSxcbmRhdC5kb20uZG9tLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGF0LWd1aS92ZW5kb3IvZGF0Lmd1aS5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsIi8qKlxuICogZGF0LWd1aSBKYXZhU2NyaXB0IENvbnRyb2xsZXIgTGlicmFyeVxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhdC1ndWlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBEYXRhIEFydHMgVGVhbSwgR29vZ2xlIENyZWF0aXZlIExhYlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG4vKiogQG5hbWVzcGFjZSAqL1xudmFyIGRhdCA9IG1vZHVsZS5leHBvcnRzID0gZGF0IHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LmNvbG9yID0gZGF0LmNvbG9yIHx8IHt9O1xuXG4vKiogQG5hbWVzcGFjZSAqL1xuZGF0LnV0aWxzID0gZGF0LnV0aWxzIHx8IHt9O1xuXG5kYXQudXRpbHMuY29tbW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgXG4gIHZhciBBUlJfRUFDSCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoO1xuICB2YXIgQVJSX1NMSUNFID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBCYW5kLWFpZCBtZXRob2RzIGZvciB0aGluZ3MgdGhhdCBzaG91bGQgYmUgYSBsb3QgZWFzaWVyIGluIEphdmFTY3JpcHQuXG4gICAqIEltcGxlbWVudGF0aW9uIGFuZCBzdHJ1Y3R1cmUgaW5zcGlyZWQgYnkgdW5kZXJzY29yZS5qc1xuICAgKiBodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL3VuZGVyc2NvcmUvXG4gICAqL1xuXG4gIHJldHVybiB7IFxuICAgIFxuICAgIEJSRUFLOiB7fSxcbiAgXG4gICAgZXh0ZW5kOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAoIXRoaXMuaXNVbmRlZmluZWQob2JqW2tleV0pKSBcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgfSwgdGhpcyk7XG4gICAgICBcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIFxuICAgICAgdGhpcy5lYWNoKEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iailcbiAgICAgICAgICBpZiAodGhpcy5pc1VuZGVmaW5lZCh0YXJnZXRba2V5XSkpIFxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICBcbiAgICB9LFxuICAgIFxuICAgIGNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRvQ2FsbCA9IEFSUl9TTElDRS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gQVJSX1NMSUNFLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRvQ2FsbC5sZW5ndGggLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgYXJncyA9IFt0b0NhbGxbaV0uYXBwbHkodGhpcywgYXJncyldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xuICAgICAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZWFjaDogZnVuY3Rpb24ob2JqLCBpdHIsIHNjb3BlKSB7XG5cbiAgICAgIFxuICAgICAgaWYgKEFSUl9FQUNIICYmIG9iai5mb3JFYWNoID09PSBBUlJfRUFDSCkgeyBcbiAgICAgICAgXG4gICAgICAgIG9iai5mb3JFYWNoKGl0ciwgc2NvcGUpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gb2JqLmxlbmd0aCArIDApIHsgLy8gSXMgbnVtYmVyIGJ1dCBub3QgTmFOXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBrZXkgPSAwLCBsID0gb2JqLmxlbmd0aDsga2V5IDwgbDsga2V5KyspXG4gICAgICAgICAgaWYgKGtleSBpbiBvYmogJiYgaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKSBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBcbiAgICAgICAgICBpZiAoaXRyLmNhbGwoc2NvcGUsIG9ialtrZXldLCBrZXkpID09PSB0aGlzLkJSRUFLKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICB9LFxuICAgIFxuICAgIGRlZmVyOiBmdW5jdGlvbihmbmMpIHtcbiAgICAgIHNldFRpbWVvdXQoZm5jLCAwKTtcbiAgICB9LFxuICAgIFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iai50b0FycmF5KSByZXR1cm4gb2JqLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBBUlJfU0xJQ0UuY2FsbChvYmopO1xuICAgIH0sXG5cbiAgICBpc1VuZGVmaW5lZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBcbiAgICBpc051bGw6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgICB9LFxuICAgIFxuICAgIGlzTmFOOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG9iajtcbiAgICB9LFxuICAgIFxuICAgIGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yID09PSBBcnJheTtcbiAgICB9LFxuICAgIFxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICAgIH0sXG4gICAgXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gb2JqKzA7XG4gICAgfSxcbiAgICBcbiAgICBpc1N0cmluZzogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSBvYmorJyc7XG4gICAgfSxcbiAgICBcbiAgICBpc0Jvb2xlYW46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuICBcbiAgfTtcbiAgICBcbn0pKCk7XG5cblxuZGF0LmNvbG9yLnRvU3RyaW5nID0gKGZ1bmN0aW9uIChjb21tb24pIHtcblxuICByZXR1cm4gZnVuY3Rpb24oY29sb3IpIHtcblxuICAgIGlmIChjb2xvci5hID09IDEgfHwgY29tbW9uLmlzVW5kZWZpbmVkKGNvbG9yLmEpKSB7XG5cbiAgICAgIHZhciBzID0gY29sb3IuaGV4LnRvU3RyaW5nKDE2KTtcbiAgICAgIHdoaWxlIChzLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgcyA9ICcwJyArIHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnIycgKyBzO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBNYXRoLnJvdW5kKGNvbG9yLnIpICsgJywnICsgTWF0aC5yb3VuZChjb2xvci5nKSArICcsJyArIE1hdGgucm91bmQoY29sb3IuYikgKyAnLCcgKyBjb2xvci5hICsgJyknO1xuXG4gICAgfVxuXG4gIH1cblxufSkoZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuZGF0LkNvbG9yID0gZGF0LmNvbG9yLkNvbG9yID0gKGZ1bmN0aW9uIChpbnRlcnByZXQsIG1hdGgsIHRvU3RyaW5nLCBjb21tb24pIHtcblxuICB2YXIgQ29sb3IgPSBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMuX19zdGF0ZSA9IGludGVycHJldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93ICdGYWlsZWQgdG8gaW50ZXJwcmV0IGNvbG9yIGFyZ3VtZW50cyc7XG4gICAgfVxuXG4gICAgdGhpcy5fX3N0YXRlLmEgPSB0aGlzLl9fc3RhdGUuYSB8fCAxO1xuXG5cbiAgfTtcblxuICBDb2xvci5DT01QT05FTlRTID0gWydyJywnZycsJ2InLCdoJywncycsJ3YnLCdoZXgnLCdhJ107XG5cbiAgY29tbW9uLmV4dGVuZChDb2xvci5wcm90b3R5cGUsIHtcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9PcmlnaW5hbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmNvbnZlcnNpb24ud3JpdGUodGhpcyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdyJywgMik7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdnJywgMSk7XG4gIGRlZmluZVJHQkNvbXBvbmVudChDb2xvci5wcm90b3R5cGUsICdiJywgMCk7XG5cbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ2gnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3MnKTtcbiAgZGVmaW5lSFNWQ29tcG9uZW50KENvbG9yLnByb3RvdHlwZSwgJ3YnKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnYScsIHtcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXRlLmE7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5fX3N0YXRlLmEgPSB2O1xuICAgIH1cblxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3IucHJvdG90eXBlLCAnaGV4Jywge1xuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCF0aGlzLl9fc3RhdGUuc3BhY2UgIT09ICdIRVgnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSBtYXRoLnJnYl90b19oZXgodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUuaGV4O1xuXG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICB0aGlzLl9fc3RhdGUuc3BhY2UgPSAnSEVYJztcbiAgICAgIHRoaXMuX19zdGF0ZS5oZXggPSB2O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZVJHQkNvbXBvbmVudCh0YXJnZXQsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbXBvbmVudCwge1xuXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9fc3RhdGUuc3BhY2UgPT09ICdSR0InKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjYWxjdWxhdGVSR0IodGhpcywgY29tcG9uZW50LCBjb21wb25lbnRIZXhJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnUkdCJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlUkdCKHRoaXMsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdSR0InO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lSFNWQ29tcG9uZW50KHRhcmdldCwgY29tcG9uZW50KSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb21wb25lbnQsIHtcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlID09PSAnSFNWJylcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlW2NvbXBvbmVudF07XG5cbiAgICAgICAgcmVjYWxjdWxhdGVIU1YodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZVtjb21wb25lbnRdO1xuXG4gICAgICB9LFxuXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICBpZiAodGhpcy5fX3N0YXRlLnNwYWNlICE9PSAnSFNWJykge1xuICAgICAgICAgIHJlY2FsY3VsYXRlSFNWKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX19zdGF0ZS5zcGFjZSA9ICdIU1YnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N0YXRlW2NvbXBvbmVudF0gPSB2O1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVSR0IoY29sb3IsIGNvbXBvbmVudCwgY29tcG9uZW50SGV4SW5kZXgpIHtcblxuICAgIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSEVYJykge1xuXG4gICAgICBjb2xvci5fX3N0YXRlW2NvbXBvbmVudF0gPSBtYXRoLmNvbXBvbmVudF9mcm9tX2hleChjb2xvci5fX3N0YXRlLmhleCwgY29tcG9uZW50SGV4SW5kZXgpO1xuXG4gICAgfSBlbHNlIGlmIChjb2xvci5fX3N0YXRlLnNwYWNlID09PSAnSFNWJykge1xuXG4gICAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsIG1hdGguaHN2X3RvX3JnYihjb2xvci5fX3N0YXRlLmgsIGNvbG9yLl9fc3RhdGUucywgY29sb3IuX19zdGF0ZS52KSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aHJvdyAnQ29ycnVwdGVkIGNvbG9yIHN0YXRlJztcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVIU1YoY29sb3IpIHtcblxuICAgIHZhciByZXN1bHQgPSBtYXRoLnJnYl90b19oc3YoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cbiAgICBjb21tb24uZXh0ZW5kKGNvbG9yLl9fc3RhdGUsXG4gICAgICAgIHtcbiAgICAgICAgICBzOiByZXN1bHQucyxcbiAgICAgICAgICB2OiByZXN1bHQudlxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGlmICghY29tbW9uLmlzTmFOKHJlc3VsdC5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gcmVzdWx0Lmg7XG4gICAgfSBlbHNlIGlmIChjb21tb24uaXNVbmRlZmluZWQoY29sb3IuX19zdGF0ZS5oKSkge1xuICAgICAgY29sb3IuX19zdGF0ZS5oID0gMDtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBDb2xvcjtcblxufSkoZGF0LmNvbG9yLmludGVycHJldCA9IChmdW5jdGlvbiAodG9TdHJpbmcsIGNvbW1vbikge1xuXG4gIHZhciByZXN1bHQsIHRvUmV0dXJuO1xuXG4gIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbigpIHtcblxuICAgIHRvUmV0dXJuID0gZmFsc2U7XG5cbiAgICB2YXIgb3JpZ2luYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGNvbW1vbi50b0FycmF5KGFyZ3VtZW50cykgOiBhcmd1bWVudHNbMF07XG5cbiAgICBjb21tb24uZWFjaChJTlRFUlBSRVRBVElPTlMsIGZ1bmN0aW9uKGZhbWlseSkge1xuXG4gICAgICBpZiAoZmFtaWx5LmxpdG11cyhvcmlnaW5hbCkpIHtcblxuICAgICAgICBjb21tb24uZWFjaChmYW1pbHkuY29udmVyc2lvbnMsIGZ1bmN0aW9uKGNvbnZlcnNpb24sIGNvbnZlcnNpb25OYW1lKSB7XG5cbiAgICAgICAgICByZXN1bHQgPSBjb252ZXJzaW9uLnJlYWQob3JpZ2luYWwpO1xuXG4gICAgICAgICAgaWYgKHRvUmV0dXJuID09PSBmYWxzZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1JldHVybiA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc3VsdC5jb252ZXJzaW9uTmFtZSA9IGNvbnZlcnNpb25OYW1lO1xuICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnNpb24gPSBjb252ZXJzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbi5CUkVBSztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29tbW9uLkJSRUFLO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0b1JldHVybjtcblxuICB9O1xuXG4gIHZhciBJTlRFUlBSRVRBVElPTlMgPSBbXG5cbiAgICAvLyBTdHJpbmdzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc1N0cmluZyxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBUSFJFRV9DSEFSX0hFWDoge1xuXG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcblxuICAgICAgICAgICAgdmFyIHRlc3QgPSBvcmlnaW5hbC5tYXRjaCgvXiMoW0EtRjAtOV0pKFtBLUYwLTldKShbQS1GMC05XSkkL2kpO1xuICAgICAgICAgICAgaWYgKHRlc3QgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdIRVgnLFxuICAgICAgICAgICAgICBoZXg6IHBhcnNlSW50KFxuICAgICAgICAgICAgICAgICAgJzB4JyArXG4gICAgICAgICAgICAgICAgICAgICAgdGVzdFsxXS50b1N0cmluZygpICsgdGVzdFsxXS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0WzJdLnRvU3RyaW5nKCkgKyB0ZXN0WzJdLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3RbM10udG9TdHJpbmcoKSArIHRlc3RbM10udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBTSVhfQ0hBUl9IRVg6IHtcblxuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0ID0gb3JpZ2luYWwubWF0Y2goL14jKFtBLUYwLTldezZ9KSQvaSk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ0hFWCcsXG4gICAgICAgICAgICAgIGhleDogcGFyc2VJbnQoJzB4JyArIHRlc3RbMV0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfSxcblxuICAgICAgICBDU1NfUkdCOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiXFwoXFxzKiguKylcXHMqLFxccyooLispXFxzKixcXHMqKC4rKVxccypcXCkvKTtcbiAgICAgICAgICAgIGlmICh0ZXN0ID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnUkdCJyxcbiAgICAgICAgICAgICAgcjogcGFyc2VGbG9hdCh0ZXN0WzFdKSxcbiAgICAgICAgICAgICAgZzogcGFyc2VGbG9hdCh0ZXN0WzJdKSxcbiAgICAgICAgICAgICAgYjogcGFyc2VGbG9hdCh0ZXN0WzNdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogdG9TdHJpbmdcblxuICAgICAgICB9LFxuXG4gICAgICAgIENTU19SR0JBOiB7XG5cbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuXG4gICAgICAgICAgICB2YXIgdGVzdCA9IG9yaWdpbmFsLm1hdGNoKC9ecmdiYVxcKFxccyooLispXFxzKixcXHMqKC4rKVxccyosXFxzKiguKylcXHMqXFwsXFxzKiguKylcXHMqXFwpLyk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IHBhcnNlRmxvYXQodGVzdFsxXSksXG4gICAgICAgICAgICAgIGc6IHBhcnNlRmxvYXQodGVzdFsyXSksXG4gICAgICAgICAgICAgIGI6IHBhcnNlRmxvYXQodGVzdFszXSksXG4gICAgICAgICAgICAgIGE6IHBhcnNlRmxvYXQodGVzdFs0XSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IHRvU3RyaW5nXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLy8gTnVtYmVyc1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNOdW1iZXIsXG5cbiAgICAgIGNvbnZlcnNpb25zOiB7XG5cbiAgICAgICAgSEVYOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNwYWNlOiAnSEVYJyxcbiAgICAgICAgICAgICAgaGV4OiBvcmlnaW5hbCxcbiAgICAgICAgICAgICAgY29udmVyc2lvbk5hbWU6ICdIRVgnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLmhleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8vIEFycmF5c1xuICAgIHtcblxuICAgICAgbGl0bXVzOiBjb21tb24uaXNBcnJheSxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JfQVJSQVk6IHtcbiAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCAhPSAzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzcGFjZTogJ1JHQicsXG4gICAgICAgICAgICAgIHI6IG9yaWdpbmFsWzBdLFxuICAgICAgICAgICAgICBnOiBvcmlnaW5hbFsxXSxcbiAgICAgICAgICAgICAgYjogb3JpZ2luYWxbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBSR0JBX0FSUkFZOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT0gNCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICByOiBvcmlnaW5hbFswXSxcbiAgICAgICAgICAgICAgZzogb3JpZ2luYWxbMV0sXG4gICAgICAgICAgICAgIGI6IG9yaWdpbmFsWzJdLFxuICAgICAgICAgICAgICBhOiBvcmlnaW5hbFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIsIGNvbG9yLmFdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvLyBPYmplY3RzXG4gICAge1xuXG4gICAgICBsaXRtdXM6IGNvbW1vbi5pc09iamVjdCxcblxuICAgICAgY29udmVyc2lvbnM6IHtcblxuICAgICAgICBSR0JBX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iLFxuICAgICAgICAgICAgICAgIGE6IG9yaWdpbmFsLmFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHI6IGNvbG9yLnIsXG4gICAgICAgICAgICAgIGc6IGNvbG9yLmcsXG4gICAgICAgICAgICAgIGI6IGNvbG9yLmIsXG4gICAgICAgICAgICAgIGE6IGNvbG9yLmFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgUkdCX09CSjoge1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLnIpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmcpICYmXG4gICAgICAgICAgICAgICAgY29tbW9uLmlzTnVtYmVyKG9yaWdpbmFsLmIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3BhY2U6ICdSR0InLFxuICAgICAgICAgICAgICAgIHI6IG9yaWdpbmFsLnIsXG4gICAgICAgICAgICAgICAgZzogb3JpZ2luYWwuZyxcbiAgICAgICAgICAgICAgICBiOiBvcmlnaW5hbC5iXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICByOiBjb2xvci5yLFxuICAgICAgICAgICAgICBnOiBjb2xvci5nLFxuICAgICAgICAgICAgICBiOiBjb2xvci5iXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIEhTVkFfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuYSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnYsXG4gICAgICAgICAgICAgICAgYTogb3JpZ2luYWwuYVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgaDogY29sb3IuaCxcbiAgICAgICAgICAgICAgczogY29sb3IucyxcbiAgICAgICAgICAgICAgdjogY29sb3IudixcbiAgICAgICAgICAgICAgYTogY29sb3IuYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBIU1ZfT0JKOiB7XG4gICAgICAgICAgcmVhZDogZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgIGlmIChjb21tb24uaXNOdW1iZXIob3JpZ2luYWwuaCkgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwucykgJiZcbiAgICAgICAgICAgICAgICBjb21tb24uaXNOdW1iZXIob3JpZ2luYWwudikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcGFjZTogJ0hTVicsXG4gICAgICAgICAgICAgICAgaDogb3JpZ2luYWwuaCxcbiAgICAgICAgICAgICAgICBzOiBvcmlnaW5hbC5zLFxuICAgICAgICAgICAgICAgIHY6IG9yaWdpbmFsLnZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB3cml0ZTogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGg6IGNvbG9yLmgsXG4gICAgICAgICAgICAgIHM6IGNvbG9yLnMsXG4gICAgICAgICAgICAgIHY6IGNvbG9yLnZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cblxuICBdO1xuXG4gIHJldHVybiBpbnRlcnByZXQ7XG5cblxufSkoZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbiksXG5kYXQuY29sb3IubWF0aCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHRtcENvbXBvbmVudDtcblxuICByZXR1cm4ge1xuXG4gICAgaHN2X3RvX3JnYjogZnVuY3Rpb24oaCwgcywgdikge1xuXG4gICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGggLyA2MCkgJSA2O1xuXG4gICAgICB2YXIgZiA9IGggLyA2MCAtIE1hdGguZmxvb3IoaCAvIDYwKTtcbiAgICAgIHZhciBwID0gdiAqICgxLjAgLSBzKTtcbiAgICAgIHZhciBxID0gdiAqICgxLjAgLSAoZiAqIHMpKTtcbiAgICAgIHZhciB0ID0gdiAqICgxLjAgLSAoKDEuMCAtIGYpICogcykpO1xuICAgICAgdmFyIGMgPSBbXG4gICAgICAgIFt2LCB0LCBwXSxcbiAgICAgICAgW3EsIHYsIHBdLFxuICAgICAgICBbcCwgdiwgdF0sXG4gICAgICAgIFtwLCBxLCB2XSxcbiAgICAgICAgW3QsIHAsIHZdLFxuICAgICAgICBbdiwgcCwgcV1cbiAgICAgIF1baGldO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiBjWzBdICogMjU1LFxuICAgICAgICBnOiBjWzFdICogMjU1LFxuICAgICAgICBiOiBjWzJdICogMjU1XG4gICAgICB9O1xuXG4gICAgfSxcblxuICAgIHJnYl90b19oc3Y6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblxuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgICAgIGgsIHM7XG5cbiAgICAgIGlmIChtYXggIT0gMCkge1xuICAgICAgICBzID0gZGVsdGEgLyBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGg6IE5hTixcbiAgICAgICAgICBzOiAwLFxuICAgICAgICAgIHY6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIgPT0gbWF4KSB7XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGcgPT0gbWF4KSB7XG4gICAgICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG4gICAgICB9XG4gICAgICBoIC89IDY7XG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiBoICogMzYwLFxuICAgICAgICBzOiBzLFxuICAgICAgICB2OiBtYXggLyAyNTVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJnYl90b19oZXg6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHZhciBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudCgwLCAyLCByKTtcbiAgICAgIGhleCA9IHRoaXMuaGV4X3dpdGhfY29tcG9uZW50KGhleCwgMSwgZyk7XG4gICAgICBoZXggPSB0aGlzLmhleF93aXRoX2NvbXBvbmVudChoZXgsIDAsIGIpO1xuICAgICAgcmV0dXJuIGhleDtcbiAgICB9LFxuXG4gICAgY29tcG9uZW50X2Zyb21faGV4OiBmdW5jdGlvbihoZXgsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgICByZXR1cm4gKGhleCA+PiAoY29tcG9uZW50SW5kZXggKiA4KSkgJiAweEZGO1xuICAgIH0sXG5cbiAgICBoZXhfd2l0aF9jb21wb25lbnQ6IGZ1bmN0aW9uKGhleCwgY29tcG9uZW50SW5kZXgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPDwgKHRtcENvbXBvbmVudCA9IGNvbXBvbmVudEluZGV4ICogOCkgfCAoaGV4ICYgfiAoMHhGRiA8PCB0bXBDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgfVxuXG59KSgpLFxuZGF0LmNvbG9yLnRvU3RyaW5nLFxuZGF0LnV0aWxzLmNvbW1vbik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZGF0LWd1aS92ZW5kb3IvZGF0LmNvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLy8gc3RhdHMuanMgLSBodHRwOi8vZ2l0aHViLmNvbS9tcmRvb2Ivc3RhdHMuanNcbihmdW5jdGlvbihmLGUpe1wib2JqZWN0XCI9PT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGUpOmYuU3RhdHM9ZSgpfSkodGhpcyxmdW5jdGlvbigpe3ZhciBmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShhKXtjLmFwcGVuZENoaWxkKGEuZG9tKTtyZXR1cm4gYX1mdW5jdGlvbiB1KGEpe2Zvcih2YXIgZD0wO2Q8Yy5jaGlsZHJlbi5sZW5ndGg7ZCsrKWMuY2hpbGRyZW5bZF0uc3R5bGUuZGlzcGxheT1kPT09YT9cImJsb2NrXCI6XCJub25lXCI7bD1hfXZhciBsPTAsYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2Muc3R5bGUuY3NzVGV4dD1cInBvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDtjdXJzb3I6cG9pbnRlcjtvcGFjaXR5OjAuOTt6LWluZGV4OjEwMDAwXCI7Yy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCk7XG51KCsrbCVjLmNoaWxkcmVuLmxlbmd0aCl9LCExKTt2YXIgaz0ocGVyZm9ybWFuY2V8fERhdGUpLm5vdygpLGc9ayxhPTAscj1lKG5ldyBmLlBhbmVsKFwiRlBTXCIsXCIjMGZmXCIsXCIjMDAyXCIpKSxoPWUobmV3IGYuUGFuZWwoXCJNU1wiLFwiIzBmMFwiLFwiIzAyMFwiKSk7aWYoc2VsZi5wZXJmb3JtYW5jZSYmc2VsZi5wZXJmb3JtYW5jZS5tZW1vcnkpdmFyIHQ9ZShuZXcgZi5QYW5lbChcIk1CXCIsXCIjZjA4XCIsXCIjMjAxXCIpKTt1KDApO3JldHVybntSRVZJU0lPTjoxNixkb206YyxhZGRQYW5lbDplLHNob3dQYW5lbDp1LGJlZ2luOmZ1bmN0aW9uKCl7az0ocGVyZm9ybWFuY2V8fERhdGUpLm5vdygpfSxlbmQ6ZnVuY3Rpb24oKXthKys7dmFyIGM9KHBlcmZvcm1hbmNlfHxEYXRlKS5ub3coKTtoLnVwZGF0ZShjLWssMjAwKTtpZihjPmcrMUUzJiYoci51cGRhdGUoMUUzKmEvKGMtZyksMTAwKSxnPWMsYT0wLHQpKXt2YXIgZD1wZXJmb3JtYW5jZS5tZW1vcnk7dC51cGRhdGUoZC51c2VkSlNIZWFwU2l6ZS9cbjEwNDg1NzYsZC5qc0hlYXBTaXplTGltaXQvMTA0ODU3Nil9cmV0dXJuIGN9LHVwZGF0ZTpmdW5jdGlvbigpe2s9dGhpcy5lbmQoKX0sZG9tRWxlbWVudDpjLHNldE1vZGU6dX19O2YuUGFuZWw9ZnVuY3Rpb24oZSxmLGwpe3ZhciBjPUluZmluaXR5LGs9MCxnPU1hdGgucm91bmQsYT1nKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfHwxKSxyPTgwKmEsaD00OCphLHQ9MyphLHY9MiphLGQ9MyphLG09MTUqYSxuPTc0KmEscD0zMCphLHE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtxLndpZHRoPXI7cS5oZWlnaHQ9aDtxLnN0eWxlLmNzc1RleHQ9XCJ3aWR0aDo4MHB4O2hlaWdodDo0OHB4XCI7dmFyIGI9cS5nZXRDb250ZXh0KFwiMmRcIik7Yi5mb250PVwiYm9sZCBcIis5KmErXCJweCBIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZlwiO2IudGV4dEJhc2VsaW5lPVwidG9wXCI7Yi5maWxsU3R5bGU9bDtiLmZpbGxSZWN0KDAsMCxyLGgpO2IuZmlsbFN0eWxlPWY7Yi5maWxsVGV4dChlLHQsdik7XG5iLmZpbGxSZWN0KGQsbSxuLHApO2IuZmlsbFN0eWxlPWw7Yi5nbG9iYWxBbHBoYT0uOTtiLmZpbGxSZWN0KGQsbSxuLHApO3JldHVybntkb206cSx1cGRhdGU6ZnVuY3Rpb24oaCx3KXtjPU1hdGgubWluKGMsaCk7az1NYXRoLm1heChrLGgpO2IuZmlsbFN0eWxlPWw7Yi5nbG9iYWxBbHBoYT0xO2IuZmlsbFJlY3QoMCwwLHIsbSk7Yi5maWxsU3R5bGU9ZjtiLmZpbGxUZXh0KGcoaCkrXCIgXCIrZStcIiAoXCIrZyhjKStcIi1cIitnKGspK1wiKVwiLHQsdik7Yi5kcmF3SW1hZ2UocSxkK2EsbSxuLWEscCxkLG0sbi1hLHApO2IuZmlsbFJlY3QoZCtuLWEsbSxhLHApO2IuZmlsbFN0eWxlPWw7Yi5nbG9iYWxBbHBoYT0uOTtiLmZpbGxSZWN0KGQrbi1hLG0sYSxnKCgxLWgvdykqcCkpfX19O3JldHVybiBmfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdGF0cy5qcy9idWlsZC9zdGF0cy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9